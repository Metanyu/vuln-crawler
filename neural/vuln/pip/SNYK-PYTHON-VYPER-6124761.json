{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 7.5,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "HIGH",
                "availability": "NONE"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 5.9,
    "disclosureTime": "2023-12-13 13:18:52",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.12306",
        "probability": "0.00045"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-VYPER-6124761",
    "identifiers": {
        "CVE": [
            "CVE-2023-46247"
        ],
        "CWE": [
            "CWE-682"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2023-12-13 16:17:29",
    "remediation": "Upgrade vyper to version 0.3.8 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Incorrect Calculation of Numerical Quantity",
    "vulnDescription": {
        "Overview": "vyper is a Pythonic Smart Contract Language for the EVM. Affected versions of this package are vulnerable to Incorrect Calculation of Numerical Quantity due to an incorrect calculation of storage slots for large arrays. An attacker can overwrite storage variables by writing to array indices that exceed the allocated storage space. "
    },
    "source_code": [
        {
            "filename": "docs/types.rst",
            "diff": "@@ -520,6 +520,9 @@ A two dimensional list can be declared with ``_name: _ValueType[inner_size][oute\n     # Returning the value in row 0 column 4 (in this case 14)\n     return exampleList2D[0][4]\n \n+.. note::\n+    Defining an array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.\n+\n .. index:: !dynarrays\n \n Dynamic Arrays\n@@ -561,6 +564,10 @@ Dynamic arrays represent bounded arrays whose length can be modified at runtime,\n \n In the ABI, they are represented as ``_Type[]``. For instance, ``DynArray[int128, 3]`` gets represented as ``int128[]``, and ``DynArray[DynArray[int128, 3], 3]`` gets represented as ``int128[][]``.\n \n+.. note::\n+    Defining a dynamic array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.\n+\n+\n .. _types-struct:\n \n Structs"
        },
        {
            "filename": "tests/cli/outputs/test_storage_layout_overrides.py",
            "diff": "@@ -95,6 +95,21 @@ def test_simple_collision():\n         )\n \n \n+def test_overflow():\n+    code = \"\"\"\n+x: uint256[2]\n+    \"\"\"\n+\n+    storage_layout_override = {\"x\": {\"slot\": 2**256 - 1, \"type\": \"uint256[2]\"}}\n+\n+    with pytest.raises(\n+        StorageLayoutException, match=f\"Invalid storage slot for var x, out of bounds: {2**256}\\n\"\n+    ):\n+        compile_code(\n+            code, output_formats=[\"layout\"], storage_layout_override=storage_layout_override\n+        )\n+\n+\n def test_incomplete_overrides():\n     code = \"\"\"\n name: public(String[64])"
        },
        {
            "filename": "tests/functional/test_storage_slots.py",
            "diff": "@@ -1,3 +1,7 @@\n+import pytest\n+\n+from vyper.exceptions import StorageLayoutException\n+\n code = \"\"\"\n \n struct StructOne:\n@@ -97,3 +101,15 @@ def test_reentrancy_lock(get_contract):\n     assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]\n     assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]\n     assert c.h(0) == 123456789\n+\n+\n+def test_allocator_overflow(get_contract):\n+    code = \"\"\"\n+x: uint256\n+y: uint256[max_value(uint256)]\n+    \"\"\"\n+    with pytest.raises(\n+        StorageLayoutException,\n+        match=f\"Invalid storage slot for var y, tried to allocate slots 1 through {2**256}\\n\",\n+    ):\n+        get_contract(code)"
        },
        {
            "filename": "vyper/semantics/analysis/data_positions.py",
            "diff": "@@ -6,6 +6,7 @@\n from vyper.exceptions import StorageLayoutException\n from vyper.semantics.analysis.base import CodeOffset, StorageSlot\n from vyper.typing import StorageLayout\n+from vyper.utils import ceil32\n \n \n def set_data_positions(\n@@ -121,8 +122,7 @@ def set_storage_slots_with_overrides(\n         # Expect to find this variable within the storage layout overrides\n         if node.target.id in storage_layout_overrides:\n             var_slot = storage_layout_overrides[node.target.id][\"slot\"]\n-            # Calculate how many storage slots are required\n-            storage_length = math.ceil(varinfo.typ.size_in_bytes / 32)\n+            storage_length = varinfo.typ.storage_size_in_words\n             # Ensure that all required storage slots are reserved, and prevents other variables\n             # from using these slots\n             reserved_slots.reserve_slot_range(var_slot, storage_length, node.target.id)\n@@ -139,14 +139,29 @@ def set_storage_slots_with_overrides(\n     return ret\n \n \n+class SimpleStorageAllocator:\n+    def __init__(self, starting_slot: int = 0):\n+        self._slot = starting_slot\n+\n+    def allocate_slot(self, n, var_name):\n+        ret = self._slot\n+        if self._slot + n >= 2**256:\n+            raise StorageLayoutException(\n+                f\"Invalid storage slot for var {var_name}, tried to allocate\"\n+                f\" slots {self._slot} through {self._slot + n}\"\n+            )\n+        self._slot += n\n+        return ret\n+\n+\n def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:\n     \"\"\"\n     Parse module-level Vyper AST to calculate the layout of storage variables.\n     Returns the layout as a dict of variable name -> variable info\n     \"\"\"\n     # Allocate storage slots from 0\n     # note storage is word-addressable, not byte-addressable\n-    storage_slot = 0\n+    allocator = SimpleStorageAllocator()\n \n     ret: Dict[str, Dict] = {}\n \n@@ -165,36 +180,38 @@ def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:\n             type_.set_reentrancy_key_position(StorageSlot(_slot))\n             continue\n \n-        type_.set_reentrancy_key_position(StorageSlot(storage_slot))\n+        # TODO use one byte - or bit - per reentrancy key\n+        # requires either an extra SLOAD or caching the value of the\n+        # location in memory at entrance\n+        slot = allocator.allocate_slot(1, variable_name)\n+\n+        type_.set_reentrancy_key_position(StorageSlot(slot))\n \n         # TODO this could have better typing but leave it untyped until\n         # we nail down the format better\n-        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": storage_slot}\n+        ret[variable_name] = {\"type\": \"nonreentrant lock\", \"slot\": slot}\n \n-        # TODO use one byte - or bit - per reentrancy key\n-        # requires either an extra SLOAD or caching the value of the\n-        # location in memory at entrance\n-        storage_slot += 1\n \n     for node in vyper_module.get_children(vy_ast.VariableDecl):\n         # skip non-storage variables\n         if node.is_constant or node.is_immutable:\n             continue\n \n         varinfo = node.target._metadata[\"varinfo\"]\n-        varinfo.set_position(StorageSlot(storage_slot))\n-\n         type_ = varinfo.typ\n \n-        # this could have better typing but leave it untyped until\n-        # we understand the use case better\n-        ret[node.target.id] = {\"type\": str(type_), \"slot\": storage_slot}\n-\n         # CMC 2021-07-23 note that HashMaps get assigned a slot here.\n         # I'm not sure if it's safe to avoid allocating that slot\n         # for HashMaps because downstream code might use the slot\n         # ID as a salt.\n-        storage_slot += math.ceil(type_.size_in_bytes / 32)\n+        n_slots = type_.storage_size_in_words\n+        slot = allocator.allocate_slot(n_slots, node.target.id)\n+\n+        varinfo.set_position(StorageSlot(slot))\n+\n+        # this could have better typing but leave it untyped until\n+        # we understand the use case better\n+        ret[node.target.id] = {\"type\": str(type_), \"slot\": slot}\n \n     return ret\n \n@@ -216,7 +233,7 @@ def set_code_offsets(vyper_module: vy_ast.Module) -> Dict:\n         type_ = varinfo.typ\n         varinfo.set_position(CodeOffset(offset))\n \n-        len_ = math.ceil(type_.size_in_bytes / 32) * 32\n+        len_ = ceil32(type_.size_in_bytes)\n \n         # this could have better typing but leave it untyped until\n         # we understand the use case better"
        },
        {
            "filename": "vyper/semantics/types/subscriptable.py",
            "diff": "@@ -103,6 +103,9 @@ def __init__(self, value_type: VyperType, length: int):\n         if not 0 < length < 2**256:\n             raise InvalidType(\"Array length is invalid\")\n \n+        if length >= 2**64:\n+            warnings.warn(\"Use of large arrays can be unsafe!\")\n+\n         super().__init__(UINT256_T, value_type)\n         self.length = length\n "
        }
    ],
    "commitTime": "2023-04-29 00:40:15"
}