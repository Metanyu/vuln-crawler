{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "LOCAL",
        "attackComplexity": "HIGH",
        "privilegesRequired": "LOW",
        "userInteraction": "REQUIRED",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [
        {
            "assigner": "SUSE",
            "cvssV3BaseScore": 8.4,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "LOCAL",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "HIGH",
                "availability": "HIGH"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 6.7,
    "disclosureTime": "2024-01-01 06:39:09",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-SALT-6141124",
    "identifiers": {
        "CVE": [
            "CVE-2023-34049"
        ],
        "CWE": [
            "CWE-284"
        ],
        "PVE": [
            "PVE-2023-62825"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2024-01-01 12:05:46",
    "remediation": "Upgrade salt to version 3005.4, 3006.4 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Improper Access Control",
    "vulnDescription": {
        "Overview": "salt is a new approach to infrastructure management built on a dynamic communication bus. Salt can be used for data-driven orchestration, remote execution for any infrastructure, configuration management for any app stack, and much more. Affected versions of this package are vulnerable to Improper Access Control. The Salt-SSH pre-flight option copies the script to the target at a predictable path, which allows an attacker to force Salt-SSH to run their script. If an attacker has access to the target VM and knows the path to the pre-flight script before it runs they can ensure Salt-SSH runs their script with the privileges of the user running Salt-SSH. "
    },
    "source_code": [
        {
            "filename": "changelog/cve-2023-34049.security",
            "diff": "@@ -0,0 +1,2 @@\n+Fix CVE-2023-34049 by ensuring we do not use a predictable name for the script and correctly check returncode of scp command.\n+This only impacts salt-ssh users using the pre-flight option."
        },
        {
            "filename": "salt/client/ssh/__init__.py",
            "diff": "@@ -11,9 +11,11 @@\n import logging\n import multiprocessing\n import os\n+import pathlib\n import queue\n import re\n import shlex\n+import shutil\n import subprocess\n import sys\n import tarfile\n@@ -467,7 +469,14 @@ def key_deploy(self, host, ret):\n             if target.get(\"passwd\", False) or self.opts[\"ssh_passwd\"]:\n                 self._key_deploy_run(host, target, False)\n             return ret\n-        if ret[host].get(\"stderr\", \"\").count(\"Permission denied\"):\n+        stderr = ret[host].get(\"stderr\", \"\")\n+        # -failed to upload file- is detecting scp errors\n+        # Errors to ignore when Permission denied is in the stderr. For example\n+        # scp can get a permission denied on the target host, but they where\n+        # able to accurate authenticate against the box\n+        ignore_err = [\"failed to upload file\"]\n+        check_err = [x for x in ignore_err if stderr.count(x)]\n+        if \"Permission denied\" in stderr and not check_err:\n             target = self.targets[host]\n             # permission denied, attempt to auto deploy ssh key\n             print(\n@@ -500,7 +509,7 @@ def _key_deploy_run(self, host, target, re_run=True):\n             mods=self.mods,\n             fsclient=self.fsclient,\n             thin=self.thin,\n-            **target\n+            **target,\n         )\n         if salt.utils.path.which(\"ssh-copy-id\"):\n             # we have ssh-copy-id, use it!\n@@ -516,7 +525,7 @@ def _key_deploy_run(self, host, target, re_run=True):\n                 mods=self.mods,\n                 fsclient=self.fsclient,\n                 thin=self.thin,\n-                **target\n+                **target,\n             )\n             stdout, stderr, retcode = single.cmd_block()\n             try:\n@@ -543,7 +552,7 @@ def handle_routine(self, que, opts, host, target, mine=False):\n             fsclient=self.fsclient,\n             thin=self.thin,\n             mine=mine,\n-            **target\n+            **target,\n         )\n         ret = {\"id\": single.id}\n         stdout, stderr, retcode = single.run()\n@@ -883,7 +892,7 @@ def __init__(\n         remote_port_forwards=None,\n         winrm=False,\n         ssh_options=None,\n-        **kwargs\n+        **kwargs,\n     ):\n         # Get mine setting and mine_functions if defined in kwargs (from roster)\n         self.mine = mine\n@@ -1007,11 +1016,32 @@ def run_ssh_pre_flight(self):\n         \"\"\"\n         Run our pre_flight script before running any ssh commands\n         \"\"\"\n-        script = os.path.join(tempfile.gettempdir(), self.ssh_pre_file)\n-\n-        self.shell.send(self.ssh_pre_flight, script)\n+        with tempfile.NamedTemporaryFile() as temp:\n+            # ensure we use copyfile to not copy the file attributes\n+            # we want to ensure we use the perms set by the secure\n+            # NamedTemporaryFile\n+            try:\n+                shutil.copyfile(self.ssh_pre_flight, temp.name)\n+            except OSError as err:\n+                return (\n+                    \"\",\n+                    f\"Could not copy pre flight script {self.ssh_pre_flight} to temporary path\",\n+                    1,\n+                )\n+            target_script = f\".{pathlib.Path(temp.name).name}\"\n+            log.trace(f\"Copying the pre flight script {self.ssh_pre_file} to target\")\n+            stdout, stderr, retcode = self.shell.send(temp.name, target_script)\n+            if retcode != 0:\n+                # We could not copy the script to the target\n+                log.error(\n+                    f\"Could not copy the pre flight script {self.ssh_pre_file} to target\"\n+                )\n+                return stdout, stderr, retcode\n \n-        return self.execute_script(script, script_args=self.ssh_pre_flight_args)\n+            log.trace(f\"Executing the pre flight script {self.ssh_pre_file} on target\")\n+            return self.execute_script(\n+                target_script, script_args=self.ssh_pre_flight_args\n+            )\n \n     def check_thin_dir(self):\n         \"\"\"\n@@ -1131,7 +1161,7 @@ def run_wfunc(self):\n                 self.id,\n                 fsclient=self.fsclient,\n                 minion_opts=self.minion_opts,\n-                **self.target\n+                **self.target,\n             )\n \n             opts_pkg = pre_wrapper[\"test.opts_pkg\"]()  # pylint: disable=E1102\n@@ -1210,7 +1240,7 @@ def run_wfunc(self):\n             self.id,\n             fsclient=self.fsclient,\n             minion_opts=self.minion_opts,\n-            **self.target\n+            **self.target,\n         )\n         wrapper.fsclient.opts[\"cachedir\"] = opts[\"cachedir\"]\n         self.wfuncs = salt.loader.ssh_wrapper(opts, wrapper, self.context)\n@@ -1381,18 +1411,20 @@ def shim_cmd(self, cmd_str, extension=\"py\"):\n             return self.shell.exec_cmd(cmd_str)\n \n         # Write the shim to a temporary file in the default temp directory\n-        with tempfile.NamedTemporaryFile(\n-            mode=\"w+b\", prefix=\"shim_\", delete=False\n-        ) as shim_tmp_file:\n+        with tempfile.NamedTemporaryFile(mode=\"w+b\", delete=False) as shim_tmp_file:\n             shim_tmp_file.write(salt.utils.stringutils.to_bytes(cmd_str))\n \n         # Copy shim to target system, under $HOME/.<randomized name>\n-        target_shim_file = \".{}.{}\".format(\n-            binascii.hexlify(os.urandom(6)).decode(\"ascii\"), extension\n-        )\n+        target_shim_file = f\".{pathlib.Path(shim_tmp_file.name).name}\"\n+\n         if self.winrm:\n             target_shim_file = saltwinshell.get_target_shim_file(self, target_shim_file)\n-        self.shell.send(shim_tmp_file.name, target_shim_file, makedirs=True)\n+        stdout, stderr, retcode = self.shell.send(\n+            shim_tmp_file.name, target_shim_file, makedirs=True\n+        )\n+        if retcode != 0:\n+            log.error(f\"Could not copy the shim script to target\")\n+            return stdout, stderr, retcode\n \n         # Remove our shim file\n         try:"
        },
        {
            "filename": "tests/pytests/unit/client/ssh/test_single.py",
            "diff": "@@ -0,0 +1,820 @@\n+import logging\n+import re\n+from textwrap import dedent\n+\n+import pytest\n+import salt.client.ssh.client\n+import salt.config\n+import salt.roster\n+import salt.utils.files\n+import salt.utils.path\n+import salt.utils.platform\n+import salt.utils.thin\n+import salt.utils.yaml\n+from salt.client import ssh\n+from tests.support.mock import MagicMock, call, patch\n+\n+log = logging.getLogger(__name__)\n+\n+\n+@pytest.fixture\n+def opts(tmp_path):\n+    return {\n+        \"argv\": [\n+            \"ssh.set_auth_key\",\n+            \"root\",\n+            \"hobn+amNAXSBTiOXEqlBjGB...rsa root@master\",\n+        ],\n+        \"__role\": \"master\",\n+        \"cachedir\": str(tmp_path),\n+        \"extension_modules\": str(tmp_path / \"extmods\"),\n+    }\n+\n+\n+@pytest.fixture\n+def target():\n+    return {\n+        \"passwd\": \"abc123\",\n+        \"ssh_options\": None,\n+        \"sudo\": False,\n+        \"identities_only\": False,\n+        \"host\": \"login1\",\n+        \"user\": \"root\",\n+        \"timeout\": 65,\n+        \"remote_port_forwards\": None,\n+        \"sudo_user\": \"\",\n+        \"port\": \"22\",\n+        \"priv\": \"/etc/salt/pki/master/ssh/salt-ssh.rsa\",\n+    }\n+\n+\n+def test_single_opts(opts, target):\n+    \"\"\"Sanity check for ssh.Single options\"\"\"\n+\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    assert single.shell._ssh_opts() == \"\"\n+    expected_cmd = (\n+        \"ssh login1 \"\n+        \"-o KbdInteractiveAuthentication=no -o \"\n+        \"PasswordAuthentication=yes -o ConnectTimeout=65 -o Port=22 \"\n+        \"-o IdentityFile=/etc/salt/pki/master/ssh/salt-ssh.rsa \"\n+        \"-o User=root  date +%s\"\n+    )\n+    assert single.shell._cmd_str(\"date +%s\") == expected_cmd\n+\n+\n+def test_run_with_pre_flight(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run() when ssh_pre_flight is set\n+    and script successfully runs\n+    \"\"\"\n+    target[\"ssh_pre_flight\"] = str(tmp_path / \"script.sh\")\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    cmd_ret = (\"Success\", \"\", 0)\n+    mock_flight = MagicMock(return_value=cmd_ret)\n+    mock_cmd = MagicMock(return_value=cmd_ret)\n+    patch_flight = patch(\"salt.client.ssh.Single.run_ssh_pre_flight\", mock_flight)\n+    patch_cmd = patch(\"salt.client.ssh.Single.cmd_block\", mock_cmd)\n+    patch_exec_cmd = patch(\n+        \"salt.client.ssh.shell.Shell.exec_cmd\", return_value=(\"\", \"\", 1)\n+    )\n+    patch_os = patch(\"os.path.exists\", side_effect=[True])\n+\n+    with patch_os, patch_flight, patch_cmd, patch_exec_cmd:\n+        ret = single.run()\n+        mock_cmd.assert_called()\n+        mock_flight.assert_called()\n+        assert ret == cmd_ret\n+\n+\n+def test_run_with_pre_flight_with_args(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run() when ssh_pre_flight is set\n+    and script successfully runs\n+    \"\"\"\n+    target[\"ssh_pre_flight\"] = str(tmp_path / \"script.sh\")\n+    target[\"ssh_pre_flight_args\"] = \"foobar\"\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    cmd_ret = (\"Success\", \"foobar\", 0)\n+    mock_flight = MagicMock(return_value=cmd_ret)\n+    mock_cmd = MagicMock(return_value=cmd_ret)\n+    patch_flight = patch(\"salt.client.ssh.Single.run_ssh_pre_flight\", mock_flight)\n+    patch_cmd = patch(\"salt.client.ssh.Single.cmd_block\", mock_cmd)\n+    patch_exec_cmd = patch(\n+        \"salt.client.ssh.shell.Shell.exec_cmd\", return_value=(\"\", \"\", 1)\n+    )\n+    patch_os = patch(\"os.path.exists\", side_effect=[True])\n+\n+    with patch_os, patch_flight, patch_cmd, patch_exec_cmd:\n+        ret = single.run()\n+        mock_cmd.assert_called()\n+        mock_flight.assert_called()\n+        assert ret == cmd_ret\n+\n+\n+def test_run_with_pre_flight_stderr(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run() when ssh_pre_flight is set\n+    and script errors when run\n+    \"\"\"\n+    target[\"ssh_pre_flight\"] = str(tmp_path / \"script.sh\")\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    cmd_ret = (\"\", \"Error running script\", 1)\n+    mock_flight = MagicMock(return_value=cmd_ret)\n+    mock_cmd = MagicMock(return_value=cmd_ret)\n+    patch_flight = patch(\"salt.client.ssh.Single.run_ssh_pre_flight\", mock_flight)\n+    patch_cmd = patch(\"salt.client.ssh.Single.cmd_block\", mock_cmd)\n+    patch_exec_cmd = patch(\n+        \"salt.client.ssh.shell.Shell.exec_cmd\", return_value=(\"\", \"\", 1)\n+    )\n+    patch_os = patch(\"os.path.exists\", side_effect=[True])\n+\n+    with patch_os, patch_flight, patch_cmd, patch_exec_cmd:\n+        ret = single.run()\n+        mock_cmd.assert_not_called()\n+        mock_flight.assert_called()\n+        assert ret == cmd_ret\n+\n+\n+def test_run_with_pre_flight_script_doesnot_exist(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run() when ssh_pre_flight is set\n+    and the script does not exist\n+    \"\"\"\n+    target[\"ssh_pre_flight\"] = str(tmp_path / \"script.sh\")\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    cmd_ret = (\"Success\", \"\", 0)\n+    mock_flight = MagicMock(return_value=cmd_ret)\n+    mock_cmd = MagicMock(return_value=cmd_ret)\n+    patch_flight = patch(\"salt.client.ssh.Single.run_ssh_pre_flight\", mock_flight)\n+    patch_cmd = patch(\"salt.client.ssh.Single.cmd_block\", mock_cmd)\n+    patch_exec_cmd = patch(\n+        \"salt.client.ssh.shell.Shell.exec_cmd\", return_value=(\"\", \"\", 1)\n+    )\n+    patch_os = patch(\"os.path.exists\", side_effect=[False])\n+\n+    with patch_os, patch_flight, patch_cmd, patch_exec_cmd:\n+        ret = single.run()\n+        mock_cmd.assert_called()\n+        mock_flight.assert_not_called()\n+        assert ret == cmd_ret\n+\n+\n+def test_run_with_pre_flight_thin_dir_exists(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run() when ssh_pre_flight is set\n+    and thin_dir already exists\n+    \"\"\"\n+    target[\"ssh_pre_flight\"] = str(tmp_path / \"script.sh\")\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    cmd_ret = (\"\", \"\", 0)\n+    mock_flight = MagicMock(return_value=cmd_ret)\n+    mock_cmd = MagicMock(return_value=cmd_ret)\n+    patch_flight = patch(\"salt.client.ssh.Single.run_ssh_pre_flight\", mock_flight)\n+    patch_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_cmd)\n+    patch_cmd_block = patch(\"salt.client.ssh.Single.cmd_block\", mock_cmd)\n+    patch_os = patch(\"os.path.exists\", return_value=True)\n+\n+    with patch_os, patch_flight, patch_cmd, patch_cmd_block:\n+        ret = single.run()\n+        mock_cmd.assert_called()\n+        mock_flight.assert_not_called()\n+        assert ret == cmd_ret\n+\n+\n+def test_run_ssh_pre_flight(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run_ssh_pre_flight function\n+    \"\"\"\n+    target[\"ssh_pre_flight\"] = str(tmp_path / \"script.sh\")\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    cmd_ret = (\"Success\", \"\", 0)\n+    mock_flight = MagicMock(return_value=cmd_ret)\n+    mock_cmd = MagicMock(return_value=cmd_ret)\n+    patch_flight = patch(\"salt.client.ssh.Single.run_ssh_pre_flight\", mock_flight)\n+    patch_cmd = patch(\"salt.client.ssh.Single.cmd_block\", mock_cmd)\n+    patch_exec_cmd = patch(\n+        \"salt.client.ssh.shell.Shell.exec_cmd\", return_value=(\"\", \"\", 1)\n+    )\n+    patch_os = patch(\"os.path.exists\", side_effect=[True])\n+\n+    with patch_os, patch_flight, patch_cmd, patch_exec_cmd:\n+        ret = single.run()\n+        mock_cmd.assert_called()\n+        mock_flight.assert_called()\n+        assert ret == cmd_ret\n+\n+\n+def test_execute_script(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.execute_script()\n+    \"\"\"\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        **target,\n+    )\n+\n+    exp_ret = (\"Success\", \"\", 0)\n+    mock_cmd = MagicMock(return_value=exp_ret)\n+    patch_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_cmd)\n+    script = str(tmp_path / \"script.sh\")\n+\n+    with patch_cmd:\n+        ret = single.execute_script(script=script)\n+        assert ret == exp_ret\n+        assert mock_cmd.call_count == 2\n+        assert [\n+            call(\"/bin/sh '{}'\".format(script)),\n+            call(\"rm '{}'\".format(script)),\n+        ] == mock_cmd.call_args_list\n+\n+\n+def test_shim_cmd(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.shim_cmd()\n+    \"\"\"\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        tty=True,\n+        **target,\n+    )\n+\n+    exp_ret = (\"Success\", \"\", 0)\n+    mock_cmd = MagicMock(return_value=exp_ret)\n+    patch_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_cmd)\n+    patch_send = patch(\"salt.client.ssh.shell.Shell.send\", return_value=(\"\", \"\", 0))\n+    patch_rand = patch(\"os.urandom\", return_value=b\"5\\xd9l\\xca\\xc2\\xff\")\n+    tmp_file = tmp_path / \"tmp_file\"\n+    mock_tmp = MagicMock()\n+    patch_tmp = patch(\"tempfile.NamedTemporaryFile\", mock_tmp)\n+    mock_tmp.return_value.__enter__.return_value.name = tmp_file\n+\n+    with patch_cmd, patch_tmp, patch_send:\n+        ret = single.shim_cmd(cmd_str=\"echo test\")\n+        assert ret == exp_ret\n+        assert [\n+            call(f\"/bin/sh '.{tmp_file.name}'\"),\n+            call(f\"rm '.{tmp_file.name}'\"),\n+        ] == mock_cmd.call_args_list\n+\n+\n+def test_shim_cmd_copy_fails(opts, target, caplog):\n+    \"\"\"\n+    test Single.shim_cmd() when copying the file fails\n+    \"\"\"\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        tty=True,\n+        **target,\n+    )\n+\n+    ret_cmd = (\"Success\", \"\", 0)\n+    mock_cmd = MagicMock(return_value=ret_cmd)\n+    patch_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_cmd)\n+    ret_send = (\"\", \"General error in file copy\", 1)\n+    patch_send = patch(\"salt.client.ssh.shell.Shell.send\", return_value=ret_send)\n+    patch_rand = patch(\"os.urandom\", return_value=b\"5\\xd9l\\xca\\xc2\\xff\")\n+\n+    with patch_cmd, patch_rand, patch_send:\n+        ret = single.shim_cmd(cmd_str=\"echo test\")\n+        assert ret == ret_send\n+        assert \"Could not copy the shim script to target\" in caplog.text\n+        mock_cmd.assert_not_called()\n+\n+\n+def test_run_ssh_pre_flight_no_connect(opts, target, tmp_path, caplog):\n+    \"\"\"\n+    test Single.run_ssh_pre_flight when you\n+    cannot connect to the target\n+    \"\"\"\n+    pre_flight = tmp_path / \"script.sh\"\n+    pre_flight.write_text(\"\")\n+    target[\"ssh_pre_flight\"] = str(pre_flight)\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        tty=True,\n+        **target,\n+    )\n+    mock_exec_cmd = MagicMock(return_value=(\"\", \"\", 1))\n+    patch_exec_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_exec_cmd)\n+    tmp_file = tmp_path / \"tmp_file\"\n+    mock_tmp = MagicMock()\n+    patch_tmp = patch(\"tempfile.NamedTemporaryFile\", mock_tmp)\n+    mock_tmp.return_value.__enter__.return_value.name = tmp_file\n+    ret_send = (\n+        \"\",\n+        \"ssh: connect to host 192.168.1.186 port 22: No route to host\\nscp: Connection closed\\n\",\n+        255,\n+    )\n+    send_mock = MagicMock(return_value=ret_send)\n+    patch_send = patch(\"salt.client.ssh.shell.Shell.send\", send_mock)\n+\n+    with caplog.at_level(logging.TRACE):\n+        with patch_send, patch_exec_cmd, patch_tmp:\n+            ret = single.run_ssh_pre_flight()\n+    assert f\"Copying the pre flight script {pre_flight.name}\" in caplog.text\n+    assert (\n+        f\"Could not copy the pre flight script {pre_flight.name} to target\"\n+        in caplog.text\n+    )\n+    assert ret == ret_send\n+    assert send_mock.call_args_list[0][0][0] == tmp_file\n+    target_script = send_mock.call_args_list[0][0][1]\n+    assert re.search(r\".[a-z0-9]+\", target_script)\n+    mock_exec_cmd.assert_not_called()\n+\n+\n+def test_run_ssh_pre_flight_permission_denied(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run_ssh_pre_flight when you\n+    cannot copy script to the target due to\n+    a permission denied error\n+    \"\"\"\n+    pre_flight = tmp_path / \"script.sh\"\n+    pre_flight.write_text(\"\")\n+    target[\"ssh_pre_flight\"] = str(pre_flight)\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        tty=True,\n+        **target,\n+    )\n+    mock_exec_cmd = MagicMock(return_value=(\"\", \"\", 1))\n+    patch_exec_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_exec_cmd)\n+    tmp_file = tmp_path / \"tmp_file\"\n+    mock_tmp = MagicMock()\n+    patch_tmp = patch(\"tempfile.NamedTemporaryFile\", mock_tmp)\n+    mock_tmp.return_value.__enter__.return_value.name = tmp_file\n+    ret_send = (\n+        \"\",\n+        'scp: dest open \"/tmp/preflight.sh\": Permission denied\\nscp: failed to upload file /etc/salt/preflight.sh to /tmp/preflight.sh\\n',\n+        255,\n+    )\n+    send_mock = MagicMock(return_value=ret_send)\n+    patch_send = patch(\"salt.client.ssh.shell.Shell.send\", send_mock)\n+\n+    with patch_send, patch_exec_cmd, patch_tmp:\n+        ret = single.run_ssh_pre_flight()\n+    assert ret == ret_send\n+    assert send_mock.call_args_list[0][0][0] == tmp_file\n+    target_script = send_mock.call_args_list[0][0][1]\n+    assert re.search(r\".[a-z0-9]+\", target_script)\n+    mock_exec_cmd.assert_not_called()\n+\n+\n+def test_run_ssh_pre_flight_connect(opts, target, tmp_path, caplog):\n+    \"\"\"\n+    test Single.run_ssh_pre_flight when you\n+    can connect to the target\n+    \"\"\"\n+    pre_flight = tmp_path / \"script.sh\"\n+    pre_flight.write_text(\"\")\n+    target[\"ssh_pre_flight\"] = str(pre_flight)\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        tty=True,\n+        **target,\n+    )\n+    ret_exec_cmd = (\"\", \"\", 1)\n+    mock_exec_cmd = MagicMock(return_value=ret_exec_cmd)\n+    patch_exec_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_exec_cmd)\n+    tmp_file = tmp_path / \"tmp_file\"\n+    mock_tmp = MagicMock()\n+    patch_tmp = patch(\"tempfile.NamedTemporaryFile\", mock_tmp)\n+    mock_tmp.return_value.__enter__.return_value.name = tmp_file\n+    ret_send = (\n+        \"\",\n+        \"\\rroot@192.168.1.187's password: \\n\\rpreflight.sh 0%    0 0.0KB/s   --:-- ETA\\rpreflight.sh 100%   20     2.7KB/s   00:00 \\n\",\n+        0,\n+    )\n+    send_mock = MagicMock(return_value=ret_send)\n+    patch_send = patch(\"salt.client.ssh.shell.Shell.send\", send_mock)\n+\n+    with caplog.at_level(logging.TRACE):\n+        with patch_send, patch_exec_cmd, patch_tmp:\n+            ret = single.run_ssh_pre_flight()\n+\n+    assert f\"Executing the pre flight script {pre_flight.name} on target\" in caplog.text\n+    assert ret == ret_exec_cmd\n+    assert send_mock.call_args_list[0][0][0] == tmp_file\n+    target_script = send_mock.call_args_list[0][0][1]\n+    assert re.search(r\".[a-z0-9]+\", target_script)\n+    mock_exec_cmd.assert_called()\n+\n+\n+def test_run_ssh_pre_flight_shutil_fails(opts, target, tmp_path):\n+    \"\"\"\n+    test Single.run_ssh_pre_flight when cannot\n+    copyfile with shutil\n+    \"\"\"\n+    pre_flight = tmp_path / \"script.sh\"\n+    pre_flight.write_text(\"\")\n+    target[\"ssh_pre_flight\"] = str(pre_flight)\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        tty=True,\n+        **target,\n+    )\n+    ret_exec_cmd = (\"\", \"\", 1)\n+    mock_exec_cmd = MagicMock(return_value=ret_exec_cmd)\n+    patch_exec_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_exec_cmd)\n+    tmp_file = tmp_path / \"tmp_file\"\n+    mock_tmp = MagicMock()\n+    patch_tmp = patch(\"tempfile.NamedTemporaryFile\", mock_tmp)\n+    mock_tmp.return_value.__enter__.return_value.name = tmp_file\n+    send_mock = MagicMock()\n+    mock_shutil = MagicMock(side_effect=IOError(\"Permission Denied\"))\n+    patch_shutil = patch(\"shutil.copyfile\", mock_shutil)\n+    patch_send = patch(\"salt.client.ssh.shell.Shell.send\", send_mock)\n+\n+    with patch_send, patch_exec_cmd, patch_tmp, patch_shutil:\n+        ret = single.run_ssh_pre_flight()\n+\n+    assert ret == (\n+        \"\",\n+        f\"Could not copy pre flight script {pre_flight} to temporary path\",\n+        1,\n+    )\n+    mock_exec_cmd.assert_not_called()\n+    send_mock.assert_not_called()\n+\n+\n+@pytest.mark.skip_on_windows(reason=\"SSH_PY_SHIM not set on windows\")\n+@pytest.mark.slow_test\n+def test_cmd_run_set_path(opts, target):\n+    \"\"\"\n+    test when set_path is set\n+    \"\"\"\n+    target[\"set_path\"] = \"$PATH:/tmp/path/\"\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    ret = single._cmd_str()\n+    assert re.search(\"\\\\\" + target[\"set_path\"], ret)\n+\n+\n+@pytest.mark.skip_on_windows(reason=\"SSH_PY_SHIM not set on windows\")\n+@pytest.mark.slow_test\n+def test_cmd_run_not_set_path(opts, target):\n+    \"\"\"\n+    test when set_path is not set\n+    \"\"\"\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    ret = single._cmd_str()\n+    assert re.search('SET_PATH=\"\"', ret)\n+\n+\n+@pytest.mark.skip_on_windows(reason=\"SSH_PY_SHIM not set on windows\")\n+@pytest.mark.slow_test\n+def test_cmd_block_python_version_error(opts, target):\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        winrm=False,\n+        **target,\n+    )\n+    mock_shim = MagicMock(\n+        return_value=((\"\", \"ERROR: Unable to locate appropriate python command\\n\", 10))\n+    )\n+    patch_shim = patch(\"salt.client.ssh.Single.shim_cmd\", mock_shim)\n+    with patch_shim:\n+        ret = single.cmd_block()\n+        assert \"ERROR: Python version error. Recommendation(s) follow:\" in ret[0]\n+\n+\n+def _check_skip(grains):\n+    if grains[\"os\"] == \"MacOS\":\n+        return True\n+    return False\n+\n+\n+@pytest.mark.skip_initial_gh_actions_failure(skip=_check_skip)\n+@pytest.mark.skip_on_windows(reason=\"pre_flight_args is not implemented for Windows\")\n+@pytest.mark.parametrize(\n+    \"test_opts\",\n+    [\n+        (None, \"\"),\n+        (\"one\", \" one\"),\n+        (\"one two\", \" one two\"),\n+        (\"| touch /tmp/test\", \" '|' touch /tmp/test\"),\n+        (\"; touch /tmp/test\", \" ';' touch /tmp/test\"),\n+        ([\"one\"], \" one\"),\n+        ([\"one\", \"two\"], \" one two\"),\n+        ([\"one\", \"two\", \"| touch /tmp/test\"], \" one two '| touch /tmp/test'\"),\n+        ([\"one\", \"two\", \"; touch /tmp/test\"], \" one two '; touch /tmp/test'\"),\n+    ],\n+)\n+def test_run_with_pre_flight_args(opts, target, test_opts, tmp_path):\n+    \"\"\"\n+    test Single.run() when ssh_pre_flight is set\n+    and script successfully runs\n+    \"\"\"\n+    opts[\"ssh_run_pre_flight\"] = True\n+    pre_flight_script = tmp_path / \"script.sh\"\n+    pre_flight_script.write_text(\"\")\n+    target[\"ssh_pre_flight\"] = str(pre_flight_script)\n+\n+    if test_opts[0] is not None:\n+        target[\"ssh_pre_flight_args\"] = test_opts[0]\n+    expected_args = test_opts[1]\n+\n+    single = ssh.Single(\n+        opts,\n+        opts[\"argv\"],\n+        \"localhost\",\n+        mods={},\n+        fsclient=None,\n+        thin=salt.utils.thin.thin_path(opts[\"cachedir\"]),\n+        mine=False,\n+        **target,\n+    )\n+\n+    cmd_ret = (\"Success\", \"\", 0)\n+    mock_cmd = MagicMock(return_value=cmd_ret)\n+    mock_exec_cmd = MagicMock(return_value=(\"\", \"\", 0))\n+    patch_cmd = patch(\"salt.client.ssh.Single.cmd_block\", mock_cmd)\n+    patch_exec_cmd = patch(\"salt.client.ssh.shell.Shell.exec_cmd\", mock_exec_cmd)\n+    patch_shell_send = patch(\n+        \"salt.client.ssh.shell.Shell.send\", return_value=(\"\", \"\", 0)\n+    )\n+    patch_os = patch(\"os.path.exists\", side_effect=[True])\n+\n+    with patch_os, patch_cmd, patch_exec_cmd, patch_shell_send:\n+        single.run()\n+        script_args = mock_exec_cmd.mock_calls[0].args[0]\n+        assert re.search(r\"\\/bin\\/sh '.[a-z0-9]+\", script_args)\n+\n+\n+@pytest.mark.slow_test\n+@pytest.mark.skip_on_windows(reason=\"Windows does not support salt-ssh\")\n+@pytest.mark.skip_if_binaries_missing(\"ssh\", check_all=True)\n+def test_ssh_single__cmd_str(opts):\n+    argv = []\n+    id_ = \"minion\"\n+    host = \"minion\"\n+\n+    single = ssh.Single(opts, argv, id_, host, sudo=False)\n+    cmd = single._cmd_str()\n+    expected = dedent(\n+        \"\"\"\n+        SUDO=\"\"\n+        if [ -n \"\" ]\n+        then SUDO=\" \"\n+        fi\n+        SUDO_USER=\"\"\n+        if [ \"$SUDO\" ] && [ \"$SUDO_USER\" ]\n+        then SUDO=\"$SUDO -u $SUDO_USER\"\n+        fi\n+        \"\"\"\n+    )\n+\n+    assert expected in cmd\n+\n+\n+@pytest.mark.slow_test\n+@pytest.mark.skip_on_windows(reason=\"Windows does not support salt-ssh\")\n+@pytest.mark.skip_if_binaries_missing(\"ssh\", check_all=True)\n+def test_ssh_single__cmd_str_sudo(opts):\n+    argv = []\n+    id_ = \"minion\"\n+    host = \"minion\"\n+\n+    single = ssh.Single(opts, argv, id_, host, sudo=True)\n+    cmd = single._cmd_str()\n+    expected = dedent(\n+        \"\"\"\n+        SUDO=\"\"\n+        if [ -n \"sudo\" ]\n+        then SUDO=\"sudo \"\n+        fi\n+        SUDO_USER=\"\"\n+        if [ \"$SUDO\" ] && [ \"$SUDO_USER\" ]\n+        then SUDO=\"$SUDO -u $SUDO_USER\"\n+        fi\n+        \"\"\"\n+    )\n+\n+    assert expected in cmd\n+\n+\n+@pytest.mark.slow_test\n+@pytest.mark.skip_on_windows(reason=\"Windows does not support salt-ssh\")\n+@pytest.mark.skip_if_binaries_missing(\"ssh\", check_all=True)\n+def test_ssh_single__cmd_str_sudo_user(opts):\n+    argv = []\n+    id_ = \"minion\"\n+    host = \"minion\"\n+    user = \"wayne\"\n+\n+    single = ssh.Single(opts, argv, id_, host, sudo=True, sudo_user=user)\n+    cmd = single._cmd_str()\n+    expected = dedent(\n+        \"\"\"\n+        SUDO=\"\"\n+        if [ -n \"sudo\" ]\n+        then SUDO=\"sudo \"\n+        fi\n+        SUDO_USER=\"wayne\"\n+        if [ \"$SUDO\" ] && [ \"$SUDO_USER\" ]\n+        then SUDO=\"$SUDO -u $SUDO_USER\"\n+        fi\n+        \"\"\"\n+    )\n+\n+    assert expected in cmd\n+\n+\n+@pytest.mark.slow_test\n+@pytest.mark.skip_on_windows(reason=\"Windows does not support salt-ssh\")\n+@pytest.mark.skip_if_binaries_missing(\"ssh\", check_all=True)\n+def test_ssh_single__cmd_str_sudo_passwd(opts):\n+    argv = []\n+    id_ = \"minion\"\n+    host = \"minion\"\n+    passwd = \"salty\"\n+\n+    single = ssh.Single(opts, argv, id_, host, sudo=True, passwd=passwd)\n+    cmd = single._cmd_str()\n+    expected = dedent(\n+        \"\"\"\n+        SUDO=\"\"\n+        if [ -n \"sudo -p '[salt:sudo:d11bd4221135c33324a6bdc09674146fbfdf519989847491e34a689369bbce23]passwd:'\" ]\n+        then SUDO=\"sudo -p '[salt:sudo:d11bd4221135c33324a6bdc09674146fbfdf519989847491e34a689369bbce23]passwd:' \"\n+        fi\n+        SUDO_USER=\"\"\n+        if [ \"$SUDO\" ] && [ \"$SUDO_USER\" ]\n+        then SUDO=\"$SUDO -u $SUDO_USER\"\n+        fi\n+        \"\"\"\n+    )\n+\n+    assert expected in cmd\n+\n+\n+@pytest.mark.slow_test\n+@pytest.mark.skip_on_windows(reason=\"Windows does not support salt-ssh\")\n+@pytest.mark.skip_if_binaries_missing(\"ssh\", check_all=True)\n+def test_ssh_single__cmd_str_sudo_passwd_user(opts):\n+    argv = []\n+    id_ = \"minion\"\n+    host = \"minion\"\n+    user = \"wayne\"\n+    passwd = \"salty\"\n+\n+    single = ssh.Single(opts, argv, id_, host, sudo=True, passwd=passwd, sudo_user=user)\n+    cmd = single._cmd_str()\n+    expected = dedent(\n+        \"\"\"\n+        SUDO=\"\"\n+        if [ -n \"sudo -p '[salt:sudo:d11bd4221135c33324a6bdc09674146fbfdf519989847491e34a689369bbce23]passwd:'\" ]\n+        then SUDO=\"sudo -p '[salt:sudo:d11bd4221135c33324a6bdc09674146fbfdf519989847491e34a689369bbce23]passwd:' \"\n+        fi\n+        SUDO_USER=\"wayne\"\n+        if [ \"$SUDO\" ] && [ \"$SUDO_USER\" ]\n+        then SUDO=\"$SUDO -u $SUDO_USER\"\n+        fi\n+        \"\"\"\n+    )\n+\n+    assert expected in cmd"
        },
        {
            "filename": "tests/pytests/unit/client/ssh/test_ssh.py",
            "diff": "@@ -194,3 +194,280 @@ def test_run_with_pre_flight_args(ssh_target, test_opts):\n         assert mock_exec_cmd.mock_calls[0].args[\n             0\n         ] == \"/bin/sh '/tmp/script.sh'{}\".format(expected_args)\n+\n+\n+def test_expand_target_dns(opts, roster):\n+    \"\"\"\n+    test expand_target when target is root@<dns>\n+    \"\"\"\n+    host = \"localhost\"\n+    user = \"test-user@\"\n+    opts[\"tgt\"] = user + host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        client = ssh.SSH(opts)\n+    assert opts[\"tgt\"] == user + host\n+    with patch(\n+        \"salt.roster.get_roster_file\", MagicMock(return_value=\"/etc/salt/roster\")\n+    ), patch(\n+        \"salt.client.ssh.compile_template\",\n+        MagicMock(return_value=salt.utils.yaml.safe_load(roster)),\n+    ):\n+        client._expand_target()\n+    assert opts[\"tgt\"] == host\n+\n+\n+def test_expand_target_no_user(opts, roster):\n+    \"\"\"\n+    test expand_target when no user defined\n+    \"\"\"\n+    host = \"127.0.0.1\"\n+    opts[\"tgt\"] = host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        client = ssh.SSH(opts)\n+    assert opts[\"tgt\"] == host\n+\n+    with patch(\n+        \"salt.roster.get_roster_file\", MagicMock(return_value=\"/etc/salt/roster\")\n+    ), patch(\n+        \"salt.client.ssh.compile_template\",\n+        MagicMock(return_value=salt.utils.yaml.safe_load(roster)),\n+    ):\n+        client._expand_target()\n+    assert opts[\"tgt\"] == host\n+\n+\n+def test_update_targets_ip_address(opts):\n+    \"\"\"\n+    test update_targets when host is ip address\n+    \"\"\"\n+    host = \"127.0.0.1\"\n+    user = \"test-user@\"\n+    opts[\"tgt\"] = user + host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        client = ssh.SSH(opts)\n+    assert opts[\"tgt\"] == user + host\n+    client._update_targets()\n+    assert opts[\"tgt\"] == host\n+    assert client.targets[host][\"user\"] == user.split(\"@\")[0]\n+\n+\n+def test_update_targets_dns(opts):\n+    \"\"\"\n+    test update_targets when host is dns\n+    \"\"\"\n+    host = \"localhost\"\n+    user = \"test-user@\"\n+    opts[\"tgt\"] = user + host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        client = ssh.SSH(opts)\n+    assert opts[\"tgt\"] == user + host\n+    client._update_targets()\n+    assert opts[\"tgt\"] == host\n+    assert client.targets[host][\"user\"] == user.split(\"@\")[0]\n+\n+\n+def test_update_targets_no_user(opts):\n+    \"\"\"\n+    test update_targets when no user defined\n+    \"\"\"\n+    host = \"127.0.0.1\"\n+    opts[\"tgt\"] = host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        client = ssh.SSH(opts)\n+    assert opts[\"tgt\"] == host\n+    client._update_targets()\n+    assert opts[\"tgt\"] == host\n+\n+\n+def test_update_expand_target_dns(opts, roster):\n+    \"\"\"\n+    test update_targets and expand_target when host is dns\n+    \"\"\"\n+    host = \"localhost\"\n+    user = \"test-user@\"\n+    opts[\"tgt\"] = user + host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        client = ssh.SSH(opts)\n+    assert opts[\"tgt\"] == user + host\n+    with patch(\n+        \"salt.roster.get_roster_file\", MagicMock(return_value=\"/etc/salt/roster\")\n+    ), patch(\n+        \"salt.client.ssh.compile_template\",\n+        MagicMock(return_value=salt.utils.yaml.safe_load(roster)),\n+    ):\n+        client._expand_target()\n+    client._update_targets()\n+    assert opts[\"tgt\"] == host\n+    assert client.targets[host][\"user\"] == user.split(\"@\")[0]\n+\n+\n+def test_parse_tgt(opts):\n+    \"\"\"\n+    test parse_tgt when user and host set on\n+    the ssh cli tgt\n+    \"\"\"\n+    host = \"localhost\"\n+    user = \"test-user@\"\n+    opts[\"tgt\"] = user + host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        assert not opts.get(\"ssh_cli_tgt\")\n+        client = ssh.SSH(opts)\n+        assert client.parse_tgt[\"hostname\"] == host\n+        assert client.parse_tgt[\"user\"] == user.split(\"@\")[0]\n+        assert opts.get(\"ssh_cli_tgt\") == user + host\n+\n+\n+def test_parse_tgt_no_user(opts):\n+    \"\"\"\n+    test parse_tgt when only the host set on\n+    the ssh cli tgt\n+    \"\"\"\n+    host = \"localhost\"\n+    opts[\"ssh_user\"] = \"ssh-usr\"\n+    opts[\"tgt\"] = host\n+\n+    with patch(\"salt.utils.network.is_reachable_host\", MagicMock(return_value=False)):\n+        assert not opts.get(\"ssh_cli_tgt\")\n+        client = ssh.SSH(opts)\n+        assert client.parse_tgt[\"hostname\"] == host\n+        assert client.parse_tgt[\"user\"] == opts[\"ssh_user\"]\n+        assert opts.get(\"ssh_cli_tgt\") == host\n+\n+\n+def test_extra_filerefs(tmp_path, opts):\n+    \"\"\"\n+    test \"extra_filerefs\" are not excluded from kwargs\n+    when preparing the SSH opts\n+    \"\"\"\n+    ssh_opts = {\n+        \"eauth\": \"auto\",\n+        \"username\": \"test\",\n+        \"password\": \"test\",\n+        \"client\": \"ssh\",\n+        \"tgt\": \"localhost\",\n+        \"fun\": \"test.ping\",\n+        \"ssh_port\": 22,\n+        \"extra_filerefs\": \"salt://foobar\",\n+    }\n+    roster = str(tmp_path / \"roster\")\n+    client = salt.client.ssh.client.SSHClient(mopts=opts, disable_custom_roster=True)\n+    with patch(\"salt.roster.get_roster_file\", MagicMock(return_value=roster)):\n+        ssh_obj = client._prep_ssh(**ssh_opts)\n+        assert ssh_obj.opts.get(\"extra_filerefs\", None) == \"salt://foobar\"\n+\n+\n+def test_key_deploy_permission_denied_scp(tmp_path, opts):\n+    \"\"\"\n+    test \"key_deploy\" function when\n+    permission denied authentication error\n+    when attempting to use scp to copy file\n+    to target\n+    \"\"\"\n+    host = \"localhost\"\n+    passwd = \"password\"\n+    usr = \"ssh-usr\"\n+    opts[\"ssh_user\"] = usr\n+    opts[\"tgt\"] = host\n+\n+    ssh_ret = {\n+        host: {\n+            \"stdout\": \"\\rroot@192.168.1.187's password: \\n\\rroot@192.168.1.187's password: \\n\\rroot@192.168.1.187's password: \\n\",\n+            \"stderr\": \"Permission denied, please try again.\\nPermission denied, please try again.\\nroot@192.168.1.187: Permission denied (publickey,gssapi-keyex,gssapi-with-micimport pudb; pu.dbassword).\\nscp: Connection closed\\n\",\n+            \"retcode\": 255,\n+        }\n+    }\n+    key_run_ret = {\n+        \"localhost\": {\n+            \"jid\": \"20230922155652279959\",\n+            \"return\": \"test\",\n+            \"retcode\": 0,\n+            \"id\": \"test\",\n+            \"fun\": \"cmd.run\",\n+            \"fun_args\": [\"echo test\"],\n+        }\n+    }\n+    patch_roster_file = patch(\"salt.roster.get_roster_file\", MagicMock(return_value=\"\"))\n+    with patch_roster_file:\n+        client = ssh.SSH(opts)\n+    patch_input = patch(\"builtins.input\", side_effect=[\"y\"])\n+    patch_getpass = patch(\"getpass.getpass\", return_value=[\"password\"])\n+    mock_key_run = MagicMock(return_value=key_run_ret)\n+    patch_key_run = patch(\"salt.client.ssh.SSH._key_deploy_run\", mock_key_run)\n+    with patch_input, patch_getpass, patch_key_run:\n+        ret = client.key_deploy(host, ssh_ret)\n+    assert mock_key_run.call_args_list[0][0] == (\n+        host,\n+        {\"passwd\": [passwd], \"host\": host, \"user\": usr},\n+        True,\n+    )\n+    assert ret == key_run_ret\n+    assert mock_key_run.call_count == 1\n+\n+\n+def test_key_deploy_permission_denied_file_scp(tmp_path, opts):\n+    \"\"\"\n+    test \"key_deploy\" function when permission denied\n+    due to not having access to copy the file to the target\n+    We do not want to deploy the key, because this is not\n+    an authentication to the target error.\n+    \"\"\"\n+    host = \"localhost\"\n+    passwd = \"password\"\n+    usr = \"ssh-usr\"\n+    opts[\"ssh_user\"] = usr\n+    opts[\"tgt\"] = host\n+\n+    mock_key_run = MagicMock(return_value=False)\n+    patch_key_run = patch(\"salt.client.ssh.SSH._key_deploy_run\", mock_key_run)\n+\n+    ssh_ret = {\n+        \"localhost\": {\n+            \"stdout\": \"\",\n+            \"stderr\": 'scp: dest open \"/tmp/preflight.sh\": Permission denied\\nscp: failed to upload file /etc/salt/preflight.sh to /tmp/preflight.sh\\n',\n+            \"retcode\": 1,\n+        }\n+    }\n+    patch_roster_file = patch(\"salt.roster.get_roster_file\", MagicMock(return_value=\"\"))\n+    with patch_roster_file:\n+        client = ssh.SSH(opts)\n+    ret = client.key_deploy(host, ssh_ret)\n+    assert ret == ssh_ret\n+    assert mock_key_run.call_count == 0\n+\n+\n+def test_key_deploy_no_permission_denied(tmp_path, opts):\n+    \"\"\"\n+    test \"key_deploy\" function when no permission denied\n+    is returned\n+    \"\"\"\n+    host = \"localhost\"\n+    passwd = \"password\"\n+    usr = \"ssh-usr\"\n+    opts[\"ssh_user\"] = usr\n+    opts[\"tgt\"] = host\n+\n+    mock_key_run = MagicMock(return_value=False)\n+    patch_key_run = patch(\"salt.client.ssh.SSH._key_deploy_run\", mock_key_run)\n+    ssh_ret = {\n+        \"localhost\": {\n+            \"jid\": \"20230922161937998385\",\n+            \"return\": \"test\",\n+            \"retcode\": 0,\n+            \"id\": \"test\",\n+            \"fun\": \"cmd.run\",\n+            \"fun_args\": [\"echo test\"],\n+        }\n+    }\n+    patch_roster_file = patch(\"salt.roster.get_roster_file\", MagicMock(return_value=\"\"))\n+    with patch_roster_file:\n+        client = ssh.SSH(opts)\n+    ret = client.key_deploy(host, ssh_ret)\n+    assert ret == ssh_ret\n+    assert mock_key_run.call_count == 0"
        }
    ],
    "commitTime": "2023-10-03 19:12:31"
}