{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "LOCAL",
        "attackComplexity": "LOW",
        "privilegesRequired": "LOW",
        "userInteraction": "REQUIRED",
        "scope": "CHANGED",
        "confidentiality": "LOW",
        "integrity": "NONE",
        "availability": "NONE"
    },
    "credit": [
        "Jeremy Cohen"
    ],
    "cvssDetails": [],
    "cvssScore": 3.2,
    "disclosureTime": "2023-12-08 15:38:37",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-DBTCORE-6114733",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-315"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2023-12-11 13:54:14",
    "remediation": "Upgrade dbt-core to version 1.7.3 or higher. ",
    "severity": "low",
    "socialTrendAlert": false,
    "title": "Cleartext Storage of Sensitive Information",
    "vulnDescription": {
        "Overview": "dbt-core is a With dbt, data analysts and engineers can build analytics the way engineers build applications. Affected versions of this package are vulnerable to Cleartext Storage of Sensitive Information when used to pull source code from a private repository using a Personal Access Token ,thus writing a URL with the PAT in plaintext to the package-lock.yml file. ",
        "Workarounds": " Remove any git URLs with plaintext secrets from package-lock.yml file(s) on servers, workstations, or in source control. Rotate any tokens that have been written to version-controlled files. "
    },
    "source_code": [
        {
            "filename": ".changes/unreleased/Fixes-20231127-154310.yaml",
            "diff": "@@ -0,0 +1,6 @@\n+kind: Fixes\n+body: 'deps: Lock git packages to commit SHA during resolution'\n+time: 2023-11-27T15:43:10.122069+01:00\n+custom:\n+  Author: jtcohen6\n+  Issue: \"9050\""
        },
        {
            "filename": ".changes/unreleased/Fixes-20231127-154347.yaml",
            "diff": "@@ -0,0 +1,6 @@\n+kind: Fixes\n+body: 'deps: Use PackageRenderer to read package-lock.json'\n+time: 2023-11-27T15:43:47.842423+01:00\n+custom:\n+  Author: jtcohen6\n+  Issue: \"9127\""
        },
        {
            "filename": "core/dbt/clients/git.py",
            "diff": "@@ -111,7 +111,7 @@ def checkout(cwd, repo, revision=None):\n def get_current_sha(cwd):\n     out, err = run_cmd(cwd, [\"git\", \"rev-parse\", \"HEAD\"], env={\"LC_ALL\": \"C\"})\n \n-    return out.decode(\"utf-8\")\n+    return out.decode(\"utf-8\").strip()\n \n \n def remove_remote(cwd):"
        },
        {
            "filename": "core/dbt/config/project.py",
            "diff": "@@ -128,10 +128,19 @@ def package_and_project_data_from_root(project_root):\n     return packages_dict, packages_specified_path\n \n \n-def package_config_from_data(packages_data: Dict[str, Any]) -> PackageConfig:\n+def package_config_from_data(\n+    packages_data: Dict[str, Any],\n+    unrendered_packages_data: Optional[Dict[str, Any]] = None,\n+) -> PackageConfig:\n     if not packages_data:\n         packages_data = {\"packages\": []}\n \n+    # this depends on the two lists being in the same order\n+    if unrendered_packages_data:\n+        unrendered_packages_data = deepcopy(unrendered_packages_data)\n+        for i in range(0, len(packages_data.get(\"packages\", []))):\n+            packages_data[\"packages\"][i][\"unrendered\"] = unrendered_packages_data[\"packages\"][i]\n+\n     if PACKAGE_LOCK_HASH_KEY in packages_data:\n         packages_data.pop(PACKAGE_LOCK_HASH_KEY)\n     try:\n@@ -326,7 +335,7 @@ def render(self, renderer: DbtProjectYamlRenderer) -> \"Project\":\n \n     def render_package_metadata(self, renderer: PackageRenderer) -> ProjectPackageMetadata:\n         packages_data = renderer.render_data(self.packages_dict)\n-        packages_config = package_config_from_data(packages_data)\n+        packages_config = package_config_from_data(packages_data, self.packages_dict)\n         if not self.project_name:\n             raise DbtProjectError(\"Package dbt_project.yml must have a name!\")\n         return ProjectPackageMetadata(self.project_name, packages_config.packages)\n@@ -461,8 +470,9 @@ def create_project(self, rendered: RenderComponents) -> \"Project\":\n         on_run_end: List[str] = value_or(cfg.on_run_end, [])\n \n         query_comment = _query_comment_from_cfg(cfg.query_comment)\n-\n-        packages: PackageConfig = package_config_from_data(rendered.packages_dict)\n+        packages: PackageConfig = package_config_from_data(\n+            rendered.packages_dict, unrendered.packages_dict\n+        )\n         selectors = selector_config_from_data(rendered.selectors_dict)\n         manifest_selectors: Dict[str, Any] = {}\n         if rendered.selectors_dict and rendered.selectors_dict[\"selectors\"]:"
        },
        {
            "filename": "core/dbt/contracts/project.py",
            "diff": "@@ -46,6 +46,7 @@ class Package(dbtClassMixin, Replaceable):\n @dataclass\n class LocalPackage(Package):\n     local: str\n+    unrendered: Dict[str, Any] = field(default_factory=dict)\n \n \n # `float` also allows `int`, according to PEP484 (and jsonschema!)\n@@ -56,6 +57,7 @@ class LocalPackage(Package):\n class TarballPackage(Package):\n     tarball: str\n     name: str\n+    unrendered: Dict[str, Any] = field(default_factory=dict)\n \n \n @dataclass\n@@ -64,6 +66,7 @@ class GitPackage(Package):\n     revision: Optional[RawVersion] = None\n     warn_unpinned: Optional[bool] = field(default=None, metadata={\"alias\": \"warn-unpinned\"})\n     subdirectory: Optional[str] = None\n+    unrendered: Dict[str, Any] = field(default_factory=dict)\n \n     def get_revisions(self) -> List[str]:\n         if self.revision is None:\n@@ -77,6 +80,7 @@ class RegistryPackage(Package):\n     package: str\n     version: Union[RawVersion, List[RawVersion]]\n     install_prerelease: Optional[bool] = False\n+    unrendered: Dict[str, Any] = field(default_factory=dict)\n \n     def get_versions(self) -> List[str]:\n         if isinstance(self.version, list):"
        },
        {
            "filename": "core/dbt/deps/git.py",
            "diff": "@@ -9,9 +9,9 @@\n     GitPackage,\n )\n from dbt.deps.base import PinnedPackage, UnpinnedPackage, get_downloads_path\n-from dbt.exceptions import ExecutableError, MultipleVersionGitDepsError\n+from dbt.exceptions import ExecutableError, MultipleVersionGitDepsError, scrub_secrets, env_secrets\n from dbt.events.functions import fire_event, warn_or_error\n-from dbt.events.types import EnsureGitInstalled, DepsUnpinned\n+from dbt.events.types import EnsureGitInstalled, DepsUnpinned, DepsScrubbedPackageName\n from dbt.utils import md5\n \n \n@@ -23,10 +23,12 @@ class GitPackageMixin:\n     def __init__(\n         self,\n         git: str,\n+        git_unrendered: str,\n         subdirectory: Optional[str] = None,\n     ) -> None:\n         super().__init__()\n         self.git = git\n+        self.git_unrendered = git_unrendered\n         self.subdirectory = subdirectory\n \n     @property\n@@ -41,19 +43,23 @@ class GitPinnedPackage(GitPackageMixin, PinnedPackage):\n     def __init__(\n         self,\n         git: str,\n+        git_unrendered: str,\n         revision: str,\n         warn_unpinned: bool = True,\n         subdirectory: Optional[str] = None,\n     ) -> None:\n-        super().__init__(git, subdirectory)\n+        super().__init__(git, git_unrendered, subdirectory)\n         self.revision = revision\n         self.warn_unpinned = warn_unpinned\n         self.subdirectory = subdirectory\n         self._checkout_name = md5sum(self.name)\n \n     def to_dict(self) -> Dict[str, str]:\n+        git_scrubbed = scrub_secrets(self.git_unrendered, env_secrets())\n+        if self.git_unrendered != git_scrubbed:\n+            warn_or_error(DepsScrubbedPackageName(package_name=git_scrubbed))\n         ret = {\n-            \"git\": self.git,\n+            \"git\": git_scrubbed,\n             \"revision\": self.revision,\n         }\n         if self.subdirectory:\n@@ -96,8 +102,13 @@ def _fetch_metadata(\n     ) -> ProjectPackageMetadata:\n         path = self._checkout()\n \n+        # raise warning (or error) if this package is not pinned\n         if (self.revision == \"HEAD\" or self.revision in (\"main\", \"master\")) and self.warn_unpinned:\n-            warn_or_error(DepsUnpinned(git=self.git))\n+            warn_or_error(DepsUnpinned(revision=self.revision, git=self.git))\n+\n+        # now overwrite 'revision' with actual commit SHA\n+        self.revision = git.get_current_sha(path)\n+\n         partial = PartialProject.from_project_root(path)\n         return partial.render_package_metadata(renderer)\n \n@@ -116,11 +127,12 @@ class GitUnpinnedPackage(GitPackageMixin, UnpinnedPackage[GitPinnedPackage]):\n     def __init__(\n         self,\n         git: str,\n+        git_unrendered: str,\n         revisions: List[str],\n         warn_unpinned: bool = True,\n         subdirectory: Optional[str] = None,\n     ) -> None:\n-        super().__init__(git, subdirectory)\n+        super().__init__(git, git_unrendered, subdirectory)\n         self.revisions = revisions\n         self.warn_unpinned = warn_unpinned\n         self.subdirectory = subdirectory\n@@ -133,6 +145,7 @@ def from_contract(cls, contract: GitPackage) -> \"GitUnpinnedPackage\":\n         warn_unpinned = contract.warn_unpinned is not False\n         return cls(\n             git=contract.git,\n+            git_unrendered=(contract.unrendered.get(\"git\") or contract.git),\n             revisions=revisions,\n             warn_unpinned=warn_unpinned,\n             subdirectory=contract.subdirectory,\n@@ -157,6 +170,7 @@ def incorporate(self, other: \"GitUnpinnedPackage\") -> \"GitUnpinnedPackage\":\n \n         return GitUnpinnedPackage(\n             git=self.git,\n+            git_unrendered=self.git_unrendered,\n             revisions=self.revisions + other.revisions,\n             warn_unpinned=warn_unpinned,\n             subdirectory=self.subdirectory,\n@@ -168,9 +182,9 @@ def resolved(self) -> GitPinnedPackage:\n             requested = {\"HEAD\"}\n         elif len(requested) > 1:\n             raise MultipleVersionGitDepsError(self.name, requested)\n-\n         return GitPinnedPackage(\n             git=self.git,\n+            git_unrendered=self.git_unrendered,\n             revision=requested.pop(),\n             warn_unpinned=self.warn_unpinned,\n             subdirectory=self.subdirectory,"
        },
        {
            "filename": "core/dbt/deps/tarball.py",
            "diff": "@@ -2,12 +2,16 @@\n \n from dbt.contracts.project import RegistryPackageMetadata, TarballPackage\n from dbt.deps.base import PinnedPackage, UnpinnedPackage\n+from dbt.exceptions import scrub_secrets, env_secrets\n+from dbt.events.functions import warn_or_error\n+from dbt.events.types import DepsScrubbedPackageName\n \n \n class TarballPackageMixin:\n-    def __init__(self, tarball: str) -> None:\n+    def __init__(self, tarball: str, tarball_unrendered: str) -> None:\n         super().__init__()\n         self.tarball = tarball\n+        self.tarball_unrendered = tarball_unrendered\n \n     @property\n     def name(self):\n@@ -18,8 +22,8 @@ def source_type(self) -> str:\n \n \n class TarballPinnedPackage(TarballPackageMixin, PinnedPackage):\n-    def __init__(self, tarball: str, package: str) -> None:\n-        super().__init__(tarball)\n+    def __init__(self, tarball: str, tarball_unrendered: str, package: str) -> None:\n+        super().__init__(tarball, tarball_unrendered)\n         # setup to recycle RegistryPinnedPackage fns\n         self.package = package\n         self.version = \"tarball\"\n@@ -29,8 +33,11 @@ def name(self):\n         return self.package\n \n     def to_dict(self) -> Dict[str, str]:\n+        tarball_scrubbed = scrub_secrets(self.tarball_unrendered, env_secrets())\n+        if self.tarball_unrendered != tarball_scrubbed:\n+            warn_or_error(DepsScrubbedPackageName(package_name=tarball_scrubbed))\n         return {\n-            \"tarball\": self.tarball,\n+            \"tarball\": tarball_scrubbed,\n             \"name\": self.package,\n         }\n \n@@ -64,19 +71,28 @@ class TarballUnpinnedPackage(TarballPackageMixin, UnpinnedPackage[TarballPinnedP\n     def __init__(\n         self,\n         tarball: str,\n+        tarball_unrendered: str,\n         package: str,\n     ) -> None:\n-        super().__init__(tarball)\n+        super().__init__(tarball, tarball_unrendered)\n         # setup to recycle RegistryPinnedPackage fns\n         self.package = package\n         self.version = \"tarball\"\n \n     @classmethod\n     def from_contract(cls, contract: TarballPackage) -> \"TarballUnpinnedPackage\":\n-        return cls(tarball=contract.tarball, package=contract.name)\n+        return cls(\n+            tarball=contract.tarball,\n+            tarball_unrendered=(contract.unrendered.get(\"tarball\") or contract.tarball),\n+            package=contract.name,\n+        )\n \n     def incorporate(self, other: \"TarballUnpinnedPackage\") -> \"TarballUnpinnedPackage\":\n-        return TarballUnpinnedPackage(tarball=self.tarball, package=self.package)\n+        return TarballUnpinnedPackage(\n+            tarball=self.tarball, tarball_unrendered=self.tarball_unrendered, package=self.package\n+        )\n \n     def resolved(self) -> TarballPinnedPackage:\n-        return TarballPinnedPackage(tarball=self.tarball, package=self.package)\n+        return TarballPinnedPackage(\n+            tarball=self.tarball, tarball_unrendered=self.tarball_unrendered, package=self.package\n+        )"
        },
        {
            "filename": "core/dbt/events/types.proto",
            "diff": "@@ -1641,6 +1641,16 @@ message DepsVersionMissingMsg{\n     DepsVersionMissing data = 2;\n }\n \n+//M035\n+message DepsScrubbedPackageName{\n+    string package_name = 1;\n+}\n+\n+message DepsScrubbedPackageNameMsg{\n+    EventInfo info = 1;\n+    DepsScrubbedPackageName data = 2;\n+}\n+\n // Q - Node execution\n \n // Q001"
        },
        {
            "filename": "core/dbt/events/types.py",
            "diff": "@@ -1497,7 +1497,7 @@ def message(self) -> str:\n         elif self.revision in (\"main\", \"master\"):\n             unpinned_msg = f'pinned to the \"{self.revision}\" branch'\n         else:\n-            unpinned_msg = None\n+            unpinned_msg = \"not pinned to any branch, tag, or commit\"\n \n         msg = (\n             f'The git package \"{self.git}\" \\n\\tis {unpinned_msg}.\\n\\tThis can introduce '\n@@ -1538,6 +1538,17 @@ def message(self) -> str:\n         return f\"Found duplicate package in packages.yml, removing: {self.removed_package}\"\n \n \n+# M034 is missing\n+\n+\n+class DepsScrubbedPackageName(WarnLevel):\n+    def code(self):\n+        return \"M035\"\n+\n+    def message(self) -> str:\n+        return f\"Detected secret env var in {self.package_name}. dbt will write a scrubbed representation to the lock file. This will cause issues with subsequent 'dbt deps' using the lock file, requiring 'dbt deps --upgrade'\"\n+\n+\n # =======================================================\n # Q - Node execution\n # ======================================================="
        },
        {
            "filename": "core/dbt/task/deps.py",
            "diff": "@@ -7,7 +7,7 @@\n import dbt.exceptions\n import json\n \n-from dbt.config.renderer import DbtProjectYamlRenderer\n+from dbt.config.renderer import PackageRenderer\n from dbt.config.project import package_config_from_data, load_yml_dict\n from dbt.constants import PACKAGE_LOCK_FILE_NAME, PACKAGE_LOCK_HASH_KEY\n from dbt.deps.base import downloads_directory\n@@ -231,15 +231,18 @@ def run(self) -> None:\n \n         packages_lock_dict = load_yml_dict(f\"{self.project.project_root}/{PACKAGE_LOCK_FILE_NAME}\")\n \n-        packages_lock_config = package_config_from_data(packages_lock_dict).packages\n+        renderer = PackageRenderer(self.cli_vars)\n+        packages_lock_config = package_config_from_data(\n+            renderer.render_data(packages_lock_dict), packages_lock_dict\n+        ).packages\n \n         if not packages_lock_config:\n             fire_event(DepsNoPackagesFound())\n             return\n \n         with downloads_directory():\n             lock_defined_deps = resolve_lock_packages(packages_lock_config)\n-            renderer = DbtProjectYamlRenderer(None, self.cli_vars)\n+            renderer = PackageRenderer(self.cli_vars)\n \n             packages_to_upgrade = []\n "
        },
        {
            "filename": "tests/functional/context_methods/test_secret_env_vars.py",
            "diff": "@@ -4,7 +4,7 @@\n from dbt.constants import SECRET_ENV_PREFIX\n from dbt.exceptions import ParsingError, DbtInternalError\n from tests.functional.context_methods.first_dependency import FirstDependencyProject\n-from dbt.tests.util import run_dbt, run_dbt_and_capture\n+from dbt.tests.util import run_dbt, run_dbt_and_capture, read_file\n \n \n secret_bad__context_sql = \"\"\"\n@@ -76,10 +76,12 @@ def setup(self):\n         os.environ[SECRET_ENV_PREFIX + \"USER\"] = \"root\"\n         os.environ[SECRET_ENV_PREFIX + \"PASS\"] = \"password\"\n         os.environ[SECRET_ENV_PREFIX + \"PACKAGE\"] = \"first_dependency\"\n+        os.environ[SECRET_ENV_PREFIX + \"GIT_TOKEN\"] = \"abc123\"\n         yield\n         del os.environ[SECRET_ENV_PREFIX + \"USER\"]\n         del os.environ[SECRET_ENV_PREFIX + \"PASS\"]\n         del os.environ[SECRET_ENV_PREFIX + \"PACKAGE\"]\n+        del os.environ[SECRET_ENV_PREFIX + \"GIT_TOKEN\"]\n \n     @pytest.fixture(scope=\"class\")\n     def models(self):\n@@ -89,7 +91,19 @@ def models(self):\n     def packages(self):\n         return {\n             \"packages\": [\n-                {\"local\": \"{{ env_var('DBT_ENV_SECRET_PACKAGE') }}\"},\n+                {\n+                    # the raw value of this secret *will* be written to lock file\n+                    \"local\": \"{{ env_var('DBT_ENV_SECRET_PACKAGE') }}\"\n+                },\n+                {\n+                    # this secret env var will *not* be written to lock file\n+                    \"git\": \"https://{{ env_var('DBT_ENV_SECRET_GIT_TOKEN') }}@github.com/dbt-labs/dbt-external-tables.git\"\n+                },\n+                {\n+                    # this secret env var will *not* be written to lock file\n+                    \"tarball\": \"https://{{ env_var('DBT_ENV_SECRET_GIT_TOKEN') }}@github.com/dbt-labs/dbt-utils/archive/refs/tags/1.1.1.tar.gz\",\n+                    \"name\": \"dbt_utils\",\n+                },\n             ]\n         }\n \n@@ -108,7 +122,16 @@ def profile_target(self):\n \n     def test_allow_secrets(self, project, first_dependency):\n         _, log_output = run_dbt_and_capture([\"deps\"])\n+        lock_file_contents = read_file(\"package-lock.yml\")\n+\n+        # this will not be written to logs or lock file\n+        assert not (\"abc123\" in log_output)\n+        assert not (\"abc123\" in lock_file_contents)\n+        assert \"{{ env_var('DBT_ENV_SECRET_GIT_TOKEN') }}\" in lock_file_contents\n+\n+        # this will be scrubbed from logs, but not from the lock file\n         assert not (\"first_dependency\" in log_output)\n+        assert \"first_dependency\" in lock_file_contents\n \n \n class TestCloneFailSecretScrubbed:"
        },
        {
            "filename": "tests/functional/dependencies/test_dependency_options.py",
            "diff": "@@ -39,7 +39,7 @@ def test_deps_lock(self, clean_start):\n   version: 0.4.7\n - package: dbt-labs/dbt_utils\n   version: 1.1.1\n-sha1_hash: 0592fbd3e387012e8f7c12ed04688689858f5196\n+sha1_hash: 71304bca2138cf8004070b3573a1e17183c0c1a8\n \"\"\"\n         )\n \n@@ -56,7 +56,7 @@ def test_deps_default(self, clean_start):\n   version: 0.4.7\n - package: dbt-labs/dbt_utils\n   version: 1.1.1\n-sha1_hash: 0592fbd3e387012e8f7c12ed04688689858f5196\n+sha1_hash: 71304bca2138cf8004070b3573a1e17183c0c1a8\n \"\"\"\n         )\n "
        },
        {
            "filename": "tests/functional/dependencies/test_simple_dependency.py",
            "diff": "@@ -242,12 +242,12 @@ def test_git_with_multiple_subdir(self, project):\n         assert os.path.exists(\"package-lock.yml\")\n         expected = \"\"\"packages:\n - git: https://github.com/dbt-labs/dbt-multipe-packages.git\n-  revision: v0.1.0\n+  revision: 53782f3ede8fdf307ee1d8e418aa65733a4b72fa\n   subdirectory: dbt-utils-main\n - git: https://github.com/dbt-labs/dbt-multipe-packages.git\n-  revision: v0.1.0\n+  revision: 53782f3ede8fdf307ee1d8e418aa65733a4b72fa\n   subdirectory: dbt-date-main\n-sha1_hash: 0b643b06246ca34be82ef09524a30635d37aa3be\n+sha1_hash: b9c8042f29446c55a33f9f211737f445a640c7a1\n \"\"\"\n         with open(\"package-lock.yml\") as fp:\n             contents = fp.read()"
        },
        {
            "filename": "tests/unit/test_config.py",
            "diff": "@@ -793,8 +793,15 @@ def test_all_overrides(self):\n             project.packages,\n             PackageConfig(\n                 packages=[\n-                    LocalPackage(local=\"foo\"),\n-                    GitPackage(git=\"git@example.com:dbt-labs/dbt-utils.git\", revision=\"test-rev\"),\n+                    LocalPackage(local=\"foo\", unrendered={\"local\": \"foo\"}),\n+                    GitPackage(\n+                        git=\"git@example.com:dbt-labs/dbt-utils.git\",\n+                        revision=\"test-rev\",\n+                        unrendered={\n+                            \"git\": \"git@example.com:dbt-labs/dbt-utils.git\",\n+                            \"revision\": \"test-rev\",\n+                        },\n+                    ),\n                 ]\n             ),\n         )"
        },
        {
            "filename": "tests/unit/test_deps.py",
            "diff": "@@ -22,6 +22,10 @@\n from dbt.version import get_installed_version\n \n from dbt.dataclass_schema import ValidationError\n+from dbt.flags import set_from_args\n+from argparse import Namespace\n+\n+set_from_args(Namespace(WARN_ERROR=False), None)\n \n \n class TestLocalPackage(unittest.TestCase):\n@@ -71,6 +75,27 @@ def test_TarballPackage(self):\n         metastore = RegistryPackageMetadata.from_dict(dct)\n         self.assertEqual(metastore.downloads.tarball, \"http://example.com\")\n \n+    def test_tarball_pinned_package_contract_with_unrendered(self):\n+        contract = TarballPackage(\n+            tarball=\"http://example.com/invalid_url@/package.tar.gz\",\n+            name=\"my_cool_package\",\n+            unrendered={\"tarball\": \"tarball_unrendered\"},\n+        )\n+        tarball_unpinned_package = TarballUnpinnedPackage.from_contract(contract)\n+\n+        self.assertEqual(\n+            tarball_unpinned_package.tarball, \"http://example.com/invalid_url@/package.tar.gz\"\n+        )\n+        self.assertEqual(tarball_unpinned_package.package, \"my_cool_package\")\n+        self.assertEqual(tarball_unpinned_package.tarball_unrendered, \"tarball_unrendered\")\n+\n+        tarball_pinned_package = tarball_unpinned_package.resolved()\n+        tarball_unpinned_package_dict = tarball_pinned_package.to_dict()\n+        self.assertEqual(\n+            tarball_unpinned_package_dict,\n+            {\"tarball\": \"tarball_unrendered\", \"name\": \"my_cool_package\"},\n+        )\n+\n \n class TestGitPackage(unittest.TestCase):\n     def test_init(self):\n@@ -92,6 +117,23 @@ def test_init(self):\n         self.assertEqual(a_pinned.source_type(), \"git\")\n         self.assertIs(a_pinned.warn_unpinned, True)\n \n+        a_pinned_dict = a_pinned.to_dict()\n+        self.assertEqual(a_pinned_dict, {\"git\": \"http://example.com\", \"revision\": \"0.0.1\"})\n+\n+    def test_init_with_unrendered(self):\n+        contract = GitPackage(\n+            git=\"http://example.com\", revision=\"0.0.1\", unrendered={\"git\": \"git_unrendered\"}\n+        )\n+\n+        git_unpinned_package = GitUnpinnedPackage.from_contract(contract)\n+        self.assertEqual(git_unpinned_package.git, \"http://example.com\")\n+        self.assertEqual(git_unpinned_package.revisions, [\"0.0.1\"])\n+        self.assertIs(git_unpinned_package.git_unrendered, \"git_unrendered\")\n+\n+        git_pinned_package = git_unpinned_package.resolved()\n+        git_pinned_package_dict = git_pinned_package.to_dict()\n+        self.assertEqual(git_pinned_package_dict, {\"git\": \"git_unrendered\", \"revision\": \"0.0.1\"})\n+\n     @mock.patch(\"shutil.copytree\")\n     @mock.patch(\"dbt.deps.local.system.make_symlink\")\n     @mock.patch(\"dbt.deps.local.LocalPinnedPackage.get_installation_path\")"
        },
        {
            "filename": "tests/unit/test_events.py",
            "diff": "@@ -303,6 +303,7 @@ def test_event_codes(self):\n     types.DepsLockUpdating(lock_filepath=\"\"),\n     types.DepsAddPackage(package_name=\"\", version=\"\", packages_filepath=\"\"),\n     types.DepsFoundDuplicatePackage(removed_package={}),\n+    types.DepsScrubbedPackageName(package_name=\"\"),\n     types.SemanticValidationFailure(msg=\"\"),\n     # Q - Node execution ======================\n     types.RunningOperationCaughtError(exc=\"\"),"
        }
    ],
    "commitTime": "2023-11-29 07:40:54"
}