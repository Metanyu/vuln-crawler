{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 9.8,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "HIGH",
                "availability": "HIGH"
            },
            "severity": "critical"
        }
    ],
    "cvssScore": 9.1,
    "disclosureTime": "2023-12-12 02:51:01",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.08199",
        "probability": "0.00044"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-SAPXSSEC-6117572",
    "identifiers": {
        "CVE": [
            "CVE-2023-50423"
        ],
        "CWE": [
            "CWE-639"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2023-12-12 10:34:14",
    "remediation": "Upgrade sap-xssec to version 4.1.0 or higher. ",
    "severity": "critical",
    "socialTrendAlert": false,
    "title": "Authorization Bypass Through User-Controlled Key",
    "vulnDescription": {
        "Overview": "sap-xssec is a SAP Python Security Library Affected versions of this package are vulnerable to Authorization Bypass Through User-Controlled Key due to improper handling of user-controlled keys. An attacker can obtain arbitrary permissions within the application by manipulating the key values to bypass authorization checks. This is only exploitable if the attacker can control the key values used for authorization decisions. "
    },
    "source_code": [
        {
            "filename": "CHANGELOG.md",
            "diff": "@@ -1,10 +1,17 @@\n+\n # Change Log\n All notable changes to this project will be documented in this file.\n \n This project adheres to [Semantic Versioning](http://semver.org/).\n \n The format is based on [Keep a Changelog](http://keepachangelog.com/).\n \n+## 4.1.0\n+### Changed\n+- Removed JKU validation for XSUAA tokens and replaced it with composing JKU using UAA Domain.\n+- Added extra HTTP headers for improved IAS verification key retrieval.\n+- Implemented more strict issuer validation for IAS tokens.\n+\n ## 4.0.1\n ### Fixed\n - Bug: fix `aud` validation for IAS tokens"
        },
        {
            "filename": "sap/xssec/key_cache_v2.py",
            "diff": "@@ -11,7 +11,7 @@\n from collections import defaultdict\n from functools import _make_key # noqa\n from threading import Lock\n-from typing import Optional, List, Dict, Any\n+from typing import List, Dict, Any\n \n import httpx\n from cachetools import cached, TTLCache\n@@ -42,12 +42,18 @@ def _fetch_verification_key_url_ias(issuer_url: str) -> str:\n     return resp.json()[\"jwks_uri\"]\n \n \n-def _download_verification_key_ias(verification_key_url: str, zone_id: Optional[str]) -> List[Dict[str, Any]]:\n+def _download_verification_key_ias(verification_key_url: str, app_tid: str, azp: str,\n+                                   client_id: str) -> List[Dict[str, Any]]:\n     \"\"\"\n     get all the keys from verification key url\n     \"\"\"\n-    default_headers = {'Accept': 'application/json'}\n-    headers = default_headers if zone_id is None else {**default_headers, \"x-zone_uuid\": zone_id}\n+    headers = {\n+        'x-app_tid': app_tid,\n+        'x-azp': azp,\n+        'x-client_id': client_id,\n+        'Accept': 'application/json',\n+    }\n+    headers = {k: v for k, v in headers.items() if v is not None}\n     resp = httpx.get(verification_key_url, headers=headers, timeout=HTTP_TIMEOUT_IN_SECONDS)\n     resp.raise_for_status()\n     return resp.json()[\"keys\"]\n@@ -59,12 +65,13 @@ def _download_verification_key_ias(verification_key_url: str, zone_id: Optional[\n \n @thread_safe_by_args\n @cached(cache=key_cache)\n-def get_verification_key_ias(issuer_url: str, zone_id: Optional[str], kid: str) -> str:\n+def get_verification_key_ias(issuer_url: str, app_tid: str, azp: str, client_id: str, kid: str) -> str:\n     \"\"\"\n     get verification key for ias\n     \"\"\"\n     verification_key_url: str = _fetch_verification_key_url_ias(issuer_url)\n-    verification_key_list: List[Dict[str, Any]] = _download_verification_key_ias(verification_key_url, zone_id)\n+    verification_key_list: List[Dict[str, Any]] = _download_verification_key_ias(verification_key_url, app_tid, azp,\n+                                                                                 client_id)\n     found = list(filter(lambda k: k[\"kid\"] == kid, verification_key_list))\n     if len(found) == 0:\n         raise ValueError(\"Could not find key with kid {}\".format(kid))"
        },
        {
            "filename": "sap/xssec/security_context_ias.py",
            "diff": "@@ -1,5 +1,6 @@\n \"\"\" Security Context class for IAS support\"\"\"\n import logging\n+import re\n from typing import List, Dict\n from urllib3.util import Url, parse_url  # type: ignore\n from sap.xssec.jwt_audience_validator import JwtAudienceValidator\n@@ -45,7 +46,12 @@ def validate_issuer(self):\n \n         domains: List[str] = self.service_credentials.get(\"domains\") or (\n             [self.service_credentials[\"domain\"]] if \"domain\" in self.service_credentials else [])\n-        if not any(map(lambda d: issuer_url.host.endswith(d), domains)):\n+\n+        def validate_issuer_subdomain(parent_domain) -> bool:\n+            pattern = r'^https://[a-zA-Z0-9-]{{1,63}}\\.{parent_domain}$'.format(parent_domain=re.escape(parent_domain))\n+            return bool(re.match(pattern, self.get_issuer()))\n+\n+        if not any(map(validate_issuer_subdomain, domains)):\n             raise ValueError(\"Token's issuer is not found in domain list {}\".format(\", \".join(domains)))\n \n         return self\n@@ -76,7 +82,12 @@ def validate_signature(self):\n         check signature in jwt token\n         \"\"\"\n         verification_key: str = get_verification_key_ias(\n-            self.get_issuer(), self.token_payload.get(\"zone_uuid\"), self.token_header[\"kid\"])\n+            issuer_url=self.get_issuer(),\n+            app_tid=self.token_payload.get(\"app_tid\") or self.token_payload.get(\"zone_uuid\"),\n+            azp=self.token_payload.get(\"azp\"),\n+            client_id=self.service_credentials[\"clientid\"],\n+            kid=self.token_header[\"kid\"],\n+        )\n \n         result_code = self.jwt_validator.loadPEM(verification_key)\n         if result_code != 0:"
        },
        {
            "filename": "sap/xssec/security_context_xsuaa.py",
            "diff": "@@ -1,6 +1,7 @@\n # pylint: disable=too-many-public-methods\n \"\"\" Security Context class \"\"\"\n import functools\n+import re\n import tempfile\n from os import environ, unlink\n import json\n@@ -10,7 +11,6 @@\n \n import httpx\n import deprecation\n-import urllib3\n \n from sap.xssec import constants\n from sap.xssec.jwt_validation_facade import JwtValidationFacade, DecodeError\n@@ -118,17 +118,14 @@ def _init_xsappname(self):\n                                      ' the manifest.yml (legacy) as well as in xs-security.json.'\n                                      ' Remove it in manifest.yml.')\n \n-    def _validate_jku(self):\n-        # configured uaa domain must be part of jku in order to trust jku\n-        uaa_domain = self._config['uaadomain']\n-\n+    def _get_jku(self):\n+        uaa_domain: str = self._config.get('uaadomain') or self._config.get('url')\n         if not uaa_domain:\n             raise RuntimeError(\"Service is not properly configured in 'VCAP_SERVICES'\")\n-\n-        jku_url = urllib3.util.parse_url(self._properties['jku'])\n-        if not jku_url.hostname.endswith(uaa_domain):\n-            self._logger.error(\"Error: Do not trust jku '{}' because it does not match uaa domain\".format(self._properties['jku']))\n-            raise RuntimeError(\"JKU of token is not trusted\")\n+        uaa_domain = re.sub(r'^https://', '', uaa_domain)\n+        payload = self._jwt_validator.decode(self._token, verify=False)\n+        zid = payload.get(\"zid\")\n+        return f\"https://{uaa_domain}/token_keys?zid={zid}\" if zid else f\"https://{uaa_domain}/token_keys\"\n \n     def _set_token_properties(self):\n \n@@ -338,13 +335,11 @@ def _set_scopes(self, jwt_payload):\n         self._logger.debug('Obtained scopes: %s.', self._properties['scopes'])\n \n     def _validate_token(self):\n-        \"\"\" Try to retrieve the key from the uaa if jku and kid is set. Otherwise use configured one.\"\"\"\n-\n-        if \"uaadomain\" in self._config and self._properties['jku'] and self._properties['kid']:\n-            self._validate_jku()\n+        \"\"\" Try to retrieve the key from the composed jku if kid is set. Otherwise use configured one.\"\"\"\n+        if self._properties['kid']:\n             try:\n-                verification_key = SecurityContextXSUAA.verificationKeyCache.load_key(self._properties['jku'],\n-                                                                                      self._properties['kid'])\n+                jku = self._get_jku()\n+                verification_key = SecurityContextXSUAA.verificationKeyCache.load_key(jku, self._properties['kid'])\n                 return self._get_jwt_payload(verification_key)\n             except (DecodeError, RuntimeError, IOError) as e:\n                 self._logger.warning(\"Warning: Could not validate key: {} Will retry with configured key.\".format(e))"
        },
        {
            "filename": "tests/ias/ias_configs.py",
            "diff": "@@ -35,5 +35,17 @@\n              \"-1opcRmlX1x8zgi2l-XxzSKrLABz0Fq2GJGZmD1PU_\"\n              \"-W6FHzE7ocokfYSViJ1_mBGn5KJwUIC2vBO9jWquGlM9TkdPP5DpmONEO5yFu6aO6GeEF3k9hOEL0AS0GOm8KmywhDg\"\n              \"-s5FGVNuwNG0O_nQn3VI9jigXuKuz5_e1becT2rw88fpizFG476TwB6BQCk8SWc \"\n+    }, {\n+        \"kty\": \"RSA\",\n+        \"e\": \"AQAB\",\n+        \"use\": \"sig\",\n+        \"kid\": \"another-kid\",\n+        \"alg\": \"RS256\",\n+        \"value\": \"public key here\",\n+        \"n\": \"AMGmSCHT8kourWCKVwTQKKr7a_rs8AGiwVPmeycKq2Mja5P3YXMDMOO7Qb9\"\n+             \"-v5YNv0dkD7eu9v4AzilpcnnGASQbewNbaz2wJWMwIvjxG7VcHjqcf-oF9bfHv8nR1TTp52OwSKaKqunMtIrS1uJ\"\n+             \"-1opcRmlX1x8zgi2l-XxzSKrLABz0Fq2GJGZmD1PU_\"\n+             \"-W6FHzE7ocokfYSViJ1_mBGn5KJwUIC2vBO9jWquGlM9TkdPP5DpmONEO5yFu6aO6GeEF3k9hOEL0AS0GOm8KmywhDg\"\n+             \"-s5FGVNuwNG0O_nQn3VI9jigXuKuz5_e1becT2rw88fpizFG476TwB6BQCk8SWc \"\n     }]\n-}\n\\ No newline at end of file\n+}"
        },
        {
            "filename": "tests/ias/ias_tokens.py",
            "diff": "@@ -23,6 +23,7 @@ def merge(dict1, dict2):\n         \"user_uuid\": \"db60e49c-1fb7-4a15-9a9e-8ababf856fe9\",\n         \"azp\": \"70af88d4-0371-4374-b4f5-f24f650bfac5\",\n         \"zone_uuid\": \"4b0c2b7a-1279-4352-a68d-a9a228a4f1e9\",\n+        \"app_tid\": \"4b0c2b7a-1279-4352-a68d-a9a228a4f1e9\",\n         \"iat\": 1470815434,\n         \"exp\": 2101535434,\n         \"family_name\": \"Nachname\","
        },
        {
            "filename": "tests/ias/test_xssec_ias.py",
            "diff": "@@ -17,6 +17,14 @@\n     reload = None\n     from mock import MagicMock, patch\n \n+VERIFICATION_KEY_PARAMS = {\n+    \"issuer_url\": PAYLOAD[\"iss\"],\n+    \"app_tid\": PAYLOAD[\"app_tid\"] or PAYLOAD[\"zone_uuid\"],\n+    \"azp\": PAYLOAD[\"azp\"],\n+    \"client_id\": SERVICE_CREDENTIALS[\"clientid\"],\n+    \"kid\": HEADER[\"kid\"]\n+}\n+\n \n class IASXSSECTest(unittest.TestCase):\n \n@@ -27,7 +35,7 @@ def setUp(self):\n     @patch('sap.xssec.security_context_ias.get_verification_key_ias', return_value=JWT_SIGNING_PUBLIC_KEY)\n     def test_input_validation_valid_token(self, get_verification_key_ias_mock):\n         xssec.create_security_context_ias(VALID_TOKEN, ias_configs.SERVICE_CREDENTIALS)\n-        get_verification_key_ias_mock.assert_called_with(PAYLOAD[\"iss\"], PAYLOAD[\"zone_uuid\"], HEADER[\"kid\"])\n+        get_verification_key_ias_mock.assert_called_with(**VERIFICATION_KEY_PARAMS)\n \n     def test_input_validation_invalid_token(self):\n         with self.assertRaises(ValueError) as ctx:"
        },
        {
            "filename": "tests/test_key_cache_v2.py",
            "diff": "@@ -3,11 +3,19 @@\n from typing import List, Callable\n \n import pytest\n-from httpx import Response, HTTPStatusError\n+from httpx import Response, HTTPStatusError, Request\n \n from sap.xssec.key_tools import jwk_to_pem\n-from tests.ias.ias_configs import JWKS, WELL_KNOWN\n-from tests.ias.ias_tokens import PAYLOAD, HEADER\n+from tests.ias.ias_configs import JWKS, WELL_KNOWN, SERVICE_CREDENTIALS\n+from tests.ias.ias_tokens import PAYLOAD, HEADER, merge\n+\n+VERIFICATION_KEY_PARAMS = {\n+    \"issuer_url\": PAYLOAD[\"iss\"],\n+    \"app_tid\": PAYLOAD[\"app_tid\"] or PAYLOAD[\"zone_uuid\"],\n+    \"azp\": PAYLOAD[\"azp\"],\n+    \"client_id\": SERVICE_CREDENTIALS[\"clientid\"],\n+    \"kid\": HEADER[\"kid\"]\n+}\n \n \n def test_thread_safe_decorator():\n@@ -30,13 +38,13 @@ def run_func_in_threads(func: Callable[[int], None], func_args: List[int]):\n \n     # not thread-safe without decorator\n     sum = 0\n-    run_func_in_threads(add_to_sum, [1]*10)\n+    run_func_in_threads(add_to_sum, [1] * 10)\n     assert 10 != sum\n \n     # thread-safe when args are same\n     sum = 0\n     from sap.xssec.key_cache_v2 import thread_safe_by_args\n-    run_func_in_threads(thread_safe_by_args(add_to_sum), [1]*10)\n+    run_func_in_threads(thread_safe_by_args(add_to_sum), [1] * 10)\n     assert 10 == sum\n \n     # not thread-safe when args are different\n@@ -51,15 +59,22 @@ def well_known_endpoint_mock(respx_mock):\n         return_value=Response(200, json=WELL_KNOWN))\n \n \n+def jwk_endpoint_response(request: Request):\n+    if all(k in request.headers for k in (\"x-app_tid\", \"x-azp\", \"x-client_id\")):\n+        return Response(200, json=JWKS)\n+    else:\n+        return Response(404)\n+\n+\n @pytest.fixture\n def jwk_endpoint_mock(respx_mock):\n-    return respx_mock.get(WELL_KNOWN[\"jwks_uri\"]).mock(return_value=Response(200, json=JWKS))\n+    return respx_mock.get(WELL_KNOWN[\"jwks_uri\"]).mock(side_effect=jwk_endpoint_response)\n \n \n def test_get_verification_key_ias_should_return_key(well_known_endpoint_mock, jwk_endpoint_mock):\n     from sap.xssec.key_cache_v2 import get_verification_key_ias, key_cache\n     key_cache.clear()\n-    pem_key = get_verification_key_ias(PAYLOAD[\"iss\"], PAYLOAD[\"zone_uuid\"], HEADER[\"kid\"])\n+    pem_key = get_verification_key_ias(**VERIFICATION_KEY_PARAMS)\n     assert well_known_endpoint_mock.called\n     assert jwk_endpoint_mock.called\n     jwk = next(filter(lambda k: k[\"kid\"] == HEADER[\"kid\"], JWKS[\"keys\"]))\n@@ -70,9 +85,33 @@ def test_get_verification_key_ias_should_cache_key(well_known_endpoint_mock, jwk\n     from sap.xssec.key_cache_v2 import get_verification_key_ias, key_cache\n     key_cache.clear()\n     for _ in range(0, 10):\n-        get_verification_key_ias(PAYLOAD[\"iss\"], PAYLOAD[\"zone_uuid\"], HEADER[\"kid\"])\n-    assert 1 == well_known_endpoint_mock.call_count\n-    assert 1 == jwk_endpoint_mock.call_count\n+        get_verification_key_ias(**VERIFICATION_KEY_PARAMS)\n+    assert 1 == well_known_endpoint_mock.call_count == jwk_endpoint_mock.call_count\n+\n+    for _ in range(0, 10):\n+        get_verification_key_ias(**merge(VERIFICATION_KEY_PARAMS, {\"app_tid\": \"another-app-tid\"}))\n+    assert 2 == well_known_endpoint_mock.call_count == jwk_endpoint_mock.call_count\n+\n+    for _ in range(0, 10):\n+        get_verification_key_ias(**merge(VERIFICATION_KEY_PARAMS, {\"azp\": \"another-azp\"}))\n+    assert 3 == well_known_endpoint_mock.call_count == jwk_endpoint_mock.call_count\n+\n+    for _ in range(0, 10):\n+        get_verification_key_ias(**merge(VERIFICATION_KEY_PARAMS, {\"client_id\": \"another-client-id\"}))\n+    assert 4 == well_known_endpoint_mock.call_count == jwk_endpoint_mock.call_count\n+\n+    for _ in range(0, 10):\n+        get_verification_key_ias(**merge(VERIFICATION_KEY_PARAMS, {\"kid\": \"another-kid\"}))\n+    assert 5 == well_known_endpoint_mock.call_count == jwk_endpoint_mock.call_count\n+\n+\n+def test_get_verification_key_ias_should_throw_error_for_missing_key(well_known_endpoint_mock, jwk_endpoint_mock):\n+    from sap.xssec.key_cache_v2 import get_verification_key_ias, key_cache\n+    key_cache.clear()\n+    for _ in range(0, 10):\n+        with pytest.raises(ValueError):\n+            get_verification_key_ias(**merge(VERIFICATION_KEY_PARAMS, {\"kid\": \"non-existing-kid\"}))\n+    assert 10 == well_known_endpoint_mock.call_count == jwk_endpoint_mock.call_count\n \n \n def test_get_verification_key_ias_should_raise_http_error(respx_mock):\n@@ -81,4 +120,4 @@ def test_get_verification_key_ias_should_raise_http_error(respx_mock):\n     from sap.xssec.key_cache_v2 import get_verification_key_ias, key_cache\n     key_cache.clear()\n     with pytest.raises(HTTPStatusError):\n-        get_verification_key_ias(PAYLOAD[\"iss\"], PAYLOAD[\"zone_uuid\"], HEADER[\"kid\"])\n+        get_verification_key_ias(**VERIFICATION_KEY_PARAMS)"
        },
        {
            "filename": "tests/test_xssec.py",
            "diff": "@@ -458,14 +458,22 @@ def test_get_verification_key_from_uaa(self, mock_requests):\n             sec_context.get_clone_service_instance_id(), 'abcd1234')\n         self.assertEqual(\n             sec_context.get_additional_auth_attribute('external_group'), 'domaingroup1')\n-        mock_requests.assert_called_once_with(\"https://api.cf.test.com\", timeout=constants.HTTP_TIMEOUT_IN_SECONDS)\n+        mock_requests.assert_called_once_with(\"https://api.cf.test.com/token_keys?zid=test-idz\",\n+                                              timeout=constants.HTTP_TIMEOUT_IN_SECONDS)\n \n-    def test_not_trusted_jku(self):\n+    @patch('httpx.get')\n+    def test_composed_jku_with_uaadomain(self, mock_requests):\n+        from sap.xssec.key_cache import KeyCache\n+        xssec.SecurityContextXSUAA.verificationKeyCache = KeyCache()\n \n-        with self.assertRaises(RuntimeError) as e:\n-            xssec.create_security_context(sign(jwt_payloads.USER_TOKEN), uaa_configs.VALID['uaa_no_verification_key_other_domain'])\n+        mock = MagicMock()\n+        mock_requests.return_value = mock\n+        mock.json.return_value = HTTP_SUCCESS\n \n-        self.assertEqual(\"JKU of token is not trusted\", str(e.exception),)\n+        xssec.create_security_context(\n+            sign(jwt_payloads.USER_TOKEN), uaa_configs.VALID['uaa_no_verification_key_other_domain'])\n+        mock_requests.assert_called_once_with(\"https://api.cf2.test.com/token_keys?zid=test-idz\",\n+                                              timeout=constants.HTTP_TIMEOUT_IN_SECONDS)\n \n     def test_valid_xsa_token_attributes(self):\n         ''' valid client credentials token (with attributes) '''\n@@ -475,7 +483,6 @@ def test_valid_xsa_token_attributes(self):\n         self.assertEqual(\n             sec_context.get_logon_name(), 'ADMIN')\n \n-\n     def test_valid_xsa_token_with_newlines(self):\n         ''' valid client credentials token (with attributes) '''\n         sec_context = xssec.create_security_context(\n@@ -484,12 +491,20 @@ def test_valid_xsa_token_with_newlines(self):\n         self.assertEqual(\n             sec_context.get_logon_name(), 'ADMIN')\n \n-    def test_invalid_jku_in_token_header(self):\n+    @patch('httpx.get')\n+    def test_ignored_invalid_jku_in_token_header(self, mock_requests):\n+        from sap.xssec.key_cache import KeyCache\n+        xssec.SecurityContextXSUAA.verificationKeyCache = KeyCache()\n+\n         uaa_config = uaa_configs.VALID['uaa']\n         token = sign(jwt_payloads.USER_TOKEN, headers={\n             \"jku\": 'http://ana.ondemandh.com\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\@' + uaa_config['uaadomain'],\n             \"kid\": \"key-id-0\"\n         })\n-        with self.assertRaises(RuntimeError) as e:\n-            xssec.create_security_context(token, uaa_config)\n-        self.assertEqual(\"JKU of token is not trusted\", str(e.exception),)\n+        mock = MagicMock()\n+        mock_requests.return_value = mock\n+        mock.json.return_value = HTTP_SUCCESS\n+\n+        xssec.create_security_context(token, uaa_config)\n+        mock_requests.assert_called_once_with(\"https://api.cf.test.com/token_keys?zid=test-idz\",\n+                                              timeout=constants.HTTP_TIMEOUT_IN_SECONDS)"
        },
        {
            "filename": "version.txt",
            "diff": "@@ -1 +1 @@\n-4.0.1\n+4.1.0"
        }
    ],
    "commitTime": "2023-11-23 16:14:38"
}