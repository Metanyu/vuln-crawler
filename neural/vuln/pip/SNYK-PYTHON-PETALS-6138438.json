{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "LOW",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 6.5,
    "disclosureTime": "2023-10-01 06:36:39",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-PETALS-6138438",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-362"
        ],
        "PVE": [
            "PVE-2023-61009"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2023-12-22 13:50:09",
    "remediation": "Upgrade petals to version 2.2.0 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Race Condition",
    "vulnDescription": {
        "Overview": "petals is an Easy way to efficiently run 100B+ language models without high-end GPUs Affected versions of this package are vulnerable to Race Condition in MemoryCache. "
    },
    "source_code": [
        {
            "filename": "src/petals/server/memory_cache.py",
            "diff": "@@ -31,7 +31,7 @@ def __init__(self, max_size_bytes: Optional[int], max_alloc_timeout: Optional[fl\n         self.max_alloc_timeout = max_alloc_timeout\n         self._lock_metadata = mp.Lock()\n         self._current_size = mp.Value(ctypes.c_int64, 0, lock=False)\n-        self._enqueued_size = mp.Value(ctypes.c_int64, 0, lock=False)\n+        self._enqueued_size = mp.Value(ctypes.c_int64, 0, lock=True)\n         self._handle_counter = mp.Value(ctypes.c_int64, 0, lock=False)\n         self._allocated_tensors: Dict[Handle, torch.Tensor] = {}\n         self.runtime_pid = os.getpid()\n@@ -138,7 +138,8 @@ async def _wait_for_free_memory(self, alloc_size: int, timeout: Optional[float])\n         start_time = time.perf_counter()\n         loop = asyncio.get_event_loop()\n \n-        self.enqueued_size_bytes += alloc_size\n+        with self._enqueued_size.get_lock():\n+            self._enqueued_size.value += alloc_size\n         allocated = False\n         try:\n             context_manager = async_timeout.timeout(timeout) if timeout != 0 else contextlib.AsyncExitStack()\n@@ -155,13 +156,15 @@ async def _wait_for_free_memory(self, alloc_size: int, timeout: Optional[float])\n                         await loop.run_in_executor(None, self._wait_until_available, alloc_size, remaining_timeout)\n \n                 allocated = True\n-                self.enqueued_size_bytes -= alloc_size\n+                with self._enqueued_size.get_lock():\n+                    self._enqueued_size.value -= alloc_size\n                 yield\n         except asyncio.TimeoutError:\n             raise AllocationFailed(f\"Could not allocate {alloc_size} within {timeout} seconds\")\n         finally:\n             if not allocated:\n-                self.enqueued_size_bytes -= alloc_size\n+                with self._enqueued_size.get_lock():\n+                    self._enqueued_size.value -= alloc_size\n \n     def _free(self, alloc_size: int, alloc_task: asyncio.Task):\n         if alloc_task.exception() is not None:"
        }
    ],
    "commitTime": "2023-08-30 10:13:43"
}