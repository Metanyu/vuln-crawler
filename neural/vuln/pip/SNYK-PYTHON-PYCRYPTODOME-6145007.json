{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "NONE",
        "availability": "NONE"
    },
    "credit": [
        "Hubert Kario"
    ],
    "cvssDetails": [],
    "cvssScore": 5.9,
    "disclosureTime": "2024-01-05 04:44:39",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-PYCRYPTODOME-6145007",
    "identifiers": {
        "CVE": [
            "CVE-2023-52323"
        ],
        "CWE": [
            "CWE-203"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2024-01-05 14:41:01",
    "remediation": "Upgrade pycryptodome to version 3.19.1 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Observable Timing Discrepancy",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Observable Timing Discrepancy due to improper handling of OAEP decryption. An attacker can extract sensitive information by exploiting the side-channel leakage to perform a Manger attack. "
    },
    "source_code": [
        {
            "filename": "lib/Crypto/Cipher/PKCS1_OAEP.py",
            "diff": "@@ -167,10 +167,8 @@ def decrypt(self, ciphertext):\n             raise ValueError(\"Ciphertext with incorrect length.\")\n         # Step 2a (O2SIP)\n         ct_int = bytes_to_long(ciphertext)\n-        # Step 2b (RSADP)\n-        m_int = self._key._decrypt(ct_int)\n-        # Complete step 2c (I2OSP)\n-        em = long_to_bytes(m_int, k)\n+        # Step 2b (RSADP) and step 2c (I2OSP)\n+        em = self._key._decrypt(ct_int)\n         # Step 3a\n         lHash = self._hashObj.new(self._label).digest()\n         # Step 3b"
        },
        {
            "filename": "lib/Crypto/Cipher/PKCS1_v1_5.py",
            "diff": "@@ -176,11 +176,8 @@ def decrypt(self, ciphertext, sentinel, expected_pt_len=0):\n         # Step 2a (O2SIP)\n         ct_int = bytes_to_long(ciphertext)\n \n-        # Step 2b (RSADP)\n-        m_int = self._key._decrypt(ct_int)\n-\n-        # Complete step 2c (I2OSP)\n-        em = long_to_bytes(m_int, k)\n+        # Step 2b (RSADP) and Step 2c (I2OSP)\n+        em = self._key._decrypt(ct_int)\n \n         # Step 3 (not constant time when the sentinel is not a byte string)\n         output = bytes(bytearray(k))"
        },
        {
            "filename": "lib/Crypto/Math/_IntegerBase.py",
            "diff": "@@ -390,3 +390,23 @@ def random_range(cls, **kwargs):\n                                     )\n         return norm_candidate + min_inclusive\n \n+    @staticmethod\n+    @abc.abstractmethod\n+    def _mult_modulo_bytes(term1, term2, modulus):\n+        \"\"\"Multiply two integers, take the modulo, and encode as big endian.\n+        This specialized method is used for RSA decryption.\n+\n+        Args:\n+          term1 : integer\n+            The first term of the multiplication, non-negative.\n+          term2 : integer\n+            The second term of the multiplication, non-negative.\n+          modulus: integer\n+            The modulus, a positive odd number.\n+        :Returns:\n+            A byte string, with the result of the modular multiplication\n+            encoded in big endian mode.\n+            It is as long as the modulus would be, with zero padding\n+            on the left if needed.\n+        \"\"\"\n+        pass"
        },
        {
            "filename": "lib/Crypto/Math/_IntegerBase.pyi",
            "diff": "@@ -60,4 +60,8 @@ class IntegerBase:\n     def random(cls, **kwargs: Union[int,RandFunc]) -> IntegerBase : ...\n     @classmethod\n     def random_range(cls, **kwargs: Union[int,RandFunc]) -> IntegerBase : ...\n+    @staticmethod\n+    def _mult_modulo_bytes(term1: Union[IntegerBase, int],\n+                           term2:  Union[IntegerBase, int],\n+                           modulus: Union[IntegerBase, int]) -> bytes: ...\n "
        },
        {
            "filename": "lib/Crypto/Math/_IntegerCustom.py",
            "diff": "@@ -41,12 +41,18 @@\n from Crypto.Random.random import getrandbits\n \n c_defs = \"\"\"\n-int monty_pow(const uint8_t *base,\n-               const uint8_t *exp,\n-               const uint8_t *modulus,\n-               uint8_t       *out,\n-               size_t len,\n-               uint64_t seed);\n+int monty_pow(uint8_t       *out,\n+              const uint8_t *base,\n+              const uint8_t *exp,\n+              const uint8_t *modulus,\n+              size_t        len,\n+              uint64_t      seed);\n+\n+int monty_multiply(uint8_t       *out,\n+                   const uint8_t *term1,\n+                   const uint8_t *term2,\n+                   const uint8_t *modulus,\n+                   size_t        len);\n \"\"\"\n \n \n@@ -116,3 +122,41 @@ def inplace_pow(self, exponent, modulus=None):\n         result = bytes_to_long(get_raw_buffer(out))\n         self._value = result\n         return self\n+\n+    @staticmethod\n+    def _mult_modulo_bytes(term1, term2, modulus):\n+\n+        # With modular reduction\n+        mod_value = int(modulus)\n+        if mod_value < 0:\n+            raise ValueError(\"Modulus must be positive\")\n+        if mod_value == 0:\n+            raise ZeroDivisionError(\"Modulus cannot be zero\")\n+\n+        # C extension only works with odd moduli\n+        if (mod_value & 1) == 0:\n+            raise ValueError(\"Odd modulus is required\")\n+\n+        # C extension only works with non-negative terms smaller than modulus\n+        if term1 >= mod_value or term1 < 0:\n+            term1 %= mod_value\n+        if term2 >= mod_value or term2 < 0:\n+            term2 %= mod_value\n+\n+        modulus_b = long_to_bytes(mod_value)\n+        numbers_len = len(modulus_b)\n+        term1_b = long_to_bytes(term1, numbers_len)\n+        term2_b = long_to_bytes(term2, numbers_len)\n+        out = create_string_buffer(numbers_len)\n+\n+        error = _raw_montgomery.monty_multiply(\n+                    out,\n+                    term1_b,\n+                    term2_b,\n+                    modulus_b,\n+                    c_size_t(numbers_len)\n+                    )\n+        if error:\n+            raise ValueError(\"monty_multiply failed with error: %d\" % error)\n+\n+        return get_raw_buffer(out)"
        },
        {
            "filename": "lib/Crypto/Math/_IntegerGMP.py",
            "diff": "@@ -749,6 +749,26 @@ def jacobi_symbol(a, n):\n             raise ValueError(\"n must be positive odd for the Jacobi symbol\")\n         return _gmp.mpz_jacobi(a._mpz_p, n._mpz_p)\n \n+    @staticmethod\n+    def _mult_modulo_bytes(term1, term2, modulus):\n+        if not isinstance(term1, IntegerGMP):\n+            term1 = IntegerGMP(term1)\n+        if not isinstance(term2, IntegerGMP):\n+            term2 = IntegerGMP(term2)\n+        if not isinstance(modulus, IntegerGMP):\n+            modulus = IntegerGMP(modulus)\n+\n+        if modulus < 0:\n+            raise ValueError(\"Modulus must be positive\")\n+        if modulus == 0:\n+            raise ZeroDivisionError(\"Modulus cannot be zero\")\n+        if (modulus & 1) == 0:\n+            raise ValueError(\"Odd modulus is required\")\n+\n+        numbers_len = len(modulus.to_bytes())\n+        result = ((term1 * term2) % modulus).to_bytes(numbers_len)\n+        return result\n+\n     # Clean-up\n     def __del__(self):\n "
        },
        {
            "filename": "lib/Crypto/Math/_IntegerNative.py",
            "diff": "@@ -368,3 +368,15 @@ def jacobi_symbol(a, n):\n         n1 = n % a1\n         # Step 8\n         return s * IntegerNative.jacobi_symbol(n1, a1)\n+\n+    @staticmethod\n+    def _mult_modulo_bytes(term1, term2, modulus):\n+        if modulus < 0:\n+            raise ValueError(\"Modulus must be positive\")\n+        if modulus == 0:\n+            raise ZeroDivisionError(\"Modulus cannot be zero\")\n+        if (modulus & 1) == 0:\n+            raise ValueError(\"Odd modulus is required\")\n+\n+        number_len = len(long_to_bytes(modulus))\n+        return long_to_bytes((term1 * term2) % modulus, number_len)"
        },
        {
            "filename": "lib/Crypto/PublicKey/RSA.py",
            "diff": "@@ -38,6 +38,7 @@\n from Crypto import Random\n from Crypto.Util.py3compat import tobytes, bord, tostr\n from Crypto.Util.asn1 import DerSequence, DerNull\n+from Crypto.Util.number import bytes_to_long\n \n from Crypto.Math.Numbers import Integer\n from Crypto.Math.Primality import (test_probable_prime,\n@@ -198,10 +199,11 @@ def _decrypt(self, ciphertext):\n         h = ((m2 - m1) * self._u) % self._q\n         mp = h * self._p + m1\n         # Step 4: Compute m = m' * (r**(-1)) mod n\n-        result = (r.inverse(self._n) * mp) % self._n\n-        # Verify no faults occurred\n-        if ciphertext != pow(result, self._e, self._n):\n-            raise ValueError(\"Fault detected in RSA decryption\")\n+        # then encode into a big endian byte string\n+        result = Integer._mult_modulo_bytes(\n+                    r.inverse(self._n),\n+                    mp,\n+                    self._n)\n         return result\n \n     def has_private(self):"
        },
        {
            "filename": "lib/Crypto/SelfTest/Math/__init__.py",
            "diff": "@@ -38,9 +38,11 @@ def get_tests(config={}):\n     from Crypto.SelfTest.Math import test_Numbers\n     from Crypto.SelfTest.Math import test_Primality\n     from Crypto.SelfTest.Math import test_modexp\n+    from Crypto.SelfTest.Math import test_modmult\n     tests += test_Numbers.get_tests(config=config)\n     tests += test_Primality.get_tests(config=config)\n     tests += test_modexp.get_tests(config=config)\n+    tests += test_modmult.get_tests(config=config)\n     return tests\n \n if __name__ == '__main__':"
        },
        {
            "filename": "lib/Crypto/SelfTest/Math/test_Numbers.py",
            "diff": "@@ -696,6 +696,34 @@ def test_hex(self):\n         v1, = self.Integers(0x10)\n         self.assertEqual(hex(v1), \"0x10\")\n \n+    def test_mult_modulo_bytes(self):\n+        modmult = self.Integer._mult_modulo_bytes\n+\n+        res = modmult(4, 5, 19)\n+        self.assertEqual(res, b'\\x01')\n+\n+        res = modmult(4 - 19, 5, 19)\n+        self.assertEqual(res, b'\\x01')\n+\n+        res = modmult(4, 5 - 19, 19)\n+        self.assertEqual(res, b'\\x01')\n+\n+        res = modmult(4 + 19, 5, 19)\n+        self.assertEqual(res, b'\\x01')\n+\n+        res = modmult(4, 5 + 19, 19)\n+        self.assertEqual(res, b'\\x01')\n+\n+        modulus = 2**512 - 1    # 64 bytes\n+        t1 = 13**100\n+        t2 = 17**100\n+        expect = b\"\\xfa\\xb2\\x11\\x87\\xc3(y\\x07\\xf8\\xf1n\\xdepq\\x0b\\xca\\xf3\\xd3B,\\xef\\xf2\\xfbf\\xcc)\\x8dZ*\\x95\\x98r\\x96\\xa8\\xd5\\xc3}\\xe2q:\\xa2'z\\xf48\\xde%\\xef\\t\\x07\\xbc\\xc4[C\\x8bUE2\\x90\\xef\\x81\\xaa:\\x08\"\n+        self.assertEqual(expect, modmult(t1, t2, modulus))\n+\n+        self.assertRaises(ZeroDivisionError, modmult, 4, 5, 0)\n+        self.assertRaises(ValueError, modmult, 4, 5, -1)\n+        self.assertRaises(ValueError, modmult, 4, 5, 4)\n+\n \n class TestIntegerInt(TestIntegerBase):\n "
        },
        {
            "filename": "lib/Crypto/SelfTest/Math/test_modmult.py",
            "diff": "@@ -0,0 +1,120 @@\n+#\n+#  SelfTest/Math/test_modmult.py: Self-test for custom modular multiplication\n+#\n+# ===================================================================\n+#\n+# Copyright (c) 2023, Helder Eijs <helderijs@gmail.com>\n+# All rights reserved.\n+#\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions\n+# are met:\n+#\n+# 1. Redistributions of source code must retain the above copyright\n+#    notice, this list of conditions and the following disclaimer.\n+# 2. Redistributions in binary form must reproduce the above copyright\n+#    notice, this list of conditions and the following disclaimer in\n+#    the documentation and/or other materials provided with the\n+#    distribution.\n+#\n+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+# ===================================================================\n+\n+\"\"\"Self-test for the custom modular multiplication\"\"\"\n+\n+import unittest\n+\n+from Crypto.SelfTest.st_common import list_test_cases\n+\n+from Crypto.Util.number import long_to_bytes, bytes_to_long\n+\n+from Crypto.Util._raw_api import (create_string_buffer,\n+                                  get_raw_buffer,\n+                                  c_size_t)\n+\n+from Crypto.Math._IntegerCustom import _raw_montgomery\n+\n+\n+class ExceptionModulus(ValueError):\n+    pass\n+\n+\n+def monty_mult(term1, term2, modulus):\n+\n+    if term1 >= modulus:\n+        term1 %= modulus\n+    if term2 >= modulus:\n+        term2 %= modulus\n+\n+    modulus_b = long_to_bytes(modulus)\n+    numbers_len = len(modulus_b)\n+    term1_b = long_to_bytes(term1, numbers_len)\n+    term2_b = long_to_bytes(term2, numbers_len)\n+\n+    out = create_string_buffer(numbers_len)\n+    error = _raw_montgomery.monty_multiply(\n+                out,\n+                term1_b,\n+                term2_b,\n+                modulus_b,\n+                c_size_t(numbers_len)\n+                )\n+\n+    if error == 17:\n+        raise ExceptionModulus()\n+    if error:\n+        raise ValueError(\"monty_multiply() failed with error: %d\" % error)\n+\n+    return get_raw_buffer(out)\n+\n+\n+modulus1 = 0xd66691b20071be4d66d4b71032b37fa007cfabf579fcb91e50bfc2753b3f0ce7be74e216aef7e26d4ae180bc20d7bd3ea88a6cbf6f87380e613c8979b5b043b200a8ff8856a3b12875e36e98a7569f3852d028e967551000b02c19e9fa52e83115b89309aabb1e1cf1e2cb6369d637d46775ce4523ea31f64ad2794cbc365dd8a35e007ed3b57695877fbf102dbeb8b3212491398e494314e93726926e1383f8abb5889bea954eb8c0ca1c62c8e9d83f41888095c5e645ed6d32515fe0c58c1368cad84694e18da43668c6f43e61d7c9bca633ddcda7aef5b79bc396d4a9f48e2a9abe0836cc455e435305357228e93d25aaed46b952defae0f57339bf26f5a9\n+\n+\n+class TestModMultiply(unittest.TestCase):\n+\n+    def test_small(self):\n+        self.assertEqual(b\"\\x01\", monty_mult(5, 6, 29))\n+\n+    def test_large(self):\n+        numbers_len = (modulus1.bit_length() + 7) // 8\n+\n+        t1 = modulus1 // 2\n+        t2 = modulus1 - 90\n+        expect = b'\\x00' * (numbers_len - 1) + b'\\x2d'\n+        self.assertEqual(expect, monty_mult(t1, t2, modulus1))\n+\n+    def test_zero_term(self):\n+        numbers_len = (modulus1.bit_length() + 7) // 8\n+        expect = b'\\x00' * numbers_len\n+        self.assertEqual(expect, monty_mult(0x100, 0, modulus1))\n+        self.assertEqual(expect, monty_mult(0, 0x100, modulus1))\n+\n+    def test_larger_term(self):\n+        t1 = 2**2047\n+        expect_int = 0x8edf4071f78e3d7ba622cdbbbef74612e301d69186776ae6bf87ff38c320d9aebaa64889c2f67de2324e6bccd2b10ad89e91fd21ba4bb523904d033eff5e70e62f01a84f41fa90a4f248ef249b82e1d2729253fdfc2a3b5b740198123df8bfbf7057d03e15244ad5f26eb9a099763b5c5972121ec076b0bf899f59bd95f7cc129abddccf24217bce52ca0f3a44c9ccc504765dbb89734205f3ae6a8cc560494a60ea84b27d8e00fa24bdd5b4f1d4232edb61e47d3d984c1fa50a3820a2e580fbc3fc8bc11e99df53b9efadf5a40ac75d384e400905aa6f1d88950cd53b1c54dc2222115ad84a27260fa4d978155c1434c551de1ee7361a17a2f79d4388f78a5d\n+        res = bytes_to_long(monty_mult(t1, t1, modulus1))\n+        self.assertEqual(res, expect_int)\n+\n+\n+def get_tests(config={}):\n+    tests = []\n+    tests += list_test_cases(TestModMultiply)\n+    return tests\n+\n+\n+if __name__ == '__main__':\n+    def suite():\n+        return unittest.TestSuite(get_tests())\n+    unittest.main(defaultTest='suite')"
        },
        {
            "filename": "lib/Crypto/SelfTest/PublicKey/test_RSA.py",
            "diff": "@@ -279,7 +279,7 @@ def _exercise_primitive(self, rsaObj):\n         ciphertext = bytes_to_long(a2b_hex(self.ciphertext))\n \n         # Test decryption\n-        plaintext = rsaObj._decrypt(ciphertext)\n+        plaintext = bytes_to_long(rsaObj._decrypt(ciphertext))\n \n         # Test encryption (2 arguments)\n         new_ciphertext2 = rsaObj._encrypt(plaintext)\n@@ -304,7 +304,7 @@ def _check_decryption(self, rsaObj):\n         ciphertext = bytes_to_long(a2b_hex(self.ciphertext))\n \n         # Test plain decryption\n-        new_plaintext = rsaObj._decrypt(ciphertext)\n+        new_plaintext = bytes_to_long(rsaObj._decrypt(ciphertext))\n         self.assertEqual(plaintext, new_plaintext)\n \n "
        },
        {
            "filename": "lib/Crypto/SelfTest/PublicKey/test_import_RSA.py",
            "diff": "@@ -29,7 +29,7 @@\n from Crypto.PublicKey import RSA\n from Crypto.SelfTest.st_common import a2b_hex, list_test_cases\n from Crypto.Util.py3compat import b, tostr, FileNotFoundError\n-from Crypto.Util.number import inverse\n+from Crypto.Util.number import inverse, bytes_to_long\n from Crypto.Util import asn1\n \n try:\n@@ -239,13 +239,13 @@ def testImportKey4bytes(self):\n     def testImportKey5(self):\n         \"\"\"Verifies that the imported key is still a valid RSA pair\"\"\"\n         key = RSA.importKey(self.rsaKeyPEM)\n-        idem = key._encrypt(key._decrypt(89))\n+        idem = key._encrypt(bytes_to_long(key._decrypt(89)))\n         self.assertEqual(idem, 89)\n \n     def testImportKey6(self):\n         \"\"\"Verifies that the imported key is still a valid RSA pair\"\"\"\n         key = RSA.importKey(self.rsaKeyDER)\n-        idem = key._encrypt(key._decrypt(65))\n+        idem = key._encrypt(bytes_to_long(key._decrypt(65)))\n         self.assertEqual(idem, 65)\n \n     def testImportKey7(self):"
        },
        {
            "filename": "lib/Crypto/Signature/pkcs1_15.py",
            "diff": "@@ -77,10 +77,11 @@ def sign(self, msg_hash):\n         em = _EMSA_PKCS1_V1_5_ENCODE(msg_hash, k)\n         # Step 2a (OS2IP)\n         em_int = bytes_to_long(em)\n-        # Step 2b (RSASP1)\n-        m_int = self._key._decrypt(em_int)\n-        # Step 2c (I2OSP)\n-        signature = long_to_bytes(m_int, k)\n+        # Step 2b (RSASP1) and Step 2c (I2OSP)\n+        signature = self._key._decrypt(em_int)\n+        # Verify no faults occurred\n+        if em_int != pow(bytes_to_long(signature), self._key.e, self._key.n):\n+            raise ValueError(\"Fault detected in RSA private key operation\")\n         return signature\n \n     def verify(self, msg_hash, signature):"
        },
        {
            "filename": "lib/Crypto/Signature/pss.py",
            "diff": "@@ -107,10 +107,11 @@ def sign(self, msg_hash):\n         em = _EMSA_PSS_ENCODE(msg_hash, modBits-1, self._randfunc, mgf, sLen)\n         # Step 2a (OS2IP)\n         em_int = bytes_to_long(em)\n-        # Step 2b (RSASP1)\n-        m_int = self._key._decrypt(em_int)\n-        # Step 2c (I2OSP)\n-        signature = long_to_bytes(m_int, k)\n+        # Step 2b (RSASP1) and Step 2c (I2OSP)\n+        signature = self._key._decrypt(em_int)\n+        # Verify no faults occurred\n+        if em_int != pow(bytes_to_long(signature), self._key.e, self._key.n):\n+            raise ValueError(\"Fault detected in RSA private key operation\")\n         return signature\n \n     def verify(self, msg_hash, signature):\n@@ -178,7 +179,7 @@ def MGF1(mgfSeed, maskLen, hash_gen):\n \n     :return: the mask, as a *byte string*\n     \"\"\"\n-    \n+\n     T = b\"\"\n     for counter in iter_range(ceil_div(maskLen, hash_gen.digest_size)):\n         c = long_to_bytes(counter, 4)"
        },
        {
            "filename": "src/bignum.c",
            "diff": "@@ -165,7 +165,7 @@ STATIC int mod_select(uint64_t *out, const uint64_t *a, const uint64_t *b, unsig\n     mask = (uint64_t)((cond != 0) - 1); /* 0 for a, 1s for b */\n \n #if SYS_BITS == 64\n-    r0 = _mm_set1_epi64x(mask);\n+    r0 = _mm_set1_epi64x((int64_t)mask);\n #else\n     r0 = _mm_loadl_epi64((__m128i*)&mask);\n     r0 = _mm_unpacklo_epi64(r0, r0);"
        },
        {
            "filename": "src/modexp.c",
            "diff": "@@ -179,6 +179,71 @@ EXPORT_SYM int monty_pow(\n     return res;\n }\n \n+/*\n+ * Modular multiplication. All numbers are\n+ * encoded in big endian form, possibly with\n+ * zero padding on the left.\n+ *\n+ * @param out     The memory area where to store the result\n+ * @param term1   First term of the multiplication, strictly smaller than the modulus\n+ * @param term2   Second term of the multiplication, strictly smaller than the modulus\n+ * @param modulus Modulus, it must be odd\n+ * @param len     Size in bytes of out, term1, term2, and modulus\n+ * @return        0 in case of success, the appropriate error code otherwise\n+ */\n+EXPORT_SYM int monty_multiply(\n+               uint8_t       *out,\n+               const uint8_t *term1,\n+               const uint8_t *term2,\n+               const uint8_t *modulus,\n+               size_t        len)\n+{\n+    MontContext *ctx = NULL;\n+    uint64_t *mont_term1 = NULL;\n+    uint64_t *mont_term2 = NULL;\n+    uint64_t *mont_output = NULL;\n+    uint64_t *scratchpad = NULL;\n+    int res;\n+\n+    if (!term1 || !term2 || !modulus || !out)\n+        return ERR_NULL;\n+\n+    if (len == 0)\n+        return ERR_NOT_ENOUGH_DATA;\n+\n+    /* Allocations **/\n+    res = mont_context_init(&ctx, modulus, len);\n+    if (res)\n+        return res;\n+\n+    res = mont_from_bytes(&mont_term1, term1, len, ctx);\n+    if (res) goto cleanup;\n+\n+    res = mont_from_bytes(&mont_term2, term2, len, ctx);\n+    if (res) goto cleanup;\n+\n+    res = mont_number(&mont_output, 1, ctx);\n+    if (res) goto cleanup;\n+\n+    res = mont_number(&scratchpad, SCRATCHPAD_NR, ctx);\n+    if (res) goto cleanup;\n+\n+    /* Multiply, then transform result back into big-endian, byte form **/\n+    res = mont_mult(mont_output, mont_term1, mont_term2, scratchpad, ctx);\n+    if (res) goto cleanup;\n+\n+    res = mont_to_bytes(out, len, mont_output, ctx);\n+\n+cleanup:\n+    mont_context_free(ctx);\n+    free(mont_term1);\n+    free(mont_term2);\n+    free(mont_output);\n+    free(scratchpad);\n+\n+    return res;\n+}\n+\n #ifdef MAIN\n int main(void)\n {\n@@ -205,7 +270,7 @@ int main(void)\n     res = fread(out, 1, length, stdin);\n \n     result = monty_pow(out, base, exponent, modulus, length, 12);\n-    \n+\n     free(base);\n     free(modulus);\n     free(exponent);\n@@ -232,5 +297,6 @@ int main(void)\n     monty_pow(out, base, exponent, modulus, length, 12);\n     }\n \n+    monty_multiply(out, base, out, modulus, length);\n }\n #endif"
        }
    ],
    "commitTime": "2023-12-25 00:30:40"
}