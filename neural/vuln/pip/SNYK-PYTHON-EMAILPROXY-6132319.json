{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "LOW",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 6.8,
    "disclosureTime": "2023-12-19 23:12:03",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-EMAILPROXY-6132319",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-620"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2023-12-20 10:32:15",
    "remediation": "Upgrade emailproxy to version 2023.11.19 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Unverified Password Change",
    "vulnDescription": {
        "Overview": "emailproxy is a Transparently add OAuth 2.0 support to IMAP/POP/SMTP clients that don't support this authentication method. Affected versions of this package are vulnerable to Unverified Password Change due to improper validation of expired authorization tokens. An attacker with knowledge of valid account addresses and careful timing could exploit this vulnerability to gain unauthorized access to an account without needing to validate the account password. Note: This is only exploitable when using a proxy with the CCG flow, It is particularly important to update if you use the proxy in a publicly accessible setting (i.e., it is available from the internet or across a network) "
    },
    "source_code": [
        {
            "filename": "README.md",
            "diff": "@@ -33,7 +33,7 @@ As part of the proxy setup process you need to provide an OAuth 2.0 `client_id`\n \n If you have an existing client ID and secret for a desktop app, you can use these directly in the proxy. If this is not possible, you can also reuse the client ID and secret from any email client that supports IMAP/POP/SMTP OAuth 2.0 authentication with the email server you would like to connect to (such as the [various](https://github.com/mozilla/releases-comm-central/blob/master/mailnews/base/src/OAuth2Providers.jsm) [open](https://github.com/Foundry376/Mailspring/blob/master/app/internal_packages/onboarding/lib/onboarding-constants.ts) [source](https://gitlab.gnome.org/GNOME/evolution-data-server/-/blob/master/CMakeLists.txt) [clients](https://gitlab.gnome.org/GNOME/gnome-online-accounts/-/blob/master/meson_options.txt) with OAuth 2.0 support), but please do this with care and restraint as access through reused tokens will be associated with the token owner rather than your own client.\n \n-If you do not have access to credentials for an existing client you will need to register your own. The process to do this is different for each provider, but the registration guides for several common ones are linked below. In all cases, when registering, make sure your client is set up to use an OAuth scope that will give it permission to access IMAP/POP/SMTP as desired (see the sample configuration file for examples).\n+If you do not have access to credentials for an existing client you will need to register your own. The process to do this is different for each provider, but the registration guides for several common ones are linked below. In all cases, when registering, make sure your client is set up to use an OAuth scope that will give it permission to access IMAP/POP/SMTP as desired. It is also highly recommended to use a scope that will grant \"offline\" access (i.e., a way to [refresh the OAuth 2.0 authentication token](https://oauth.net/2/refresh-tokens/) without user intervention). The sample configuration file provides example scope values for several common providers.\n \n - Office 365: register a new [Microsoft identity application](https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app)\n - Gmail / Google Workspace: register a [Google API desktop app client](https://developers.google.com/identity/protocols/oauth2/native-app)"
        },
        {
            "filename": "emailproxy.config",
            "diff": "@@ -82,6 +82,10 @@ documentation = Accounts are specified using your email address as the section h\n \tSee the proxy's README.md file for more information and further configuration options.\n \t\n \tOffice 365 customisation:\n+\t- Unlike other providers, Office 365 requires an OAuth 2.0 scope that explicitly specifies `offline_access` (shown\n+\tin the example below) in order to allow the proxy to refresh its access token on your behalf. The proxy will still\n+\twork if this parameter is not included, but you will need to re-authenticate extremely often (about once per hour).\n+\t\n \t- If your Office 365 configuration requires a tenant ID, place it in both `permission_url` and `token_url` in place\n \tof `common` in the example below. For more detail about this, and guides for setting up your desktop app API client,\n \tsee the documentation at https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app.\n@@ -93,7 +97,9 @@ documentation = Accounts are specified using your email address as the section h\n \tsetup, delete the `client_secret` line from your account's configuration entry (do not leave the default value).\n \t\n \tAdvanced account configuration:\n-\t- For most configurations the default `redirect_uri` value of `http://localhost` is correct, but when using the\n+\t- For most configurations the default `redirect_uri` value of `http://localhost` is correct, unless you have\n+\texplicitly set your OAuth 2.0 client to use a different address here (which you will need to manually redirect to\n+\tthe proxy). Please also note that this address is `http` and not `https` (which is not supported). When using the\n \t`--local-server-auth` proxy option you will need to either run the script via sudo (to use the implicit default port\n \t80) or specify a different port (and/or a different host) - for example, `redirect_uri = http://localhost:8080`. In\n \taddition, if you are using this proxy option in a configuration that is not directly exposed (such as a container or"
        },
        {
            "filename": "emailproxy.py",
            "diff": "@@ -4,7 +4,7 @@\n __author__ = 'Simon Robinson'\n __copyright__ = 'Copyright (c) 2022 Simon Robinson'\n __license__ = 'Apache 2.0'\n-__version__ = '2022-08-30'  # ISO 8601 (YYYY-MM-DD)\n+__version__ = '2022-09-05'  # ISO 8601 (YYYY-MM-DD)\n \n import argparse\n import base64\n@@ -129,7 +129,7 @@ class NSObject:\n IMAP_CAPABILITY_MATCHER = re.compile(r'^(\\* |\\* OK \\[)CAPABILITY .*$', flags=re.IGNORECASE)  # note: '* ' and '* OK ['\n \n REQUEST_QUEUE = queue.Queue()  # requests for authentication\n-RESPONSE_QUEUE = queue.Queue()  # responses from client web view\n+RESPONSE_QUEUE = queue.Queue()  # responses from user\n WEBVIEW_QUEUE = queue.Queue()  # authentication window events (macOS only)\n QUEUE_SENTINEL = object()  # object to send to signify queues should exit loops\n \n@@ -310,7 +310,7 @@ def save():\n \n class OAuth2Helper:\n     @staticmethod\n-    def get_oauth2_credentials(username, password, connection_info, recurse_retries=True):\n+    def get_oauth2_credentials(username, password, recurse_retries=True):\n         \"\"\"Using the given username (i.e., email address) and password, reads account details from AppConfig and\n         handles OAuth 2.0 token request and renewal, saving the updated details back to AppConfig (or removing them\n         if invalid). Returns either (True, '[OAuth2 string for authentication]') or (False, '[Error message]')\"\"\"\n@@ -367,13 +367,35 @@ def get_oauth2_credentials(username, password, connection_info, recurse_retries=\n         cryptographer = Fernet(key)\n \n         try:\n-            if not refresh_token:\n+            if access_token:\n+                if access_token_expiry - current_time < TOKEN_EXPIRY_MARGIN:\n+                    if refresh_token:\n+                        # if expiring soon, refresh token (if possible)\n+                        response = OAuth2Helper.refresh_oauth2_access_token(token_url, client_id, client_secret,\n+                                                                            OAuth2Helper.decrypt(cryptographer,\n+                                                                                                 refresh_token))\n+\n+                        access_token = response['access_token']\n+                        config.set(username, 'access_token', OAuth2Helper.encrypt(cryptographer, access_token))\n+                        config.set(username, 'access_token_expiry', str(current_time + response['expires_in']))\n+                        if 'refresh_token' in response:\n+                            config.set(username, 'refresh_token',\n+                                       OAuth2Helper.encrypt(cryptographer, response['refresh_token']))\n+                        AppConfig.save()\n+\n+                    elif access_token_expiry <= current_time:\n+                        # cannot get another access token without a refresh token - must submit another manual request\n+                        access_token = None\n+                else:\n+                    access_token = OAuth2Helper.decrypt(cryptographer, access_token)\n+\n+            if not access_token:\n                 permission_url = OAuth2Helper.construct_oauth2_permission_url(permission_url, redirect_uri, client_id,\n                                                                               oauth2_scope, username)\n                 # note: get_oauth2_authorisation_code is a blocking call\n                 success, authorisation_code = OAuth2Helper.get_oauth2_authorisation_code(permission_url, redirect_uri,\n                                                                                          redirect_listen_address,\n-                                                                                         username, connection_info)\n+                                                                                         username)\n                 if not success:\n                     Log.info('Authentication request failed or expired for account', username, '- aborting login')\n                     return False, '%s: Login failed - the authentication request expired or was cancelled for ' \\\n@@ -386,24 +408,13 @@ def get_oauth2_credentials(username, password, connection_info, recurse_retries=\n                 config.set(username, 'token_salt', token_salt)\n                 config.set(username, 'access_token', OAuth2Helper.encrypt(cryptographer, access_token))\n                 config.set(username, 'access_token_expiry', str(current_time + response['expires_in']))\n-                config.set(username, 'refresh_token', OAuth2Helper.encrypt(cryptographer, response['refresh_token']))\n-                AppConfig.save()\n-\n-            else:\n-                if access_token_expiry - current_time < TOKEN_EXPIRY_MARGIN:  # if expiring soon, refresh token\n-                    response = OAuth2Helper.refresh_oauth2_access_token(token_url, client_id, client_secret,\n-                                                                        OAuth2Helper.decrypt(cryptographer,\n-                                                                                             refresh_token))\n-\n-                    access_token = response['access_token']\n-                    config.set(username, 'access_token', OAuth2Helper.encrypt(cryptographer, access_token))\n-                    config.set(username, 'access_token_expiry', str(current_time + response['expires_in']))\n-                    if 'refresh_token' in response:\n-                        config.set(username, 'refresh_token',\n-                                   OAuth2Helper.encrypt(cryptographer, response['refresh_token']))\n-                    AppConfig.save()\n+                if 'refresh_token' in response:\n+                    config.set(username, 'refresh_token',\n+                               OAuth2Helper.encrypt(cryptographer, response['refresh_token']))\n                 else:\n-                    access_token = OAuth2Helper.decrypt(cryptographer, access_token)\n+                    Log.info('Warning: no refresh token returned for', username, '- you will need to re-authenticate',\n+                             'each time the access token expires (does your `oauth2_scope` value allow `offline` use?)')\n+                AppConfig.save()\n \n             # send authentication command to server (response checked in ServerConnection) - note: we only support\n             # single-trip authentication (SASL) without actually checking the server's capabilities - improve?\n@@ -425,15 +436,17 @@ def get_oauth2_credentials(username, password, connection_info, recurse_retries=\n \n             if recurse_retries:\n                 Log.info('Retrying login due to exception while requesting OAuth 2.0 credentials:', Log.error_string(e))\n-                return OAuth2Helper.get_oauth2_credentials(username, password, connection_info, recurse_retries=False)\n+                return OAuth2Helper.get_oauth2_credentials(username, password, recurse_retries=False)\n             else:\n                 Log.error('Invalid password to decrypt', username, 'credentials - aborting login:', Log.error_string(e))\n                 return False, '%s: Login failed - the password for account %s is incorrect' % (APP_NAME, username)\n \n         except Exception as e:\n-            # note that we don't currently remove cached credentials here, as failures on the initial request are\n-            # before caching happens, and the assumption is that refresh token request exceptions are temporal (e.g.,\n-            # network errors: URLError(OSError(50, 'Network is down'))) rather than e.g., bad requests\n+            # note that we don't currently remove cached credentials here, as failures on the initial request are before\n+            # caching happens, and the assumption is that refresh token request exceptions are temporal (e.g., network\n+            # errors: URLError(OSError(50, 'Network is down'))) - access token 400 Bad Request HTTPErrors with messages\n+            # such as 'authorisation code was already redeemed' are caused by our support for simultaneous requests,\n+            # and will work from the next request; however, please report an issue if you encounter problems here\n             Log.info('Caught exception while requesting OAuth 2.0 credentials:', Log.error_string(e))\n             return False, '%s: Login failed for account %s - please check your internet connection and retry' % (\n                 APP_NAME, username)\n@@ -457,9 +470,8 @@ def oauth2_url_unescape(text):\n     @staticmethod\n     def start_redirection_receiver_server(token_request):\n         \"\"\"Starts a local WSGI web server at token_request['redirect_uri'] to receive OAuth responses\"\"\"\n-        wsgi_address = token_request['redirect_listen_address'] if token_request['redirect_listen_address'] else \\\n-            token_request['redirect_uri']\n-        parsed_uri = urllib.parse.urlparse(wsgi_address)\n+        redirect_listen_type = 'redirect_listen_address' if token_request['redirect_listen_address'] else 'redirect_uri'\n+        parsed_uri = urllib.parse.urlparse(token_request[redirect_listen_type])\n         parsed_port = 80 if parsed_uri.port is None else parsed_uri.port\n         Log.debug('Local server auth mode (%s:%d): starting server to listen for authentication response' % (\n             parsed_uri.hostname, parsed_port))\n@@ -480,28 +492,38 @@ def __call__(self, environ, start_response):\n \n         try:\n             wsgiref.simple_server.WSGIServer.allow_reuse_address = False\n+            wsgiref.simple_server.WSGIServer.timeout = AUTHENTICATION_TIMEOUT\n             redirection_server = wsgiref.simple_server.make_server(str(parsed_uri.hostname), parsed_port,\n                                                                    RedirectionReceiverWSGIApplication(),\n                                                                    handler_class=LoggingWSGIRequestHandler)\n-            token_request['local_server_auth_wsgi'] = redirection_server\n+\n             Log.info('Please visit the following URL to authenticate account %s: %s' %\n                      (token_request['username'], token_request['permission_url']))\n             redirection_server.handle_request()\n-            redirection_server.server_close()\n+            try:\n+                redirection_server.server_close()\n+            except socket.error:\n+                pass\n \n-            Log.debug('Local server auth mode (%s:%d): closing local server and returning response' % (\n-                parsed_uri.hostname, parsed_port), token_request['response_url'])\n-            del token_request['local_server_auth']\n-            del token_request['local_server_auth_wsgi']\n-            RESPONSE_QUEUE.put(token_request)\n+            if 'response_url' in token_request:\n+                Log.debug('Local server auth mode (%s:%d): closing local server and returning response' % (\n+                    parsed_uri.hostname, parsed_port), token_request['response_url'])\n+            else:\n+                # failed, likely because of an incorrect address (e.g., https vs http), but can also be due to timeout\n+                Log.info('Local server auth mode (%s:%d):' % (parsed_uri.hostname, parsed_port), 'request failed - if',\n+                         'this error reoccurs, please check `%s` for' % redirect_listen_type, token_request['username'],\n+                         'is not specified as `https` mistakenly. See the sample configuration file for documentation')\n+                token_request['expired'] = True\n \n         except socket.error as e:\n-            Log.error('Local server auth mode (%s:%d): unable to start local server. Please check that the %s for '\n-                      'account %s is unique across accounts, specifies a port number, and is not already in use. See '\n-                      'the documentation in the proxy\\'s sample configuration file for further detail' % (\n-                          parsed_uri.hostname, parsed_port,\n-                          'redirect_listen_address' if token_request['redirect_listen_address'] else 'redirect_uri',\n-                          token_request['username']), Log.error_string(e))\n+            Log.error('Local server auth mode (%s:%d):' % (parsed_uri.hostname, parsed_port), 'unable to start local',\n+                      'server. Please check that `%s` for %s is unique across accounts, specifies a port number, and '\n+                      'is not already in use. See the documentation in the proxy\\'s sample configuration file.' % (\n+                          redirect_listen_type, token_request['username']), Log.error_string(e))\n+            token_request['expired'] = True\n+\n+        del token_request['local_server_auth']\n+        RESPONSE_QUEUE.put(token_request)\n \n     @staticmethod\n     def construct_oauth2_permission_url(permission_url, redirect_uri, client_id, scope, username):\n@@ -516,11 +538,10 @@ def construct_oauth2_permission_url(permission_url, redirect_uri, client_id, sco\n         return '%s?%s' % (permission_url, '&'.join(param_pairs))\n \n     @staticmethod\n-    def get_oauth2_authorisation_code(permission_url, redirect_uri, redirect_listen_address, username, connection_info):\n+    def get_oauth2_authorisation_code(permission_url, redirect_uri, redirect_listen_address, username):\n         \"\"\"Submit an authorisation request to the parent app and block until it is provided (or the request fails)\"\"\"\n-        token_request = {'connection': connection_info, 'permission_url': permission_url,\n-                         'redirect_uri': redirect_uri, 'redirect_listen_address': redirect_listen_address,\n-                         'username': username, 'expired': False}\n+        token_request = {'permission_url': permission_url, 'redirect_uri': redirect_uri,\n+                         'redirect_listen_address': redirect_listen_address, 'username': username, 'expired': False}\n         REQUEST_QUEUE.put(token_request)\n         wait_time = 0\n         while True:\n@@ -532,24 +553,26 @@ def get_oauth2_authorisation_code(permission_url, redirect_uri, redirect_listen_\n                     continue\n                 else:\n                     token_request['expired'] = True\n-                    if 'local_server_auth_wsgi' in token_request:\n-                        token_request['local_server_auth_wsgi'].server_close()\n                     REQUEST_QUEUE.put(token_request)  # re-insert the request as expired so the parent app can remove it\n                     return False, None\n \n             if data is QUEUE_SENTINEL:  # app is closing\n                 RESPONSE_QUEUE.put(QUEUE_SENTINEL)  # make sure all watchers exit\n                 return False, None\n \n-            elif data['connection'] == connection_info:  # found an authentication response meant for us\n+            elif data['permission_url'] == permission_url and data['username'] == username:  # a response meant for us\n                 # to improve no-GUI mode we also support the use of a local server to receive the OAuth redirection\n                 # (note: not enabled by default because no-GUI mode is typically unattended, but useful in some cases)\n-                if 'local_server_auth' in data:\n+                if 'expired' in data and data['expired']:  # local server auth wsgi request error or failure\n+                    return False, None\n+\n+                elif 'local_server_auth' in data:\n                     threading.Thread(target=OAuth2Helper.start_redirection_receiver_server, args=(data,),\n                                      name='EmailOAuth2Proxy-auth-%s' % data['username'], daemon=True).start()\n \n                 else:\n-                    if 'response_url' in data and 'code=' in data['response_url']:\n+                    if 'response_url' in data and 'code=' in data['response_url'] and data['response_url'].startswith(\n+                            token_request['redirect_uri']):\n                         authorisation_code = OAuth2Helper.oauth2_url_unescape(\n                             data['response_url'].split('code=')[1].split('&')[0])\n                         if authorisation_code:\n@@ -835,9 +858,8 @@ def handle_read(self):\n     def process_data(self, byte_data, censor_server_log=False):\n         try:\n             self.server_connection.send(byte_data, censor_log=censor_server_log)  # default = send everything to server\n-        except AttributeError as e:\n-            Log.info(self.info_string(), 'Caught client exception; server connection closed before data could be sent:',\n-                     Log.error_string(e))\n+        except AttributeError:  # AttributeError(\"'NoneType' object has no attribute 'send'\")\n+            Log.info(self.info_string(), 'Caught client exception; server connection closed before data could be sent')\n             self.close()\n \n     def send(self, byte_data):\n@@ -928,14 +950,17 @@ def process_data(self, byte_data, censor_server_log=False):\n                 super().process_data(byte_data)\n \n     def authenticate_connection(self, username, password, command='login'):\n-        success, result = OAuth2Helper.get_oauth2_credentials(username, password, self.connection_info)\n+        success, result = OAuth2Helper.get_oauth2_credentials(username, password)\n         if success:\n             # send authentication command to server (response checked in ServerConnection)\n             # note: we only support single-trip authentication (SASL) without checking server capabilities - improve?\n             super().process_data(b'%s AUTHENTICATE XOAUTH2 ' % self.authentication_tag.encode('utf-8'))\n             super().process_data(OAuth2Helper.encode_oauth2_string(result), censor_server_log=True)\n             super().process_data(b'\\r\\n')\n-            self.server_connection.authenticated_username = username\n+\n+            # because get_oauth2_credentials blocks, the server could have disconnected, and may no-longer exist\n+            if self.server_connection:\n+                self.server_connection.authenticated_username = username\n \n         else:\n             error_message = '%s NO %s %s\\r\\n' % (self.authentication_tag, command.upper(), result)\n@@ -1190,9 +1215,8 @@ def handle_read(self):\n     def process_data(self, byte_data):\n         try:\n             self.client_connection.send(byte_data)  # by default we just send everything straight to the client\n-        except AttributeError as e:\n-            Log.info(self.info_string(), 'Caught server exception; client connection closed before data could be sent:',\n-                     Log.error_string(e))\n+        except AttributeError:  # AttributeError(\"'NoneType' object has no attribute 'send'\")\n+            Log.info(self.info_string(), 'Caught server exception; client connection closed before data could be sent')\n             self.close()\n \n     def send(self, byte_data, censor_log=False):\n@@ -1322,8 +1346,7 @@ def process_data(self, byte_data):\n \n         elif self.client_connection.connection_state is POPOAuth2ClientConnection.STATE.XOAUTH2_AWAITING_CONFIRMATION:\n             if str_data.startswith('+') and self.username and self.password:  # '+ ' = 'please send credentials'\n-                success, result = OAuth2Helper.get_oauth2_credentials(self.username, self.password,\n-                                                                      self.connection_info)\n+                success, result = OAuth2Helper.get_oauth2_credentials(self.username, self.password)\n                 if success:\n                     self.client_connection.connection_state = POPOAuth2ClientConnection.STATE.XOAUTH2_CREDENTIALS_SENT\n                     self.send(b'%s\\r\\n' % OAuth2Helper.encode_oauth2_string(result), censor_log=True)\n@@ -1417,8 +1440,7 @@ def process_data(self, byte_data):\n         # ...then, once we have the username and password we can respond to the '334 ' response with credentials\n         elif self.client_connection.connection_state is SMTPOAuth2ClientConnection.STATE.XOAUTH2_AWAITING_CONFIRMATION:\n             if str_data.startswith('334') and self.username and self.password:  # '334 ' = 'please send credentials'\n-                success, result = OAuth2Helper.get_oauth2_credentials(self.username, self.password,\n-                                                                      self.connection_info)\n+                success, result = OAuth2Helper.get_oauth2_credentials(self.username, self.password)\n                 if success:\n                     self.client_connection.connection_state = SMTPOAuth2ClientConnection.STATE.XOAUTH2_CREDENTIALS_SENT\n                     self.authenticated_username = self.username\n@@ -1999,16 +2021,17 @@ def authorisation_window_loaded(self):\n                 continue  # skip dummy window\n \n             url = window.get_current_url()\n-            account_name = window.get_title(window).split(' ')[-1]  # see note above: title *must* match this format\n-            if not url or not account_name:\n+            username = window.get_title(window).split(' ')[-1]  # see note above: title *must* match this format\n+            if not url or not username:\n                 continue  # skip any invalid windows\n \n             # respond to both the original request and any duplicates in the list\n             completed_request = None\n             for request in self.authorisation_requests[:]:  # iterate over a copy; remove from original\n-                if url.startswith(request['redirect_uri']) and account_name == request['username']:\n+                if url.startswith(request['redirect_uri']) and username == request['username']:\n                     Log.info('Successfully authorised request for', request['username'])\n-                    RESPONSE_QUEUE.put({'connection': request['connection'], 'response_url': url})\n+                    RESPONSE_QUEUE.put(\n+                        {'permission_url': request['permission_url'], 'response_url': url, 'username': username})\n                     self.authorisation_requests.remove(request)\n                     completed_request = request\n                 else:\n@@ -2208,6 +2231,11 @@ def stop_servers(self):\n         global RESPONSE_QUEUE\n         RESPONSE_QUEUE.put(QUEUE_SENTINEL)\n         RESPONSE_QUEUE = queue.Queue()  # recreate so existing queue closes watchers but we don't have to wait here\n+        while True:\n+            try:\n+                REQUEST_QUEUE.get(block=False)  # remove any pending requests (unlikely any exist, but safest)\n+            except queue.Empty:\n+                break\n         for proxy in self.proxies:\n             # noinspection PyBroadException\n             try:\n@@ -2314,9 +2342,9 @@ def post_create(self, icon):\n                         self.notify(APP_NAME, 'Please authorise your account %s from the menu' % data['username'])\n                 else:\n                     for request in self.authorisation_requests[:]:  # iterate over a copy; remove from original\n-                        if request['connection'] == data['connection']:\n+                        if request['permission_url'] == data['permission_url']:\n                             self.authorisation_requests.remove(request)\n-                            break\n+                            break  # we could have multiple simultaneous requests, some not yet expired\n \n     @staticmethod\n     def run_proxy():\n@@ -2328,7 +2356,7 @@ def run_proxy():\n                 # exit on server start failure), otherwise this will throw an error every time and loop indefinitely\n                 asyncore.loop()\n             except Exception as e:\n-                if not EXITING:\n+                if not EXITING and not (isinstance(e, OSError) and e.errno == errno.EBADF):\n                     Log.info('Caught asyncore exception in main loop; attempting to continue:', Log.error_string(e))\n                     error_count += 1\n                     time.sleep(error_count)"
        }
    ],
    "commitTime": "2022-09-06 06:20:57"
}