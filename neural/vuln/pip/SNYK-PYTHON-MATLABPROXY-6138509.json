{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "LOW",
        "userInteraction": "REQUIRED",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "LOW",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 7.6,
    "disclosureTime": "2023-10-01 06:35:08",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-PYTHON-MATLABPROXY-6138509",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-829"
        ],
        "PVE": [
            "PVE-2023-61464"
        ]
    },
    "language": "python",
    "malicious": false,
    "packageManager": "pip",
    "publicationTime": "2023-12-22 14:20:10",
    "remediation": "Upgrade matlab-proxy to version 0.8.0 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Inclusion of Functionality from Untrusted Control Sphere",
    "vulnDescription": {
        "Overview": "matlab-proxy is a Python\u00ae package enables you to launch MATLAB\u00ae and access it from a web browser. Affected versions of this package are vulnerable to Inclusion of Functionality from Untrusted Control Sphere due to a unsafe defaults in matlab_proxy component. "
    },
    "source_code": [
        {
            "filename": "Advanced-Usage.md",
            "diff": "@@ -26,8 +26,8 @@ The following table describes all the environment variables that you can set to\n | **TMPDIR** or **TMP** | string | `\"/path/for/MATLAB/to/use/as/tmp\"` | Set either one of these variables to control the temporary folder used by MATLAB. `TMPDIR` takes precedence over `TMP` and if neither variable is set, `/tmp` is the default value used by MATLAB. |\n | **MWI_SSL_CERT_FILE** | string | `\"/path/to/certificate.pem\"` | The certfile string must be the path to a single file in PEM format containing the certificate as well as any number of CA certificates needed to establish the certificate\u2019s authenticity. See [SSL Support](./SECURITY.md#ssl-support) for more information.|\n | **MWI_SSL_KEY_FILE** | string | `\"/path/to/keyfile.key\"` | The keyfile string, if present, must point to a file containing the private key. Otherwise the private key will be taken from certfile as well. |\n-| **MWI_ENABLE_TOKEN_AUTH** | string | `\"True\"` | When set to `True`, matlab-proxy will require users to provide the security token to access the proxy. <br />The default value is `False` . See [Token-Based Authentication](./SECURITY.md#token-based-authentication) for more information.|\n-| **MWI_AUTH_TOKEN** | string (optional) | `\"AnyURLSafeToken\"` | Optionally, provide a custom `token` for use with `MWI_ENABLE_TOKEN_AUTH`. A token can safely contain any combination of alpha numeric text along with the following permitted characters: `- .  _  ~`.<br />When absent matlab-proxy will generate a random URL safe token. |\n+| **MWI_ENABLE_TOKEN_AUTH** | string | `\"True\"` | When set to `True`, matlab-proxy will require users to provide the security token to access the proxy. One can optionally set the token using the environment variable `MWI_AUTH_TOKEN`. If `MWI_AUTH_TOKEN` is not specified, then a token will be generated for you. <br />The default value is `False` . See [Token-Based Authentication](./SECURITY.md#token-based-authentication) for more information.|\n+| **MWI_AUTH_TOKEN** | string (optional) | `\"AnyURLSafeToken\"` | Specify a custom `token` for matlab-proxy to use with [Token-Based Authentication](./SECURITY.md#token-based-authentication). A token can safely contain any combination of alpha numeric text along with the following permitted characters: `- .  _  ~`.<br />When absent matlab-proxy will generate a random URL safe token. |\n | **MWI_USE_EXISTING_LICENSE** | string (optional) | `\"True\"` | When set to True, matlab-proxy will not ask you for additional licensing information and will try to launch an already activated MATLAB on your system PATH.\n | **MWI_CUSTOM_MATLAB_ROOT** | string (optional) | `\"/path/to/matlab/root/\"` | Optionally, provide a custom path to MATLAB root. For more information see [Adding MATLAB to System Path](#adding-matlab-to-system-path) |\n "
        },
        {
            "filename": "SECURITY.md",
            "diff": "@@ -77,6 +77,11 @@ This token can be provided to the server in 2 ways:\n       <img width=\"800\" src=\"./img/token_authentication_page.png\">\n     </p>\n \n+3. Through a `mwi_auth_token` header. Example:\n+    ``` html\n+    mwi_auth_token:abcdef..\n+    ```\n+\n **NOTE** : Its highly recommended to use this feature along with SSL enabled as shown [here](#use-token-authentication-with-ssl-enabled).\n \n ### **Use with auto-generated tokens**"
        },
        {
            "filename": "gui/src/actionCreators/index.js",
            "diff": "@@ -220,10 +220,8 @@ export function updateAuthStatus(token){\n         const options = {\n             method: 'POST',\n             headers: {\n-                'Accept': 'application/text',\n-                'Content-Type': 'application/text'\n+                'mwi_auth_token': token\n                 },\n-            body: token\n         };\n         const response = await fetchWithTimeout(dispatch, './authenticate_request', options, 15000);\n         const data = await response.json()"
        },
        {
            "filename": "matlab_proxy/app.py",
            "diff": "@@ -15,8 +15,7 @@\n import matlab_proxy\n from matlab_proxy import constants, settings, util\n from matlab_proxy.app_state import AppState\n-from matlab_proxy.default_configuration import config\n-from matlab_proxy.util import list_servers, mwi\n+from matlab_proxy.util import mwi\n from matlab_proxy.util.mwi import environment_variables as mwi_env\n from matlab_proxy.util.mwi import token_auth\n from matlab_proxy.util.mwi.exceptions import AppError, InvalidTokenError, LicensingError\n@@ -119,6 +118,9 @@ async def create_status_response(app, loadUrl=None):\n     )\n \n \n+# @token_auth.authenticate_access_decorator\n+# Explicitly disabling authentication for this end-point,\n+# because the front end requires this endpoint to be available at all times.\n async def get_env_config(req):\n     \"\"\"API Endpoint to get Matlab Web Desktop environment specific configuration.\n \n@@ -142,6 +144,9 @@ async def get_env_config(req):\n     return web.json_response(config)\n \n \n+# @token_auth.authenticate_access_decorator\n+# Explicitly disabling authentication for this end-point,\n+# because the front end requires this endpoint to be available at all times.\n async def get_status(req):\n     \"\"\"API Endpoint to get the generic status of the server, MATLAB and MATLAB Licensing.\n \n@@ -154,39 +159,39 @@ async def get_status(req):\n     return await create_status_response(req.app)\n \n \n+# @token_auth.authenticate_access_decorator\n+# Explicitly disabling authentication for this end-point, as it checks for authenticity internally.\n async def authenticate_request(req):\n     \"\"\"API Endpoint to authenticate request to access server\n \n     Returns:\n         JSONResponse: JSONResponse object containing information about authentication status and error if any.\n     \"\"\"\n-    if await token_auth.authenticate_request(req):\n-        logger.debug(\"!!!!!! REQUEST IS AUTHORIZED !!!!\")\n-        authStatus = True\n-        error = None\n-    else:\n-        logger.debug(\"!!!!!! REQUEST IS NOT AUTHORIZED !!!!\")\n-        authStatus = False\n-        error = marshal_error(\n+    is_authenticated = await token_auth.authenticate_request(req)\n+    error = (\n+        None\n+        if is_authenticated\n+        else marshal_error(\n             InvalidTokenError(\n                 \"Token invalid. Please enter a valid token to authenticate\"\n             )\n         )\n-\n+    )\n     # If there is an error, state.error is not updated because the client may have set the\n     # token incorrectly which is not an error raised on the backend.\n-\n-    token = await req.text() if not error else \"\"\n+    # TODO: @krisctl to remove this.\n+    token = req.app[\"settings\"][\"mwi_auth_token\"] if is_authenticated else \"\"\n \n     return web.json_response(\n         {\n-            \"authStatus\": authStatus,\n+            \"authStatus\": is_authenticated,\n             \"authToken\": token,\n             \"error\": error,\n         }\n     )\n \n \n+@token_auth.authenticate_access_decorator\n async def start_matlab(req):\n     \"\"\"API Endpoint to start MATLAB\n \n@@ -204,6 +209,7 @@ async def start_matlab(req):\n     return await create_status_response(req.app)\n \n \n+@token_auth.authenticate_access_decorator\n async def stop_matlab(req):\n     \"\"\"API Endpoint to stop MATLAB\n \n@@ -220,6 +226,7 @@ async def stop_matlab(req):\n     return await create_status_response(req.app)\n \n \n+@token_auth.authenticate_access_decorator\n async def set_licensing_info(req):\n     \"\"\"API Endpoint to set licensing information on the server side.\n \n@@ -261,6 +268,7 @@ async def set_licensing_info(req):\n     return await create_status_response(req.app)\n \n \n+@token_auth.authenticate_access_decorator\n async def update_entitlement(req):\n     \"\"\"API endpoint to update selected entitlement to start MATLAB with.\n \n@@ -290,6 +298,7 @@ async def __start_matlab_if_licensed(state):\n         await state.start_matlab(restart_matlab=True)\n \n \n+@token_auth.authenticate_access_decorator\n async def licensing_info_delete(req):\n     \"\"\"API Endpoint to stop MATLAB and remove licensing details.\n \n@@ -312,6 +321,7 @@ async def licensing_info_delete(req):\n     return await create_status_response(req.app)\n \n \n+@token_auth.authenticate_access_decorator\n async def termination_integration_delete(req):\n     \"\"\"API Endpoint to terminate the Integration and shutdown the server.\n \n@@ -339,6 +349,8 @@ async def termination_integration_delete(req):\n         sys.exit(0)\n \n \n+# @token_auth.authenticate_access_decorator\n+# Explicitly disabling authentication for this end-point, as authenticity is checked by the redirected endpoint.\n async def root_redirect(request):\n     \"\"\"API Endpoint to return the root index.html file.\n \n@@ -421,6 +433,7 @@ def make_static_route_table(app):\n     return table\n \n \n+@token_auth.authenticate_access_decorator\n async def matlab_view(req):\n     \"\"\"API Endpoint which proxies requests to the MATLAB Embedded Connector\n "
        },
        {
            "filename": "matlab_proxy/app_state.py",
            "diff": "@@ -271,9 +271,21 @@ async def get_matlab_state(self):\n         # If execution reaches here, it implies that:\n         # 1) MATLAB process has started.\n         # 2) Embedded connector has not started yet.\n+        # Proceed to query the Embedded Connector about its state.\n+        # matlab-proxy sends a request to itself to the endpoint: /messageservice/json/state\n+        # which the server redirects to the matlab_view() function to handle (which then sends the request to EC)\n+        # As the matlab_view is now a protected endpoint, we need to pass token information through headers.\n+\n+        # Include token information into the headers if authentication is enabled.\n+        headers = (\n+            {self.settings[\"mwi_auth_token_name\"]: self.settings[\"mwi_auth_token\"]}\n+            if self.settings[\"mwi_is_token_auth_enabled\"]\n+            else None\n+        )\n \n         embedded_connector_status = await mwi.embedded_connector.request.get_state(\n-            self.settings[\"mwi_server_url\"]\n+            mwi_server_url=self.settings[\"mwi_server_url\"],\n+            headers=headers,\n         )\n \n         # Embedded Connector can be in either \"up\" or \"down\" state"
        },
        {
            "filename": "matlab_proxy/util/mwi/embedded_connector/request.py",
            "diff": "@@ -8,6 +8,10 @@\n \n from matlab_proxy.util.mwi.exceptions import EmbeddedConnectorError\n \n+from matlab_proxy.util import mwi\n+\n+logger = mwi.logger.get()\n+\n from .helpers import get_data_for_ping_request, get_ping_endpoint\n \n \n@@ -39,9 +43,14 @@ async def send_request(url: str, data: dict, method: str, headers: dict = None)\n \n     try:\n         async with aiohttp.ClientSession() as session:\n+            logger.debug(\n+                f\"sending request: method={method}, url={url}, data={data}, headers={headers}, \"\n+            )\n+\n             async with session.request(\n-                method=method, url=url, data=data, headers=None, ssl=False\n+                method=method, url=url, data=data, headers=headers, ssl=False\n             ) as resp:\n+                logger.debug(f\"response from endpoint{url} and resp={resp}\")\n                 if not resp.ok:\n                     # Converting to dict and formatting for printing\n                     data = json.loads(data)\n@@ -55,19 +64,25 @@ async def send_request(url: str, data: dict, method: str, headers: dict = None)\n         raise err\n \n \n-async def get_state(mwi_server_url):\n+async def get_state(mwi_server_url, headers=None):\n     \"\"\"Returns the state of MATLAB's Embedded Connector.\n \n     Args:\n         port (int): The port on which the embedded connector is running at\n-\n+        headers: Headers to include with the request\n     Returns:\n         str: Either \"up\" or \"down\"\n     \"\"\"\n     data = get_data_for_ping_request()\n     url = get_ping_endpoint(mwi_server_url)\n+\n     try:\n-        resp = await send_request(url=url, data=data, method=\"POST\")\n+        resp = await send_request(\n+            url=url,\n+            data=data,\n+            method=\"POST\",\n+            headers=headers,\n+        )\n \n         # Additional assert statements to catch any changes in response from embedded connector\n         # Tested from R2020b to R2023a"
        },
        {
            "filename": "matlab_proxy/util/mwi/token_auth.py",
            "diff": "@@ -1,52 +1,74 @@\n-# Copyright (c) 2020-2022 The MathWorks, Inc.\n+# Copyright (c) 2020-2023 The MathWorks, Inc.\n \n # This file contains functions required to enable token based authentication in the server.\n \n import os\n import secrets\n \n from aiohttp import web\n-from aiohttp_session import get_session, new_session, setup\n-from aiohttp_session.cookie_storage import EncryptedCookieStorage\n+from aiohttp_session import get_session, new_session\n from matlab_proxy.util.mwi import environment_variables as mwi_env\n+from hmac import compare_digest\n+from urllib.parse import parse_qs\n \n-from . import logger as mwi_logger\n+from matlab_proxy.util.mwi import logger as mwi_logger\n \n logger = mwi_logger.get()\n \n+## Module Public Methods:\n \n-def decorator_authenticate_access(endpoint):\n-    \"\"\"Decorates any endpoint function with token authentication checks.\"\"\"\n-    logger.debug(\"inside decorator_authenticate_access\")\n \n-    async def authenticate_access(request):\n-        \"\"\"\n-        If Authentication is enabled, this function expects the token to be present either in\n-            the URL or in the session cookie.\n-        If token is provided and matches the expected secret, then the request is considered authentic,\n-            and the token is saved into the session cookie.\n-        \"\"\"\n-        logger.debug(f\" inside authenticate_access for request:{request}\")\n-        app_settings = request.app[\"settings\"]\n-        base_url = app_settings[\"base_url\"]\n+def generate_mwi_auth_token():\n+    \"\"\"\n+    Generate the MWI Token to be used by the server,\n+    based on the environment variables that control it.\n \n-        if await authenticate_request(request):\n-            logger.debug(\n-                f\" Request is authenticated, proceed to endpoint:{endpoint}{request}\"\n-            )\n-            return await endpoint(request)\n+    If MWI_AUTH_TOKEN is set then assume that the user wants authentication\n+    even if MWI_ENABLE_TOKEN_AUTH is not set. Unless, MWI_ENABLE_TOKEN_AUTH is\n+    explicitly set to FALSE.\n \n-    return authenticate_access\n+    If MWI_ENABLE_TOKEN_AUTH is set, and MWI_AUTH_TOKEN is unset, then generate a token.\n \n+    Returns the Token to be used for authentication if enabled.\n+    Returns None, if Token-Based Authentication is not enabled by user.\n+    \"\"\"\n+    mwi_enable_auth_token = os.getenv(\n+        mwi_env.get_env_name_enable_mwi_auth_token(), None\n+    )\n \n-def is_mwi_token_auth_enabled(app_settings):\n-    \"\"\"Returns True/False based on whether the mwi_auth_token_auth is enabled.\"\"\"\n-    return app_settings[\"mwi_is_token_auth_enabled\"]\n+    # Is set explicitly\n+    is_auth_explicitly_disabled = (\n+        mwi_enable_auth_token and mwi_enable_auth_token.lower() == \"false\"\n+    )\n+    is_auth_explicitly_enabled = (\n+        mwi_enable_auth_token and mwi_enable_auth_token.lower() == \"true\"\n+    )\n+\n+    mwi_auth_token = os.getenv(mwi_env.get_env_name_mwi_auth_token(), None)\n+\n+    if mwi_auth_token:\n+        if is_auth_explicitly_disabled:\n+            logger.warn(\n+                \"Ignoring MWI_AUTH_TOKEN, as MWI_ENABLE_AUTH_TOKEN explicitly set to false\"\n+            )\n+            return None\n+        else:\n+            # Strip leading and trailing whitespaces if token is not None.\n+            mwi_auth_token = mwi_auth_token.strip()\n+            logger.debug(f\"Using provided mwi_auth_token.\")\n+            return mwi_auth_token\n+    else:\n+        if is_auth_explicitly_enabled:\n+            # Generate a url safe token\n+            return secrets.token_urlsafe()\n+\n+    # Return none in all other cases\n+    return None\n \n \n def get_mwi_auth_token_access_str(app_settings):\n     \"\"\"Returns formatted string with mwi token for use with server URL\"\"\"\n-    if is_mwi_token_auth_enabled(app_settings):\n+    if app_settings[\"mwi_is_token_auth_enabled\"]:\n         mwi_auth_token_name = app_settings[\"mwi_auth_token_name\"]\n         mwi_auth_token = app_settings[\"mwi_auth_token\"]\n         return f\"?{mwi_auth_token_name}={mwi_auth_token}\"\n@@ -56,93 +78,190 @@ def get_mwi_auth_token_access_str(app_settings):\n \n \n async def authenticate_request(request):\n-    \"\"\"Returns True/False based on whether the server is authenticated.\"\"\"\n+    \"\"\"Authenticates incoming request by verifying whether the expected token is in the request.\n \n-    logger.debug(f\" inside authenticate_request for request:{request}\")\n-    # Get information from APP\n-    app_settings = request.app[\"settings\"]\n-    # Verify that the request contains the authorization token\n-    if is_mwi_token_auth_enabled(app_settings):\n-        logger.debug(\" Token Authentication is Enabled!!\")\n-        the_secret_token = app_settings[\"mwi_auth_token\"]\n-        token_name = app_settings[\"mwi_auth_token_name\"]\n-        base_url = app_settings[\"base_url\"]\n-\n-        # get token if present in URL\n-        parsed_url_token = await request.text()\n-\n-        if parsed_url_token == \"\":\n-            logger.debug(\"No Token found in URL. Checking session cookie...\")\n-\n-            # Check to see if there are cookies?\n-            session = await get_session(request)\n-            logger.debug(f\"Got session cookie : {session}\")\n-\n-            if token_name in session:\n-                stored_session_token = session[token_name]\n-                logger.debug(f\"Found token with value: {stored_session_token}\")\n-                # Verify that token contains expected value\n-                if stored_session_token == the_secret_token:\n-                    logger.debug(\"Token validation success!\")\n-                    return True\n-                else:\n-                    logger.info(\"Invalid Token found in session!\")\n-                    logger.debug(f\"Expected: {the_secret_token}    \")\n-                    logger.debug(f\"Actual  : {stored_session_token}\")\n-                    return False\n-            else:\n-                logger.debug(f\"{token_name} not found in session cookie.\")\n-                return False\n+    The mwi_auth_token must be present either in:\n+    a. session cookie\n+    b. request's query parameters\n+    c. or the request's headers.\n+\n+    Returns True/False based on whether the request is authenticated.\n+    Returns True when authentication is disabled.\n+    \"\"\"\n+\n+    logger.debug(f\"<======== Authenticate request: {request}\")\n+\n+    if _is_mwi_token_auth_enabled(request):\n+        logger.debug(\"Authentication is Enabled.\")\n+        is_authenticated = (\n+            await _is_valid_token_in_session_cookie(request)\n+            or await _is_valid_token_in_headers(request)\n+            or await _is_valid_token_in_url_query(request)\n+        )\n+        if is_authenticated:\n+            logger.debug(\"Authentication successful. ========>\")\n         else:\n-            logger.debug(f\"Token found in URL with value: {parsed_url_token}\")\n-            # Token is being provided, check it and stash it.\n-            if parsed_url_token == the_secret_token:\n-                logger.debug(\"Token validation success!\")\n-                # Stash token in session for other endpoints\n-                # Always use `new_session` during login to guard against\n-                # Session Fixation. See aiohttp-session#281\n-                session = await new_session(request)\n-                session[token_name] = the_secret_token\n-                logger.debug(f\"Created session : {session} and saved cookie\")\n-                return True\n-            else:\n-                logger.info(\"Invalid Token found in URL!\")\n-                logger.debug(f\"Expected: {the_secret_token}\")\n-                logger.debug(f\"Actual  : {parsed_url_token}\")\n-                return False\n-    else:\n-        # Token Authentication is not enabled\n-        logger.debug(\" Token Authentication is NOT Enabled!!\")\n-        return True\n+            logger.error(\"Token Authentication failed. ========>\")\n \n+        return is_authenticated\n \n-def generate_mwi_auth_token():\n+    logger.debug(\"Token Authentication disabled.========>\")\n+    return True\n+\n+\n+def authenticate_access_decorator(endpoint):\n+    \"\"\"This decorator verifies that the request to an endpoint exposed by matlab-proxy\n+    contains the correct MWI_AUTH_TOKEN before servicing an endpoint.\"\"\"\n+\n+    async def protect_endpoint(request):\n+        \"\"\"Passes request to the endpoint after validating the token\n+\n+        Args:\n+            request (HTTPRequest) : Web Request to endpoint\n+\n+        Raises:\n+            web.HTTPForbidden: Thrown when validation of token fails\n+        \"\"\"\n+        if await authenticate_request(request):\n+            # request is authentic, proceed to execute the endpoint\n+            return await endpoint(request)\n+        else:\n+            raise web.HTTPForbidden(reason=\"Unauthorized access to matlab-proxy.\")\n+\n+    return protect_endpoint\n+\n+\n+## Module Private Methods:\n+async def _get_token_name(request):\n+    \"\"\"Gets the name of the token from settings.\n+\n+    Args:\n+        request (HTTPRequest) : Used to get to app settings\n+\n+    Returns:\n+        str : token name\n     \"\"\"\n-    Generate the MWI Token to be used by the server,\n-    based on the environment variables that control it.\n+    app_settings = request.app[\"settings\"]\n+    return app_settings[\"mwi_auth_token_name\"]\n \n-    Returns None, if Token-Based Authentication is not enabled by user.\n+\n+async def _get_token(request):\n+    \"\"\"Gets the value of secret token from settings.\n+\n+    Args:\n+        request (HTTPRequest) : Used to get to app settings\n+\n+    Returns:\n+        str : token value\n     \"\"\"\n-    is_mwi_auth_token_enabled = (\n-        os.getenv(mwi_env.get_env_name_enable_mwi_auth_token(), \"false\").lower()\n-        == \"true\"\n-    )\n-    mwi_auth_token = os.getenv(mwi_env.get_env_name_mwi_auth_token(), None)\n+    app_settings = request.app[\"settings\"]\n+    return app_settings[await _get_token_name(request)]\n \n-    if is_mwi_auth_token_enabled:\n-        if mwi_auth_token and mwi_auth_token.strip():\n-            # Use the provided MWI token, after stripping leading and trailing whitespaces\n-            mwi_auth_token = mwi_auth_token.strip()\n-            logger.debug(f\"Using provided mwi_auth_token: {mwi_auth_token.strip()}\")\n-        else:\n-            # Generate a token\n-            mwi_auth_token = secrets.token_urlsafe()\n-    else:\n-        # Token Authentication must be enabled to provide custom tokens.\n-        if mwi_auth_token is not None:\n-            logger.error(\n-                \"Ignoring MWI_AUTH_TOKEN. To enable, set MWI_ENABLE_TOKEN_AUTH to True !!!\"\n-            )\n-            mwi_auth_token = None\n \n-    return mwi_auth_token\n+async def _store_token_into_session(request):\n+    \"\"\"Stores the token into the session cookie.\"\"\"\n+    # Always use `new_session` during login to guard against\n+    # Session Fixation. See aiohttp-session#281\n+    session = await new_session(request)\n+\n+    # Stash token in session for other endpoints\n+    session[await _get_token_name(request)] = await _get_token(request)\n+    logger.debug(f\"Created session and saved cookie.\")\n+\n+\n+def _is_mwi_token_auth_enabled(request):\n+    \"\"\"Returns True/False based on whether the mwi_auth_token_auth is enabled in app settings\n+\n+    Args:\n+        request (HTTPRequest) : Used to get access to app settings\n+    \"\"\"\n+    app_settings = request.app[\"settings\"]\n+    return app_settings[\"mwi_is_token_auth_enabled\"]\n+\n+\n+async def _is_valid_token(token, request):\n+    \"\"\"Checks if token contains expected value.\n+\n+    Args:\n+        token (str): Token string to validate\n+        request (HTTPRequest) : Used to access app settings\n+\n+    Returns:\n+        _type_: True is token is valid, false otherwise.\n+    \"\"\"\n+    app_settings = request.app[\"settings\"]\n+    expected_token = app_settings[\"mwi_auth_token\"]\n+    # equivalent to a == b, but protects against timing attacks\n+    is_valid = compare_digest(token, expected_token)\n+    logger.debug(\"Token validation \" + (\"successful.\" if is_valid else \"failed.\"))\n+    return is_valid\n+\n+\n+async def _is_valid_token_in_session_cookie(request):\n+    \"\"\"Checks the session cookie for auth token\n+\n+    Args:\n+        request (HTTPRequest) : Used to access app settings\n+\n+    Returns:\n+        Boolean : True if valid token is found\n+    \"\"\"\n+    logger.debug(\"Checking for token in session cookie...\")\n+    session = await get_session(request)\n+    logger.debug(f\"Got session cookie.\")\n+    token_name = await _get_token_name(request)\n+    if token_name in session:\n+        stored_session_token = session[token_name]\n+        logger.debug(f\"Found token in session cookie, validating...\")\n+        return await _is_valid_token(stored_session_token, request)\n+\n+    logger.debug(\"Token not found in session cookie.\")\n+    return False\n+\n+\n+async def _is_valid_token_in_url_query(request):\n+    \"\"\"Checks the url_query parameter for auth token\n+\n+    Args:\n+        request (HTTPRequest) : Used to access app settings\n+\n+    Returns:\n+        Boolean : True if valid token is found\n+    \"\"\"\n+    logger.debug(\"Checking for token in url query...\")\n+    query_string = request.query_string\n+    logger.debug(f\"url query parameters found:{query_string}\")\n+    if query_string:\n+        token_name = await _get_token_name(request)\n+        parsed_token = parse_qs(request.query_string).get(token_name)\n+        if parsed_token:\n+            parsed_token = parsed_token[0]\n+            logger.debug(f\"parsed_token from url query string.\")\n+            return await _is_valid_token(parsed_token, request)\n+\n+    logger.debug(\"Token not found in url query.\")\n+    return False\n+\n+\n+async def _is_valid_token_in_headers(request):\n+    \"\"\"Checks the request headers for auth token\n+    Additionally, save token into session cookie when a token is found.\n+    This is done to avoid the front end from having to send the token in every header.\n+\n+    Args:\n+        request (HTTPRequest) : Used to access app settings\n+\n+    Returns:\n+        Boolean : True if valid token is found\n+    \"\"\"\n+    logger.debug(\"Checking for token in request headers...\")\n+    headers = request.headers\n+    token_name = await _get_token_name(request)\n+    if token_name in headers:\n+        is_valid_token = await _is_valid_token(headers[token_name], request)\n+        if is_valid_token:\n+            await _store_token_into_session(request)\n+        return is_valid_token\n+\n+    logger.debug(\"Token not found in request headers.\")\n+    return False"
        },
        {
            "filename": "tests/test_app.py",
            "diff": "@@ -15,7 +15,6 @@\n from datetime import timedelta, timezone\n from matlab_proxy.util.mwi.exceptions import EntitlementError\n import test_constants\n-import matlab_proxy\n \n \n def test_create_app():\n@@ -543,7 +542,7 @@ async def test_matlab_proxy_web_socket(test_server, headers):\n         test_server (aiohttp_client): Test Server to send HTTP Requests.\n     \"\"\"\n \n-    sleep_interval = 2\n+    sleep_interval = 1\n     await wait_for_matlab_to_be_up(test_server, sleep_interval)\n     resp = await test_server.ws_connect(\"/http_ws_request.html/\", headers=headers)\n     text = await resp.receive()"
        },
        {
            "filename": "tests/util/mwi/test_token_auth.py",
            "diff": "@@ -0,0 +1,234 @@\n+# Copyright (c) 2023 The MathWorks, Inc.\n+\n+from aiohttp import web\n+from aiohttp_session import setup as aiohttp_session_setup\n+from aiohttp_session.cookie_storage import EncryptedCookieStorage\n+from cryptography import fernet\n+from matlab_proxy.util.mwi import environment_variables as mwi_env\n+from matlab_proxy.util.mwi import token_auth\n+import pytest\n+\n+## APIs to test:\n+# 1. generate_mwi_auth_token (auth enabled, auth enabled+custom token, custom token, auth disabled)\n+# 2. authenticate_access_decorator (headers & url_string, and session storage)\n+\n+## Testing generate_mwi_auth_token :\n+\n+\n+def test_generate_mwi_auth_token(monkeypatch):\n+    # Test if token is auto-generated when MWI_ENABLE_AUTH_TOKEN is True\n+    expected_auth_enablement = \"True\"\n+    monkeypatch.setenv(\n+        mwi_env.get_env_name_enable_mwi_auth_token(), str(expected_auth_enablement)\n+    )\n+\n+    generated_token = token_auth.generate_mwi_auth_token()\n+    assert generated_token is not None\n+\n+    # Test if token is generated when MWI_ENABLE_AUTH_TOKEN is True & has custom token set\n+    expected_auth_token = \"CustomTokenStr123_-Test1\"\n+    expected_auth_enablement = \"True\"\n+    monkeypatch.setenv(\n+        mwi_env.get_env_name_enable_mwi_auth_token(), str(expected_auth_enablement)\n+    )\n+    monkeypatch.setenv(mwi_env.get_env_name_mwi_auth_token(), str(expected_auth_token))\n+\n+    generated_token = token_auth.generate_mwi_auth_token()\n+    assert generated_token == expected_auth_token\n+\n+    # Test if token is generated when MWI_ENABLE_AUTH_TOKEN is unset & has custom token set\n+    expected_auth_token = \"CustomTokenStr123_-Test2\"\n+    monkeypatch.delenv(mwi_env.get_env_name_enable_mwi_auth_token())\n+    monkeypatch.setenv(mwi_env.get_env_name_mwi_auth_token(), str(expected_auth_token))\n+\n+    generated_token = token_auth.generate_mwi_auth_token()\n+    assert generated_token == expected_auth_token\n+\n+    # Test if token is not generated when MWI_ENABLE_AUTH_TOKEN is explicitly disabled & has custom token set\n+    expected_auth_token = \"CustomTokenStr123_-Test3\"\n+    expected_auth_enablement = \"False\"\n+    monkeypatch.setenv(\n+        mwi_env.get_env_name_enable_mwi_auth_token(), str(expected_auth_enablement)\n+    )\n+    monkeypatch.setenv(mwi_env.get_env_name_mwi_auth_token(), str(expected_auth_token))\n+\n+    generated_token = token_auth.generate_mwi_auth_token()\n+    assert generated_token is None\n+\n+\n+## Testing authenticate_access_decorator :\n+# This in turn, also tests authenticate_request\n+\n+\n+@pytest.fixture\n+def get_custom_auth_token_str():\n+    return \"CustomTokenStr123_-TestOtherAPIS\"\n+\n+\n+@token_auth.authenticate_access_decorator\n+async def fake_endpoint(request):\n+    if request.method == \"POST\":\n+        request.app[\"value\"] = (await request.post())[\"value\"]\n+        return web.Response(body=b\"thanks for the data\")\n+    return web.Response(body=\"value: {}\".format(request.app[\"value\"]).encode(\"utf-8\"))\n+\n+\n+@pytest.fixture\n+def fake_server_with_auth_enabled(\n+    loop, aiohttp_client, monkeypatch, get_custom_auth_token_str\n+):\n+    auth_token = get_custom_auth_token_str\n+    auth_enablement = \"True\"\n+    monkeypatch.setenv(\n+        mwi_env.get_env_name_enable_mwi_auth_token(), str(auth_enablement)\n+    )\n+    monkeypatch.setenv(mwi_env.get_env_name_mwi_auth_token(), str(auth_token))\n+\n+    mwi_auth_token = token_auth.generate_mwi_auth_token()\n+\n+    app = web.Application()\n+    app[\"settings\"] = {\n+        \"mwi_is_token_auth_enabled\": mwi_auth_token != None,\n+        \"mwi_auth_token\": mwi_auth_token,\n+        \"mwi_auth_token_name\": mwi_env.get_env_name_mwi_auth_token().lower(),\n+    }\n+    app.router.add_get(\"/\", fake_endpoint)\n+    app.router.add_post(\"/\", fake_endpoint)\n+    # Setup the session storage\n+    fernet_key = fernet.Fernet.generate_key()\n+    f = fernet.Fernet(fernet_key)\n+    aiohttp_session_setup(\n+        app, EncryptedCookieStorage(f, cookie_name=\"matlab-proxy-session\")\n+    )\n+    return loop.run_until_complete(aiohttp_client(app))\n+\n+\n+async def test_set_value_with_token(\n+    fake_server_with_auth_enabled, get_custom_auth_token_str\n+):\n+    resp = await fake_server_with_auth_enabled.post(\n+        \"/\",\n+        data={\"value\": \"foo\"},\n+        headers={\"mwi_auth_token\": get_custom_auth_token_str},\n+    )\n+    assert resp.status == web.HTTPOk.status_code\n+    assert await resp.text() == \"thanks for the data\"\n+    assert fake_server_with_auth_enabled.server.app[\"value\"] == \"foo\"\n+\n+    # Test subsequent requests do not need token authentication\n+    resp2 = await fake_server_with_auth_enabled.post(\n+        \"/\",\n+        data={\"value\": \"foobar\"},\n+    )\n+    assert resp2.status == web.HTTPOk.status_code\n+    assert fake_server_with_auth_enabled.server.app[\"value\"] == \"foobar\"\n+\n+    # Test request which accepts cookies from previous request\n+    resp3 = await fake_server_with_auth_enabled.post(\n+        \"/\",\n+        data={\"value\": \"foobar1\"},\n+        cookies=resp.cookies,\n+    )\n+    assert resp3.status == web.HTTPOk.status_code\n+    assert fake_server_with_auth_enabled.server.app[\"value\"] == \"foobar1\"\n+\n+\n+async def test_set_value_without_token(fake_server_with_auth_enabled):\n+    resp2 = await fake_server_with_auth_enabled.post(\n+        \"/\",\n+        data={\"value\": \"foobar\"},\n+    )\n+    assert resp2.status == web.HTTPForbidden.status_code\n+\n+\n+async def test_set_value_with_invalid_token(fake_server_with_auth_enabled):\n+    resp2 = await fake_server_with_auth_enabled.post(\n+        \"/\", data={\"value\": \"foobar\"}, headers={\"mwi_auth_token\": \"invalid-token\"}\n+    )\n+    assert resp2.status == web.HTTPForbidden.status_code\n+\n+\n+async def test_set_value_with_token_in_params(\n+    fake_server_with_auth_enabled, get_custom_auth_token_str\n+):\n+    fake_server_with_auth_enabled.server.app[\"value\"] = \"foo\"\n+    resp = await fake_server_with_auth_enabled.post(\n+        \"/\",\n+        data={\"value\": \"foofoo\"},\n+        params={\"mwi_auth_token\": get_custom_auth_token_str},\n+    )\n+    assert resp.status == web.HTTPOk.status_code\n+    assert await resp.text() == \"thanks for the data\"\n+    assert fake_server_with_auth_enabled.server.app[\"value\"] == \"foofoo\"\n+\n+    # Test subsequent requests do not need token authentication\n+    resp2 = await fake_server_with_auth_enabled.post(\n+        \"/\",\n+        data={\"value\": \"foobar\"},\n+    )\n+    assert resp2.status == web.HTTPForbidden.status_code\n+    # assert server_with_auth_enabled.server.app[\"value\"] == \"foobar\"\n+\n+\n+async def test_get_value_without_token(fake_server_with_auth_enabled):\n+    fake_server_with_auth_enabled.server.app[\"value\"] = \"bar\"\n+    resp = await fake_server_with_auth_enabled.get(\"/\")\n+    assert resp.status == web.HTTPForbidden.status_code\n+\n+\n+async def test_get_value_with_token_in_query_params(\n+    fake_server_with_auth_enabled, get_custom_auth_token_str\n+):\n+    fake_server_with_auth_enabled.server.app[\"value\"] = \"bar\"\n+    resp = await fake_server_with_auth_enabled.get(\n+        \"/\", params={\"mwi_auth_token\": get_custom_auth_token_str}\n+    )\n+    assert resp.status == web.HTTPOk.status_code\n+    assert await resp.text() == \"value: bar\"\n+\n+\n+## Create a fake_server without authentication enabled, and test that you can access data.\n+\n+\n+@pytest.fixture\n+def fake_server_without_auth_enabled(loop, aiohttp_client, monkeypatch):\n+    auth_enablement = \"False\"\n+    monkeypatch.setenv(\n+        mwi_env.get_env_name_enable_mwi_auth_token(), str(auth_enablement)\n+    )\n+    mwi_auth_token = token_auth.generate_mwi_auth_token()\n+\n+    app = web.Application()\n+    app[\"settings\"] = {\n+        \"mwi_is_token_auth_enabled\": mwi_auth_token != None,\n+        \"mwi_auth_token\": mwi_auth_token,\n+        \"mwi_auth_token_name\": mwi_env.get_env_name_mwi_auth_token().lower(),\n+    }\n+    app.router.add_get(\"/\", fake_endpoint)\n+    app.router.add_post(\"/\", fake_endpoint)\n+    # Setup the session storage\n+    fernet_key = fernet.Fernet.generate_key()\n+    f = fernet.Fernet(fernet_key)\n+    aiohttp_session_setup(\n+        app, EncryptedCookieStorage(f, cookie_name=\"matlab-proxy-session\")\n+    )\n+    return loop.run_until_complete(aiohttp_client(app))\n+\n+\n+async def test_get_value(fake_server_without_auth_enabled):\n+    fake_server_without_auth_enabled.server.app[\"value\"] = \"bar1\"\n+    resp = await fake_server_without_auth_enabled.get(\"/\")\n+    assert resp.status == web.HTTPOk.status_code\n+    assert await resp.text() == \"value: bar1\"\n+\n+\n+async def test_get_value_in_query_params(\n+    fake_server_without_auth_enabled, get_custom_auth_token_str\n+):\n+    # Server should respond even if token is provided when not needed.\n+    fake_server_without_auth_enabled.server.app[\"value\"] = \"bar2\"\n+    resp = await fake_server_without_auth_enabled.get(\n+        \"/\", params={\"mwi_auth_token\": get_custom_auth_token_str}\n+    )\n+    assert resp.status == web.HTTPOk.status_code\n+    assert await resp.text() == \"value: bar2\""
        }
    ],
    "commitTime": "2023-09-22 12:35:14"
}