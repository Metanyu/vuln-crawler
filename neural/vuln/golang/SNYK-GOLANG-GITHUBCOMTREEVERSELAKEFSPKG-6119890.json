{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "HIGH",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "LOW"
    },
    "credit": [
        "Barak Amar",
        "Ariel Shaqed"
    ],
    "cvssDetails": [],
    "cvssScore": 6.2,
    "disclosureTime": "2023-12-12 00:58:04",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-GOLANG-GITHUBCOMTREEVERSELAKEFSPKG-6119890",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-287"
        ]
    },
    "language": "golang",
    "malicious": false,
    "packageManager": "golang",
    "publicationTime": "2023-12-12 14:46:00",
    "remediation": "Upgrade github.com/treeverse/lakefs/pkg to version 1.3.1 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Improper Authentication",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Improper Authentication via the configuration of the auth.encrypt.secret_key through an environment variable when actions are enabled. An attacker with permission to write actions can impersonate any other user. This is only exploitable if both the auth.encrypt.secret_key is passed through an environment variable and actions are enabled via the actions.enabled configuration option. ",
        "Workaround": "This vulnerability can be mitigated by not passing auth.encrypt.secret_key through an environment variable, disabling actions, or limiting users allowed to configure actions. "
    },
    "source_code": [
        {
            "filename": "docs/howto/hooks/webhooks.md",
            "diff": "@@ -34,6 +34,9 @@ _See the [Action configuration](./index.md#action-file) for overall configuratio\n lakeFS Actions supports secrets by using environment variables.\n The format `{% raw %}{{{% endraw %} ENV.SOME_ENV_VAR {% raw %}}}{% endraw %}` will be replaced with the value of `$SOME_ENV_VAR`\n during the execution of the action. If that environment variable doesn't exist in the lakeFS server environment, the action run will fail.\n+\n+For security purposes, any environment variable whose name begins with \"LAKEFS\" will be blocked. In this case, the variable will be evaluated to an empty string, effectively making it inaccessible.\n+Additionally, the `actions.env.enabled` configuration parameter can be set to `false` to block access to all environment variables.\n {: .note }\n \n Example:"
        },
        {
            "filename": "docs/reference/configuration.md",
            "diff": "@@ -33,6 +33,8 @@ This reference uses `.` to denote the nesting of values.\n * `logging.files_keep` `(int : 0)` - Number of log files to keep, default is all.\n * `actions.enabled` `(bool : true)` - Setting this to false will block hooks from being executed.\n * `actions.lua.net_http_enabled` `(bool : false)` - Setting this to true will load the `net/http` package.\n+* `actions.env.enabled` `(bool : true)` - Environment variables accessible by hooks, disabled values evaluated to empty strings\n+* `actions.env.prefix` `(string : \"LAKEFSACTION_\")` - Access to environment variables is restricted to those with the prefix. When environment access is enabled and no prefix is provided, all variables are accessible.\n \n   **Note:** Deprecated - See `database` section\n   {: .note }"
        },
        {
            "filename": "pkg/actions/airflow.go",
            "diff": "@@ -56,7 +56,7 @@ var (\n \terrAirflowHookDAGFailed     = errors.New(\"airflow hook DAG failed\")\n )\n \n-func NewAirflowHook(h ActionHook, action *Action, cfg Config, endpoint *http.Server, collector stats.Collector) (Hook, error) {\n+func NewAirflowHook(h ActionHook, action *Action, cfg Config, endpoint *http.Server, _ stats.Collector) (Hook, error) {\n \tairflowHook := Airflow{\n \t\tHookBase: HookBase{\n \t\t\tID:         h.ID,\n@@ -86,7 +86,8 @@ func NewAirflowHook(h ActionHook, action *Action, cfg Config, endpoint *http.Ser\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"airflow hook password property: %w\", err)\n \t}\n-\tairflowHook.Password, err = NewSecureString(rawPass)\n+\tenvGetter := NewEnvironmentVariableGetter(cfg.Env.Enabled, cfg.Env.Prefix)\n+\tairflowHook.Password, err = NewSecureString(rawPass, envGetter)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"airflow hook password property: %w\", err)\n \t}"
        },
        {
            "filename": "pkg/actions/lua.go",
            "diff": "@@ -12,6 +12,7 @@ import (\n \t\"time\"\n \n \t\"github.com/Shopify/go-lua\"\n+\t\"github.com/spf13/viper\"\n \tlualibs \"github.com/treeverse/lakefs/pkg/actions/lua\"\n \t\"github.com/treeverse/lakefs/pkg/actions/lua/lakefs\"\n \tluautil \"github.com/treeverse/lakefs/pkg/actions/lua/util\"\n@@ -148,41 +149,41 @@ func (h *LuaHook) collectMetrics(l *lua.State) {\n \tl.Pop(1) // Pop the _LOADED table from the stack\n }\n \n-func DescendArgs(args interface{}) (interface{}, error) {\n+func DescendArgs(args interface{}, getter EnvGetter) (interface{}, error) {\n \tvar err error\n \tswitch t := args.(type) {\n \tcase Properties:\n \t\tfor k, v := range t {\n-\t\t\tt[k], err = DescendArgs(v)\n+\t\t\tt[k], err = DescendArgs(v, getter)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t}\n \t\treturn t, nil\n \tcase map[string]interface{}:\n \t\tfor k, v := range t {\n-\t\t\tt[k], err = DescendArgs(v)\n+\t\t\tt[k], err = DescendArgs(v, getter)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t}\n \t\treturn t, nil\n \tcase string:\n-\t\tsecure, secureErr := NewSecureString(t)\n+\t\tsecure, secureErr := NewSecureString(t, getter)\n \t\tif secureErr != nil {\n \t\t\treturn t, secureErr\n \t\t}\n \t\treturn secure.val, nil\n \tcase []string:\n \t\tstuff := make([]interface{}, len(t))\n \t\tfor i, e := range t {\n-\t\t\tstuff[i], err = DescendArgs(e)\n+\t\t\tstuff[i], err = DescendArgs(e, getter)\n \t\t}\n \t\treturn stuff, err\n \tcase []interface{}:\n \t\tstuff := make([]interface{}, len(t))\n \t\tfor i, e := range t {\n-\t\t\tstuff[i], err = DescendArgs(e)\n+\t\t\tstuff[i], err = DescendArgs(e, getter)\n \t\t}\n \t\treturn stuff, err\n \tdefault:\n@@ -206,7 +207,10 @@ func NewLuaHook(h ActionHook, action *Action, cfg Config, e *http.Server, collec\n \t\t\treturn nil, fmt.Errorf(\"'args' should be a map: %w\", errWrongValueType)\n \t\t}\n \t}\n-\tparsedArgs, err := DescendArgs(args)\n+\tparsedArgs, err := DescendArgs(args, &EnvironmentVariableGetter{\n+\t\tEnabled: cfg.Env.Enabled,\n+\t\tPrefix:  viper.GetEnvPrefix(),\n+\t})\n \tif err != nil {\n \t\treturn &LuaHook{}, fmt.Errorf(\"error parsing args: %w\", err)\n \t}"
        },
        {
            "filename": "pkg/actions/lua/storage/aws/glue.go",
            "diff": "@@ -91,7 +91,6 @@ func deleteTable(c *GlueClient) lua.Function {\n \t\t\tName:         aws.String(tableName),\n \t\t\tCatalogId:    catalogID,\n \t\t})\n-\n \t\tif err != nil {\n \t\t\tlua.Errorf(l, err.Error())\n \t\t\tpanic(\"unreachable\")\n@@ -100,6 +99,7 @@ func deleteTable(c *GlueClient) lua.Function {\n \t\treturn 0\n \t}\n }\n+\n func updateTable(c *GlueClient) lua.Function {\n \treturn func(l *lua.State) int {\n \t\tclient := c.client()\n@@ -148,6 +148,7 @@ func updateTable(c *GlueClient) lua.Function {\n \t\treturn 0\n \t}\n }\n+\n func createTable(c *GlueClient) lua.Function {\n \treturn func(l *lua.State) int {\n \t\tclient := c.client()"
        },
        {
            "filename": "pkg/actions/lua_test.go",
            "diff": "@@ -462,7 +462,8 @@ func TestDescendArgs(t *testing.T) {\n \t\t\t\t\"e\":        []interface{}{\"a\", 1, false, \"{{ ENV.magic_environ123123 }}\"},\n \t\t\t},\n \t\t}\n-\t\tout, err := actions.DescendArgs(v)\n+\t\tenvGetter := actions.NewEnvironmentVariableGetter(true, \"\")\n+\t\tout, err := actions.DescendArgs(v, envGetter)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"unexpected err: %s\", err)\n \t\t}\n@@ -501,9 +502,71 @@ func TestDescendArgs(t *testing.T) {\n \t\t\t\t\"e\":        []interface{}{\"a\", 1, false, \"{{ ENV.magic_environ123123456 }}\"}, // <- shouldn't exist?\n \t\t\t},\n \t\t}\n-\t\t_, err := actions.DescendArgs(v)\n+\n+\t\tenvGetter := actions.NewEnvironmentVariableGetter(true, \"\")\n+\t\t_, err := actions.DescendArgs(v, envGetter)\n \t\tif err == nil {\n \t\t\tt.Fatalf(\"expected error!\")\n \t\t}\n \t})\n+\n+\tt.Run(\"env_disabled\", func(t *testing.T) {\n+\t\ttestutil.WithEnvironmentVariable(t, \"magic_environ123123\", \"magic_environ_value\")\n+\t\tv := map[string]interface{}{\n+\t\t\t\"key\":        \"value\",\n+\t\t\t\"secure_key\": \"value with {{ ENV.magic_environ123123 }}\",\n+\t\t}\n+\t\tenvGetter := actions.NewEnvironmentVariableGetter(false, \"\")\n+\t\targs, err := actions.DescendArgs(v, envGetter)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"DescendArgs failed: %s\", err)\n+\t\t}\n+\t\targsMap, ok := args.(map[string]interface{})\n+\t\tif !ok {\n+\t\t\tt.Fatalf(\"expected map[string]interface{}, got a %T\", argsMap)\n+\t\t}\n+\t\tsecureString, ok := argsMap[\"secure_key\"].(string)\n+\t\tif !ok {\n+\t\t\tt.Fatalf(\"expected a string, got a %T\", argsMap[\"secure_key\"])\n+\t\t}\n+\t\tconst expectedValue = \"value with \"\n+\t\tif secureString != expectedValue {\n+\t\t\tt.Fatalf(\"expected '%s' as value from env when env is disabled, got '%s'\", expectedValue, secureString)\n+\t\t}\n+\t})\n+\n+\tt.Run(\"env_prefix\", func(t *testing.T) {\n+\t\ttestutil.WithEnvironmentVariable(t, \"magic_environ123123\", \"magic_environ_value\")\n+\t\tv := map[string]interface{}{\n+\t\t\t\"key\":        \"value{{ ENV.no_magic_environ123123 }}\",\n+\t\t\t\"secure_key\": \"value with {{ ENV.magic_environ123123 }}\",\n+\t\t}\n+\t\tenvGetter := actions.NewEnvironmentVariableGetter(true, \"magic_\")\n+\t\targs, err := actions.DescendArgs(v, envGetter)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"DescendArgs failed: %s\", err)\n+\t\t}\n+\t\targsMap, ok := args.(map[string]interface{})\n+\t\tif !ok {\n+\t\t\tt.Fatalf(\"expected map[string]interface{}, got a %T\", argsMap)\n+\t\t}\n+\n+\t\t// verify that we have value access to keys with the prefix\n+\t\tsecureString, ok := argsMap[\"secure_key\"].(string)\n+\t\tif !ok {\n+\t\t\tt.Fatalf(\"expected a string, got a %T\", argsMap[\"secure_key\"])\n+\t\t}\n+\t\tif secureString != \"value with magic_environ_value\" {\n+\t\t\tt.Fatalf(\"expected magic environ value, got '%s'\", secureString)\n+\t\t}\n+\n+\t\t// verify that we don't have value access to keys without the prefix\n+\t\tsecureString, ok = argsMap[\"key\"].(string)\n+\t\tif !ok {\n+\t\t\tt.Fatalf(\"expected a string, got a %T\", argsMap[\"key\"])\n+\t\t}\n+\t\tif secureString != \"value\" {\n+\t\t\tt.Fatalf(\"expected just value for 'key', got '%s'\", secureString)\n+\t\t}\n+\t})\n }"
        },
        {
            "filename": "pkg/actions/secure_string.go",
            "diff": "@@ -26,7 +26,12 @@ func (s SecureString) String() string {\n var envVarRegex = regexp.MustCompile(`{{ ?ENV\\..*? ?}}`)\n \n // NewSecureString creates a new SecureString, reading env var if needed.\n-func NewSecureString(s string) (SecureString, error) {\n+// If the string is not of the form {{ ENV.EXAMPLE_VARIABLE }}, the value is not considered a secret.\n+// If the string is of the form {{ ENV.EXAMPLE_VARIABLE }}, the value is populated from EXAMPLE_VARIABLE and\n+// is considered a secret.\n+// If the environment variable is not found, an error is returned.\n+// IF envEnabled is false, the value we evaluate is an empty string.\n+func NewSecureString(s string, envGetter EnvGetter) (SecureString, error) {\n \tmatches := 0\n \tvar err error\n \tret := envVarRegex.ReplaceAllStringFunc(s, func(origin string) string {\n@@ -35,13 +40,12 @@ func NewSecureString(s string) (SecureString, error) {\n \t\t}\n \t\tmatches++\n \t\traw := strings.Trim(origin, \"{} \")\n-\t\tparts := strings.SplitN(raw, \".\", 2) //nolint: gomnd\n-\t\tif len(parts) != 2 || parts[0] != \"ENV\" {\n+\t\tsource, envVarName, ok := strings.Cut(raw, \".\")\n+\t\tif !ok || source != \"ENV\" {\n \t\t\treturn origin\n \t\t}\n \n-\t\tenvVarName := parts[1]\n-\t\tval, ok := os.LookupEnv(envVarName)\n+\t\tval, ok := envGetter.Lookup(envVarName)\n \t\tif !ok {\n \t\t\terr = fmt.Errorf(\"%s not found: %w\", envVarName, errMissingEnvVar)\n \t\t\treturn \"\"\n@@ -57,3 +61,36 @@ func NewSecureString(s string) (SecureString, error) {\n \n \treturn SecureString{val: ret, secret: true}, nil\n }\n+\n+type EnvGetter interface {\n+\tLookup(name string) (string, bool)\n+}\n+\n+type EnvironmentVariableGetter struct {\n+\tEnabled bool\n+\tPrefix  string\n+}\n+\n+// NewEnvironmentVariableGetter creates a new EnvironmentVariableGetter.\n+// If envEnabled is false, the value we evaluate is an empty string.\n+// If filterPrefix is not empty, we only evaluate environment variables that start with this prefix.\n+func NewEnvironmentVariableGetter(envEnabled bool, prefix string) *EnvironmentVariableGetter {\n+\treturn &EnvironmentVariableGetter{\n+\t\tEnabled: envEnabled,\n+\t\tPrefix:  prefix,\n+\t}\n+}\n+\n+// Lookup retrieves the value of the environment variable named\n+// by the key. If the variable is present in the environment, the\n+// value (which may be empty) is returned and the boolean is true.\n+// This function doesn't provide a way to extract variables that can be used by viper.\n+func (o *EnvironmentVariableGetter) Lookup(name string) (string, bool) {\n+\tif !o.Enabled {\n+\t\treturn \"\", true\n+\t}\n+\tif o.Prefix != \"\" && !strings.HasPrefix(name, o.Prefix) {\n+\t\treturn \"\", true\n+\t}\n+\treturn os.LookupEnv(name)\n+}"
        },
        {
            "filename": "pkg/actions/secure_string_test.go",
            "diff": "@@ -10,62 +10,95 @@ import (\n \n func TestSecureString(t *testing.T) {\n \ttests := []struct {\n-\t\tname        string\n-\t\tinput       string\n-\t\terr         error\n-\t\tenvVarToSet map[string]string\n-\t\texpectedOut SecureString\n+\t\tname            string\n+\t\tinput           string\n+\t\terr             error\n+\t\tenvVarToSet     map[string]string\n+\t\tenvEnabled      bool\n+\t\tenvFilterPrefix string\n+\t\texpectedOut     SecureString\n \t}{\n \t\t{\n \t\t\tname:        \"No env var\",\n \t\t\tinput:       \"this is just a string\",\n+\t\t\tenvEnabled:  true,\n \t\t\texpectedOut: SecureString{val: \"this is just a string\", secret: false},\n \t\t},\n \t\t{\n \t\t\tname:        \"simple env var\",\n \t\t\tinput:       \"{{ ENV.SIMPLE_FIRST }}\",\n \t\t\tenvVarToSet: map[string]string{\"SIMPLE_FIRST\": \"some value\"},\n+\t\t\tenvEnabled:  true,\n \t\t\texpectedOut: SecureString{val: \"some value\", secret: true},\n \t\t},\n \t\t{\n \t\t\tname:        \"no spaces env var\",\n \t\t\tinput:       \"{{ENV.NO_SPACES_FIRST}}\",\n \t\t\tenvVarToSet: map[string]string{\"NO_SPACES_FIRST\": \"this is some value\"},\n+\t\t\tenvEnabled:  true,\n \t\t\texpectedOut: SecureString{val: \"this is some value\", secret: true},\n \t\t},\n \t\t{\n \t\t\tname:        \"wrapped with text\",\n \t\t\tinput:       \"this {{ ENV.WRAPPED_FIRST }} value\",\n \t\t\tenvVarToSet: map[string]string{\"WRAPPED_FIRST\": \"is another\"},\n+\t\t\tenvEnabled:  true,\n \t\t\texpectedOut: SecureString{val: \"this is another value\", secret: true},\n \t\t},\n \t\t{\n \t\t\tname:        \"multiple vars and text\",\n \t\t\tinput:       \"let me count: {{ ENV.MULTIPLE_FIRST }}, {{ENV.MULTIPLE_SECOND}}, {{ ENV.MULTIPLE_THIRD }}\",\n \t\t\tenvVarToSet: map[string]string{\"MULTIPLE_FIRST\": \"one\", \"MULTIPLE_SECOND\": \"two\", \"MULTIPLE_THIRD\": \"three\"},\n+\t\t\tenvEnabled:  true,\n \t\t\texpectedOut: SecureString{val: \"let me count: one, two, three\", secret: true},\n \t\t},\n \t\t{\n \t\t\tname:        \"not an env var\",\n \t\t\tinput:       \"{{ NV.NOT_AN_ENV_VAR }}\",\n \t\t\tenvVarToSet: map[string]string{\"NOT_AN_ENV_VAR\": \"one\"},\n+\t\t\tenvEnabled:  true,\n \t\t\texpectedOut: SecureString{val: \"{{ NV.NOT_AN_ENV_VAR }}\", secret: false},\n \t\t},\n \t\t{\n \t\t\tname:        \"missing env var\",\n \t\t\tinput:       \"{{ ENV.MISSING_FIRST }}\",\n \t\t\tenvVarToSet: map[string]string{\"SIMPLE_FIRST\": \"some value\"},\n+\t\t\tenvEnabled:  true,\n \t\t\texpectedOut: SecureString{},\n \t\t\terr:         errMissingEnvVar,\n \t\t},\n+\t\t{\n+\t\t\tname:        \"env disabled\",\n+\t\t\tinput:       \"{{ ENV.SIMPLE_FIRST }}\",\n+\t\t\tenvVarToSet: map[string]string{\"SIMPLE_FIRST\": \"some value\"},\n+\t\t\tenvEnabled:  false,\n+\t\t\texpectedOut: SecureString{val: \"\", secret: true},\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"filter env by prefix no match\",\n+\t\t\tinput:           \"{{ ENV.SIMPLE_FIRST }}\",\n+\t\t\tenvVarToSet:     map[string]string{\"SIMPLE_FIRST\": \"some value\", \"COMPLEX_SECOND\": \"another value\"},\n+\t\t\tenvEnabled:      true,\n+\t\t\tenvFilterPrefix: \"COMPLEX\",\n+\t\t\texpectedOut:     SecureString{val: \"\", secret: true},\n+\t\t},\n+\t\t{\n+\t\t\tname:            \"filter env by prefix match\",\n+\t\t\tinput:           \"{{ ENV.SIMPLE_FIRST }}\",\n+\t\t\tenvVarToSet:     map[string]string{\"SIMPLE_FIRST\": \"some value\", \"COMPLEX_SECOND\": \"another value\"},\n+\t\t\tenvEnabled:      true,\n+\t\t\tenvFilterPrefix: \"SIMPLE\",\n+\t\t\texpectedOut:     SecureString{val: \"some value\", secret: true},\n+\t\t},\n \t}\n \tfor _, tt := range tests {\n \t\tt.Run(tt.name, func(t *testing.T) {\n \t\t\tfor k, v := range tt.envVarToSet {\n \t\t\t\trequire.NoError(t, os.Setenv(k, v))\n \t\t\t}\n \n-\t\t\tout, err := NewSecureString(tt.input)\n+\t\t\tenvGetter := NewEnvironmentVariableGetter(tt.envEnabled, tt.envFilterPrefix)\n+\t\t\tout, err := NewSecureString(tt.input, envGetter)\n \t\t\tif tt.err == nil {\n \t\t\t\trequire.Nil(t, err)\n \t\t\t} else {"
        },
        {
            "filename": "pkg/actions/service.go",
            "diff": "@@ -42,6 +42,10 @@ type Config struct {\n \tLua     struct {\n \t\tNetHTTPEnabled bool\n \t}\n+\tEnv struct {\n+\t\tEnabled bool\n+\t\tPrefix  string\n+\t}\n }\n \n // StoreService is an implementation of actions.Service that saves"
        },
        {
            "filename": "pkg/actions/service_test.go",
            "diff": "@@ -63,6 +63,7 @@ func GetKVService(t *testing.T, ctx context.Context, source actions.Source, writ\n \tkvStore := kvtest.GetStore(ctx, t)\n \tcfg := actions.Config{Enabled: runHooks}\n \tcfg.Lua.NetHTTPEnabled = true\n+\tcfg.Env.Enabled = true\n \treturn actions.NewService(ctx, actions.NewActionsKVStore(kvStore), source, writer, &actions.DecreasingIDGenerator{}, stats, cfg)\n }\n "
        },
        {
            "filename": "pkg/actions/webhook.go",
            "diff": "@@ -36,7 +36,7 @@ var (\n \terrWebhookWrongFormat   = errors.New(\"webhook wrong format\")\n )\n \n-func NewWebhook(h ActionHook, action *Action, cfg Config, e *http.Server, collector stats.Collector) (Hook, error) {\n+func NewWebhook(h ActionHook, action *Action, cfg Config, e *http.Server, _ stats.Collector) (Hook, error) {\n \turl, ok := h.Properties[webhookURLPropertyKey]\n \tif !ok {\n \t\treturn nil, fmt.Errorf(\"missing url: %w\", errWebhookWrongFormat)\n@@ -46,12 +46,13 @@ func NewWebhook(h ActionHook, action *Action, cfg Config, e *http.Server, collec\n \t\treturn nil, fmt.Errorf(\"webhook url must be string: %w\", errWebhookWrongFormat)\n \t}\n \n-\tqueryParams, err := extractQueryParams(h.Properties)\n+\tenvGetter := NewEnvironmentVariableGetter(cfg.Env.Enabled, cfg.Env.Prefix)\n+\tqueryParams, err := extractQueryParams(h.Properties, envGetter)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"extracting query params: %w\", err)\n \t}\n \n-\theaders, err := extractHeaders(h.Properties)\n+\theaders, err := extractHeaders(h.Properties, envGetter)\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"extracting headers: %w\", err)\n \t}\n@@ -171,7 +172,7 @@ func doHTTPRequestResponseWithLog(ctx context.Context, req *http.Request, respJS\n \treturn resp.StatusCode, nil\n }\n \n-func extractQueryParams(props map[string]interface{}) (map[string][]SecureString, error) {\n+func extractQueryParams(props map[string]interface{}, envGetter EnvGetter) (map[string][]SecureString, error) {\n \tparams, ok := props[queryParamsPropertyKey]\n \tif !ok {\n \t\treturn nil, nil\n@@ -190,8 +191,7 @@ func extractQueryParams(props map[string]interface{}) (map[string][]SecureString\n \t\t\t\tif !ok {\n \t\t\t\t\treturn nil, fmt.Errorf(\"query params array should contains only strings: %w\", errWebhookWrongFormat)\n \t\t\t\t}\n-\n-\t\t\t\tavs, err := NewSecureString(av)\n+\t\t\t\tavs, err := NewSecureString(av, envGetter)\n \t\t\t\tif err != nil {\n \t\t\t\t\treturn nil, fmt.Errorf(\"reading query param: %w\", err)\n \t\t\t\t}\n@@ -204,7 +204,7 @@ func extractQueryParams(props map[string]interface{}) (map[string][]SecureString\n \t\t\treturn nil, fmt.Errorf(\"query params single value should be of type string: %w\", errWebhookWrongFormat)\n \t\t}\n \n-\t\tavs, err := NewSecureString(av)\n+\t\tavs, err := NewSecureString(av, envGetter)\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"reading query param: %w\", err)\n \t\t}\n@@ -214,7 +214,7 @@ func extractQueryParams(props map[string]interface{}) (map[string][]SecureString\n \treturn res, nil\n }\n \n-func extractHeaders(props map[string]interface{}) (map[string]SecureString, error) {\n+func extractHeaders(props map[string]interface{}, envGetter EnvGetter) (map[string]SecureString, error) {\n \tparams, ok := props[HeadersPropertyKey]\n \tif !ok {\n \t\treturn map[string]SecureString{}, nil\n@@ -232,7 +232,7 @@ func extractHeaders(props map[string]interface{}) (map[string]SecureString, erro\n \t\t\treturn nil, fmt.Errorf(\"headers array should contains only strings: %w\", errWebhookWrongFormat)\n \t\t}\n \n-\t\tvss, err := NewSecureString(vs)\n+\t\tvss, err := NewSecureString(vs, envGetter)\n \t\tif err != nil {\n \t\t\treturn nil, fmt.Errorf(\"reading header: %w\", err)\n \t\t}"
        },
        {
            "filename": "pkg/config/config.go",
            "diff": "@@ -104,7 +104,11 @@ type Config struct {\n \t\tLua     struct {\n \t\t\tNetHTTPEnabled bool `mapstructure:\"net_http_enabled\"`\n \t\t} `mapstructure:\"lua\"`\n-\t}\n+\t\tEnv struct {\n+\t\t\tEnabled bool   `mapstructure:\"enabled\"`\n+\t\t\tPrefix  string `mapstructure:\"prefix\"`\n+\t\t} `mapstructure:\"env\"`\n+\t} `mapstructure:\"actions\"`\n \n \tLogging struct {\n \t\tFormat        string   `mapstructure:\"format\"`"
        },
        {
            "filename": "pkg/config/defaults.go",
            "diff": "@@ -45,6 +45,8 @@ func setDefaults(cfgType string) {\n \tviper.SetDefault(\"logging.file_max_size_mb\", (1<<10)*100) // 100MiB\n \n \tviper.SetDefault(\"actions.enabled\", true)\n+\tviper.SetDefault(\"actions.env.enabled\", true)\n+\tviper.SetDefault(\"actions.env.prefix\", \"LAKEFSACTION_\")\n \n \tviper.SetDefault(\"auth.cache.enabled\", true)\n \tviper.SetDefault(\"auth.cache.size\", 1024)"
        },
        {
            "filename": "pkg/config/types_test.go",
            "diff": "@@ -1,14 +1,14 @@\n package config_test\n \n import (\n+\t\"errors\"\n+\t\"strings\"\n+\t\"testing\"\n+\n \t\"github.com/go-test/deep\"\n \t\"github.com/mitchellh/mapstructure\"\n \t\"github.com/treeverse/lakefs/pkg/config\"\n \t\"github.com/treeverse/lakefs/pkg/testutil\"\n-\n-\t\"errors\"\n-\t\"strings\"\n-\t\"testing\"\n )\n \n type StringsStruct struct {"
        }
    ],
    "commitTime": "2023-12-03 14:04:16"
}