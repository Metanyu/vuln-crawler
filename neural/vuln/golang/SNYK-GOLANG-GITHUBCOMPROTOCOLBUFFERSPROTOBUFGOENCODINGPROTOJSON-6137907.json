{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "jhump"
    ],
    "cvssDetails": [],
    "cvssScore": 5.9,
    "disclosureTime": "2023-12-21 17:31:13",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-GOLANG-GITHUBCOMPROTOCOLBUFFERSPROTOBUFGOENCODINGPROTOJSON-6137907",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-121"
        ]
    },
    "language": "golang",
    "malicious": false,
    "packageManager": "golang",
    "publicationTime": "2023-12-22 07:57:46",
    "remediation": "Upgrade github.com/protocolbuffers/protobuf-go/encoding/protojson to version 1.32.0 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Stack-based Buffer Overflow",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Stack-based Buffer Overflow when processing input that uses pathologically deep nesting. "
    },
    "source_code": [
        {
            "filename": "encoding/protojson/decode.go",
            "diff": "@@ -11,6 +11,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \n+\t\"google.golang.org/protobuf/encoding/protowire\"\n \t\"google.golang.org/protobuf/internal/encoding/json\"\n \t\"google.golang.org/protobuf/internal/encoding/messageset\"\n \t\"google.golang.org/protobuf/internal/errors\"\n@@ -47,6 +48,10 @@ type UnmarshalOptions struct {\n \t\tprotoregistry.MessageTypeResolver\n \t\tprotoregistry.ExtensionTypeResolver\n \t}\n+\n+\t// RecursionLimit limits how deeply messages may be nested.\n+\t// If zero, a default limit is applied.\n+\tRecursionLimit int\n }\n \n // Unmarshal reads the given []byte and populates the given [proto.Message]\n@@ -67,6 +72,9 @@ func (o UnmarshalOptions) unmarshal(b []byte, m proto.Message) error {\n \tif o.Resolver == nil {\n \t\to.Resolver = protoregistry.GlobalTypes\n \t}\n+\tif o.RecursionLimit == 0 {\n+\t\to.RecursionLimit = protowire.DefaultRecursionLimit\n+\t}\n \n \tdec := decoder{json.NewDecoder(b), o}\n \tif err := dec.unmarshalMessage(m.ProtoReflect(), false); err != nil {\n@@ -114,6 +122,10 @@ func (d decoder) syntaxError(pos int, f string, x ...interface{}) error {\n \n // unmarshalMessage unmarshals a message into the given protoreflect.Message.\n func (d decoder) unmarshalMessage(m protoreflect.Message, skipTypeURL bool) error {\n+\td.opts.RecursionLimit--\n+\tif d.opts.RecursionLimit < 0 {\n+\t\treturn errors.New(\"exceeded max recursion depth\")\n+\t}\n \tif unmarshal := wellKnownTypeUnmarshaler(m.Descriptor().FullName()); unmarshal != nil {\n \t\treturn unmarshal(d, m)\n \t}"
        },
        {
            "filename": "encoding/protojson/decode_test.go",
            "diff": "@@ -2489,6 +2489,87 @@ func TestUnmarshal(t *testing.T) {\n \t\tinputText:    `{\"weak_message1\":{\"a\":1}, \"weak_message2\":{\"a\":1}}`,\n \t\twantErr:      `unknown field \"weak_message2\"`, // weak_message2 is unknown since the package containing it is not imported\n \t\tskip:         !flags.ProtoLegacy,\n+\t}, {\n+\t\tdesc:         \"just at recursion limit: nested messages\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"optionalNestedMessage\":{\"corecursive\":{\"optionalNestedMessage\":{\"corecursive\":{}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5},\n+\t}, {\n+\t\tdesc:         \"exceed recursion limit: nested messages\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"optionalNestedMessage\":{\"corecursive\":{\"optionalNestedMessage\":{\"corecursive\":{\"optionalNestedMessage\":{}}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5},\n+\t\twantErr:      \"exceeded max recursion depth\",\n+\t}, {\n+\n+\t\tdesc:         \"just at recursion limit: maps\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"mapStringNestedMessage\":{\"key1\":{\"corecursive\":{\"mapStringNestedMessage\":{}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 3},\n+\t}, {\n+\t\tdesc:         \"exceed recursion limit: maps\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"mapStringNestedMessage\":{\"key1\":{\"corecursive\":{\"mapStringNestedMessage\":{}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 2},\n+\t\twantErr:      \"exceeded max recursion depth\",\n+\t}, {\n+\t\tdesc:         \"just at recursion limit: arrays\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"repeatedNestedMessage\":[{\"corecursive\":{\"repeatedInt32\":[1,2,3]}}]}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 3},\n+\t}, {\n+\t\tdesc:         \"exceed recursion limit: arrays\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"repeatedNestedMessage\":[{\"corecursive\":{\"repeatedNestedMessage\":[{}]}}]}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 3},\n+\t\twantErr:      \"exceeded max recursion depth\",\n+\t}, {\n+\t\tdesc:         \"just at recursion limit: value\",\n+\t\tinputMessage: &structpb.Value{},\n+\t\tinputText:    `{\"a\":{\"b\":{\"c\":{\"d\":{}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5},\n+\t}, {\n+\t\tdesc:         \"exceed recursion limit: value\",\n+\t\tinputMessage: &structpb.Value{},\n+\t\tinputText:    `{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":[]}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5},\n+\t\twantErr:      \"exceeded max recursion depth\",\n+\t}, {\n+\t\tdesc:         \"just at recursion limit: list value\",\n+\t\tinputMessage: &structpb.ListValue{},\n+\t\tinputText:    `[[[[[1, 2, 3, 4]]]]]`,\n+\t\t// Note: the JSON appears to have recursion of only 5. But it's actually 6 because the\n+\t\t// first leaf value (1) is actually a message (google.protobuf.Value), even though the\n+\t\t// JSON doesn't use an open brace.\n+\t\tumo: protojson.UnmarshalOptions{RecursionLimit: 6},\n+\t}, {\n+\t\tdesc:         \"exceed recursion limit: list value\",\n+\t\tinputMessage: &structpb.ListValue{},\n+\t\tinputText:    `[[[[[1, 2, 3, 4, [\"a\", \"b\"]]]]]]`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 6},\n+\t\twantErr:      \"exceeded max recursion depth\",\n+\t}, {\n+\t\tdesc:         \"just at recursion limit: struct value\",\n+\t\tinputMessage: &structpb.Struct{},\n+\t\tinputText:    `{\"a\":{\"b\":{\"c\":{\"d\":{}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5},\n+\t}, {\n+\t\tdesc:         \"exceed recursion limit: struct value\",\n+\t\tinputMessage: &structpb.Struct{},\n+\t\tinputText:    `{\"a\":{\"b\":{\"c\":{\"d\":{\"e\":{}]}}}}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5},\n+\t\twantErr:      \"exceeded max recursion depth\",\n+\t}, {\n+\t\tdesc:         \"just at recursion limit: skip unknown\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"foo\":{\"bar\":[{\"baz\":{}}]}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5, DiscardUnknown: true},\n+\t}, {\n+\t\tdesc:         \"exceed recursion limit: skip unknown\",\n+\t\tinputMessage: &testpb.TestAllTypes{},\n+\t\tinputText:    `{\"foo\":{\"bar\":[{\"baz\":[{}]]}}`,\n+\t\tumo:          protojson.UnmarshalOptions{RecursionLimit: 5, DiscardUnknown: true},\n+\t\twantErr:      \"exceeded max recursion depth\",\n \t}}\n \n \tfor _, tt := range tests {"
        },
        {
            "filename": "encoding/protojson/well_known_types.go",
            "diff": "@@ -176,7 +176,7 @@ func (d decoder) unmarshalAny(m protoreflect.Message) error {\n \t// Use another decoder to parse the unread bytes for @type field. This\n \t// avoids advancing a read from current decoder because the current JSON\n \t// object may contain the fields of the embedded type.\n-\tdec := decoder{d.Clone(), UnmarshalOptions{}}\n+\tdec := decoder{d.Clone(), UnmarshalOptions{RecursionLimit: d.opts.RecursionLimit}}\n \ttok, err := findTypeURL(dec)\n \tswitch err {\n \tcase errEmptyObject:\n@@ -308,48 +308,25 @@ Loop:\n // array) in order to advance the read to the next JSON value. It relies on\n // the decoder returning an error if the types are not in valid sequence.\n func (d decoder) skipJSONValue() error {\n-\ttok, err := d.Read()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\t// Only need to continue reading for objects and arrays.\n-\tswitch tok.Kind() {\n-\tcase json.ObjectOpen:\n-\t\tfor {\n-\t\t\ttok, err := d.Read()\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tswitch tok.Kind() {\n-\t\t\tcase json.ObjectClose:\n-\t\t\t\treturn nil\n-\t\t\tcase json.Name:\n-\t\t\t\t// Skip object field value.\n-\t\t\t\tif err := d.skipJSONValue(); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t}\n+\tvar open int\n+\tfor {\n+\t\ttok, err := d.Read()\n+\t\tif err != nil {\n+\t\t\treturn err\n \t\t}\n-\n-\tcase json.ArrayOpen:\n-\t\tfor {\n-\t\t\ttok, err := d.Peek()\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tswitch tok.Kind() {\n-\t\t\tcase json.ArrayClose:\n-\t\t\t\td.Read()\n-\t\t\t\treturn nil\n-\t\t\tdefault:\n-\t\t\t\t// Skip array item.\n-\t\t\t\tif err := d.skipJSONValue(); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n+\t\tswitch tok.Kind() {\n+\t\tcase json.ObjectClose, json.ArrayClose:\n+\t\t\topen--\n+\t\tcase json.ObjectOpen, json.ArrayOpen:\n+\t\t\topen++\n+\t\t\tif open > d.opts.RecursionLimit {\n+\t\t\t\treturn errors.New(\"exceeded max recursion depth\")\n \t\t\t}\n \t\t}\n+\t\tif open == 0 {\n+\t\t\treturn nil\n+\t\t}\n \t}\n-\treturn nil\n }\n \n // unmarshalAnyValue unmarshals the given custom-type message from the JSON"
        }
    ],
    "commitTime": "2023-12-21 22:43:23"
}