{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "LOCAL",
        "attackComplexity": "HIGH",
        "privilegesRequired": "LOW",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "Nick Nam"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 7,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "LOCAL",
                "attackComplexity": "HIGH",
                "privilegesRequired": "LOW",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "HIGH",
                "availability": "HIGH"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 4.7,
    "disclosureTime": "2023-12-22 12:31:50",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.06905",
        "probability": "0.00043"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-GOLANG-GITHUBCOMBUILDKITEELASTICCISTACKFORAWSV5-6144787",
    "identifiers": {
        "CVE": [
            "CVE-2023-43741"
        ],
        "CWE": [
            "CWE-367"
        ]
    },
    "language": "golang",
    "malicious": false,
    "packageManager": "golang",
    "publicationTime": "2024-01-05 08:55:11",
    "remediation": "Upgrade github.com/buildkite/elastic-ci-stack-for-aws/v5 to version 5.22.5 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Time-of-check Time-of-use Race Condition",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Time-of-check Time-of-use Race Condition via the fix-buildkite-agent-builds-permissions script. An attacker can bypass a symbolic link check for the PIPELINE_PATH variable. "
    },
    "source_code": [
        {
            "filename": ".buildkite/docker-compose.yml",
            "diff": "@@ -0,0 +1,17 @@\n+version: '3'\n+\n+services:\n+  fixperms-tests:\n+    image: golang:latest\n+    working_dir: /code\n+    volumes:\n+      - ..:/code:ro\n+    command: go test -v ./...\n+\n+  fixperms-build:\n+    image: golang:latest\n+    working_dir: /code\n+    volumes:\n+      - ..:/code\n+      - /var/lib/buildkite-agent/git-mirrors:/var/lib/buildkite-agent/git-mirrors\n+    command: .buildkite/steps/build-fixperms.sh"
        },
        {
            "filename": ".buildkite/pipeline.yaml",
            "diff": "@@ -7,14 +7,28 @@ steps:\n     agents:\n       queue: \"${BUILDKITE_AGENT_META_DATA_QUEUE}\"\n \n-  - id: \"bats-tests\"\n-    name: \":bash: Unit tests\"\n+  - id: \"fixperms-tests\"\n+    name: \":go: fixperms tests\"\n     agents:\n       queue: \"${BUILDKITE_AGENT_META_DATA_QUEUE}\"\n     plugins:\n-      docker-compose#v2.1.0:\n-        run: unit-tests\n-        config: docker-compose.unit-tests.yml\n+      - docker-compose#v2.1.0:\n+          run: fixperms-tests\n+          config: .buildkite/docker-compose.yml\n+\n+  - id: \"fixperms-build\"\n+    name: \":go: fixperms build\"\n+    agents:\n+      queue: \"${BUILDKITE_AGENT_META_DATA_QUEUE}\"\n+    depends_on:\n+      - \"fixperms-tests\"\n+    artifact_paths: \"build/fix-perms-*\"\n+    plugins:\n+      - docker-compose#v2.1.0:\n+          run: fixperms-build\n+          config: .buildkite/docker-compose.yml\n+      - artifacts#v1.9.0:\n+          upload: \"builds/fix-perms-*\"\n \n   - id: \"deploy-service-role-stack\"\n     name: \":aws-iam: :cloudformation:\"\n@@ -23,7 +37,8 @@ steps:\n     command: .buildkite/steps/deploy-service-role-stack.sh\n     depends_on:\n       - \"lint\"\n-      - \"bats-tests\"\n+      - \"fixperms-tests\"\n+      - \"fixperms-build\"\n \n   - id: \"packer-windows-amd64\"\n     name: \":packer: :windows:\"\n@@ -34,7 +49,8 @@ steps:\n       queue: \"${BUILDKITE_AGENT_META_DATA_QUEUE}\"\n     depends_on:\n       - \"lint\"\n-      - \"bats-tests\"\n+      - \"fixperms-tests\"\n+      - \"fixperms-build\"\n \n   - id: \"launch-windows-amd64\"\n     name: \":cloudformation: :windows: AMD64 Launch\"\n@@ -77,7 +93,8 @@ steps:\n       queue: \"${BUILDKITE_AGENT_META_DATA_QUEUE}\"\n     depends_on:\n       - \"lint\"\n-      - \"bats-tests\"\n+      - \"fixperms-tests\"\n+      - \"fixperms-build\"\n \n   - id: \"launch-linux-amd64\"\n     name: \":cloudformation: :linux: AMD64 Launch\"\n@@ -119,7 +136,8 @@ steps:\n       queue: \"${BUILDKITE_AGENT_META_DATA_QUEUE}\"\n     depends_on:\n       - \"lint\"\n-      - \"bats-tests\"\n+      - \"fixperms-tests\"\n+      - \"fixperms-build\"\n \n   - id: \"launch-linux-arm64\"\n     name: \":cloudformation: :linux: ARM64 Launch\""
        },
        {
            "filename": ".buildkite/steps/build-fixperms.sh",
            "diff": "@@ -0,0 +1,5 @@\n+#!/usr/bin/env bash\n+set -euo pipefail\n+for arch in amd64 arm64; do\n+  GOOS=linux GOARCH=\"${arch}\" go build -v -o \"build/fix-perms-linux-${arch}\" ./internal/fixperms\n+done"
        },
        {
            "filename": ".buildkite/steps/packer.sh",
            "diff": "@@ -16,6 +16,12 @@ fi\n \n mkdir -p \"build/\"\n \n+if [[ \"$os\" == \"linux\" ]] ; then\n+  buildkite-agent artifact download \"build/fix-perms-linux-${arch}\" ./build\n+  mv \"build/fix-perms-linux-${arch}\" packer/linux/conf/buildkite-agent/scripts/fix-buildkite-agent-builds-permissions\n+  chmod 755 packer/linux/conf/buildkite-agent/scripts/fix-buildkite-agent-builds-permissions\n+fi\n+\n # Build a hash of packer files and the agent versions\n packer_files_sha=$(find Makefile \"packer/${os}\" plugins/ -type f -print0 | xargs -0 sha1sum | awk '{print $1}' | sort | sha1sum | awk '{print $1}')\n stable_agent_sha=$(curl -Lfs \"https://download.buildkite.com/agent/stable/latest/${agent_binary}.sha256\")"
        },
        {
            "filename": "docker-compose.unit-tests.yml",
            "diff": "@@ -1,9 +0,0 @@\n-version: '3'\n-\n-services:\n-  unit-tests:\n-    image: bats/bats\n-    volumes:\n-      - .:/code:ro\n-      - ./unit-tests/fixtures:/var/lib/buildkite-agent/builds:ro\n-    command: /code/unit-tests\n\\ No newline at end of file"
        },
        {
            "filename": "go.mod",
            "diff": "@@ -0,0 +1,8 @@\n+module github.com/buildkite/elastic-ci-stack-for-aws/v6\n+\n+go 1.20\n+\n+require (\n+\tgithub.com/google/go-cmp v0.5.9\n+\tgolang.org/x/sys v0.12.0\n+)"
        },
        {
            "filename": "go.sum",
            "diff": "@@ -0,0 +1,4 @@\n+github.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\n+github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\n+golang.org/x/sys v0.12.0 h1:CM0HF96J0hcLAwsHPJZjfdNzs0gftsLfgKt57wWHJ0o=\n+golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg="
        },
        {
            "filename": "internal/fixperms/fdfs/fdfs.go",
            "diff": "@@ -0,0 +1,64 @@\n+//go:build linux\n+\n+// Package fdfs is like os.DirFS, but with a file descriptor and openat(2),\n+// fchownat(2), etc, to ensure symlinks do not escape.\n+package fdfs\n+\n+import (\n+\t\"io/fs\"\n+\t\"os\"\n+\n+\t\"golang.org/x/sys/unix\"\n+)\n+\n+const resolveFlags = unix.RESOLVE_BENEATH | unix.RESOLVE_NO_SYMLINKS | unix.RESOLVE_NO_MAGICLINKS | unix.RESOLVE_NO_XDEV\n+\n+// FS uses a file descriptor for a directory as the base of a fs.FS.\n+type FS uintptr\n+\n+// DirFS opens the directory dir, and returns an FS rooted at that directory.\n+// It uses open(2) with O_PATH+O_DIRECTORY+O_CLOEXEC.\n+func DirFS(dir string) (FS, error) {\n+\tbd, err := os.OpenFile(dir, unix.O_PATH|unix.O_DIRECTORY|unix.O_CLOEXEC, 0)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn FS(bd.Fd()), nil\n+}\n+\n+// Close closes the file descriptor.\n+func (s FS) Close() error {\n+\treturn unix.Close(int(s))\n+}\n+\n+// Open wraps openat2(2) with O_RDONLY+O_NOFOLLOW+O_CLOEXEC.\n+func (s FS) Open(path string) (fs.File, error) {\n+\tfd, err := unix.Openat2(int(s), path, &unix.OpenHow{\n+\t\tFlags:   unix.O_RDONLY | unix.O_NOFOLLOW | unix.O_CLOEXEC,\n+\t\tMode:    0,\n+\t\tResolve: resolveFlags,\n+\t})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tf := os.NewFile(uintptr(fd), path)\n+\treturn f, nil\n+}\n+\n+// Lchown wraps fchownat(2) (with AT_SYMLINK_NOFOLLOW).\n+func (s FS) Lchown(path string, uid, gid int) error {\n+\treturn unix.Fchownat(int(s), path, uid, gid, unix.AT_SYMLINK_NOFOLLOW)\n+}\n+\n+// Sub wraps openat2(2) (with O_PATH+O_DIRECTORY+O_NOFOLLOW+O_CLOEXEC), and returns an FS.\n+func (s FS) Sub(dir string) (FS, error) {\n+\tsubFD, err := unix.Openat2(int(s), dir, &unix.OpenHow{\n+\t\tFlags:   unix.O_PATH | unix.O_DIRECTORY | unix.O_NOFOLLOW | unix.O_CLOEXEC,\n+\t\tMode:    0,\n+\t\tResolve: resolveFlags,\n+\t})\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\treturn FS(subFD), nil\n+}"
        },
        {
            "filename": "internal/fixperms/fdfs/fdfs_test.go",
            "diff": "@@ -0,0 +1,61 @@\n+//go:build linux\n+\n+package fdfs\n+\n+import (\n+\t\"io/fs\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+)\n+\n+func TestTOCTOUShenanigans(t *testing.T) {\n+\tpath := \"/tmp/TestTOCTOUShenanigans/foo\"\n+\tif err := os.MkdirAll(path, 0o777); err != nil {\n+\t\tt.Fatalf(\"os.MkdirAll(%s, %o) = %v\", path, 0o777, err)\n+\t}\n+\tfp := filepath.Join(path, \"data\")\n+\tif err := os.WriteFile(fp, []byte(\"innocent\"), 0o666); err != nil {\n+\t\tt.Fatalf(\"os.WriteFile(%s, nil, 0o666) = %v\", fp, err)\n+\t}\n+\n+\tpath2 := \"/tmp/TestTOCTOUShenanigans/crimes\"\n+\tif err := os.MkdirAll(path2, 0o777); err != nil {\n+\t\tt.Fatalf(\"os.MkdirAll(%s, %o) = %v\", path2, 0o777, err)\n+\t}\n+\tfp2 := filepath.Join(path2, \"data\")\n+\tif err := os.WriteFile(fp2, []byte(\"guilty\"), 0o666); err != nil {\n+\t\tt.Fatalf(\"os.WriteFile(%s, nil, 0o666) = %v\", fp2, err)\n+\t}\n+\n+\t// Do it in two steps, to simulate a trusted directory and an untrusted\n+\t// subpath.\n+\tfsys, err := DirFS(\"/tmp/TestTOCTOUShenanigans\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"DirFS(/tmp/TestTOCTOUShenanigans) error = %v\", err)\n+\t}\n+\tdefer fsys.Close()\n+\tfooFS, err := fsys.Sub(\"foo\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"DirFS(/tmp/TestTOCTOUShenanigans).Sub(foo) error = %v\", err)\n+\t}\n+\tdefer fooFS.Close()\n+\n+\t// Replace foo with a symlink to crimes...\n+\tpath3 := \"/tmp/TestTOCTOUShenanigans/foo.bak\"\n+\tif err := os.Rename(path, path3); err != nil {\n+\t\tt.Fatalf(\"os.Rename(%s, %s) = %v\", path, path3, err)\n+\t}\n+\tif err := os.Symlink(path2, path); err != nil {\n+\t\tt.Fatalf(\"os.Symlink(%s, %s) = %v\", path2, path, err)\n+\t}\n+\n+\t// What do we get?\n+\tdf, err := fs.ReadFile(fooFS, \"data\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"fs.ReadFile(DirFS(%s), data) error = %v\", path, err)\n+\t}\n+\tif got, want := string(df), \"innocent\"; got != want {\n+\t\tt.Fatalf(\"fs.ReadFile(DirFS(%s), data) contents = %q, want %q\", path, got, want)\n+\t}\n+}"
        },
        {
            "filename": "internal/fixperms/fixer/fixer.go",
            "diff": "@@ -0,0 +1,85 @@\n+//go:buid linux\n+\n+package fixer\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io/fs\"\n+\t\"os/user\"\n+\t\"path/filepath\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n+\t\"github.com/buildkite/elastic-ci-stack-for-aws/v6/internal/fixperms/fdfs\"\n+)\n+\n+// Main contains the higher-level operations of the permissions fixer.\n+func Main(argv []string, baseDir, uname string) (string, int) {\n+\tif len(argv) != 4 {\n+\t\treturn exitf(1, \"Usage: %s AGENT_DIR ORG_DIR PIPELINE_DIR\", argv[0])\n+\t}\n+\tfor _, seg := range argv[1:] {\n+\t\tif seg != filepath.Clean(seg) {\n+\t\t\treturn exitf(2, \"Invalid argument %q\", seg)\n+\t\t}\n+\t\tif seg == \".\" || seg == \"..\" || strings.ContainsRune(seg, '/') {\n+\t\t\treturn exitf(2, \"Invalid argument %q\", seg)\n+\t\t}\n+\t}\n+\tsubpath := filepath.Join(argv[1:]...)\n+\n+\t// Get a file descriptor for the base builds directory.\n+\tbd, err := fdfs.DirFS(baseDir)\n+\tif err != nil {\n+\t\tif errors.Is(err, fs.ErrNotExist) {\n+\t\t\treturn exit0()\n+\t\t}\n+\t\treturn exitf(3, \"Couldn't open %s: %v\", baseDir, err)\n+\t}\n+\tdefer bd.Close()\n+\n+\t// Get a file descriptor for the agentdir/orgdir/pipelinedir within the\n+\t// builds directory.\n+\t// openat2(2) flags ensures this is within the builds directory, and does\n+\t// not involve a symlink.\n+\tpd, err := bd.Sub(subpath)\n+\tif err != nil {\n+\t\tif errors.Is(err, fs.ErrNotExist) {\n+\t\t\treturn exit0()\n+\t\t}\n+\t\treturn exitf(3, \"Couldn't open %s: %v\", subpath, err)\n+\t}\n+\tdefer pd.Close()\n+\n+\t// Get the uid and gid of buildkite-agent\n+\tagentUser, err := user.Lookup(uname)\n+\tif err != nil {\n+\t\treturn exitf(4, \"Couldn't look up buildkite-agent user: %v\", err)\n+\t}\n+\tuid, err := strconv.Atoi(agentUser.Uid)\n+\tif err != nil {\n+\t\treturn exitf(4, \"buildkite-agent uid %q not an integer: %v\", agentUser.Uid, err)\n+\t}\n+\tgid, err := strconv.Atoi(agentUser.Gid)\n+\tif err != nil {\n+\t\treturn exitf(4, \"buildkite-agent gid %q not an integer: %v\", agentUser.Gid, err)\n+\t}\n+\n+\t// fs.WalkDir to find everything within the directory.\n+\t// fchownat(2) to change the owner of the item.\n+\t// We allow symlinks here, but operate on the symlinks themselves.\n+\tif err := fs.WalkDir(pd, \".\", func(path string, d fs.DirEntry, err error) error {\n+\t\treturn pd.Lchown(path, uid, gid)\n+\t}); err != nil {\n+\t\treturn exitf(5, \"Couldn't recursively chown %s: %v\", subpath, err)\n+\t}\n+\n+\treturn exit0()\n+}\n+\n+func exit0() (string, int) { return \"\", 0 }\n+\n+func exitf(code int, f string, v ...any) (string, int) {\n+\treturn fmt.Sprintf(f, v...), code\n+}"
        },
        {
            "filename": "internal/fixperms/fixer/fixer_test.go",
            "diff": "@@ -0,0 +1,138 @@\n+//go:build linux\n+\n+package fixer\n+\n+import (\n+\t\"fmt\"\n+\t\"io/fs\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"syscall\"\n+\t\"testing\"\n+\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+func TestFixer_SlashesErrors(t *testing.T) {\n+\ttests := [][]string{\n+\t\t{\"os.Args[0]\", \"/\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc/\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"/abc\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc/def\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc/def/ghi\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"/abc/\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"/\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc/\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"/abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc/def\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc/def/ghi\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"/abc/\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \"/\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \"abc/\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \"/abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \"abc/def\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \"abc/def/ghi\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \"/abc/\"},\n+\t}\n+\tfor _, test := range tests {\n+\t\t_, code := Main(test, \"/code/internal/fixperms/fixtures\", \"root\")\n+\t\tif got, want := code, 2; got != want {\n+\t\t\tt.Errorf(\"Main(%v) code = %d, want %d\", test, got, want)\n+\t\t}\n+\t}\n+}\n+\n+func TestFixer_DotsErrors(t *testing.T) {\n+\ttests := [][]string{\n+\t\t{\"os.Args[0]\", \".\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"..\", \"abc\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \".\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"..\", \"abc\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \".\"},\n+\t\t{\"os.Args[0]\", \"abc\", \"abc\", \"..\"},\n+\t}\n+\tfor _, test := range tests {\n+\t\t_, code := Main(test, \"/code/internal/fixperms/fixtures\", \"root\")\n+\t\tif got, want := code, 2; got != want {\n+\t\t\tt.Errorf(\"Main(%v) code = %d, want %d\", test, got, want)\n+\t\t}\n+\t}\n+}\n+\n+func TestFixer_SymlinksErrors(t *testing.T) {\n+\ttests := [][]string{\n+\t\t{\"os.Args[0]\", \"link\", \"b\", \"c\"},\n+\t\t{\"os.Args[0]\", \"a\", \"link\", \"c\"},\n+\t\t{\"os.Args[0]\", \"a\", \"b\", \"link\"},\n+\t}\n+\tfor _, test := range tests {\n+\t\t_, code := Main(test, \"/code/internal/fixperms/fixtures\", \"root\")\n+\t\tif got, want := code, 3; got != want {\n+\t\t\tt.Errorf(\"Main(%v) code = %d, want %d\", test, got, want)\n+\t\t}\n+\t}\n+}\n+\n+func TestFixer_NonDirectoryErrors(t *testing.T) {\n+\targv := []string{\"os.Args[0]\", \"d\", \"e\", \"f\"}\n+\t_, code := Main(argv, \"/code/internal/fixperms/fixtures\", \"root\")\n+\tif got, want := code, 3; got != want {\n+\t\tt.Errorf(\"Main(%v) code = %d, want %d\", argv, got, want)\n+\t}\n+}\n+\n+func TestFixer_NonExistSkips(t *testing.T) {\n+\targv := []string{\"os.Args[0]\", \"g\", \"h\", \"i\"}\n+\t_, code := Main(argv, \"/code/internal/fixperms/fixtures\", \"root\")\n+\tif got, want := code, 0; got != want {\n+\t\tt.Errorf(\"Main(%v) code = %d, want %d\", argv, got, want)\n+\t}\n+}\n+\n+func TestFixer_Fixes(t *testing.T) {\n+\tif err := exec.Command(\"/usr/bin/cp\", \"-r\", \"/code/internal/fixperms/fixtures/a\", \"/tmp\").Run(); err != nil {\n+\t\tt.Fatalf(\"cp -r fixtures/a /tmp: %v\", err)\n+\t}\n+\n+\targv := []string{\"os.Args[0]\", \"a\", \"b\", \"c\"}\n+\t_, code := Main(argv, \"/tmp\", \"nobody\")\n+\tif got, want := code, 0; got != want {\n+\t\tt.Errorf(\"Main(%v) code = %d, want %d\", argv, got, want)\n+\t}\n+\n+\tvar gotFiles []string\n+\twantFiles := []string{\n+\t\t\".\",\n+\t\t\"d\",\n+\t\t\"d/e\",\n+\t\t\"d/link\",\n+\t\t\"link\",\n+\t}\n+\n+\tif err := fs.WalkDir(os.DirFS(\"/tmp/a/b/c\"), \".\", func(path string, d fs.DirEntry, err error) error {\n+\t\tgotFiles = append(gotFiles, path)\n+\n+\t\tfi, err := d.Info()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tst, ok := fi.Sys().(*syscall.Stat_t)\n+\t\tif !ok {\n+\t\t\treturn fmt.Errorf(\"file info for %s not a *syscall.Stat_t: %T\", path, fi.Sys())\n+\t\t}\n+\t\tif st.Uid != 65534 {\n+\t\t\tt.Errorf(\"uid of %s = %d, want 65534\", path, st.Uid)\n+\t\t}\n+\t\tif st.Gid != 65534 {\n+\t\t\tt.Errorf(\"gid of %s = %d, want 65534\", path, st.Gid)\n+\t\t}\n+\t\treturn nil\n+\n+\t}); err != nil {\n+\t\tt.Errorf(\"fs.WalkDir(/tmp/a/b/c, .) = %v\", err)\n+\t}\n+\n+\tif diff := cmp.Diff(gotFiles, wantFiles); diff != \"\" {\n+\t\tt.Errorf(\"walked files diff (-got +want):\\n%s\", diff)\n+\t}\n+}"
        },
        {
            "filename": "internal/fixperms/fixperms.go",
            "diff": "@@ -0,0 +1,63 @@\n+//go:build linux\n+\n+// The fixperms tool changes the ownership of certain files to buildkite-agent.\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\n+\t\"github.com/buildkite/elastic-ci-stack-for-aws/v6/internal/fixperms/fixer\"\n+)\n+\n+// Files that are created by Docker containers end up with strange user and\n+// group ids, usually 0 (root). Docker namespacing will one day save us, but it\n+// can only map a single docker user id to a given user id (not any docker user\n+// id to a single system user id).\n+//\n+// Until we can map any old user id back to buildkite-agent automatically with\n+// Docker, then we just need to fix the permissions manually before each build\n+// runs so git clean can work as expected.\n+//\n+// In order to fix ownership of files owned by root, we need to be root. Thus,\n+// buildkite-agent has rights to run this program with sudo (see sudoers.conf).\n+// That means we have to take extra care to not chown things we shouldn't.\n+//\n+// Q1: Why not `chown -Rh /var/lib/buildkite-agents/builds`?\n+// A1: That gets slower as more and more builds are run on this agent, hence the\n+//     args that specify a particular pipeline dir. See #340.\n+//\n+// Q2: Why not a small script that checks the args for shenanigans, then runs\n+//     `chown -Rh ...`?\n+// A2: Because of TOCTOU. There's a race between checking that there are no\n+//     symlink shenanigans, and calling `chown`, which provides time for an\n+//     attacker to put some shenanigans back in before `chown` is called.\n+//\n+// Q3: What about running `chown -Rh` in a chroot that also contains the dir?\n+// A3: You have to copy the tools you need to run into the chroot. A job could\n+//     overwrite the tool with its own binary, which is then run as root.\n+//     And if you think you can carefully lay out the chroot and set permissions\n+//     to prevent that, you still need to stop the script receiving a symlink to\n+//     the directory containing chown, changing its own perms. If you add a\n+//     check for that first, then there's still TOCTOU.\n+//\n+// Q4: Containers!\n+// A4: *sigh*\n+//\n+// File paths are not a good security interface for files. But! We can use file\n+// descriptors. openat(2), fchownat(2), etc provide a way to resolve file paths\n+// relative to a given parent directory, and prevent symlink resolution at the\n+// same time.\n+\n+const (\n+\tbuildsDir = \"/var/lib/buildkite-agent/builds\"\n+\tusername  = \"buildkite-agent\"\n+)\n+\n+func main() {\n+\tmsg, code := fixer.Main(os.Args, buildsDir, username)\n+\tif code != 0 {\n+\t\tfmt.Fprintln(os.Stderr, msg)\n+\t\tos.Exit(code)\n+\t}\n+}"
        },
        {
            "filename": "internal/fixperms/fixtures/a/b/c/d/link",
            "diff": "@@ -0,0 +1 @@\n+e\n\\ No newline at end of file"
        },
        {
            "filename": "internal/fixperms/fixtures/a/b/c/link",
            "diff": "@@ -0,0 +1 @@\n+d\n\\ No newline at end of file"
        },
        {
            "filename": "packer/linux/conf/buildkite-agent/scripts/fix-buildkite-agent-builds-permissions",
            "diff": "@@ -1,100 +0,0 @@\n-#!/usr/bin/env bash\n-\n-# To run the unit tests for this file, run the following command in the root of\n-# the project:\n-# $ docker-compose -f docker-compose.unit-tests.yml run unit-tests\n-\n-# Files that are created by Docker containers end up with strange user and\n-# group ids, usually 0 (root). Docker namespacing will one day save us, but it\n-# can only map a single docker user id to a given user id (not any docker user\n-# id to a single system user id).\n-#\n-# Until we can map any old user id back to\n-# buildkite-agent automatically with Docker, then we just need to fix the\n-# permissions manually before each build runs so git clean can work as\n-# expected.\n-\n-set -eu -o pipefail\n-\n-# We need to scope the next bit to only the currently running agent dir and\n-# pipeline, but we also need to control security and make sure arbitrary folders\n-# can't be chmoded.\n-#\n-# We prepare the agent build directory basename in the environment hook and pass\n-# it as the first argument, org name as second argument, and the pipeline dir as\n-# the third.\n-#\n-# In here we need to check that they both don't contain slashes or contain a\n-# traversal component.\n-\n-AGENT_DIR=\"$1\"\n-# => \"my-agent-1\"\n-\n-ORG_DIR=\"$2\"\n-# => \"my-org\"\n-\n-PIPELINE_DIR=\"$3\"\n-# => \"my-pipeline\"\n-\n-# Make sure it doesn't contain any slashes by substituting slashes with nothing\n-# and making sure it doesn't change\n-function exit_if_contains_slashes() {\n-\tif [[ \"${1//\\//}\" != \"${1}\" ]]; then\n-\t\texit 1\n-\tfi\n-}\n-\n-function exit_if_contains_traversal() {\n-\tif [[ \"${1}\" == \".\" || \"${1}\" == \"..\" ]]; then\n-\t\texit 2\n-\tfi\n-}\n-\n-function exit_if_blank() {\n-\tif [[ -z \"${1}\" ]]; then\n-\t\texit 3\n-\tfi\n-}\n-\n-# Check them for slashes\n-exit_if_contains_slashes \"${AGENT_DIR}\"\n-exit_if_contains_slashes \"${ORG_DIR}\"\n-exit_if_contains_slashes \"${PIPELINE_DIR}\"\n-\n-# Check them for traversals\n-exit_if_contains_traversal \"${AGENT_DIR}\"\n-exit_if_contains_traversal \"${ORG_DIR}\"\n-exit_if_contains_traversal \"${PIPELINE_DIR}\"\n-\n-# Check them for blank values\n-exit_if_blank \"${AGENT_DIR}\"\n-exit_if_blank \"${ORG_DIR}\"\n-exit_if_blank \"${PIPELINE_DIR}\"\n-\n-# We know the builds path:\n-BUILDS_PATH=\"/var/lib/buildkite-agent/builds\"\n-\n-# And now we can reconstruct the full agent builds path:\n-PIPELINE_PATH=\"${BUILDS_PATH}/${AGENT_DIR}/${ORG_DIR}/${PIPELINE_DIR}\"\n-# => \"/var/lib/buildkite-agent/builds/my-agent-1/my-org/my-pipeline\"\n-\n-# If it doesn't exist, then we won't do anything.\n-if [[ ! -e \"${PIPELINE_PATH}\" ]]; then\n-\texit 0\n-fi\n-\n-\n-# Check for symlink shenanigans\n-if [[ \"$(realpath \"${PIPELINE_PATH}\")\" != \"${PIPELINE_PATH}\" ]]; then\n-\texit 4\n-fi\n-\n-# It should be a directory.\n-if [[ ! -d \"${PIPELINE_PATH}\" ]]; then\n-\texit 5\n-fi\n-\n-# If we make it here, we're safe to go!\n-\n-/bin/chown -R buildkite-agent:buildkite-agent \"${PIPELINE_PATH}\"\n-"
        },
        {
            "filename": "unit-tests/fix-buildkite-agent-builds-permissions.bats",
            "diff": "@@ -1,162 +0,0 @@\n-#!/usr/bin/env bats\n-\n-FIX_PERMISSIONS_SCRIPT=\"/code/packer/linux/conf/buildkite-agent/scripts/fix-buildkite-agent-builds-permissions\"\n-\n-@test \"Slashes in the agent arg cause an exit 1 (A)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"/\" \"abc\" \"abc\"\n-\t[ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the agent arg cause an exit 1 (B)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc/\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the agent arg cause an exit 1 (C)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"/abc\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the agent arg cause an exit 1 (D)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc/def\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the agent arg cause an exit 1 (E)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc/def/ghi\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the agent arg cause an exit 1 (F)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"/abc/\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the org arg cause an exit 1 (A)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"/\" \"abc\"\n-\t[ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the org arg cause an exit 1 (B)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc/\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the org arg cause an exit 1 (C)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"/abc\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the org arg cause an exit 1 (D)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc/def\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the org arg cause an exit 1 (E)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc/def/ghi\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the org arg cause an exit 1 (F)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"/abc/\" \"abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the pipeline arg cause an exit 1 (A)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"/\"\n-\t[ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the pipeline arg cause an exit 1 (B)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"abc/\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the pipeline arg cause an exit 1 (C)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"/abc\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the pipeline arg cause an exit 1 (D)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"abc/def\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the pipeline arg cause an exit 1 (E)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"abc/def/ghi\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Slashes in the pipeline arg cause an exit 1 (F)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"/abc/\"\n-  [ \"$status\" -eq 1 ]\n-}\n-\n-@test \"Single dot traversal in the agent arg cause an exit 2\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \".\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 2 ]\n-}\n-\n-@test \"Double dot traversal in the agent arg cause an exit 2\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"..\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 2 ]\n-}\n-\n-@test \"Single dot traversal in the org arg cause an exit 2\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \".\" \"abc\"\n-  [ \"$status\" -eq 2 ]\n-}\n-\n-@test \"Double dot traversal in the org arg cause an exit 2\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"..\" \"abc\"\n-  [ \"$status\" -eq 2 ]\n-}\n-\n-@test \"Single dot traversal in the pipeline arg cause an exit 2\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \".\"\n-  [ \"$status\" -eq 2 ]\n-}\n-\n-@test \"Double dot traversal in the pipeline arg cause an exit 2\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"..\"\n-  [ \"$status\" -eq 2 ]\n-}\n-\n-@test \"Blank agent arg cause an exit 3\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"\" \"abc\" \"abc\"\n-  [ \"$status\" -eq 3 ]\n-}\n-\n-@test \"Blank org arg cause an exit 3\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"\" \"abc\"\n-  [ \"$status\" -eq 3 ]\n-}\n-\n-@test \"Blank pipeline arg cause an exit 3\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"abc\" \"abc\" \"\"\n-  [ \"$status\" -eq 3 ]\n-}\n-\n-@test \"Non-existing path is skipped\" {\n-  \"$FIX_PERMISSIONS_SCRIPT\" \"g\" \"h\" \"i\"\n-}\n-\n-@test \"Symlinks in the args cause an exit 4 (A)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"link\" \"b\" \"c\"\n-  [ \"$status\" -eq 4 ]\n-}\n-\n-@test \"Symlinks in the args cause an exit 4 (B)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"a\" \"link\" \"c\"\n-  [ \"$status\" -eq 4 ]\n-}\n-\n-@test \"Symlinks in the args cause an exit 4 (C)\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"a\" \"b\" \"link\"\n-  [ \"$status\" -eq 4 ]\n-}\n-\n-@test \"Path not a directory causes an exit 5\" {\n-  run \"$FIX_PERMISSIONS_SCRIPT\" \"d\" \"e\" \"f\"\n-  [ \"$status\" -eq 5 ]\n-}"
        }
    ],
    "commitTime": "2023-09-19 06:15:22"
}