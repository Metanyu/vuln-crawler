{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "HIGH",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "LOW"
    },
    "credit": [
        "Krzysztof Skrz\u0119tnicki"
    ],
    "cvssDetails": [],
    "cvssScore": 6.7,
    "disclosureTime": "2024-01-03 21:29:33",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-GOLANG-GITHUBCOMGRAVITATIONALTELEPORTLIBSRVREGULAR-6143548",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-284"
        ]
    },
    "language": "golang",
    "malicious": false,
    "packageManager": "golang",
    "publicationTime": "2024-01-04 14:47:27",
    "remediation": "Upgrade github.com/gravitational/teleport/lib/srv/regular to version 12.4.32, 13.4.14, 14.3.0 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Improper Access Control",
    "vulnDescription": {
        "Overview": "github.com/gravitational/teleport/lib/srv/regular is a The Regular package implements an SSH server that supports multiplexing tunneling, SSH connection proxying, and only supports key based auth. Affected versions of this package are vulnerable to Improper Access Control via the SFTP feature on the Proxy server. An attacker with access to nodes within the cluster may be able to initiate an SFTP session to the Proxy Service, being able to read or modify files. Notes: The user's permissions on the Proxy server are still respected, so files can only be read or modified on the Proxy if the user has system access to read or write. To be exploitable, the user's login must exist on a proxy server and the Teleport binary must have permissions to start a session with this user. ",
        "Workaround": "This issue can be mitigated by ensuring that regular users do not have a valid principal on the proxy server. "
    },
    "source_code": [
        {
            "filename": "integration/integration_test.go",
            "diff": "@@ -7876,7 +7876,9 @@ func testSFTP(t *testing.T, suite *integrationTestSuite) {\n \t\tteleport.StopAll()\n \t})\n \n-\tclient, err := teleport.NewClient(helpers.ClientConfig{\n+\twaitForNodesToRegister(t, teleport, helpers.Site)\n+\n+\tteleportClient, err := teleport.NewClient(helpers.ClientConfig{\n \t\tLogin:   suite.Me.Username,\n \t\tCluster: helpers.Site,\n \t\tHost:    Host,\n@@ -7885,13 +7887,25 @@ func testSFTP(t *testing.T, suite *integrationTestSuite) {\n \n \t// Create SFTP session.\n \tctx := context.Background()\n-\tproxyClient, err := client.ConnectToProxy(ctx)\n+\tclusterClient, err := teleportClient.ConnectToCluster(ctx)\n \trequire.NoError(t, err)\n \tt.Cleanup(func() {\n-\t\tproxyClient.Close()\n+\t\t_ = clusterClient.Close()\n \t})\n \n-\tsftpClient, err := sftp.NewClient(proxyClient.Client.Client)\n+\tnodeClient, err := teleportClient.ConnectToNode(\n+\t\tctx,\n+\t\tclusterClient,\n+\t\tclient.NodeDetails{\n+\t\t\tAddr:      teleport.Config.SSH.Addr.Addr,\n+\t\t\tNamespace: teleportClient.Namespace,\n+\t\t\tCluster:   helpers.Site,\n+\t\t},\n+\t\tsuite.Me.Username,\n+\t)\n+\trequire.NoError(t, err)\n+\n+\tsftpClient, err := sftp.NewClient(nodeClient.Client.Client)\n \trequire.NoError(t, err)\n \tt.Cleanup(func() {\n \t\trequire.NoError(t, sftpClient.Close())"
        },
        {
            "filename": "lib/srv/regular/sshserver.go",
            "diff": "@@ -2192,11 +2192,18 @@ func (s *Server) parseSubsystemRequest(req *ssh.Request, ctx *srv.ServerContext)\n \t\treturn nil, trace.BadParameter(\"failed to parse subsystem request: %v\", err)\n \t}\n \n+\tif s.proxyMode {\n+\t\tswitch {\n+\t\tcase strings.HasPrefix(r.Name, \"proxy:\"):\n+\t\t\treturn parseProxySubsys(r.Name, s, ctx)\n+\t\tcase strings.HasPrefix(r.Name, \"proxysites\"):\n+\t\t\treturn parseProxySitesSubsys(r.Name, s)\n+\t\tdefault:\n+\t\t\treturn nil, trace.BadParameter(\"unrecognized subsystem: %v\", r.Name)\n+\t\t}\n+\t}\n+\n \tswitch {\n-\tcase s.proxyMode && strings.HasPrefix(r.Name, \"proxy:\"):\n-\t\treturn parseProxySubsys(r.Name, s, ctx)\n-\tcase s.proxyMode && strings.HasPrefix(r.Name, \"proxysites\"):\n-\t\treturn parseProxySitesSubsys(r.Name, s)\n \t// DELETE IN 15.0.0 (deprecated, tsh will not be using this anymore)\n \tcase r.Name == teleport.GetHomeDirSubsystem:\n \t\treturn newHomeDirSubsys(), nil"
        },
        {
            "filename": "lib/srv/regular/sshserver_test.go",
            "diff": "@@ -122,12 +122,12 @@ func newFixture(t *testing.T) *sshTestFixture {\n \treturn newCustomFixture(t, func(*auth.TestServerConfig) {})\n }\n \n-func newFixtureWithoutDiskBasedLogging(t *testing.T) *sshTestFixture {\n+func newFixtureWithoutDiskBasedLogging(t *testing.T, sshOpts ...ServerOption) *sshTestFixture {\n \tt.Helper()\n \n \tf := newCustomFixture(t, func(cfg *auth.TestServerConfig) {\n \t\tcfg.Auth.AuditLog = events.NewDiscardAuditLog()\n-\t})\n+\t}, sshOpts...)\n \n \t// use a sync recording mode because the disk-based uploader\n \t// that runs in the background introduces races with test cleanup\n@@ -2232,6 +2232,212 @@ func requireNoErrors(t *testing.T, errsCh <-chan []error) {\n \t}\n }\n \n+// TestParseSubsystemRequest verifies parseSubsystemRequest accepts the correct subsystems in depending on the runtime configuration.\n+func TestParseSubsystemRequest(t *testing.T) {\n+\tctx := context.Background()\n+\n+\t// start a listener to accept connections; this will be needed for the proxy test to pass, otherwise nothing will be there to handle the call.\n+\tagentlessListener, err := net.Listen(\"tcp\", \"localhost:0\")\n+\trequire.NoError(t, err)\n+\tt.Cleanup(func() { _ = agentlessListener.Close() })\n+\tgo func() {\n+\t\tfor {\n+\t\t\t// accept connections, but don't do anything else except for closing the connection on cleanup.\n+\t\t\tconn, err := agentlessListener.Accept()\n+\t\t\tif err != nil {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tt.Cleanup(func() {\n+\t\t\t\t_ = conn.Close()\n+\t\t\t})\n+\t\t}\n+\t}()\n+\n+\tagentlessSrv := types.ServerV2{\n+\t\tKind:    types.KindNode,\n+\t\tSubKind: types.SubKindOpenSSHNode,\n+\t\tVersion: types.V2,\n+\t\tMetadata: types.Metadata{\n+\t\t\tName: uuid.NewString(),\n+\t\t},\n+\t\tSpec: types.ServerSpecV2{\n+\t\t\tAddr:     agentlessListener.Addr().String(),\n+\t\t\tHostname: \"agentless\",\n+\t\t},\n+\t}\n+\n+\tgetNonProxySession := func() func() *tracessh.Session {\n+\t\tf := newFixtureWithoutDiskBasedLogging(t, SetAllowFileCopying(true))\n+\t\treturn func() *tracessh.Session {\n+\t\t\tse, err := f.ssh.clt.NewSession(context.Background())\n+\t\t\trequire.NoError(t, err)\n+\t\t\tt.Cleanup(func() { _ = se.Close() })\n+\t\t\treturn se\n+\t\t}\n+\t}()\n+\n+\tgetProxySession := func() func() *tracessh.Session {\n+\t\tf := newFixtureWithoutDiskBasedLogging(t)\n+\t\tlistener, _ := mustListen(t)\n+\n+\t\tproxyClient, _ := newProxyClient(t, f.testSrv)\n+\t\tlockWatcher := newLockWatcher(ctx, t, proxyClient)\n+\t\tnodeWatcher := newNodeWatcher(ctx, t, proxyClient)\n+\t\tcaWatcher := newCertAuthorityWatcher(ctx, t, proxyClient)\n+\n+\t\treverseTunnelServer, err := reversetunnel.NewServer(reversetunnel.Config{\n+\t\t\tClientTLS:                     proxyClient.TLSConfig(),\n+\t\t\tID:                            hostID,\n+\t\t\tClusterName:                   f.testSrv.ClusterName(),\n+\t\t\tListener:                      listener,\n+\t\t\tHostSigners:                   []ssh.Signer{f.signer},\n+\t\t\tLocalAuthClient:               proxyClient,\n+\t\t\tLocalAccessPoint:              proxyClient,\n+\t\t\tNewCachingAccessPoint:         noCache,\n+\t\t\tNewCachingAccessPointOldProxy: noCache,\n+\t\t\tDataDir:                       t.TempDir(),\n+\t\t\tEmitter:                       proxyClient,\n+\t\t\tLog:                           logrus.StandardLogger(),\n+\t\t\tLockWatcher:                   lockWatcher,\n+\t\t\tNodeWatcher:                   nodeWatcher,\n+\t\t\tCertAuthorityWatcher:          caWatcher,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\n+\t\trequire.NoError(t, reverseTunnelServer.Start())\n+\t\tt.Cleanup(func() { _ = reverseTunnelServer.Close() })\n+\n+\t\tnodeClient, _ := newNodeClient(t, f.testSrv)\n+\n+\t\t_, err = nodeClient.UpsertNode(ctx, &agentlessSrv)\n+\t\trequire.NoError(t, err)\n+\n+\t\trouter, err := libproxy.NewRouter(libproxy.RouterConfig{\n+\t\t\tClusterName:         f.testSrv.ClusterName(),\n+\t\t\tLog:                 utils.NewLoggerForTests().WithField(trace.Component, \"test\"),\n+\t\t\tRemoteClusterGetter: proxyClient,\n+\t\t\tSiteGetter:          reverseTunnelServer,\n+\t\t\tTracerProvider:      tracing.NoopProvider(),\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\n+\t\tsessionController, err := srv.NewSessionController(srv.SessionControllerConfig{\n+\t\t\tSemaphores:   proxyClient,\n+\t\t\tAccessPoint:  proxyClient,\n+\t\t\tLockEnforcer: lockWatcher,\n+\t\t\tEmitter:      proxyClient,\n+\t\t\tComponent:    teleport.ComponentProxy,\n+\t\t\tServerID:     hostID,\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\n+\t\tproxy, err := New(\n+\t\t\tctx,\n+\t\t\tutils.NetAddr{AddrNetwork: \"tcp\", Addr: \"localhost:0\"},\n+\t\t\tf.testSrv.ClusterName(),\n+\t\t\t[]ssh.Signer{f.signer},\n+\t\t\tproxyClient,\n+\t\t\tt.TempDir(),\n+\t\t\t\"\",\n+\t\t\tutils.NetAddr{},\n+\t\t\tproxyClient,\n+\t\t\tSetProxyMode(\"\", reverseTunnelServer, proxyClient, router),\n+\t\t\tSetEmitter(nodeClient),\n+\t\t\tSetNamespace(apidefaults.Namespace),\n+\t\t\tSetPAMConfig(&servicecfg.PAMConfig{Enabled: false}),\n+\t\t\tSetBPF(&bpf.NOP{}),\n+\t\t\tSetRestrictedSessionManager(&restricted.NOP{}),\n+\t\t\tSetClock(f.clock),\n+\t\t\tSetLockWatcher(lockWatcher),\n+\t\t\tSetNodeWatcher(nodeWatcher),\n+\t\t\tSetSessionController(sessionController),\n+\t\t)\n+\t\trequire.NoError(t, err)\n+\t\trequire.NoError(t, proxy.Start())\n+\t\tt.Cleanup(func() { _ = proxy.Close() })\n+\n+\t\t// set up SSH client using the user private key for signing\n+\t\tup, err := newUpack(f.testSrv, f.user, []string{f.user}, wildcardAllow)\n+\t\trequire.NoError(t, err)\n+\n+\t\treturn func() *tracessh.Session {\n+\t\t\tsshConfig := &ssh.ClientConfig{\n+\t\t\t\tUser:            f.user,\n+\t\t\t\tAuth:            []ssh.AuthMethod{ssh.PublicKeys(up.certSigner)},\n+\t\t\t\tHostKeyCallback: ssh.FixedHostKey(f.signer.PublicKey()),\n+\t\t\t}\n+\n+\t\t\t// Connect SSH client to proxy\n+\t\t\tclient, err := tracessh.Dial(ctx, \"tcp\", proxy.Addr(), sshConfig)\n+\n+\t\t\trequire.NoError(t, err)\n+\t\t\tt.Cleanup(func() { _ = client.Close() })\n+\n+\t\t\tse, err := client.NewSession(ctx)\n+\t\t\trequire.NoError(t, err)\n+\n+\t\t\treturn se\n+\t\t}\n+\t}()\n+\n+\ttests := []struct {\n+\t\tname                 string\n+\t\tsubsystemOverride    string\n+\t\twantErrInProxyMode   bool\n+\t\twantErrInRegularMode bool\n+\t}{\n+\t\t{\n+\t\t\tname:                 \"invalid\",\n+\t\t\twantErrInProxyMode:   true,\n+\t\t\twantErrInRegularMode: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                 teleport.SFTPSubsystem,\n+\t\t\twantErrInProxyMode:   true,\n+\t\t\twantErrInRegularMode: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                 teleport.GetHomeDirSubsystem,\n+\t\t\twantErrInProxyMode:   true,\n+\t\t\twantErrInRegularMode: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:                 \"proxysites\",\n+\t\t\twantErrInProxyMode:   false,\n+\t\t\twantErrInRegularMode: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:                 \"proxy:agentlessServer\",\n+\t\t\tsubsystemOverride:    \"proxy:\" + agentlessSrv.Spec.Addr,\n+\t\t\twantErrInProxyMode:   false,\n+\t\t\twantErrInRegularMode: true,\n+\t\t},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tsubsystem := tt.name\n+\t\t\tif tt.subsystemOverride != \"\" {\n+\t\t\t\tsubsystem = tt.subsystemOverride\n+\t\t\t}\n+\n+\t\t\terr := getProxySession().RequestSubsystem(ctx, subsystem)\n+\t\t\tif tt.wantErrInProxyMode {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t}\n+\n+\t\t\terr = getNonProxySession().RequestSubsystem(ctx, subsystem)\n+\t\t\tif tt.wantErrInRegularMode {\n+\t\t\t\trequire.Error(t, err)\n+\t\t\t} else {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n // TestX11ProxySupport verifies that recording proxies correctly forward\n // X11 request/channels.\n func TestX11ProxySupport(t *testing.T) {"
        }
    ],
    "commitTime": "2023-12-29 18:52:32"
}