{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "LOW",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "LOW",
        "integrity": "NONE",
        "availability": "NONE"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 4.3,
    "disclosureTime": "2024-01-02 10:46:05",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-GOLANG-GITHUBCOMMATTERMOSTMATTERMOSTSERVERV8CHANNELSAPP-6141157",
    "identifiers": {
        "CVE": [
            "CVE-2023-48732"
        ],
        "CWE": [
            "CWE-200"
        ]
    },
    "language": "golang",
    "malicious": false,
    "packageManager": "golang",
    "publicationTime": "2024-01-02 13:10:27",
    "remediation": "Upgrade github.com/mattermost/mattermost/server/v8/channels/app to version 8.1.7 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Information Exposure",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Information Exposure due to improper scoping of WebSocket responses. An attacker can obtain sensitive information about other users' notifications by intercepting the broadcasted WebSocket messages. "
    },
    "source_code": [
        {
            "filename": "server/channels/app/notification.go",
            "diff": "@@ -515,12 +515,12 @@ func (a *App) SendNotifications(c request.CTX, post *model.Post, team *model.Tea\n \t\t}\n \t}\n \n-\tif len(mentionedUsersList) != 0 {\n-\t\tmessage.Add(\"mentions\", model.ArrayToJSON(mentionedUsersList))\n+\tif len(mentionedUsersList) > 0 {\n+\t\tuseAddMentionsHook(message, mentionedUsersList)\n \t}\n \n-\tif len(notificationsForCRT.Desktop) != 0 {\n-\t\tmessage.Add(\"followers\", model.ArrayToJSON(notificationsForCRT.Desktop))\n+\tif len(notificationsForCRT.Desktop) > 0 {\n+\t\tuseAddFollowersHook(message, notificationsForCRT.Desktop)\n \t}\n \n \tpublished, err := a.publishWebsocketEventForPermalinkPost(c, post, message)"
        },
        {
            "filename": "server/channels/app/notification_test.go",
            "diff": "@@ -4,15 +4,20 @@\n package app\n \n import (\n+\t\"encoding/json\"\n \t\"fmt\"\n+\t\"net/http\"\n+\t\"net/http/httptest\"\n \t\"testing\"\n \t\"time\"\n \n+\t\"github.com/gorilla/websocket\"\n \t\"github.com/stretchr/testify/assert\"\n \t\"github.com/stretchr/testify/require\"\n \n \t\"github.com/mattermost/mattermost/server/public/model\"\n \t\"github.com/mattermost/mattermost/server/public/shared/i18n\"\n+\t\"github.com/mattermost/mattermost/server/v8/channels/app/platform\"\n \t\"github.com/mattermost/mattermost/server/v8/channels/store\"\n \t\"github.com/mattermost/mattermost/server/v8/channels/utils\"\n )\n@@ -165,6 +170,314 @@ func TestSendNotifications(t *testing.T) {\n \t})\n }\n \n+func TestSendNotifications_MentionsFollowers(t *testing.T) {\n+\tth := Setup(t).InitBasic()\n+\tdefer th.TearDown()\n+\n+\tth.AddUserToChannel(th.BasicUser2, th.BasicChannel)\n+\n+\tsender := th.CreateUser()\n+\n+\tth.LinkUserToTeam(sender, th.BasicTeam)\n+\tmember := th.AddUserToChannel(sender, th.BasicChannel)\n+\n+\tt.Run(\"should inform each user if they were mentioned by a post\", func(t *testing.T) {\n+\t\tmessages1, closeWS1 := connectFakeWebSocket(t, th, th.BasicUser.Id, \"\")\n+\t\tdefer closeWS1()\n+\n+\t\tmessages2, closeWS2 := connectFakeWebSocket(t, th, th.BasicUser2.Id, \"\")\n+\t\tdefer closeWS2()\n+\n+\t\t// First post mentioning the whole channel\n+\t\tpost := &model.Post{\n+\t\t\tUserId:    sender.Id,\n+\t\t\tChannelId: th.BasicChannel.Id,\n+\t\t\tMessage:   \"@channel\",\n+\t\t}\n+\t\t_, err := th.App.SendNotifications(th.Context, post, th.BasicTeam, th.BasicChannel, sender, nil, false)\n+\t\trequire.NoError(t, err)\n+\n+\t\treceived1 := <-messages1\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received1.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser.Id}, received1.GetData()[\"mentions\"])\n+\n+\t\treceived2 := <-messages2\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received2.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser2.Id}, received2.GetData()[\"mentions\"])\n+\n+\t\t// Second post mentioning both users individually\n+\t\tpost = &model.Post{\n+\t\t\tUserId:    sender.Id,\n+\t\t\tChannelId: th.BasicChannel.Id,\n+\t\t\tMessage:   fmt.Sprintf(\"@%s @%s\", th.BasicUser.Username, th.BasicUser2.Username),\n+\t\t}\n+\t\t_, err = th.App.SendNotifications(th.Context, post, th.BasicTeam, th.BasicChannel, sender, nil, false)\n+\t\trequire.NoError(t, err)\n+\n+\t\treceived1 = <-messages1\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received1.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser.Id}, received1.GetData()[\"mentions\"])\n+\n+\t\treceived2 = <-messages2\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received2.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser2.Id}, received2.GetData()[\"mentions\"])\n+\n+\t\t// Third post mentioning a single user\n+\t\tpost = &model.Post{\n+\t\t\tUserId:    sender.Id,\n+\t\t\tChannelId: th.BasicChannel.Id,\n+\t\t\tMessage:   \"@\" + th.BasicUser.Username,\n+\t\t}\n+\t\t_, err = th.App.SendNotifications(th.Context, post, th.BasicTeam, th.BasicChannel, sender, nil, false)\n+\t\trequire.NoError(t, err)\n+\n+\t\treceived1 = <-messages1\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received1.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser.Id}, received1.GetData()[\"mentions\"])\n+\n+\t\treceived2 = <-messages2\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received2.EventType())\n+\t\tassert.Nil(t, received2.GetData()[\"mentions\"])\n+\t})\n+\n+\tt.Run(\"should inform each user in a group if they were mentioned by a post\", func(t *testing.T) {\n+\t\t// Make the sender a channel_admin because that's needed for group mentions\n+\t\toriginalRoles := member.Roles\n+\t\tmember.Roles = \"channel_user channel_admin\"\n+\t\t_, appErr := th.App.UpdateChannelMemberRoles(th.Context, member.ChannelId, member.UserId, member.Roles)\n+\t\trequire.Nil(t, appErr)\n+\n+\t\tdefer func() {\n+\t\t\tth.App.UpdateChannelMemberRoles(th.Context, member.ChannelId, member.UserId, originalRoles)\n+\t\t}()\n+\n+\t\tth.App.Srv().SetLicense(getLicWithSkuShortName(model.LicenseShortSkuEnterprise))\n+\n+\t\t// Make a group and add users\n+\t\tgroup := th.CreateGroup()\n+\t\tgroup.AllowReference = true\n+\t\tgroup, updateErr := th.App.UpdateGroup(group)\n+\t\trequire.Nil(t, updateErr)\n+\n+\t\t_, upsertErr := th.App.UpsertGroupMember(group.Id, th.BasicUser.Id)\n+\t\trequire.Nil(t, upsertErr)\n+\t\t_, upsertErr = th.App.UpsertGroupMember(group.Id, th.BasicUser2.Id)\n+\t\trequire.Nil(t, upsertErr)\n+\n+\t\t// Set up the websockets\n+\t\tmessages1, closeWS1 := connectFakeWebSocket(t, th, th.BasicUser.Id, \"\")\n+\t\tdefer closeWS1()\n+\n+\t\tmessages2, closeWS2 := connectFakeWebSocket(t, th, th.BasicUser2.Id, \"\")\n+\t\tdefer closeWS2()\n+\n+\t\t// Confirm permissions for group mentions are correct\n+\t\tpost := &model.Post{\n+\t\t\tUserId:    sender.Id,\n+\t\t\tChannelId: th.BasicChannel.Id,\n+\t\t\tMessage:   \"@\" + *group.Name,\n+\t\t}\n+\t\trequire.True(t, th.App.allowGroupMentions(th.Context, post))\n+\n+\t\t// Test sending notifications\n+\t\t_, err := th.App.SendNotifications(th.Context, post, th.BasicTeam, th.BasicChannel, sender, nil, false)\n+\t\trequire.NoError(t, err)\n+\n+\t\treceived1 := <-messages1\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received1.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser.Id}, received1.GetData()[\"mentions\"])\n+\n+\t\treceived2 := <-messages2\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received2.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser2.Id}, received2.GetData()[\"mentions\"])\n+\t})\n+\n+\tt.Run(\"should inform each user if they are following a thread that was posted in\", func(t *testing.T) {\n+\t\tt.Log(\"BasicUser \", th.BasicUser.Id)\n+\t\tt.Log(\"sender \", sender.Id)\n+\t\tmessages1, closeWS1 := connectFakeWebSocket(t, th, th.BasicUser.Id, \"\")\n+\t\tdefer closeWS1()\n+\n+\t\tmessages2, closeWS2 := connectFakeWebSocket(t, th, th.BasicUser2.Id, \"\")\n+\t\tdefer closeWS2()\n+\n+\t\t// Reply to a post made by BasicUser\n+\t\tpost := &model.Post{\n+\t\t\tUserId:    sender.Id,\n+\t\t\tChannelId: th.BasicChannel.Id,\n+\t\t\tRootId:    th.BasicPost.Id,\n+\t\t\tMessage:   \"This is a test\",\n+\t\t}\n+\n+\t\t// Use CreatePost instead of SendNotifications here since we need that to set up some threads state\n+\t\t_, appErr := th.App.CreatePost(th.Context, post, th.BasicChannel, false, false)\n+\t\trequire.Nil(t, appErr)\n+\n+\t\treceived1 := <-messages1\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received1.EventType())\n+\t\tassertUnmarshalsTo(t, []string{th.BasicUser.Id}, received1.GetData()[\"followers\"])\n+\n+\t\treceived2 := <-messages2\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received2.EventType())\n+\t\tassert.Nil(t, received2.GetData()[\"followers\"])\n+\t})\n+\n+\tt.Run(\"should not include broadcast hook information in messages sent to users\", func(t *testing.T) {\n+\t\tmessages1, closeWS1 := connectFakeWebSocket(t, th, th.BasicUser.Id, \"\")\n+\t\tdefer closeWS1()\n+\n+\t\tmessages2, closeWS2 := connectFakeWebSocket(t, th, th.BasicUser2.Id, \"\")\n+\t\tdefer closeWS2()\n+\n+\t\t// For a post mentioning only one user, nobody in the channel should receive information about the broadcast hooks\n+\t\tpost := &model.Post{\n+\t\t\tUserId:    sender.Id,\n+\t\t\tChannelId: th.BasicChannel.Id,\n+\t\t\tMessage:   fmt.Sprintf(\"@%s\", th.BasicUser.Username),\n+\t\t}\n+\t\t_, err := th.App.SendNotifications(th.Context, post, th.BasicTeam, th.BasicChannel, sender, nil, false)\n+\t\trequire.NoError(t, err)\n+\n+\t\treceived1 := <-messages1\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received1.EventType())\n+\t\tassert.Nil(t, received1.GetBroadcast().BroadcastHooks)\n+\t\tassert.Nil(t, received1.GetBroadcast().BroadcastHookArgs)\n+\n+\t\treceived2 := <-messages2\n+\t\trequire.Equal(t, model.WebsocketEventPosted, received2.EventType())\n+\t\tassert.Nil(t, received2.GetBroadcast().BroadcastHooks)\n+\t\tassert.Nil(t, received2.GetBroadcast().BroadcastHookArgs)\n+\t})\n+}\n+\n+func assertUnmarshalsTo(t *testing.T, expected any, actual any) {\n+\tt.Helper()\n+\n+\tval, err := json.Marshal(expected)\n+\trequire.NoError(t, err)\n+\n+\tassert.JSONEq(t, string(val), actual.(string))\n+}\n+\n+func connectFakeWebSocket(t *testing.T, th *TestHelper, userID string, connectionID string) (chan *model.WebSocketEvent, func()) {\n+\tvar session *model.Session\n+\tvar server *httptest.Server\n+\tvar webConn *platform.WebConn\n+\n+\tcloseWS := func() {\n+\t\tif webConn != nil {\n+\t\t\twebConn.Close()\n+\t\t}\n+\t\tif server != nil {\n+\t\t\tserver.Close()\n+\t\t}\n+\t\tif session != nil {\n+\t\t\tappErr := th.App.RevokeSession(session)\n+\t\t\trequire.Nil(t, appErr)\n+\t\t}\n+\t}\n+\n+\t// Create a session for the user's connection\n+\tvar appErr *model.AppError\n+\tsession, appErr = th.App.CreateSession(&model.Session{\n+\t\tUserId: userID,\n+\t})\n+\trequire.Nil(t, appErr)\n+\n+\t// Create a channel and an HTTP server to handle incoming WS events\n+\tmessages := make(chan *model.WebSocketEvent)\n+\tserver = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n+\t\tupgrader := &websocket.Upgrader{}\n+\n+\t\tc, err := upgrader.Upgrade(w, r, nil)\n+\t\tif err != nil {\n+\t\t\tt.Log(\"Received error when upgrading WebSocket connection\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tdefer c.Close()\n+\n+\t\tfor {\n+\t\t\t_, reader, err := c.NextReader()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Log(\"Received error when reading from WebSocket connection\", err)\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tmsg, err := model.WebSocketEventFromJSON(reader)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Log(\"Received error when decoding from WebSocket connection\", err)\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tmessages <- msg\n+\t\t}\n+\t}))\n+\n+\t// Connect the WebSocket\n+\td := websocket.Dialer{}\n+\tws, _, err := d.Dial(\"ws://\"+server.Listener.Addr().String(), nil)\n+\trequire.NoError(t, err)\n+\n+\t// Register the WebSocket with the server as a WebConn\n+\tif connectionID == \"\" {\n+\t\tconnectionID = model.NewId()\n+\t}\n+\twebConn = th.App.Srv().Platform().NewWebConn(&platform.WebConnConfig{\n+\t\tWebSocket:    ws,\n+\t\tSession:      *session,\n+\t\tTFunc:        i18n.IdentityTfunc(),\n+\t\tLocale:       \"en\",\n+\t\tConnectionID: connectionID,\n+\t}, th.App, th.App.Channels())\n+\tth.App.Srv().Platform().HubRegister(webConn)\n+\n+\t// Start reading from it\n+\tgo webConn.Pump()\n+\n+\t// Read the events which always occur at the start of a WebSocket connection\n+\treceived := <-messages\n+\tassert.Equal(t, model.WebsocketEventHello, received.EventType())\n+\n+\treceived = <-messages\n+\tassert.Equal(t, model.WebsocketEventStatusChange, received.EventType())\n+\n+\treturn messages, closeWS\n+}\n+\n+func TestConnectFakeWebSocket(t *testing.T) {\n+\tth := Setup(t).InitBasic()\n+\tdefer th.TearDown()\n+\n+\tteamID := th.BasicTeam.Id\n+\tuserID := th.BasicUser.Id\n+\n+\tmessages, closeWS := connectFakeWebSocket(t, th, userID, \"\")\n+\tdefer closeWS()\n+\n+\tmsg := model.NewWebSocketEvent(model.WebsocketEventPosted, teamID, \"\", \"\", nil, \"\")\n+\tth.App.Publish(msg)\n+\n+\tmsg = model.NewWebSocketEvent(\"test_event_with_data\", \"\", \"\", userID, nil, \"\")\n+\tmsg.Add(\"key1\", \"value1\")\n+\tmsg.Add(\"key2\", 2)\n+\tmsg.Add(\"key3\", []string{\"three\", \"trois\"})\n+\tth.App.Publish(msg)\n+\n+\treceived := <-messages\n+\trequire.Equal(t, model.WebsocketEventPosted, received.EventType())\n+\tassert.Equal(t, teamID, received.GetBroadcast().TeamId)\n+\n+\treceived = <-messages\n+\trequire.Equal(t, \"test_event_with_data\", received.EventType())\n+\tassert.Equal(t, userID, received.GetBroadcast().UserId)\n+\t// These type changes are annoying but unavoidable because event data is untyped\n+\tassert.Equal(t, map[string]any{\n+\t\t\"key1\": \"value1\",\n+\t\t\"key2\": float64(2),\n+\t\t\"key3\": []any{\"three\", \"trois\"},\n+\t}, received.GetData())\n+}\n+\n func TestSendNotificationsWithManyUsers(t *testing.T) {\n \tth := Setup(t).InitBasic()\n \tdefer th.TearDown()"
        },
        {
            "filename": "server/channels/app/platform/helper_test.go",
            "diff": "@@ -184,7 +184,7 @@ func setupTestHelper(dbStore store.Store, enterprise bool, includeCacheLayer boo\n \t\tth.Service.SetLicense(nil)\n \t}\n \n-\terr = th.Service.Start()\n+\terr = th.Service.Start(nil)\n \tif err != nil {\n \t\tpanic(err)\n \t}"
        },
        {
            "filename": "server/channels/app/platform/service.go",
            "diff": "@@ -339,8 +339,8 @@ func New(sc ServiceConfig, options ...Option) (*PlatformService, error) {\n \treturn ps, nil\n }\n \n-func (ps *PlatformService) Start() error {\n-\tps.hubStart()\n+func (ps *PlatformService) Start(broadcastHooks map[string]BroadcastHook) error {\n+\tps.hubStart(broadcastHooks)\n \n \tps.configListenerId = ps.AddConfigListener(func(_, _ *model.Config) {\n \t\tps.regenerateClientConfig()"
        },
        {
            "filename": "server/channels/app/platform/web_broadcast_hook.go",
            "diff": "@@ -0,0 +1,87 @@\n+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.\n+// See LICENSE.txt for license information.\n+\n+package platform\n+\n+import (\n+\t\"github.com/mattermost/mattermost/server/public/model\"\n+\t\"github.com/mattermost/mattermost/server/public/shared/mlog\"\n+)\n+\n+type BroadcastHook interface {\n+\t// Process takes a WebSocket event and modifies it in some way. It is passed a HookedWebSocketEvent which allows\n+\t// safe modification of the event.\n+\tProcess(msg *HookedWebSocketEvent, webConn *WebConn, args map[string]any) error\n+}\n+\n+func (h *Hub) runBroadcastHooks(msg *model.WebSocketEvent, webConn *WebConn, hookIDs []string, hookArgs []map[string]any) *model.WebSocketEvent {\n+\tif len(hookIDs) == 0 {\n+\t\treturn msg\n+\t}\n+\n+\thookedEvent := MakeHookedWebSocketEvent(msg)\n+\n+\tfor i, hookID := range hookIDs {\n+\t\thook := h.broadcastHooks[hookID]\n+\t\targs := hookArgs[i]\n+\t\tif hook == nil {\n+\t\t\tmlog.Warn(\"runBroadcastHooks: Unable to find broadcast hook\", mlog.String(\"hook_id\", hookID))\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\thook.Process(hookedEvent, webConn, args)\n+\t}\n+\n+\treturn hookedEvent.Event()\n+}\n+\n+// HookedWebSocketEvent is a wrapper for model.WebSocketEvent that is intended to provide a similar interface, except\n+// it ensures the original WebSocket event is not modified.\n+type HookedWebSocketEvent struct {\n+\toriginal *model.WebSocketEvent\n+\tcopy     *model.WebSocketEvent\n+}\n+\n+func MakeHookedWebSocketEvent(event *model.WebSocketEvent) *HookedWebSocketEvent {\n+\treturn &HookedWebSocketEvent{\n+\t\toriginal: event,\n+\t}\n+}\n+\n+func (he *HookedWebSocketEvent) Add(key string, value any) {\n+\the.copyIfNecessary()\n+\n+\the.copy.Add(key, value)\n+}\n+\n+func (he *HookedWebSocketEvent) EventType() string {\n+\tif he.copy == nil {\n+\t\treturn he.original.EventType()\n+\t}\n+\n+\treturn he.copy.EventType()\n+}\n+\n+// Get returns a value from the WebSocket event data. You should never mutate a value returned by this method.\n+func (he *HookedWebSocketEvent) Get(key string) any {\n+\tif he.copy == nil {\n+\t\treturn he.original.GetData()[key]\n+\t}\n+\n+\treturn he.copy.GetData()[key]\n+}\n+\n+// copyIfNecessary should be called by any mutative method to ensure that the copy is instantiated.\n+func (he *HookedWebSocketEvent) copyIfNecessary() {\n+\tif he.copy == nil {\n+\t\the.copy = he.original.RemovePrecomputedJSON()\n+\t}\n+}\n+\n+func (he *HookedWebSocketEvent) Event() *model.WebSocketEvent {\n+\tif he.copy == nil {\n+\t\treturn he.original\n+\t}\n+\n+\treturn he.copy\n+}"
        },
        {
            "filename": "server/channels/app/platform/web_broadcast_hook_test.go",
            "diff": "@@ -0,0 +1,206 @@\n+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.\n+// See LICENSE.txt for license information.\n+\n+package platform\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/mattermost/mattermost/server/public/model\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+const broadcastTest = \"test_broadcast_hook\"\n+\n+type testBroadcastHook struct{}\n+\n+func (h *testBroadcastHook) Process(msg *HookedWebSocketEvent, webConn *WebConn, args map[string]any) error {\n+\tif args[\"makes_changes\"].(bool) {\n+\t\tchangesMade, _ := msg.Get(\"changes_made\").(int)\n+\t\tmsg.Add(\"changes_made\", changesMade+1)\n+\t}\n+\n+\treturn nil\n+}\n+\n+func TestRunBroadcastHooks(t *testing.T) {\n+\thub := &Hub{\n+\t\tbroadcastHooks: map[string]BroadcastHook{\n+\t\t\tbroadcastTest: &testBroadcastHook{},\n+\t\t},\n+\t}\n+\twebConn := &WebConn{}\n+\n+\tt.Run(\"should not allocate a new object when no hooks are passed\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, nil, nil)\n+\n+\t\tassert.Same(t, event, result)\n+\t})\n+\n+\tt.Run(\"should not allocate a new object when a hook is not making changes\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\n+\t\thookIDs := []string{\n+\t\t\tbroadcastTest,\n+\t\t}\n+\t\thookArgs := []map[string]any{\n+\t\t\t{\n+\t\t\t\t\"makes_changes\": false,\n+\t\t\t},\n+\t\t}\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, hookIDs, hookArgs)\n+\n+\t\tassert.Same(t, event, result)\n+\t})\n+\n+\tt.Run(\"should allocate a new object and remove when a hook makes changes\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\n+\t\thookIDs := []string{\n+\t\t\tbroadcastTest,\n+\t\t}\n+\t\thookArgs := []map[string]any{\n+\t\t\t{\n+\t\t\t\t\"makes_changes\": true,\n+\t\t\t},\n+\t\t}\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, hookIDs, hookArgs)\n+\n+\t\tassert.NotSame(t, event, result)\n+\t\tassert.NotSame(t, event.GetData(), result.GetData())\n+\t\tassert.Equal(t, map[string]any{}, event.GetData())\n+\t\tassert.Equal(t, result.GetData(), map[string]any{\n+\t\t\t\"changes_made\": 1,\n+\t\t})\n+\t})\n+\n+\tt.Run(\"should not allocate a new object when multiple hooks are not making changes\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\n+\t\thookIDs := []string{\n+\t\t\tbroadcastTest,\n+\t\t\tbroadcastTest,\n+\t\t\tbroadcastTest,\n+\t\t}\n+\t\thookArgs := []map[string]any{\n+\t\t\t{\n+\t\t\t\t\"makes_changes\": false,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\t\"makes_changes\": false,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\t\"makes_changes\": false,\n+\t\t\t},\n+\t\t}\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, hookIDs, hookArgs)\n+\n+\t\tassert.Same(t, event, result)\n+\t})\n+\n+\tt.Run(\"should be able to make changes from only one of make hooks\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\n+\t\tvar hookIDs []string\n+\t\tvar hookArgs []map[string]any\n+\t\tfor i := 0; i < 10; i++ {\n+\t\t\thookIDs = append(hookIDs, broadcastTest)\n+\t\t\thookArgs = append(hookArgs, map[string]any{\n+\t\t\t\t\"makes_changes\": i == 6,\n+\t\t\t})\n+\t\t}\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, hookIDs, hookArgs)\n+\n+\t\tassert.NotSame(t, event, result)\n+\t\tassert.NotSame(t, event.GetData(), result.GetData())\n+\t\tassert.Equal(t, event.GetData(), map[string]any{})\n+\t\tassert.Equal(t, result.GetData(), map[string]any{\n+\t\t\t\"changes_made\": 1,\n+\t\t})\n+\t})\n+\n+\tt.Run(\"should be able to make changes from multiple hooks\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\n+\t\tvar hookIDs []string\n+\t\tvar hookArgs []map[string]any\n+\t\tfor i := 0; i < 10; i++ {\n+\t\t\thookIDs = append(hookIDs, broadcastTest)\n+\t\t\thookArgs = append(hookArgs, map[string]any{\n+\t\t\t\t\"makes_changes\": true,\n+\t\t\t})\n+\t\t}\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, hookIDs, hookArgs)\n+\n+\t\tassert.NotSame(t, event, result)\n+\t\tassert.NotSame(t, event.GetData(), result.GetData())\n+\t\tassert.Equal(t, event.GetData(), map[string]any{})\n+\t\tassert.Equal(t, result.GetData(), map[string]any{\n+\t\t\t\"changes_made\": 10,\n+\t\t})\n+\t})\n+\n+\tt.Run(\"should not remove precomputed JSON when a hook doesn't make changes\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\t\tevent = event.PrecomputeJSON()\n+\n+\t\t// Ensure that the event has precomputed JSON because changes aren't included when ToJSON is called again\n+\t\toriginalJSON, _ := event.ToJSON()\n+\t\tevent.Add(\"data\", 1234)\n+\t\teventJSON, _ := event.ToJSON()\n+\t\trequire.Equal(t, string(originalJSON), string(eventJSON))\n+\n+\t\thookIDs := []string{\n+\t\t\tbroadcastTest,\n+\t\t}\n+\t\thookArgs := []map[string]any{\n+\t\t\t{\n+\t\t\t\t\"makes_changes\": false,\n+\t\t\t},\n+\t\t}\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, hookIDs, hookArgs)\n+\n+\t\teventJSON, _ = event.ToJSON()\n+\t\tassert.Equal(t, string(originalJSON), string(eventJSON))\n+\n+\t\tresultJSON, _ := result.ToJSON()\n+\t\tassert.Equal(t, originalJSON, resultJSON)\n+\t})\n+\n+\tt.Run(\"should remove precomputed JSON when a hook makes changes\", func(t *testing.T) {\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\t\tevent = event.PrecomputeJSON()\n+\n+\t\t// Ensure that the event has precomputed JSON because changes aren't included when ToJSON is called again\n+\t\toriginalJSON, _ := event.ToJSON()\n+\t\tevent.Add(\"data\", 1234)\n+\t\teventJSON, _ := event.ToJSON()\n+\t\trequire.Equal(t, originalJSON, eventJSON)\n+\n+\t\thookIDs := []string{\n+\t\t\tbroadcastTest,\n+\t\t}\n+\t\thookArgs := []map[string]any{\n+\t\t\t{\n+\t\t\t\t\"makes_changes\": true,\n+\t\t\t},\n+\t\t}\n+\n+\t\tresult := hub.runBroadcastHooks(event, webConn, hookIDs, hookArgs)\n+\n+\t\teventJSON, _ = event.ToJSON()\n+\t\tassert.Equal(t, string(originalJSON), string(eventJSON))\n+\n+\t\tresultJSON, _ := result.ToJSON()\n+\t\tassert.NotEqual(t, originalJSON, resultJSON)\n+\t})\n+}"
        },
        {
            "filename": "server/channels/app/platform/web_hub.go",
            "diff": "@@ -69,6 +69,7 @@ type Hub struct {\n \texplicitStop    bool\n \tcheckRegistered chan *webConnSessionMessage\n \tcheckConn       chan *webConnCheckMessage\n+\tbroadcastHooks  map[string]BroadcastHook\n }\n \n // newWebHub creates a new Hub.\n@@ -89,7 +90,7 @@ func newWebHub(ps *PlatformService) *Hub {\n }\n \n // hubStart starts all the hubs.\n-func (ps *PlatformService) hubStart() {\n+func (ps *PlatformService) hubStart(broadcastHooks map[string]BroadcastHook) {\n \t// Total number of hubs is twice the number of CPUs.\n \tnumberOfHubs := runtime.NumCPU() * 2\n \tps.logger.Info(\"Starting websocket hubs\", mlog.Int(\"number_of_hubs\", numberOfHubs))\n@@ -99,6 +100,7 @@ func (ps *PlatformService) hubStart() {\n \tfor i := 0; i < numberOfHubs; i++ {\n \t\thubs[i] = newWebHub(ps)\n \t\thubs[i].connectionIndex = i\n+\t\thubs[i].broadcastHooks = broadcastHooks\n \t\thubs[i].Start()\n \t}\n \t// Assigning to the hubs slice without any mutex is fine because it is only assigned once\n@@ -491,14 +493,19 @@ func (h *Hub) Start() {\n \t\t\t\tif metrics := h.platform.metricsIFace; metrics != nil {\n \t\t\t\t\tmetrics.DecrementWebSocketBroadcastBufferSize(strconv.Itoa(h.connectionIndex), 1)\n \t\t\t\t}\n+\n+\t\t\t\t// Remove the broadcast hook information before precomputing the JSON so that those aren't included in it\n+\t\t\t\tmsg, broadcastHooks, broadcastHookArgs := msg.WithoutBroadcastHooks()\n+\n \t\t\t\tmsg = msg.PrecomputeJSON()\n+\n \t\t\t\tbroadcast := func(webConn *WebConn) {\n \t\t\t\t\tif !connIndex.Has(webConn) {\n \t\t\t\t\t\treturn\n \t\t\t\t\t}\n \t\t\t\t\tif webConn.ShouldSendEvent(msg) {\n \t\t\t\t\t\tselect {\n-\t\t\t\t\t\tcase webConn.send <- msg:\n+\t\t\t\t\t\tcase webConn.send <- h.runBroadcastHooks(msg, webConn, broadcastHooks, broadcastHookArgs):\n \t\t\t\t\t\tdefault:\n \t\t\t\t\t\t\t// Don't log the warning if it's an inactive connection.\n \t\t\t\t\t\t\tif webConn.active.Load() {"
        },
        {
            "filename": "server/channels/app/platform/web_hub_test.go",
            "diff": "@@ -4,6 +4,7 @@\n package platform\n \n import (\n+\t\"bytes\"\n \t\"encoding/json\"\n \t\"net\"\n \t\"net/http\"\n@@ -69,7 +70,7 @@ func TestHubStopWithMultipleConnections(t *testing.T) {\n \t})\n \trequire.NoError(t, err)\n \n-\tth.Service.Start()\n+\tth.Service.Start(nil)\n \twc1 := registerDummyWebConn(t, th, s.Listener.Addr(), session)\n \twc2 := registerDummyWebConn(t, th, s.Listener.Addr(), session)\n \twc3 := registerDummyWebConn(t, th, s.Listener.Addr(), session)\n@@ -93,7 +94,7 @@ func TestHubStopRaceCondition(t *testing.T) {\n \t})\n \trequire.NoError(t, err)\n \n-\tth.Service.Start()\n+\tth.Service.Start(nil)\n \twc1 := registerDummyWebConn(t, th, s.Listener.Addr(), session)\n \tdefer wc1.Close()\n \n@@ -476,7 +477,7 @@ func TestHubIsRegistered(t *testing.T) {\n \ts := httptest.NewServer(dummyWebsocketHandler(t))\n \tdefer s.Close()\n \n-\tth.Service.Start()\n+\tth.Service.Start(nil)\n \twc1 := registerDummyWebConn(t, th, s.Listener.Addr(), session)\n \twc2 := registerDummyWebConn(t, th, s.Listener.Addr(), session)\n \twc3 := registerDummyWebConn(t, th, s.Listener.Addr(), session)\n@@ -583,7 +584,7 @@ func BenchmarkGetHubForUserId(b *testing.B) {\n \tth := Setup(b).InitBasic()\n \tdefer th.TearDown()\n \n-\tth.Service.Start()\n+\tth.Service.Start(nil)\n \n \tb.ResetTimer()\n \tfor i := 0; i < b.N; i++ {\n@@ -618,3 +619,54 @@ func TestClusterBroadcast(t *testing.T) {\n \trequire.NoError(t, err)\n \trequire.Equal(t, clusterEvent.Broadcast, broadcast)\n }\n+\n+func TestClusterBroadcastHooks(t *testing.T) {\n+\tt.Run(\"should send broadcast hook information across cluster\", func(t *testing.T) {\n+\t\ttestCluster := &testlib.FakeClusterInterface{}\n+\n+\t\tth := SetupWithCluster(t, testCluster)\n+\t\tdefer th.TearDown()\n+\n+\t\thookID := broadcastTest\n+\t\thookArgs := map[string]any{\n+\t\t\t\"makes_changes\": true,\n+\t\t}\n+\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\t\tevent.GetBroadcast().AddHook(hookID, hookArgs)\n+\n+\t\tth.Service.Publish(event)\n+\n+\t\treceived, err := model.WebSocketEventFromJSON(bytes.NewReader(testCluster.GetMessages()[0].Data))\n+\n+\t\trequire.NoError(t, err)\n+\t\tassert.Equal(t, []string{hookID}, received.GetBroadcast().BroadcastHooks)\n+\t\tassert.Equal(t, []map[string]any{hookArgs}, received.GetBroadcast().BroadcastHookArgs)\n+\t})\n+\n+\tt.Run(\"should not preserve type information for args\", func(t *testing.T) {\n+\t\t// This behaviour isn't ideal, but this test confirms that it hasn't changed\n+\t\ttestCluster := &testlib.FakeClusterInterface{}\n+\n+\t\tth := SetupWithCluster(t, testCluster)\n+\t\tdefer th.TearDown()\n+\n+\t\thookID := \"test_broadcast_hook_with_args\"\n+\t\thookArgs := map[string]any{\n+\t\t\t\"user\":  &model.User{Id: \"user1\"},\n+\t\t\t\"array\": []string{\"a\", \"b\", \"c\"},\n+\t\t}\n+\n+\t\tevent := model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\")\n+\t\tevent.GetBroadcast().AddHook(hookID, hookArgs)\n+\n+\t\tth.Service.Publish(event)\n+\n+\t\treceived, err := model.WebSocketEventFromJSON(bytes.NewReader(testCluster.GetMessages()[0].Data))\n+\n+\t\trequire.NoError(t, err)\n+\t\tassert.Equal(t, []string{hookID}, received.GetBroadcast().BroadcastHooks)\n+\t\tassert.IsType(t, map[string]any{}, received.GetBroadcast().BroadcastHookArgs[0][\"user\"])\n+\t\tassert.IsType(t, []any{}, received.GetBroadcast().BroadcastHookArgs[0][\"array\"])\n+\t})\n+}"
        },
        {
            "filename": "server/channels/app/server.go",
            "diff": "@@ -271,7 +271,7 @@ func NewServer(options ...Option) (*Server, error) {\n \t// It is important to initialize the hub only after the global logger is set\n \t// to avoid race conditions while logging from inside the hub.\n \t// Step 4: Start platform\n-\ts.platform.Start()\n+\ts.platform.Start(s.makeBroadcastHooks())\n \n \t// NOTE: There should be no call to App.Srv().Channels() before step 5 is done\n \t// otherwise it will throw a panic."
        },
        {
            "filename": "server/channels/app/web_broadcast_hooks.go",
            "diff": "@@ -0,0 +1,96 @@\n+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.\n+// See LICENSE.txt for license information.\n+\n+package app\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\n+\t\"github.com/mattermost/mattermost/server/public/model\"\n+\tpUtils \"github.com/mattermost/mattermost/server/public/utils\"\n+\t\"github.com/mattermost/mattermost/server/v8/channels/app/platform\"\n+\t\"github.com/pkg/errors\"\n+)\n+\n+const (\n+\tbroadcastAddMentions  = \"add_mentions\"\n+\tbroadcastAddFollowers = \"add_followers\"\n+)\n+\n+func (s *Server) makeBroadcastHooks() map[string]platform.BroadcastHook {\n+\treturn map[string]platform.BroadcastHook{\n+\t\tbroadcastAddMentions:  &addMentionsBroadcastHook{},\n+\t\tbroadcastAddFollowers: &addFollowersBroadcastHook{},\n+\t}\n+}\n+\n+type addMentionsBroadcastHook struct{}\n+\n+func (h *addMentionsBroadcastHook) Process(msg *platform.HookedWebSocketEvent, webConn *platform.WebConn, args map[string]any) error {\n+\tmentions, err := getTypedArg[model.StringArray](args, \"mentions\")\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"Invalid mentions value passed to addMentionsBroadcastHook\")\n+\t}\n+\n+\tif len(mentions) > 0 && pUtils.Contains[string](mentions, webConn.UserId) {\n+\t\t// Note that the client expects this field to be stringified\n+\t\tmsg.Add(\"mentions\", model.ArrayToJSON([]string{webConn.UserId}))\n+\t}\n+\n+\treturn nil\n+}\n+\n+func useAddMentionsHook(message *model.WebSocketEvent, mentionedUsers model.StringArray) {\n+\tmessage.GetBroadcast().AddHook(broadcastAddMentions, map[string]any{\n+\t\t\"mentions\": mentionedUsers,\n+\t})\n+}\n+\n+type addFollowersBroadcastHook struct{}\n+\n+func (h *addFollowersBroadcastHook) Process(msg *platform.HookedWebSocketEvent, webConn *platform.WebConn, args map[string]any) error {\n+\tfollowers, err := getTypedArg[model.StringArray](args, \"followers\")\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"Invalid followers value passed to addFollowersBroadcastHook\")\n+\t}\n+\n+\tif len(followers) > 0 && pUtils.Contains[string](followers, webConn.UserId) {\n+\t\t// Note that the client expects this field to be stringified\n+\t\tmsg.Add(\"followers\", model.ArrayToJSON([]string{webConn.UserId}))\n+\t}\n+\n+\treturn nil\n+}\n+\n+func useAddFollowersHook(message *model.WebSocketEvent, followers model.StringArray) {\n+\tmessage.GetBroadcast().AddHook(broadcastAddFollowers, map[string]any{\n+\t\t\"followers\": followers,\n+\t})\n+}\n+\n+// getTypedArg returns a correctly typed hook argument with the given key, reinterpreting the type using JSON encoding\n+// if necessary. This is needed because broadcast hook args are JSON encoded in a multi-server environment, and any\n+// type information is lost because those types aren't known at decode time.\n+func getTypedArg[T any](args map[string]any, key string) (T, error) {\n+\tvar value T\n+\n+\tuntyped, ok := args[key]\n+\tif !ok {\n+\t\treturn value, fmt.Errorf(\"No argument found with key: %s\", key)\n+\t}\n+\n+\t// If the value is already correct, just return it\n+\tif typed, ok := untyped.(T); ok {\n+\t\treturn typed, nil\n+\t}\n+\n+\t// Marshal and unmarshal the data with the correct typing information\n+\tbuf, err := json.Marshal(untyped)\n+\tif err != nil {\n+\t\treturn value, err\n+\t}\n+\n+\terr = json.Unmarshal(buf, &value)\n+\treturn value, err\n+}"
        },
        {
            "filename": "server/channels/app/web_broadcast_hooks_test.go",
            "diff": "@@ -0,0 +1,114 @@\n+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.\n+// See LICENSE.txt for license information.\n+\n+package app\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/mattermost/mattermost/server/public/model\"\n+\t\"github.com/mattermost/mattermost/server/v8/channels/app/platform\"\n+\t\"github.com/stretchr/testify/assert\"\n+\t\"github.com/stretchr/testify/require\"\n+)\n+\n+func TestAddMentionsHook_Process(t *testing.T) {\n+\thook := &addMentionsBroadcastHook{}\n+\n+\tuserID := model.NewId()\n+\totherUserID := model.NewId()\n+\n+\twebConn := &platform.WebConn{\n+\t\tUserId: userID,\n+\t}\n+\n+\tt.Run(\"should add a mentions entry for the current user\", func(t *testing.T) {\n+\t\tmsg := platform.MakeHookedWebSocketEvent(model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\"))\n+\n+\t\trequire.Nil(t, msg.Event().GetData()[\"mentions\"])\n+\n+\t\thook.Process(msg, webConn, map[string]any{\n+\t\t\t\"mentions\": model.StringArray{userID},\n+\t\t})\n+\n+\t\tassert.Equal(t, `[\"`+userID+`\"]`, msg.Event().GetData()[\"mentions\"])\n+\t\tassert.Nil(t, msg.Event().GetData()[\"followers\"])\n+\t})\n+\n+\tt.Run(\"should not add a mentions entry for another user\", func(t *testing.T) {\n+\t\tmsg := platform.MakeHookedWebSocketEvent(model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\"))\n+\n+\t\trequire.Nil(t, msg.Event().GetData()[\"mentions\"])\n+\n+\t\thook.Process(msg, webConn, map[string]any{\n+\t\t\t\"mentions\": model.StringArray{otherUserID},\n+\t\t})\n+\n+\t\tassert.Nil(t, msg.Event().GetData()[\"mentions\"])\n+\t})\n+}\n+\n+func TestAddFollowersHook_Process(t *testing.T) {\n+\thook := &addFollowersBroadcastHook{}\n+\n+\tuserID := model.NewId()\n+\totherUserID := model.NewId()\n+\n+\twebConn := &platform.WebConn{\n+\t\tUserId: userID,\n+\t}\n+\n+\tt.Run(\"should add a followers entry for the current user\", func(t *testing.T) {\n+\t\tmsg := platform.MakeHookedWebSocketEvent(model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\"))\n+\n+\t\trequire.Nil(t, msg.Event().GetData()[\"followers\"])\n+\n+\t\thook.Process(msg, webConn, map[string]any{\n+\t\t\t\"followers\": model.StringArray{userID},\n+\t\t})\n+\n+\t\tassert.Equal(t, `[\"`+userID+`\"]`, msg.Event().GetData()[\"followers\"])\n+\t})\n+\n+\tt.Run(\"should not add a followers entry for another user\", func(t *testing.T) {\n+\t\tmsg := platform.MakeHookedWebSocketEvent(model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\"))\n+\n+\t\trequire.Nil(t, msg.Event().GetData()[\"followers\"])\n+\n+\t\thook.Process(msg, webConn, map[string]any{\n+\t\t\t\"followers\": model.StringArray{otherUserID},\n+\t\t})\n+\n+\t\tassert.Nil(t, msg.Event().GetData()[\"followers\"])\n+\t})\n+}\n+\n+func TestAddMentionsAndAddFollowersHooks(t *testing.T) {\n+\taddMentionsHook := &addMentionsBroadcastHook{}\n+\taddFollowersHook := &addFollowersBroadcastHook{}\n+\n+\tuserID := model.NewId()\n+\n+\twebConn := &platform.WebConn{\n+\t\tUserId: userID,\n+\t}\n+\n+\tmsg := platform.MakeHookedWebSocketEvent(model.NewWebSocketEvent(model.WebsocketEventPosted, \"\", \"\", \"\", nil, \"\"))\n+\n+\toriginalData := msg.Event().GetData()\n+\n+\trequire.Nil(t, originalData[\"mentions\"])\n+\trequire.Nil(t, originalData[\"followers\"])\n+\n+\taddMentionsHook.Process(msg, webConn, map[string]any{\n+\t\t\"mentions\": model.StringArray{userID},\n+\t})\n+\taddFollowersHook.Process(msg, webConn, map[string]any{\n+\t\t\"followers\": model.StringArray{userID},\n+\t})\n+\n+\tt.Run(\"should be able to add both mentions and followers to a single event\", func(t *testing.T) {\n+\t\tassert.Equal(t, `[\"`+userID+`\"]`, msg.Event().GetData()[\"followers\"])\n+\t\tassert.Equal(t, `[\"`+userID+`\"]`, msg.Event().GetData()[\"mentions\"])\n+\t})\n+}"
        },
        {
            "filename": "server/public/model/websocket_message.go",
            "diff": "@@ -103,6 +103,17 @@ type WebsocketBroadcast struct {\n \t// ReliableClusterSend indicates whether or not the message should\n \t// be sent through the cluster using the reliable, TCP backed channel.\n \tReliableClusterSend bool `json:\"-\"`\n+\n+\t// BroadcastHooks is a slice of hooks IDs used to process events before sending them on individual connections. The\n+\t// IDs should be understood by the WebSocket code.\n+\t//\n+\t// This field should never be sent to the client.\n+\tBroadcastHooks []string `json:\"broadcast_hooks,omitempty\"`\n+\t// BroadcastHookArgs is a slice of named arguments for each hook invocation. The index of each entry corresponds to\n+\t// the index of a hook ID in BroadcastHooks\n+\t//\n+\t// This field should never be sent to the client.\n+\tBroadcastHookArgs []map[string]any `json:\"broadcast_hook_args,omitempty\"`\n }\n \n func (wb *WebsocketBroadcast) copy() *WebsocketBroadcast {\n@@ -123,10 +134,17 @@ func (wb *WebsocketBroadcast) copy() *WebsocketBroadcast {\n \tc.OmitConnectionId = wb.OmitConnectionId\n \tc.ContainsSanitizedData = wb.ContainsSanitizedData\n \tc.ContainsSensitiveData = wb.ContainsSensitiveData\n+\tc.BroadcastHooks = wb.BroadcastHooks\n+\tc.BroadcastHookArgs = wb.BroadcastHookArgs\n \n \treturn &c\n }\n \n+func (wb *WebsocketBroadcast) AddHook(hookID string, hookArgs map[string]any) {\n+\twb.BroadcastHooks = append(wb.BroadcastHooks, hookID)\n+\twb.BroadcastHookArgs = append(wb.BroadcastHookArgs, hookArgs)\n+}\n+\n type precomputedWebSocketEventJSON struct {\n \tEvent     json.RawMessage\n \tData      json.RawMessage\n@@ -189,6 +207,32 @@ func (ev *WebSocketEvent) PrecomputeJSON() *WebSocketEvent {\n \treturn evCopy\n }\n \n+func (ev *WebSocketEvent) RemovePrecomputedJSON() *WebSocketEvent {\n+\tevCopy := ev.DeepCopy()\n+\tevCopy.precomputedJSON = nil\n+\treturn evCopy\n+}\n+\n+// WithoutBroadcastHooks gets the broadcast hook information from a WebSocketEvent and returns the event without that.\n+// If the event has broadcast hooks, a copy of the event is returned. Otherwise, the original event is returned. This\n+// is intended to be called before the event is sent to the client.\n+func (ev *WebSocketEvent) WithoutBroadcastHooks() (*WebSocketEvent, []string, []map[string]any) {\n+\thooks := ev.broadcast.BroadcastHooks\n+\thookArgs := ev.broadcast.BroadcastHookArgs\n+\n+\tif len(hooks) == 0 && len(hookArgs) == 0 {\n+\t\treturn ev, hooks, hookArgs\n+\t}\n+\n+\tevCopy := ev.Copy()\n+\tevCopy.broadcast = ev.broadcast.copy()\n+\n+\tevCopy.broadcast.BroadcastHooks = nil\n+\tevCopy.broadcast.BroadcastHookArgs = nil\n+\n+\treturn evCopy, hooks, hookArgs\n+}\n+\n func (ev *WebSocketEvent) Add(key string, value any) {\n \tev.data[key] = value\n }\n@@ -218,24 +262,24 @@ func (ev *WebSocketEvent) Copy() *WebSocketEvent {\n }\n \n func (ev *WebSocketEvent) DeepCopy() *WebSocketEvent {\n-\tvar dataCopy map[string]any\n-\tif ev.data != nil {\n-\t\tdataCopy = make(map[string]any, len(ev.data))\n-\t\tfor k, v := range ev.data {\n-\t\t\tdataCopy[k] = v\n-\t\t}\n-\t}\n-\n \tevCopy := &WebSocketEvent{\n \t\tevent:           ev.event,\n-\t\tdata:            dataCopy,\n+\t\tdata:            copyMap(ev.data),\n \t\tbroadcast:       ev.broadcast.copy(),\n \t\tsequence:        ev.sequence,\n \t\tprecomputedJSON: ev.precomputedJSON.copy(),\n \t}\n \treturn evCopy\n }\n \n+func copyMap[K comparable, V any](m map[K]V) map[K]V {\n+\tdataCopy := make(map[K]V, len(m))\n+\tfor k, v := range m {\n+\t\tdataCopy[k] = v\n+\t}\n+\treturn dataCopy\n+}\n+\n func (ev *WebSocketEvent) GetData() map[string]any {\n \treturn ev.data\n }"
        },
        {
            "filename": "server/public/utils/utils.go",
            "diff": "@@ -0,0 +1,14 @@\n+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.\n+// See LICENSE.txt for license information.\n+\n+package utils\n+\n+// Contains returns true if the slice contains the item.\n+func Contains[T comparable](slice []T, item T) bool {\n+\tfor _, s := range slice {\n+\t\tif s == item {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"
        },
        {
            "filename": "server/public/utils/utils_test.go",
            "diff": "@@ -0,0 +1,388 @@\n+// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.\n+// See LICENSE.txt for license information.\n+\n+package utils_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/mattermost/mattermost/server/public/utils\"\n+)\n+\n+func TestContains(t *testing.T) {\n+\ttestCasesStr := []struct {\n+\t\tname     string\n+\t\tslice    []string\n+\t\titem     string\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []string{},\n+\t\t\titem:     \"foo\",\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []string{\"foo\"},\n+\t\t\titem:     \"foo\",\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []string{\"bar\"},\n+\t\t\titem:     \"foo\",\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []string{\"foo\", \"bar\"},\n+\t\t\titem:     \"foo\",\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []string{\"foo\", \"bar\"},\n+\t\t\titem:     \"baz\",\n+\t\t\texpected: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesStr {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\ttestCasesInt := []struct {\n+\t\tname     string\n+\t\tslice    []int\n+\t\titem     int\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []int{},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []int{1},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []int{2},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []int{1, 2},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []int{1, 2},\n+\t\t\titem:     3,\n+\t\t\texpected: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesInt {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\ttestCasesFloat := []struct {\n+\t\tname     string\n+\t\tslice    []float64\n+\t\titem     float64\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []float64{},\n+\t\t\titem:     1.0,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []float64{1.0},\n+\t\t\titem:     1.0,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []float64{2.0},\n+\t\t\titem:     1.0,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []float64{1.0, 2.0},\n+\t\t\titem:     1.0,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []float64{1.0, 2.0},\n+\t\t\titem:     3.0,\n+\t\t\texpected: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesFloat {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\ttestCasesBool := []struct {\n+\t\tname     string\n+\t\tslice    []bool\n+\t\titem     bool\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []bool{},\n+\t\t\titem:     true,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []bool{true},\n+\t\t\titem:     true,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []bool{false},\n+\t\t\titem:     true,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []bool{true, false},\n+\t\t\titem:     true,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []bool{true, false},\n+\t\t\titem:     false,\n+\t\t\texpected: true,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesBool {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\ttestCasesByte := []struct {\n+\t\tname     string\n+\t\tslice    []byte\n+\t\titem     byte\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []byte{},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []byte{1},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []byte{2},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []byte{1, 2},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []byte{1, 2},\n+\t\t\titem:     3,\n+\t\t\texpected: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesByte {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\ttestCasesRune := []struct {\n+\t\tname     string\n+\t\tslice    []rune\n+\t\titem     rune\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []rune{},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []rune{1},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []rune{2},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []rune{1, 2},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []rune{1, 2},\n+\t\t\titem:     3,\n+\t\t\texpected: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesRune {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\ttestCasesComplex := []struct {\n+\t\tname     string\n+\t\tslice    []complex128\n+\t\titem     complex128\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []complex128{},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []complex128{1},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []complex128{2},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []complex128{1, 2},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []complex128{1, 2},\n+\t\t\titem:     3,\n+\t\t\texpected: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesComplex {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\ttestCasesUint := []struct {\n+\t\tname     string\n+\t\tslice    []uint\n+\t\titem     uint\n+\t\texpected bool\n+\t}{\n+\t\t{\n+\t\t\tname:     \"empty slice\",\n+\t\t\tslice:    []uint{},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with item\",\n+\t\t\tslice:    []uint{1},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice without item\",\n+\t\t\tslice:    []uint{2},\n+\t\t\titem:     1,\n+\t\t\texpected: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items\",\n+\t\t\tslice:    []uint{1, 2},\n+\t\t\titem:     1,\n+\t\t\texpected: true,\n+\t\t},\n+\t\t{\n+\t\t\tname:     \"slice with multiple items without item\",\n+\t\t\tslice:    []uint{1, 2},\n+\t\t\titem:     3,\n+\t\t\texpected: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCasesUint {\n+\t\tt.Run(tc.name, func(t *testing.T) {\n+\t\t\tactual := utils.Contains(tc.slice, tc.item)\n+\t\t\tif actual != tc.expected {\n+\t\t\t\tt.Errorf(\"Expected Contains(%v, %v) to be %v, but got %v\", tc.slice, tc.item, tc.expected, actual)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"
        }
    ],
    "commitTime": "2023-11-23 13:30:19"
}