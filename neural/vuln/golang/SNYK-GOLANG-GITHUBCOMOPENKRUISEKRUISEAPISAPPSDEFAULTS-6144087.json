{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "HIGH",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 6.5,
    "disclosureTime": "2024-01-03 16:44:11",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-GOLANG-GITHUBCOMOPENKRUISEKRUISEAPISAPPSDEFAULTS-6144087",
    "identifiers": {
        "CVE": [
            "CVE-2023-30617"
        ],
        "CWE": [
            "CWE-250"
        ]
    },
    "language": "golang",
    "malicious": false,
    "packageManager": "golang",
    "publicationTime": "2024-01-04 14:16:28",
    "remediation": "A fix was pushed into the master branch but not yet published. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Execution with Unnecessary Privileges",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Execution with Unnecessary Privileges via the kruise-daemon pod, an attacker with root privilege on the node can list all secrets in the cluster. Utilizing these secrets, such as the kruise-manager service account token, the attacker can escalate privileges and modify pods. This is only exploitable if the attacker has gained root privilege of the node where kruise-daemon runs. ",
        "Workaround": "This vulnerability can be mitigated by modifying kruise-daemon-role to remove the cluster level secret get/list privilege, for users not requiring imagepulljob functions. "
    },
    "source_code": [
        {
            "filename": "Makefile",
            "diff": "@@ -88,10 +88,11 @@ deploy: manifests kustomize ## Deploy controller to the K8s cluster specified in\n \tcd config/manager && $(KUSTOMIZE) edit set image controller=${IMG}\n \t$(KUSTOMIZE) build config/default | kubectl apply -f -\n \techo -e \"resources:\\n- manager.yaml\" > config/manager/kustomization.yaml\n+\t$(KUSTOMIZE) build config/daemonconfig | kubectl apply -f -\n \n undeploy: ## Undeploy controller from the K8s cluster specified in ~/.kube/config.\n \t$(KUSTOMIZE) build config/default | kubectl delete -f -\n-\n+\t$(KUSTOMIZE) build config/daemonconfig | kubectl delete -f -\n \n CONTROLLER_GEN = $(shell pwd)/bin/controller-gen\n controller-gen: ## Download controller-gen locally if necessary."
        },
        {
            "filename": "apis/apps/defaults/v1alpha1.go",
            "diff": "@@ -24,6 +24,12 @@ import (\n \t\"k8s.io/apimachinery/pkg/util/intstr\"\n \tv1 \"k8s.io/kubernetes/pkg/apis/core/v1\"\n \tutilpointer \"k8s.io/utils/pointer\"\n+\t\"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil\"\n+)\n+\n+const (\n+\t// ProtectionFinalizer is designed to ensure the GC of resources.\n+\tProtectionFinalizer = \"apps.kruise.io/deletion-protection\"\n )\n \n // SetDefaults_SidecarSet set default values for SidecarSet.\n@@ -372,7 +378,7 @@ func SetDefaultsImageTagPullPolicy(obj *v1alpha1.ImageTagPullPolicy) {\n }\n \n // SetDefaults_ImagePullJob set default values for ImagePullJob.\n-func SetDefaultsImagePullJob(obj *v1alpha1.ImagePullJob) {\n+func SetDefaultsImagePullJob(obj *v1alpha1.ImagePullJob, addProtection bool) {\n \tif obj.Spec.CompletionPolicy.Type == \"\" {\n \t\tobj.Spec.CompletionPolicy.Type = v1alpha1.Always\n \t}\n@@ -388,6 +394,9 @@ func SetDefaultsImagePullJob(obj *v1alpha1.ImagePullJob) {\n \tif obj.Spec.ImagePullPolicy == \"\" {\n \t\tobj.Spec.ImagePullPolicy = v1alpha1.PullIfNotPresent\n \t}\n+\tif addProtection {\n+\t\tcontrollerutil.AddFinalizer(obj, ProtectionFinalizer)\n+\t}\n }\n \n // SetDefaultsImageListPullJob  set default values for ImageListPullJob."
        },
        {
            "filename": "config/daemonconfig/config/kustomization.yaml",
            "diff": "@@ -0,0 +1,3 @@\n+resources:\n+- namespace.yaml\n+- rbac.yaml"
        },
        {
            "filename": "config/daemonconfig/config/namespace.yaml",
            "diff": "@@ -0,0 +1,4 @@\n+apiVersion: v1\n+kind: Namespace\n+metadata:\n+  name: kruise-daemon-config"
        },
        {
            "filename": "config/daemonconfig/config/rbac.yaml",
            "diff": "@@ -0,0 +1,29 @@\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: Role\n+metadata:\n+  creationTimestamp: null\n+  name: kruise-daemon-secret-role\n+  namespace: kruise-daemon-config\n+rules:\n+  - apiGroups:\n+      - \"\"\n+    resources:\n+      - secrets\n+    verbs:\n+      - get\n+      - list\n+      - watch\n+---\n+apiVersion: rbac.authorization.k8s.io/v1\n+kind: RoleBinding\n+metadata:\n+  name: kruise-daemon-secret-rolebinding\n+  namespace: kruise-daemon-config\n+roleRef:\n+  apiGroup: rbac.authorization.k8s.io\n+  kind: Role\n+  name: kruise-daemon-secret-role\n+subjects:\n+  - kind: ServiceAccount\n+    name: kruise-daemon\n+    namespace: kruise-system\n\\ No newline at end of file"
        },
        {
            "filename": "config/daemonconfig/kustomization.yaml",
            "diff": "@@ -0,0 +1,8 @@\n+namespace: kruise-daemon-config\n+# Value of this field is prepended to the\n+# names of all resources, e.g. a deployment named\n+# \"wordpress\" becomes \"alices-wordpress\".\n+# Note that it should also match with the prefix (text before '-') of the namespace\n+# field above.\n+bases:\n+  - config\n\\ No newline at end of file"
        },
        {
            "filename": "config/default/kruise-daemon-config.yaml",
            "diff": "@@ -0,0 +1,6 @@\n+apiVersion: v1\n+kind: Namespace\n+metadata:\n+  labels:\n+    control-plane: controller-manager\n+  name: kruise-daemon-config"
        },
        {
            "filename": "config/default/kustomization.yaml",
            "diff": "@@ -1,6 +1,3 @@\n-# Adds namespace to all resources.\n-namespace: kruise-system\n-\n # Value of this field is prepended to the\n # names of all resources, e.g. a deployment named\n # \"wordpress\" becomes \"alices-wordpress\".\n@@ -12,16 +9,19 @@ namePrefix: kruise-\n #commonLabels:\n #  someName: someValue\n \n+resources:\n+  - kruise-daemon-config.yaml\n+\n bases:\n - ../crd\n - ../rbac\n - ../manager\n-# [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in \n+# [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in\n # crd/kustomization.yaml\n - ../webhook\n # [CERTMANAGER] To enable cert-manager, uncomment all sections with 'CERTMANAGER'. 'WEBHOOK' components are required.\n #- ../certmanager\n-# [PROMETHEUS] To enable prometheus monitor, uncomment all sections with 'PROMETHEUS'. \n+# [PROMETHEUS] To enable prometheus monitor, uncomment all sections with 'PROMETHEUS'.\n #- ../prometheus\n \n patchesStrategicMerge:\n@@ -30,7 +30,7 @@ patchesStrategicMerge:\n   # endpoint w/o any authn/z, please comment the following line.\n # - manager_auth_proxy_patch.yaml\n \n-# [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in \n+# [WEBHOOK] To enable webhook, uncomment all the sections with [WEBHOOK] prefix including the one in\n # crd/kustomization.yaml\n - manager_webhook_patch.yaml\n "
        },
        {
            "filename": "config/manager/kustomization.yaml",
            "diff": "@@ -1,2 +1,5 @@\n+# Adds namespace to all resources.\n+namespace: kruise-system\n+\n resources:\n - manager.yaml"
        },
        {
            "filename": "config/rbac/daemon_role.yaml",
            "diff": "@@ -53,8 +53,6 @@ rules:\n   verbs:\n   - get\n   - list\n-  - patch\n-  - update\n   - watch\n - apiGroups:\n   - \"\"\n@@ -64,14 +62,6 @@ rules:\n   - get\n   - patch\n   - update\n-- apiGroups:\n-  - \"\"\n-  resources:\n-  - secrets\n-  verbs:\n-  - get\n-  - list\n-  - watch\n - apiGroups:\n   - apps.kruise.io\n   resources:"
        },
        {
            "filename": "config/rbac/kustomization.yaml",
            "diff": "@@ -1,3 +1,6 @@\n+# Adds namespace to all resources.\n+namespace: kruise-system\n+\n resources:\n - role.yaml\n - role_binding.yaml"
        },
        {
            "filename": "config/webhook/kustomization.yaml",
            "diff": "@@ -1,3 +1,6 @@\n+# Adds namespace to all resources.\n+namespace: kruise-system\n+\n resources:\n - manifests.yaml\n - service.yaml"
        },
        {
            "filename": "pkg/controller/imagepulljob/imagepulljob_controller.go",
            "diff": "@@ -23,6 +23,7 @@ import (\n \t\"sort\"\n \t\"time\"\n \n+\t\"github.com/openkruise/kruise/apis/apps/defaults\"\n \tappsv1alpha1 \"github.com/openkruise/kruise/apis/apps/v1alpha1\"\n \tdaemonutil \"github.com/openkruise/kruise/pkg/daemon/util\"\n \t\"github.com/openkruise/kruise/pkg/features\"\n@@ -38,10 +39,12 @@ import (\n \t\"k8s.io/apimachinery/pkg/runtime\"\n \t\"k8s.io/apimachinery/pkg/types\"\n \t\"k8s.io/apimachinery/pkg/util/clock\"\n+\t\"k8s.io/client-go/tools/cache\"\n \t\"k8s.io/client-go/util/retry\"\n \t\"k8s.io/klog/v2\"\n \t\"sigs.k8s.io/controller-runtime/pkg/client\"\n \t\"sigs.k8s.io/controller-runtime/pkg/controller\"\n+\t\"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil\"\n \t\"sigs.k8s.io/controller-runtime/pkg/handler\"\n \t\"sigs.k8s.io/controller-runtime/pkg/manager\"\n \t\"sigs.k8s.io/controller-runtime/pkg/reconcile\"\n@@ -56,11 +59,22 @@ var (\n \tconcurrentReconciles        = 3\n \tcontrollerKind              = appsv1alpha1.SchemeGroupVersion.WithKind(\"ImagePullJob\")\n \tresourceVersionExpectations = expectations.NewResourceVersionExpectation()\n+\tscaleExpectations           = expectations.NewScaleExpectations()\n )\n \n const (\n \tdefaultParallelism = 1\n \tminRequeueTime     = time.Second\n+\n+\t// SourceSecretKeyAnno is an annotations instead of label\n+\t// because the length of key may be more than 64.\n+\tSourceSecretKeyAnno = \"imagepulljobs.kruise.io/source-key\"\n+\t// SourceSecretUIDLabelKey is designed to select target via source secret.\n+\tSourceSecretUIDLabelKey = \"imagepulljobs.kruise.io/source-uid\"\n+\t// TargetOwnerReferencesAnno records the keys of imagePullJobs that refers\n+\t// the target secret. If TargetOwnerReferencesAnno is empty, means the target\n+\t// secret should be deleted.\n+\tTargetOwnerReferencesAnno = \"imagepulljobs.kruise.io/references\"\n )\n \n // Add creates a new ImagePullJob Controller and adds it to the Manager with default RBAC. The Manager will set fields on the Controller\n@@ -109,6 +123,12 @@ func add(mgr manager.Manager, r *ReconcileImagePullJob) error {\n \t\treturn err\n \t}\n \n+\t// Watch for secret for jobs that have pullSecrets\n+\terr = c.Watch(&source.Kind{Type: &v1.Secret{}}, &secretEventHandler{Reader: mgr.GetCache()})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \treturn nil\n }\n \n@@ -154,6 +174,16 @@ func (r *ReconcileImagePullJob) Reconcile(_ context.Context, request reconcile.R\n \t\treturn reconcile.Result{}, err\n \t}\n \n+\t// If scale expectations have not satisfied yet, just skip this reconcile\n+\tif scaleSatisfied, unsatisfiedDuration, dirtyData := scaleExpectations.SatisfiedExpectations(request.String()); !scaleSatisfied {\n+\t\tif unsatisfiedDuration >= expectations.ExpectationTimeout {\n+\t\t\tklog.Warningf(\"ImagePullJob: expectation unsatisfied overtime for %v, dirtyData=%v, overtime=%v\", request.String(), dirtyData, unsatisfiedDuration)\n+\t\t\treturn reconcile.Result{}, nil\n+\t\t}\n+\t\tklog.V(4).Infof(\"ImagePullJob: not satisfied scale for %v, dirtyData=%v\", request.String(), dirtyData)\n+\t\treturn reconcile.Result{RequeueAfter: expectations.ExpectationTimeout - unsatisfiedDuration}, nil\n+\t}\n+\n \t// If resourceVersion expectations have not satisfied yet, just skip this reconcile\n \tresourceVersionExpectations.Observe(job)\n \tif isSatisfied, unsatisfiedDuration := resourceVersionExpectations.IsSatisfied(job); !isSatisfied {\n@@ -166,11 +196,17 @@ func (r *ReconcileImagePullJob) Reconcile(_ context.Context, request reconcile.R\n \t}\n \n \tif job.DeletionTimestamp != nil {\n-\t\treturn reconcile.Result{}, nil\n+\t\t// ensure the GC of secrets and remove protection finalizer\n+\t\treturn reconcile.Result{}, r.finalize(job)\n \t}\n \n \t// The Job has been finished\n \tif job.Status.CompletionTime != nil {\n+\t\t// ensure the GC of secrets and remove protection finalizer\n+\t\tif err = r.finalize(job); err != nil {\n+\t\t\treturn reconcile.Result{}, fmt.Errorf(\"failed to remove finalizer: %v\", err)\n+\t\t}\n+\n \t\tvar leftTime time.Duration\n \t\tif job.Spec.CompletionPolicy.TTLSecondsAfterFinished != nil {\n \t\t\tleftTime = time.Duration(*job.Spec.CompletionPolicy.TTLSecondsAfterFinished)*time.Second - time.Since(job.Status.CompletionTime.Time)\n@@ -185,6 +221,11 @@ func (r *ReconcileImagePullJob) Reconcile(_ context.Context, request reconcile.R\n \t\treturn reconcile.Result{RequeueAfter: leftTime}, nil\n \t}\n \n+\t// add protection finalizer to ensure the GC of secrets\n+\tif err = r.addProtectionFinalizer(job); err != nil {\n+\t\treturn reconcile.Result{}, err\n+\t}\n+\n \t// Get all NodeImage related to this ImagePullJob\n \tnodeImages, err := utilimagejob.GetNodeImagesForJob(r.Client, job)\n \tif err != nil {\n@@ -204,14 +245,20 @@ func (r *ReconcileImagePullJob) Reconcile(_ context.Context, request reconcile.R\n \t\t}\n \t}\n \n+\t// sync secret to kruise-daemon-config namespace before pulling\n+\tsecrets, err := r.syncSecrets(job)\n+\tif err != nil {\n+\t\treturn reconcile.Result{}, fmt.Errorf(\"failed to sync secrets: %v\", err)\n+\t}\n+\n \t// Calculate the new status for this job\n-\tnewStatus, notSyncedNodeImages, err := r.calculateStatus(job, nodeImages)\n+\tnewStatus, notSyncedNodeImages, err := r.calculateStatus(job, nodeImages, secrets)\n \tif err != nil {\n \t\treturn reconcile.Result{}, fmt.Errorf(\"failed to calculate status: %v\", err)\n \t}\n \n \t// Sync image to more NodeImages\n-\tif err = r.syncNodeImages(job, newStatus, notSyncedNodeImages); err != nil {\n+\tif err = r.syncNodeImages(job, newStatus, notSyncedNodeImages, secrets); err != nil {\n \t\treturn reconcile.Result{}, fmt.Errorf(\"failed to sync NodeImages: %v\", err)\n \t}\n \n@@ -234,7 +281,28 @@ func (r *ReconcileImagePullJob) Reconcile(_ context.Context, request reconcile.R\n \treturn reconcile.Result{}, nil\n }\n \n-func (r *ReconcileImagePullJob) syncNodeImages(job *appsv1alpha1.ImagePullJob, newStatus *appsv1alpha1.ImagePullJobStatus, notSyncedNodeImages []string) error {\n+func (r *ReconcileImagePullJob) syncSecrets(job *appsv1alpha1.ImagePullJob) ([]appsv1alpha1.ReferenceObject, error) {\n+\tif job.Namespace == util.GetKruiseDaemonConfigNamespace() {\n+\t\treturn getSecrets(job), nil // Ignore this special case.\n+\t}\n+\n+\ttargetMap, deleteMap, err := r.getTargetSecretMap(job)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err = r.releaseTargetSecrets(deleteMap, job); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif job.DeletionTimestamp != nil || job.Status.CompletionTime != nil {\n+\t\treturn nil, r.releaseTargetSecrets(targetMap, job)\n+\t}\n+\tif err = r.checkNamespaceExists(util.GetKruiseDaemonConfigNamespace()); err != nil {\n+\t\treturn nil, fmt.Errorf(\"failed to check kruise-daemon-config namespace: %v\", err)\n+\t}\n+\treturn r.syncTargetSecrets(job, targetMap)\n+}\n+\n+func (r *ReconcileImagePullJob) syncNodeImages(job *appsv1alpha1.ImagePullJob, newStatus *appsv1alpha1.ImagePullJobStatus, notSyncedNodeImages []string, secrets []appsv1alpha1.ReferenceObject) error {\n \tif len(notSyncedNodeImages) == 0 {\n \t\treturn nil\n \t}\n@@ -254,7 +322,6 @@ func (r *ReconcileImagePullJob) syncNodeImages(job *appsv1alpha1.ImagePullJob, n\n \t}\n \n \townerRef := getOwnerRef(job)\n-\tsecrets := getSecrets(job)\n \tpullPolicy := getImagePullPolicy(job)\n \tnow := metav1.NewTime(r.clock.Now())\n \timageName, imageTag, _ := daemonutil.NormalizeImageRefToNameTag(job.Spec.Image)\n@@ -339,7 +406,116 @@ func (r *ReconcileImagePullJob) syncNodeImages(job *appsv1alpha1.ImagePullJob, n\n \treturn nil\n }\n \n-func (r *ReconcileImagePullJob) calculateStatus(job *appsv1alpha1.ImagePullJob, nodeImages []*appsv1alpha1.NodeImage) (*appsv1alpha1.ImagePullJobStatus, []string, error) {\n+func (r *ReconcileImagePullJob) getTargetSecretMap(job *appsv1alpha1.ImagePullJob) (map[string]*v1.Secret, map[string]*v1.Secret, error) {\n+\toptions := client.ListOptions{\n+\t\tNamespace: util.GetKruiseDaemonConfigNamespace(),\n+\t}\n+\ttargetLister := &v1.SecretList{}\n+\tif err := r.List(context.TODO(), targetLister, &options, utilclient.DisableDeepCopy); err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tjobKey := keyFromObject(job)\n+\tsourceReferences := getSecrets(job)\n+\tdeleteMap := make(map[string]*v1.Secret)\n+\ttargetMap := make(map[string]*v1.Secret, len(targetLister.Items))\n+\tfor i := range targetLister.Items {\n+\t\ttarget := &targetLister.Items[i]\n+\t\tif target.DeletionTimestamp != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tkeySet := referenceSetFromTarget(target)\n+\t\tif !keySet.Contains(jobKey) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsourceNs, sourceName, err := cache.SplitMetaNamespaceKey(target.Annotations[SourceSecretKeyAnno])\n+\t\tif err != nil {\n+\t\t\tklog.Warningf(\"Failed to parse source key from target %s annotations: %s\", target.Name, err)\n+\t\t}\n+\t\tif containsObject(sourceReferences, appsv1alpha1.ReferenceObject{Namespace: sourceNs, Name: sourceName}) {\n+\t\t\ttargetMap[target.Labels[SourceSecretUIDLabelKey]] = target\n+\t\t} else {\n+\t\t\tdeleteMap[target.Labels[SourceSecretUIDLabelKey]] = target\n+\t\t}\n+\t}\n+\treturn targetMap, deleteMap, nil\n+}\n+\n+func (r *ReconcileImagePullJob) releaseTargetSecrets(targetMap map[string]*v1.Secret, job *appsv1alpha1.ImagePullJob) error {\n+\tif len(targetMap) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tjobKey := keyFromObject(job)\n+\tfor _, secret := range targetMap {\n+\t\tif secret == nil {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tkeySet := referenceSetFromTarget(secret)\n+\t\t// Remove the reference to this job from target, we use Update instead of\n+\t\t// Patch to make sure we do not delete any targets that is still referred,\n+\t\t// because a target may be newly referred in this reconcile round.\n+\t\tif keySet.Contains(keyFromObject(job)) {\n+\t\t\tkeySet.Delete(jobKey)\n+\t\t\tsecret = secret.DeepCopy()\n+\t\t\tsecret.Annotations[TargetOwnerReferencesAnno] = keySet.String()\n+\t\t\tif err := r.Update(context.TODO(), secret); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tresourceVersionExpectations.Expect(secret)\n+\t\t}\n+\n+\t\t// The target is still referred by other jobs, do not delete it.\n+\t\tif !keySet.IsEmpty() {\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\t// Just delete it if no one refers it anymore.\n+\t\tif err := r.Delete(context.TODO(), secret); err != nil && !errors.IsNotFound(err) {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (r *ReconcileImagePullJob) syncTargetSecrets(job *appsv1alpha1.ImagePullJob, targetMap map[string]*v1.Secret) ([]appsv1alpha1.ReferenceObject, error) {\n+\tsourceReferences := getSecrets(job)\n+\ttargetReferences := make([]appsv1alpha1.ReferenceObject, 0, len(sourceReferences))\n+\tfor _, sourceRef := range sourceReferences {\n+\t\tsource := &v1.Secret{}\n+\t\tif err := r.Get(context.TODO(), keyFromRef(sourceRef), source); err != nil {\n+\t\t\tif errors.IsNotFound(err) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\ttarget := targetMap[string(source.UID)]\n+\t\tswitch action := computeTargetSyncAction(source, target, job); action {\n+\t\tcase create:\n+\t\t\treferenceKeys := makeReferenceSet(keyFromObject(job))\n+\t\t\ttarget = targetFromSource(source, referenceKeys)\n+\t\t\tscaleExpectations.ExpectScale(keyFromObject(job).String(), expectations.Create, string(source.UID))\n+\t\t\tif err := r.Create(context.TODO(), target); err != nil {\n+\t\t\t\tscaleExpectations.ObserveScale(keyFromObject(job).String(), expectations.Create, string(source.UID))\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\tcase update:\n+\t\t\treferenceKeys := referenceSetFromTarget(target).Insert(keyFromObject(job))\n+\t\t\ttarget = updateTarget(target, source, referenceKeys)\n+\t\t\tif err := r.Update(context.TODO(), target); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\tresourceVersionExpectations.Expect(target)\n+\t\t}\n+\t\ttargetReferences = append(targetReferences, appsv1alpha1.ReferenceObject{Namespace: target.Namespace, Name: target.Name})\n+\t}\n+\treturn targetReferences, nil\n+}\n+\n+func (r *ReconcileImagePullJob) calculateStatus(job *appsv1alpha1.ImagePullJob, nodeImages []*appsv1alpha1.NodeImage, secrets []appsv1alpha1.ReferenceObject) (*appsv1alpha1.ImagePullJobStatus, []string, error) {\n \tnewStatus := appsv1alpha1.ImagePullJobStatus{\n \t\tStartTime: job.Status.StartTime,\n \t\tDesired:   int32(len(nodeImages)),\n@@ -357,7 +533,20 @@ func (r *ReconcileImagePullJob) calculateStatus(job *appsv1alpha1.ImagePullJob,\n \tvar notSynced, pulling, succeeded, failed []string\n \tfor _, nodeImage := range nodeImages {\n \t\tvar tagVersion int64 = -1\n+\t\tvar secretSynced bool = true\n \t\tif imageSpec, ok := nodeImage.Spec.Images[imageName]; ok {\n+\t\t\tfor _, secret := range secrets {\n+\t\t\t\tif !containsObject(imageSpec.PullSecrets, secret) {\n+\t\t\t\t\tsecretSynced = false\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif !secretSynced {\n+\t\t\t\tnotSynced = append(notSynced, nodeImage.Name)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n \t\t\tfor _, tagSpec := range imageSpec.Tags {\n \t\t\t\tif tagSpec.Tag != imageTag {\n \t\t\t\t\tcontinue\n@@ -375,6 +564,7 @@ func (r *ReconcileImagePullJob) calculateStatus(job *appsv1alpha1.ImagePullJob,\n \t\t\t\ttagVersion = tagSpec.Version\n \t\t\t}\n \t\t}\n+\n \t\tif tagVersion < 0 {\n \t\t\tnotSynced = append(notSynced, nodeImage.Name)\n \t\t\tcontinue\n@@ -430,3 +620,29 @@ func (r *ReconcileImagePullJob) calculateStatus(job *appsv1alpha1.ImagePullJob,\n \tsort.Strings(newStatus.FailedNodes)\n \treturn &newStatus, notSynced, nil\n }\n+\n+func (r *ReconcileImagePullJob) checkNamespaceExists(nsName string) error {\n+\tnamespace := v1.Namespace{}\n+\treturn r.Get(context.TODO(), types.NamespacedName{Name: nsName}, &namespace)\n+}\n+\n+// addProtectionFinalizer ensure the GC of secrets in kruise-daemon-config ns\n+func (r *ReconcileImagePullJob) addProtectionFinalizer(job *appsv1alpha1.ImagePullJob) error {\n+\tif controllerutil.ContainsFinalizer(job, defaults.ProtectionFinalizer) {\n+\t\treturn nil\n+\t}\n+\tjob.Finalizers = append(job.Finalizers, defaults.ProtectionFinalizer)\n+\treturn r.Update(context.TODO(), job)\n+}\n+\n+// finalize also ensure the GC of secrets in kruise-daemon-config ns\n+func (r *ReconcileImagePullJob) finalize(job *appsv1alpha1.ImagePullJob) error {\n+\tif !controllerutil.ContainsFinalizer(job, defaults.ProtectionFinalizer) {\n+\t\treturn nil\n+\t}\n+\tif _, err := r.syncSecrets(job); err != nil {\n+\t\treturn err\n+\t}\n+\tcontrollerutil.RemoveFinalizer(job, defaults.ProtectionFinalizer)\n+\treturn r.Update(context.TODO(), job)\n+}"
        },
        {
            "filename": "pkg/controller/imagepulljob/imagepulljob_event_handler.go",
            "diff": "@@ -17,10 +17,14 @@ limitations under the License.\n package imagepulljob\n \n import (\n+\t\"context\"\n \t\"reflect\"\n \n \tappsv1alpha1 \"github.com/openkruise/kruise/apis/apps/v1alpha1\"\n \tdaemonutil \"github.com/openkruise/kruise/pkg/daemon/util\"\n+\tkruiseutil \"github.com/openkruise/kruise/pkg/util\"\n+\tutilclient \"github.com/openkruise/kruise/pkg/util/client\"\n+\t\"github.com/openkruise/kruise/pkg/util/expectations\"\n \tutilimagejob \"github.com/openkruise/kruise/pkg/util/imagejob\"\n \tv1 \"k8s.io/api/core/v1\"\n \t\"k8s.io/apimachinery/pkg/types\"\n@@ -187,6 +191,102 @@ func (e *podEventHandler) handleUpdate(pod, oldPod *v1.Pod, q workqueue.RateLimi\n \t}\n }\n \n+type secretEventHandler struct {\n+\tclient.Reader\n+}\n+\n+var _ handler.EventHandler = &secretEventHandler{}\n+\n+func (e *secretEventHandler) Create(evt event.CreateEvent, q workqueue.RateLimitingInterface) {\n+\tobj := evt.Object.(*v1.Secret)\n+\te.handle(obj, q)\n+}\n+\n+func (e *secretEventHandler) Update(evt event.UpdateEvent, q workqueue.RateLimitingInterface) {\n+\tnewObj := evt.ObjectNew.(*v1.Secret)\n+\toldObj := evt.ObjectOld.(*v1.Secret)\n+\te.handleUpdate(newObj, oldObj, q)\n+}\n+\n+func (e *secretEventHandler) Delete(evt event.DeleteEvent, q workqueue.RateLimitingInterface) {\n+}\n+\n+func (e *secretEventHandler) Generic(evt event.GenericEvent, q workqueue.RateLimitingInterface) {\n+}\n+\n+func (e *secretEventHandler) handle(secret *v1.Secret, q workqueue.RateLimitingInterface) {\n+\tif secret != nil && secret.Namespace == kruiseutil.GetKruiseDaemonConfigNamespace() {\n+\t\tjobKeySet := referenceSetFromTarget(secret)\n+\t\tklog.V(4).Infof(\"Observe secret %s/%s created, uid: %s, refs: %s\", secret.Namespace, secret.Name, secret.UID, jobKeySet.String())\n+\t\tfor key := range jobKeySet {\n+\t\t\tscaleExpectations.ObserveScale(key.String(), expectations.Create, secret.Labels[SourceSecretUIDLabelKey])\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif secret == nil || secret.DeletionTimestamp != nil {\n+\t\treturn\n+\t}\n+\t// Get jobs related to this Secret\n+\tjobKeys, err := e.getActiveJobKeysForSecret(secret)\n+\tif err != nil {\n+\t\tklog.Errorf(\"Failed to get jobs for Secret %s/%s: %v\", secret.Namespace, secret.Name, err)\n+\t}\n+\tfor _, jKey := range jobKeys {\n+\t\tq.Add(reconcile.Request{NamespacedName: jKey})\n+\t}\n+}\n+\n+func (e *secretEventHandler) handleUpdate(secretNew, secretOld *v1.Secret, q workqueue.RateLimitingInterface) {\n+\tif secretNew != nil && secretNew.Namespace == kruiseutil.GetKruiseDaemonConfigNamespace() {\n+\t\tjobKeySet := referenceSetFromTarget(secretNew)\n+\t\tfor key := range jobKeySet {\n+\t\t\tscaleExpectations.ObserveScale(key.String(), expectations.Create, secretNew.Labels[SourceSecretUIDLabelKey])\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif secretOld == nil || secretNew == nil || secretNew.DeletionTimestamp != nil ||\n+\t\t(reflect.DeepEqual(secretNew.Data, secretOld.Data) && reflect.DeepEqual(secretNew.StringData, secretOld.StringData)) {\n+\t\treturn\n+\t}\n+\t// Get jobs related to this Secret\n+\tjobKeys, err := e.getActiveJobKeysForSecret(secretNew)\n+\tif err != nil {\n+\t\tklog.Errorf(\"Failed to get jobs for Secret %s/%s: %v\", secretNew.Namespace, secretNew.Name, err)\n+\t}\n+\tfor _, jKey := range jobKeys {\n+\t\tq.Add(reconcile.Request{NamespacedName: jKey})\n+\t}\n+}\n+\n+func (e *secretEventHandler) getActiveJobKeysForSecret(secret *v1.Secret) ([]types.NamespacedName, error) {\n+\tjobLister := &appsv1alpha1.ImagePullJobList{}\n+\tif err := e.List(context.TODO(), jobLister, client.InNamespace(secret.Namespace), utilclient.DisableDeepCopy); err != nil {\n+\t\treturn nil, err\n+\t}\n+\tvar jobKeys []types.NamespacedName\n+\tfor i := range jobLister.Items {\n+\t\tjob := &jobLister.Items[i]\n+\t\tif job.DeletionTimestamp != nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif jobContainsSecret(job, secret.Name) {\n+\t\t\tjobKeys = append(jobKeys, keyFromObject(job))\n+\t\t}\n+\t}\n+\treturn jobKeys, nil\n+}\n+\n+func jobContainsSecret(job *appsv1alpha1.ImagePullJob, secretName string) bool {\n+\tfor _, s := range job.Spec.PullSecrets {\n+\t\tif secretName == s {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n func diffJobs(newJobs, oldJobs []*appsv1alpha1.ImagePullJob) set {\n \tsetNew := make(set, len(newJobs))\n \tsetOld := make(set, len(oldJobs))"
        },
        {
            "filename": "pkg/controller/imagepulljob/imagepulljob_utils.go",
            "diff": "@@ -19,15 +19,28 @@ package imagepulljob\n import (\n \t\"fmt\"\n \t\"math/rand\"\n+\t\"reflect\"\n+\t\"strings\"\n \n \tappsv1alpha1 \"github.com/openkruise/kruise/apis/apps/v1alpha1\"\n+\t\"github.com/openkruise/kruise/pkg/util\"\n \tv1 \"k8s.io/api/core/v1\"\n+\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/types\"\n+\t\"k8s.io/client-go/tools/cache\"\n+\t\"k8s.io/klog/v2\"\n+\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n )\n \n-const (\n-\tdefaultTTLSecondsForNever = int32(24 * 3600)\n+type syncAction string\n \n+const (\n+\tdefaultTTLSecondsForNever            = int32(24 * 3600)\n \tdefaultActiveDeadlineSecondsForNever = int64(1800)\n+\n+\tcreate   syncAction = \"create\"\n+\tupdate   syncAction = \"update\"\n+\tnoAction syncAction = \"noAction\"\n )\n \n func getTTLSecondsForAlways(job *appsv1alpha1.ImagePullJob) *int32 {\n@@ -118,3 +131,105 @@ func formatStatusMessage(status *appsv1alpha1.ImagePullJobStatus) (ret string) {\n \t}\n \treturn fmt.Sprintf(\"job is running, progress %.1f%%\", 100.0*float64(status.Succeeded+status.Failed)/float64(status.Desired))\n }\n+\n+func keyFromRef(ref appsv1alpha1.ReferenceObject) types.NamespacedName {\n+\treturn types.NamespacedName{\n+\t\tName:      ref.Name,\n+\t\tNamespace: ref.Namespace,\n+\t}\n+}\n+\n+func keyFromObject(object client.Object) types.NamespacedName {\n+\treturn types.NamespacedName{\n+\t\tName:      object.GetName(),\n+\t\tNamespace: object.GetNamespace(),\n+\t}\n+}\n+\n+func targetFromSource(source *v1.Secret, keySet referenceSet) *v1.Secret {\n+\ttarget := source.DeepCopy()\n+\ttarget.ObjectMeta = metav1.ObjectMeta{\n+\t\tNamespace:    util.GetKruiseDaemonConfigNamespace(),\n+\t\tGenerateName: fmt.Sprintf(\"%s-\", source.Name),\n+\t\tLabels: map[string]string{\n+\t\t\tSourceSecretUIDLabelKey: string(source.UID),\n+\t\t},\n+\t\tAnnotations: map[string]string{\n+\t\t\tSourceSecretKeyAnno:       keyFromObject(source).String(),\n+\t\t\tTargetOwnerReferencesAnno: keySet.String(),\n+\t\t},\n+\t}\n+\treturn target\n+}\n+\n+func updateTarget(target, source *v1.Secret, keySet referenceSet) *v1.Secret {\n+\ttarget = target.DeepCopy()\n+\ttarget.Data = source.Data\n+\ttarget.StringData = source.StringData\n+\ttarget.Annotations[TargetOwnerReferencesAnno] = keySet.String()\n+\treturn target\n+}\n+\n+func referenceSetFromTarget(target *v1.Secret) referenceSet {\n+\trefs := strings.Split(target.Annotations[TargetOwnerReferencesAnno], \",\")\n+\tkeys := makeReferenceSet()\n+\tfor _, ref := range refs {\n+\t\tnamespace, name, err := cache.SplitMetaNamespaceKey(ref)\n+\t\tif err != nil {\n+\t\t\tklog.Errorf(\"Failed to parse job key from target secret %s annotations: %v\", target.Name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tkeys.Insert(types.NamespacedName{Namespace: namespace, Name: name})\n+\t}\n+\treturn keys\n+}\n+\n+func computeTargetSyncAction(source, target *v1.Secret, job *appsv1alpha1.ImagePullJob) syncAction {\n+\tif target == nil || len(target.UID) == 0 {\n+\t\treturn create\n+\t}\n+\tkeySet := referenceSetFromTarget(target)\n+\tif !keySet.Contains(keyFromObject(job)) ||\n+\t\t!reflect.DeepEqual(source.Data, target.Data) ||\n+\t\t!reflect.DeepEqual(source.StringData, target.StringData) {\n+\t\treturn update\n+\t}\n+\treturn noAction\n+}\n+\n+func makeReferenceSet(items ...types.NamespacedName) referenceSet {\n+\trefSet := map[types.NamespacedName]struct{}{}\n+\tfor _, item := range items {\n+\t\trefSet[item] = struct{}{}\n+\t}\n+\treturn refSet\n+}\n+\n+type referenceSet map[types.NamespacedName]struct{}\n+\n+func (set referenceSet) String() string {\n+\tkeyList := make([]string, 0, len(set))\n+\tfor ref := range set {\n+\t\tkeyList = append(keyList, ref.String())\n+\t}\n+\treturn strings.Join(keyList, \",\")\n+}\n+\n+func (set referenceSet) Contains(key types.NamespacedName) bool {\n+\t_, exists := set[key]\n+\treturn exists\n+}\n+\n+func (set referenceSet) Insert(key types.NamespacedName) referenceSet {\n+\tset[key] = struct{}{}\n+\treturn set\n+}\n+\n+func (set referenceSet) Delete(key types.NamespacedName) referenceSet {\n+\tdelete(set, key)\n+\treturn set\n+}\n+\n+func (set referenceSet) IsEmpty() bool {\n+\treturn len(set) == 0\n+}"
        },
        {
            "filename": "pkg/util/meta.go",
            "diff": "@@ -1,5 +1,5 @@\n /*\n-Copyright 2021.\n+Copyright 2022 The Kruise Authors.\n \n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n@@ -24,3 +24,10 @@ func GetKruiseNamespace() string {\n \t}\n \treturn \"kruise-system\"\n }\n+\n+func GetKruiseDaemonConfigNamespace() string {\n+\tif ns := os.Getenv(\"KRUISE_DAEMON_CONFIG_NS\"); len(ns) > 0 {\n+\t\treturn ns\n+\t}\n+\treturn \"kruise-daemon-config\"\n+}"
        },
        {
            "filename": "pkg/util/meta_test.go",
            "diff": "@@ -0,0 +1,39 @@\n+/*\n+Copyright 2022 The Kruise Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package util\n+\n+import (\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestMetaGetNamespace(t *testing.T) {\n+\tif GetKruiseNamespace() != \"kruise-system\" {\n+\t\tt.Fatalf(\"expect(kruise-system), but get(%s)\", GetKruiseNamespace())\n+\t}\n+\t_ = os.Setenv(\"POD_NAMESPACE\", \"test\")\n+\tif GetKruiseNamespace() != \"test\" {\n+\t\tt.Fatalf(\"expect(test), but get(%s)\", GetKruiseNamespace())\n+\t}\n+\tif GetKruiseDaemonConfigNamespace() != \"kruise-daemon-config\" {\n+\t\tt.Fatalf(\"expect(kruise-daemon-config), but get(%s)\", GetKruiseDaemonConfigNamespace())\n+\t}\n+\t_ = os.Setenv(\"KRUISE_DAEMON_CONFIG_NS\", \"test\")\n+\tif GetKruiseDaemonConfigNamespace() != \"test\" {\n+\t\tt.Fatalf(\"expect(test), but get(%s)\", GetKruiseDaemonConfigNamespace())\n+\t}\n+}"
        },
        {
            "filename": "pkg/webhook/imagepulljob/mutating/imagepulljob_create_update_handler.go",
            "diff": "@@ -25,6 +25,7 @@ import (\n \t\"github.com/openkruise/kruise/apis/apps/defaults\"\n \tappsv1alpha1 \"github.com/openkruise/kruise/apis/apps/v1alpha1\"\n \t\"github.com/openkruise/kruise/pkg/util\"\n+\tadmissionv1 \"k8s.io/api/admission/v1\"\n \t\"k8s.io/apimachinery/pkg/runtime\"\n \t\"k8s.io/klog/v2\"\n \t\"sigs.k8s.io/controller-runtime/pkg/webhook/admission\"\n@@ -46,7 +47,7 @@ func (h *ImagePullJobCreateUpdateHandler) Handle(ctx context.Context, req admiss\n \t\treturn admission.Errored(http.StatusBadRequest, err)\n \t}\n \tvar copy runtime.Object = obj.DeepCopy()\n-\tdefaults.SetDefaultsImagePullJob(obj)\n+\tdefaults.SetDefaultsImagePullJob(obj, req.AdmissionRequest.Operation == admissionv1.Create)\n \tif reflect.DeepEqual(obj, copy) {\n \t\treturn admission.Allowed(\"\")\n \t}"
        },
        {
            "filename": "test/e2e/apps/pullimages.go",
            "diff": "@@ -18,22 +18,29 @@ package apps\n \n import (\n \t\"context\"\n+\t\"encoding/base64\"\n \t\"fmt\"\n+\t\"reflect\"\n+\t\"strings\"\n \t\"time\"\n \n \t\"github.com/onsi/ginkgo\"\n \t\"github.com/onsi/gomega\"\n+\tappsv1alpha1 \"github.com/openkruise/kruise/apis/apps/v1alpha1\"\n+\tkruiseclientset \"github.com/openkruise/kruise/pkg/client/clientset/versioned\"\n+\t\"github.com/openkruise/kruise/pkg/controller/imagepulljob\"\n+\t\"github.com/openkruise/kruise/pkg/util\"\n+\t\"github.com/openkruise/kruise/test/e2e/framework\"\n \tv1 \"k8s.io/api/core/v1\"\n \t\"k8s.io/apimachinery/pkg/api/errors\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/types\"\n \t\"k8s.io/apimachinery/pkg/util/intstr\"\n \tclientset \"k8s.io/client-go/kubernetes\"\n+\t\"k8s.io/client-go/tools/cache\"\n+\t\"k8s.io/klog/v2\"\n \tutilpointer \"k8s.io/utils/pointer\"\n-\n-\tappsv1alpha1 \"github.com/openkruise/kruise/apis/apps/v1alpha1\"\n-\tkruiseclientset \"github.com/openkruise/kruise/pkg/client/clientset/versioned\"\n-\t\"github.com/openkruise/kruise/pkg/util\"\n-\t\"github.com/openkruise/kruise/test/e2e/framework\"\n+\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n )\n \n var _ = SIGDescribe(\"PullImage\", func() {\n@@ -65,6 +72,20 @@ var _ = SIGDescribe(\"PullImage\", func() {\n \t\t},\n \t}\n \n+\treferenceSetFromTarget := func(target *v1.Secret) map[types.NamespacedName]struct{} {\n+\t\trefs := strings.Split(target.Annotations[imagepulljob.TargetOwnerReferencesAnno], \",\")\n+\t\tkeys := map[types.NamespacedName]struct{}{}\n+\t\tfor _, ref := range refs {\n+\t\t\tnamespace, name, err := cache.SplitMetaNamespaceKey(ref)\n+\t\t\tif err != nil {\n+\t\t\t\tklog.Errorf(\"Failed to parse job key from target secret %s annotations: %v\", target.Name, err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tkeys[types.NamespacedName{Namespace: namespace, Name: name}] = struct{}{}\n+\t\t}\n+\t\treturn keys\n+\t}\n+\n \tginkgo.BeforeEach(func() {\n \t\tc = f.ClientSet\n \t\tkc = f.KruiseClientSet\n@@ -91,6 +112,197 @@ var _ = SIGDescribe(\"PullImage\", func() {\n \t\t\tbaseJob = &appsv1alpha1.ImagePullJob{ObjectMeta: metav1.ObjectMeta{Namespace: ns, Name: \"test-imagepulljob\"}}\n \t\t})\n \n+\t\tframework.ConformanceIt(\"pull image with secret\", func() {\n+\t\t\tvar err error\n+\t\t\tbase64Code := \"eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOnsidXNlcm5hbWUiOiJtaW5jaG91IiwicGFzc3dvcmQiOiJtaW5nemhvdS5zd3giLCJlbWFpbCI6InZlYy5nLnN1bkBnbWFpbC5jb20iLCJhdXRoIjoiYldsdVkyaHZkVHB0YVc1bmVtaHZkUzV6ZDNnPSJ9fX0=\"\n+\t\t\tbytes, err := base64.StdEncoding.DecodeString(base64Code)\n+\t\t\tsecret := &v1.Secret{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tNamespace: ns,\n+\t\t\t\t\tName:      \"pull-secret\",\n+\t\t\t\t},\n+\t\t\t\tType: \"kubernetes.io/dockerconfigjson\",\n+\t\t\t\tData: map[string][]byte{\n+\t\t\t\t\t\".dockerconfigjson\": bytes,\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\tsecret, err = testerForImagePullJob.CreateSecret(secret)\n+\t\t\tgomega.Expect(err).ShouldNot(gomega.HaveOccurred())\n+\n+\t\t\tjob := baseJob.DeepCopy()\n+\t\t\tjob.Spec = appsv1alpha1.ImagePullJobSpec{\n+\t\t\t\tImage: NginxImage,\n+\t\t\t\tImagePullJobTemplate: appsv1alpha1.ImagePullJobTemplate{\n+\t\t\t\t\tSelector: &appsv1alpha1.ImagePullJobNodeSelector{LabelSelector: metav1.LabelSelector{MatchExpressions: []metav1.LabelSelectorRequirement{\n+\t\t\t\t\t\t{Key: framework.FakeNodeImageLabelKey, Operator: metav1.LabelSelectorOpDoesNotExist},\n+\t\t\t\t\t}}},\n+\t\t\t\t\tPullPolicy: &appsv1alpha1.PullPolicy{\n+\t\t\t\t\t\tTimeoutSeconds: utilpointer.Int32Ptr(50),\n+\t\t\t\t\t\tBackoffLimit:   utilpointer.Int32Ptr(2),\n+\t\t\t\t\t},\n+\t\t\t\t\tPullSecrets: []string{secret.Name},\n+\t\t\t\t\tParallelism: &intorstr4,\n+\t\t\t\t\tCompletionPolicy: appsv1alpha1.CompletionPolicy{\n+\t\t\t\t\t\tType:                    appsv1alpha1.Always,\n+\t\t\t\t\t\tActiveDeadlineSeconds:   utilpointer.Int64Ptr(50),\n+\t\t\t\t\t\tTTLSecondsAfterFinished: utilpointer.Int32Ptr(20),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\terr = testerForImagePullJob.CreateJob(job)\n+\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\n+\t\t\tginkgo.By(\"Desired should be equal to number of nodes\")\n+\t\t\tgomega.Eventually(func() int32 {\n+\t\t\t\tjob, err = testerForImagePullJob.GetJob(job)\n+\t\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\t\t\t\treturn job.Status.Desired\n+\t\t\t}, 3*time.Second, time.Second).Should(gomega.Equal(int32(len(nodes))))\n+\n+\t\t\tginkgo.By(\"Secret is synced\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tsynced, _ := testerForImagePullJob.ListSyncedSecrets(secret)\n+\t\t\t\tif len(synced) != 1 {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tif _, exists := referenceSetFromTarget(&synced[0])[client.ObjectKeyFromObject(job)]; !exists {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\treturn reflect.DeepEqual(synced[0].Data, secret.Data)\n+\t\t\t}, 10*time.Second, time.Second).Should(gomega.Equal(true))\n+\n+\t\t\tginkgo.By(\"Wait completed in 180s\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tjob, err = testerForImagePullJob.GetJob(job)\n+\t\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\t\t\t\treturn job.Status.CompletionTime != nil\n+\t\t\t}, 180*time.Second, 3*time.Second).Should(gomega.Equal(true))\n+\t\t\tgomega.Expect(job.Status.Succeeded).To(gomega.Equal(int32(len(nodes))))\n+\n+\t\t\tginkgo.By(\"Wait clean in 25s\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\t_, err = testerForImagePullJob.GetJob(job)\n+\t\t\t\treturn err != nil && errors.IsNotFound(err)\n+\t\t\t}, 25*time.Second, 2*time.Second).Should(gomega.Equal(true))\n+\n+\t\t\tginkgo.By(\"Check image should be cleaned in NodeImage\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tfound, err := testerForNodeImage.IsImageInSpec(job.Spec.Image, nodes[0].Name)\n+\t\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\t\t\t\treturn found\n+\t\t\t}, 25*time.Second, time.Second).Should(gomega.Equal(false))\n+\n+\t\t\tginkgo.By(\"Check secrets should be cleaned in kruise-daemon-config\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tsynced, _ := testerForImagePullJob.ListSyncedSecrets(secret)\n+\t\t\t\treturn len(synced) == 0\n+\t\t\t}, 10*time.Second, time.Second).Should(gomega.Equal(true))\n+\t\t})\n+\n+\t\tframework.ConformanceIt(\"never completion pull job with updated pull secrets\", func() {\n+\t\t\tvar err error\n+\t\t\tbase64Code := \"eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOnsidXNlcm5hbWUiOiJtaW5jaG91IiwicGFzc3dvcmQiOiJtaW5nemhvdS5zd3giLCJlbWFpbCI6InZlYy5nLnN1bkBnbWFpbC5jb20iLCJhdXRoIjoiYldsdVkyaHZkVHB0YVc1bmVtaHZkUzV6ZDNnPSJ9fX0=\"\n+\t\t\tnewBase64Code := \"eyJhdXRocyI6eyJodHRwczovL2luZGV4LmRvY2tlci5pby92MS8iOnsidXNlcm5hbWUiOiJtaW5jaG91IiwicGFzc3dvcmQiOiJtaW5nemhvdS50ZXN0IiwiZW1haWwiOiJ2ZWMuZy5zdW5AZ21haWwuY29tIiwiYXV0aCI6ImJXbHVZMmh2ZFRwdGFXNW5lbWh2ZFM1MFpYTjAifX19\"\n+\t\t\tbytes, _ := base64.StdEncoding.DecodeString(base64Code)\n+\t\t\tnewBytes, _ := base64.StdEncoding.DecodeString(newBase64Code)\n+\t\t\tsecret := &v1.Secret{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tNamespace: ns,\n+\t\t\t\t\tName:      \"pull-secret\",\n+\t\t\t\t},\n+\t\t\t\tType: \"kubernetes.io/dockerconfigjson\",\n+\t\t\t\tData: map[string][]byte{\n+\t\t\t\t\t\".dockerconfigjson\": bytes,\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\tsecret, err = testerForImagePullJob.CreateSecret(secret)\n+\t\t\tgomega.Expect(err).ShouldNot(gomega.HaveOccurred())\n+\n+\t\t\tjob := baseJob.DeepCopy()\n+\t\t\tjob.Spec = appsv1alpha1.ImagePullJobSpec{\n+\t\t\t\tImage: NginxImage,\n+\t\t\t\tImagePullJobTemplate: appsv1alpha1.ImagePullJobTemplate{\n+\t\t\t\t\tSelector: &appsv1alpha1.ImagePullJobNodeSelector{LabelSelector: metav1.LabelSelector{MatchExpressions: []metav1.LabelSelectorRequirement{\n+\t\t\t\t\t\t{Key: framework.FakeNodeImageLabelKey, Operator: metav1.LabelSelectorOpDoesNotExist},\n+\t\t\t\t\t}}},\n+\t\t\t\t\tPullPolicy: &appsv1alpha1.PullPolicy{\n+\t\t\t\t\t\tTimeoutSeconds: utilpointer.Int32Ptr(50),\n+\t\t\t\t\t\tBackoffLimit:   utilpointer.Int32Ptr(2),\n+\t\t\t\t\t},\n+\t\t\t\t\tPullSecrets: []string{secret.Name},\n+\t\t\t\t\tParallelism: &intorstr4,\n+\t\t\t\t\tCompletionPolicy: appsv1alpha1.CompletionPolicy{\n+\t\t\t\t\t\tType: appsv1alpha1.Never,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\terr = testerForImagePullJob.CreateJob(job)\n+\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\n+\t\t\tginkgo.By(\"Desired should be equal to number of nodes\")\n+\t\t\tgomega.Eventually(func() int32 {\n+\t\t\t\tjob, err = testerForImagePullJob.GetJob(job)\n+\t\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\t\t\t\treturn job.Status.Desired\n+\t\t\t}, 3*time.Second, time.Second).Should(gomega.Equal(int32(len(nodes))))\n+\n+\t\t\tginkgo.By(\"Secret is synced\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tsynced, _ := testerForImagePullJob.ListSyncedSecrets(secret)\n+\t\t\t\tif len(synced) != 1 {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tif _, exists := referenceSetFromTarget(&synced[0])[client.ObjectKeyFromObject(job)]; !exists {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\treturn reflect.DeepEqual(synced[0].Data, secret.Data)\n+\t\t\t}, 10*time.Second, time.Second).Should(gomega.Equal(true))\n+\n+\t\t\tginkgo.By(\"Update source secret\")\n+\t\t\tsecret.Data[\".dockerconfigjson\"] = newBytes\n+\t\t\ttesterForImagePullJob.UpdateSecret(secret)\n+\n+\t\t\tginkgo.By(\"Check target updated secret in 10s\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tsynced, _ := testerForImagePullJob.ListSyncedSecrets(secret)\n+\t\t\t\tif len(synced) != 1 {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\tif _, exists := referenceSetFromTarget(&synced[0])[client.ObjectKeyFromObject(job)]; !exists {\n+\t\t\t\t\treturn false\n+\t\t\t\t}\n+\t\t\t\treturn reflect.DeepEqual(synced[0].Data, secret.Data)\n+\t\t\t}, 10*time.Second, time.Second).Should(gomega.Equal(true))\n+\n+\t\t\tginkgo.By(\"Wait completed in 180s\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tjob, err = testerForImagePullJob.GetJob(job)\n+\t\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\t\t\t\treturn job.Status.Succeeded == int32(len(nodes))\n+\t\t\t}, 180*time.Second, 3*time.Second).Should(gomega.Equal(true))\n+\n+\t\t\tginkgo.By(\"Delete pull job and check in 10s\")\n+\t\t\terr = testerForImagePullJob.DeleteJob(job)\n+\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\t_, err := testerForImagePullJob.GetJob(job)\n+\t\t\t\treturn errors.IsNotFound(err)\n+\t\t\t}, 10*time.Second, time.Second).Should(gomega.Equal(false))\n+\n+\t\t\tginkgo.By(\"Check image should be cleaned in NodeImage\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tfound, err := testerForNodeImage.IsImageInSpec(job.Spec.Image, nodes[0].Name)\n+\t\t\t\tgomega.Expect(err).NotTo(gomega.HaveOccurred())\n+\t\t\t\treturn found\n+\t\t\t}, 25*time.Second, time.Second).Should(gomega.Equal(false))\n+\n+\t\t\tginkgo.By(\"Check secrets should be cleaned in kruise-daemon-config\")\n+\t\t\tgomega.Eventually(func() bool {\n+\t\t\t\tsynced, _ := testerForImagePullJob.ListSyncedSecrets(secret)\n+\t\t\t\treturn len(synced) == 0\n+\t\t\t}, 10*time.Second, time.Second).Should(gomega.Equal(true))\n+\t\t})\n+\n \t\tframework.ConformanceIt(\"create an always job to pull an image on all real nodes\", func() {\n \t\t\tjob := baseJob.DeepCopy()\n \t\t\tjob.Spec = appsv1alpha1.ImagePullJobSpec{\n@@ -309,5 +521,4 @@ var _ = SIGDescribe(\"PullImage\", func() {\n \t\t\t}, 60*time.Second, 3*time.Second).Should(gomega.Equal(int32(1)))\n \t\t})\n \t})\n-\n })"
        },
        {
            "filename": "test/e2e/framework/imagepulljob_util.go",
            "diff": "@@ -21,8 +21,13 @@ import (\n \n \tappsv1alpha1 \"github.com/openkruise/kruise/apis/apps/v1alpha1\"\n \tkruiseclientset \"github.com/openkruise/kruise/pkg/client/clientset/versioned\"\n+\t\"github.com/openkruise/kruise/pkg/controller/imagepulljob\"\n+\t\"github.com/openkruise/kruise/pkg/util\"\n+\tv1 \"k8s.io/api/core/v1\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\t\"k8s.io/apimachinery/pkg/labels\"\n \tclientset \"k8s.io/client-go/kubernetes\"\n+\t\"k8s.io/client-go/util/retry\"\n )\n \n type ImagePullJobTester struct {\n@@ -57,3 +62,31 @@ func (tester *ImagePullJobTester) GetJob(job *appsv1alpha1.ImagePullJob) (*appsv\n func (tester *ImagePullJobTester) ListJobs(ns string) (*appsv1alpha1.ImagePullJobList, error) {\n \treturn tester.kc.AppsV1alpha1().ImagePullJobs(ns).List(context.TODO(), metav1.ListOptions{})\n }\n+\n+func (tester *ImagePullJobTester) CreateSecret(secret *v1.Secret) (*v1.Secret, error) {\n+\treturn tester.c.CoreV1().Secrets(secret.Namespace).Create(context.TODO(), secret, metav1.CreateOptions{})\n+}\n+\n+func (tester *ImagePullJobTester) UpdateSecret(secret *v1.Secret) (*v1.Secret, error) {\n+\tnamespace, name := secret.GetNamespace(), secret.GetName()\n+\tvar err error\n+\tvar newSecret *v1.Secret\n+\terr = retry.RetryOnConflict(retry.DefaultRetry, func() error {\n+\t\tnewSecret, err = tester.c.CoreV1().Secrets(namespace).Get(context.TODO(), name, metav1.GetOptions{})\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tnewSecret.Data = secret.Data\n+\t\tnewSecret, err = tester.c.CoreV1().Secrets(namespace).Update(context.TODO(), newSecret, metav1.UpdateOptions{})\n+\t\treturn err\n+\t})\n+\treturn newSecret, err\n+}\n+\n+func (tester *ImagePullJobTester) ListSyncedSecrets(source *v1.Secret) ([]v1.Secret, error) {\n+\toptions := metav1.ListOptions{\n+\t\tLabelSelector: labels.SelectorFromSet(map[string]string{imagepulljob.SourceSecretUIDLabelKey: string(source.UID)}).String(),\n+\t}\n+\tlister, err := tester.c.CoreV1().Secrets(util.GetKruiseDaemonConfigNamespace()).List(context.TODO(), options)\n+\treturn lister.Items, err\n+}"
        }
    ],
    "commitTime": "2024-01-04 09:34:19"
}