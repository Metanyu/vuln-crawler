{
    "CVSSv3": {
        "CVSS": "3.1",
        "E": "P",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "LOW"
    },
    "credit": [
        "mschwager"
    ],
    "cvssDetails": [],
    "cvssScore": 5.3,
    "disclosureTime": "2023-12-20 17:35:00",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.06926",
        "probability": "0.00043"
    },
    "exploitMaturity": "Proof of Concept",
    "id": "SNYK-GOLANG-GITHUBCOMDVSEKHVALNOVJOSE2GO-6137739",
    "identifiers": {
        "CVE": [
            "CVE-2023-50658"
        ],
        "CWE": [
            "CWE-400"
        ],
        "GO": [
            "GO-2023-2409"
        ]
    },
    "language": "golang",
    "malicious": false,
    "packageManager": "golang",
    "publicationTime": "2023-12-21 16:13:55",
    "remediation": "Upgrade github.com/dvsekhvalnov/jose2go to version 1.6.0 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Uncontrolled Resource Consumption ('Resource Exhaustion')",
    "vulnDescription": {
        "Overview": "github.com/dvsekhvalnov/jose2go is a Pure Golang (GO) library for generating, decoding and encrypting JSON Web Tokens. Zero dependency, relies only on standard library. Affected versions of this package are vulnerable to Uncontrolled Resource Consumption ('Resource Exhaustion') via the decryption process of a PBES2 encrypted JWE blob with a manipulated p2c value. An attacker can cause a denial-of-service condition by providing an excessively large p2c value that overwhelms system resources during decryption. ",
        "PoC": "package main import ( \"flag\" \"fmt\" \"github.com/dvsekhvalnov/jose2go\" ) func main() { var jwe, key string flag.StringVar(&jwe, \"jwe\", \"\", \"JWE value\") flag.StringVar(&key, \"key\", \"\", \"JWE key\") flag.Parse() fmt.Println(\"Decrypting...\") payload, headers, err := jose.Decode(jwe, key) if err != nil { panic(err) } fmt.Println(\"Decrypted:\", string(payload)) fmt.Println(\"Headers:\", headers) } "
    },
    "source_code": [
        {
            "filename": "jose_test.go",
            "diff": "@@ -1634,6 +1634,40 @@ func (s *TestSuite) TestDecrypt_PBSE2_HS512_A256KW_A256CBC_HS512(c *C) {\n \tc.Assert(test, Equals, `{\"exp\":1392553211,\"sub\":\"alice\",\"nbf\":1392552611,\"aud\":[\"https:\\/\\/app-one.com\",\"https:\\/\\/app-two.com\"],\"iss\":\"https:\\/\\/openid.net\",\"jti\":\"586dd129-a29f-49c8-9de7-454af1155e27\",\"iat\":1392552611}`)\n }\n \n+func (s *TestSuite) TestDecrypt_PBSE2_HS512_A256KW_A256CBC_HS512_MinIterationViolation(c *C) {\n+\t//given\n+\tpbes2Hs512 := DeregisterJwa(PBES2_HS512_A256KW)\n+\tRegisterJwa(NewPbse2HmacAesKWAlg(256, 300000, 10000))\n+\ttoken := \"eyJhbGciOiJQQkVTMi1IUzUxMitBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwicDJjIjo4MTkyLCJwMnMiOiJCUlkxQ1M3VXNpaTZJNzhkIn0.ovjAL7yRnB_XdJbK8lAaUDRZ-CyVeio8f4pnqOt1FPj1PoQAdEX3S5x6DlzR8aqN_WR5LUwdqDSyUDYhSurnmq8VLfzd3AEe.YAjH6g_zekXJIlPN4Ooo5Q.tutaltxpeVyayXZ9pQovGXTWTf_GWWvtu25Jeg9jgoH0sUX9KCnL00A69e4GJR6EMxalmWsa45AItffbwjUBmwdyklC4ZbTgaovVRs-UwqsZFBO2fpEb7qLajjwra7o4OegzgXDD0jhrKrUusvRWGBvenvumb5euibUxmIfBUcVF1JbdfYxx7ztFeS-QKJpDkE00zyEkViq-QxfrMVl5p7LGmTz8hMrFL3LXLokypZSDgFBfsUzChJf3mlYzxiGaGUqhs7NksQJDoUYf6prPow.XwRVfVTTPogO74RnxZD_9Mse26fTSehna1pbWy4VHfY\"\n+\n+\t//when\n+\ttest, headers, err := Decode(token, \"top secret\")\n+\tfmt.Printf(\"\\np2c min iteration err= %v\\n\", err)\n+\n+\t//then\n+\tRegisterJwa(pbes2Hs512)\n+\tc.Assert(err, NotNil)\n+\tc.Assert(test, Equals, \"\")\n+\tc.Assert(headers, IsNil)\n+}\n+\n+func (s *TestSuite) TestDecrypt_PBSE2_HS512_A256KW_A256CBC_HS512_MaxIterationViolation(c *C) {\n+\t//given\n+\tpbes2Hs512 := DeregisterJwa(PBES2_HS512_A256KW)\n+\tRegisterJwa(NewPbse2HmacAesKWAlg(256, 8000, 0))\n+\ttoken := \"eyJhbGciOiJQQkVTMi1IUzUxMitBMjU2S1ciLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIiwicDJjIjo4MTkyLCJwMnMiOiJCUlkxQ1M3VXNpaTZJNzhkIn0.ovjAL7yRnB_XdJbK8lAaUDRZ-CyVeio8f4pnqOt1FPj1PoQAdEX3S5x6DlzR8aqN_WR5LUwdqDSyUDYhSurnmq8VLfzd3AEe.YAjH6g_zekXJIlPN4Ooo5Q.tutaltxpeVyayXZ9pQovGXTWTf_GWWvtu25Jeg9jgoH0sUX9KCnL00A69e4GJR6EMxalmWsa45AItffbwjUBmwdyklC4ZbTgaovVRs-UwqsZFBO2fpEb7qLajjwra7o4OegzgXDD0jhrKrUusvRWGBvenvumb5euibUxmIfBUcVF1JbdfYxx7ztFeS-QKJpDkE00zyEkViq-QxfrMVl5p7LGmTz8hMrFL3LXLokypZSDgFBfsUzChJf3mlYzxiGaGUqhs7NksQJDoUYf6prPow.XwRVfVTTPogO74RnxZD_9Mse26fTSehna1pbWy4VHfY\"\n+\n+\t//when\n+\ttest, headers, err := Decode(token, \"top secret\")\n+\tfmt.Printf(\"\\np2c max iteration err= %v\\n\", err)\n+\n+\t//then\n+\tRegisterJwa(pbes2Hs512)\n+\tc.Assert(err, NotNil)\n+\tc.Assert(test, Equals, \"\")\n+\tc.Assert(headers, IsNil)\n+}\n+\n func (s *TestSuite) TestEncrypt_PBSE2_HS256_A128KW_A128GCM(c *C) {\n \t//given\n \tpayload := `{\"hello\": \"world\"}`"
        },
        {
            "filename": "pbse2_hmac_aeskw.go",
            "diff": "@@ -4,6 +4,7 @@ import (\n \t\"crypto/sha256\"\n \t\"crypto/sha512\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"hash\"\n \n \t\"github.com/dvsekhvalnov/jose2go/arrays\"\n@@ -12,15 +13,28 @@ import (\n )\n \n func init() {\n-\tRegisterJwa(&Pbse2HmacAesKW{keySizeBits: 128, aesKW: &AesKW{keySizeBits: 128}})\n-\tRegisterJwa(&Pbse2HmacAesKW{keySizeBits: 192, aesKW: &AesKW{keySizeBits: 192}})\n-\tRegisterJwa(&Pbse2HmacAesKW{keySizeBits: 256, aesKW: &AesKW{keySizeBits: 256}})\n+\tRegisterJwa(NewPbse2HmacAesKWAlg(128, 310000, 0))\n+\tRegisterJwa(NewPbse2HmacAesKWAlg(192, 250000, 0))\n+\tRegisterJwa(NewPbse2HmacAesKWAlg(256, 120000, 0))\n }\n \n // PBSE2 with HMAC key management algorithm implementation\n type Pbse2HmacAesKW struct {\n-\tkeySizeBits int\n-\taesKW       JwaAlgorithm\n+\tkeySizeBits   int\n+\taesKW         JwaAlgorithm\n+\tmaxIterations int64\n+\tminIterations int64\n+}\n+\n+func NewPbse2HmacAesKWAlg(keySize int, maxIters int64, minIters int64) JwaAlgorithm {\n+\tswitch keySize {\n+\tcase 128:\n+\t\treturn &Pbse2HmacAesKW{keySizeBits: 128, maxIterations: maxIters, minIterations: minIters, aesKW: &AesKW{keySizeBits: 128}}\n+\tcase 192:\n+\t\treturn &Pbse2HmacAesKW{keySizeBits: 192, maxIterations: maxIters, minIterations: minIters, aesKW: &AesKW{keySizeBits: 192}}\n+\tdefault:\n+\t\treturn &Pbse2HmacAesKW{keySizeBits: 256, maxIterations: maxIters, minIterations: minIters, aesKW: &AesKW{keySizeBits: 256}}\n+\t}\n }\n \n func (alg *Pbse2HmacAesKW) Name() string {\n@@ -46,6 +60,21 @@ func (alg *Pbse2HmacAesKW) WrapNewKey(cekSizeBits int, key interface{}, header m\n \t\t\treturn nil, nil, err\n \t\t}\n \n+\t\t// use user provided iteration counts if any\n+\t\tif p2c, ok := header[\"p2c\"].(int); ok {\n+\t\t\titerationCount = p2c\n+\t\t}\n+\n+\t\tif int64(iterationCount) > alg.maxIterations {\n+\t\t\treturn nil, nil, errors.New(\n+\t\t\t\tfmt.Sprintf(\"Pbse2HmacAesKW.Unwrap(): expected 'p2c' to be less than %v but got %v\", alg.maxIterations, iterationCount))\n+\t\t}\n+\n+\t\tif int64(iterationCount) < alg.minIterations {\n+\t\t\treturn nil, nil, errors.New(\n+\t\t\t\tfmt.Sprintf(\"Pbse2HmacAesKW.Unwrap(): expected 'p2c' to be higher than %v but got %v\", alg.minIterations, iterationCount))\n+\t\t}\n+\n \t\theader[\"p2c\"] = iterationCount\n \t\theader[\"p2s\"] = base64url.Encode(saltInput)\n \n@@ -69,8 +98,18 @@ func (alg *Pbse2HmacAesKW) Unwrap(encryptedCek []byte, key interface{}, cekSizeB\n \t\t\treturn nil, errors.New(\"Pbse2HmacAesKW.Unwrap(): expected 'p2c' param in JWT header, but was not found.\")\n \t\t}\n \n+\t\tif int64(p2c) > alg.maxIterations {\n+\t\t\treturn nil, errors.New(\n+\t\t\t\tfmt.Sprintf(\"Pbse2HmacAesKW.Unwrap(): expected 'p2c' to be less than %v but got %v\", alg.maxIterations, p2c))\n+\t\t}\n+\n+\t\tif int64(p2c) < alg.minIterations {\n+\t\t\treturn nil, errors.New(\n+\t\t\t\tfmt.Sprintf(\"Pbse2HmacAesKW.Unwrap(): expected 'p2c' to be higher than %v but got %v\", alg.minIterations, p2c))\n+\t\t}\n+\n \t\tif p2s, ok = header[\"p2s\"].(string); !ok {\n-\t\t\treturn nil, errors.New(\"Pbse2HmacAesKW.Unwrap(): expected 'p2s' param in JWT header, but was not found.\")\n+\t\t\treturn nil, errors.New(\"Pbse2HmacAesKW.Unwrap(): expected 'p2s' param in JWT header, but was not found\")\n \t\t}\n \n \t\tvar saltInput []byte"
        }
    ],
    "commitTime": "2023-11-23 17:26:26"
}