{
    "CVSSv3": {
        "CVSS": "3.1",
        "E": "P",
        "attackVector": "LOCAL",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "REQUIRED",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 7.5,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "NONE",
                "availability": "HIGH"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 5.5,
    "disclosureTime": "2023-12-25 07:46:24",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.12298",
        "probability": "0.00045"
    },
    "exploitMaturity": "Proof of Concept",
    "id": "SNYK-UNMANAGED-BLOSCCBLOSC2-6139296",
    "identifiers": {
        "CVE": [
            "CVE-2023-37186"
        ],
        "CWE": [
            "CWE-476"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-25 21:32:55",
    "remediation": "Upgrade blosc/c-blosc2 to version 2.9.3 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "NULL Pointer Dereference",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to NULL Pointer Dereference in ndlz8x8.c. . An attacker can cause a crash by processing a malicious file. "
    },
    "source_code": [
        {
            "filename": "plugins/codecs/ndlz/ndlz4x4.c",
            "diff": "@@ -59,6 +59,8 @@\n int ndlz4_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_cparams *cparams) {\n   BLOSC_UNUSED_PARAM(meta);\n+  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);\n+  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);\n   uint8_t *smeta;\n   int32_t smeta_len;\n \n@@ -513,6 +515,8 @@ int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, i\n                      uint8_t meta, blosc2_dparams *dparams) {\n   BLOSC_UNUSED_PARAM(meta);\n   BLOSC_UNUSED_PARAM(dparams);\n+  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n+  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n \n   uint8_t *ip = (uint8_t *) input;\n   uint8_t *ip_limit = ip + input_len;\n@@ -541,7 +545,7 @@ int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, i\n   eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n   eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n \n-  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {\n+  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n     return 0;\n   }\n   memset(op, 0, blockshape[0] * blockshape[1]);"
        },
        {
            "filename": "plugins/codecs/ndlz/ndlz8x8.c",
            "diff": "@@ -59,6 +59,8 @@\n int ndlz8_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                    uint8_t meta, blosc2_cparams *cparams) {\n   BLOSC_UNUSED_PARAM(meta);\n+  BLOSC_ERROR_NULL(cparams, BLOSC2_ERROR_NULL_POINTER);\n+  BLOSC_ERROR_NULL(cparams->schunk, BLOSC2_ERROR_NULL_POINTER);\n   uint8_t *smeta;\n   int32_t smeta_len;\n \n@@ -430,6 +432,8 @@ int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, i\n                      uint8_t meta, blosc2_dparams *dparams) {\n   BLOSC_UNUSED_PARAM(meta);\n   BLOSC_UNUSED_PARAM(dparams);\n+  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n+  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n \n   const int cell_shape = 8;\n   const int cell_size = 64;\n@@ -458,8 +462,7 @@ int ndlz8_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, i\n   ip += 4;\n   eshape[0] = ((blockshape[0] + 7) / cell_shape) * cell_shape;\n   eshape[1] = ((blockshape[1] + 7) / cell_shape) * cell_shape;\n-\n-  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < blockshape[0] * blockshape[1])) {\n+  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n     return 0;\n   }\n   memset(op, 0, blockshape[0] * blockshape[1]);"
        }
    ],
    "commitTime": "2023-06-21 09:17:51"
}