{
    "CVSSv3": {
        "CVSS": "3.1",
        "E": "P",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "Fabian B\u00e4umer",
        "Marcus Brinkmann",
        "J\u00f6rg Schwenk"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 5.9,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "HIGH",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "HIGH",
                "availability": "NONE"
            },
            "severity": "medium"
        },
        {
            "assigner": "Red Hat",
            "cvssV3BaseScore": 5.9,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "HIGH",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "HIGH",
                "availability": "NONE"
            },
            "severity": "medium"
        },
        {
            "assigner": "SUSE",
            "cvssV3BaseScore": 5.9,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "HIGH",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "HIGH",
                "availability": "NONE"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 5.9,
    "disclosureTime": "2023-12-18 21:18:26",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.97023",
        "probability": "0.43479"
    },
    "exploitMaturity": "Proof of Concept",
    "id": "SNYK-UNMANAGED-OPENSSHPORTABLE-6130672",
    "identifiers": {
        "CVE": [
            "CVE-2023-48795"
        ],
        "CWE": [
            "CWE-294"
        ],
        "GO": [
            "GO-2023-2402"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-19 10:31:05",
    "remediation": "Upgrade openssh-portable to version 9.6 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Authentication Bypass by Capture-replay",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Authentication Bypass by Capture-replay during the establishment of the secure channel. An attacker can manipulate handshake sequence numbers to delete messages sent immediately after the channel is established. Note: Sequence numbers are only validated once the channel is established and arbitrary messages are allowed during the handshake, allowing them to manipulate the sequence numbers. The potential consequences of the general Terrapin attack are dependent on the messages exchanged after the handshake concludes. If you are using a custom SSH service and do not resort to the authentication protocol, you should check that dropping the first few messages of a connection does not yield security risks. Impact: While cryptographically novel, there is no discernable impact on the integrity of SSH traffic beyond giving the attacker the ability to delete the message that enables some features related to keystroke timing obfuscation. To successfully carry out the exploitation, the connection needs to be protected using either the ChaCha20-Poly1305 or CBC with Encrypt-then-MAC encryption methods. The attacker must also be able to intercept and modify the connection's traffic. ",
        "Workaround": "Temporarily disable the affected chacha20-poly1305@openssh.com encryption and *-etm@openssh.com MAC algorithms in the affected configuration, and use unaffected algorithms like AES-GCM instead. "
    },
    "source_code": [
        {
            "filename": "ssh/handshake.go",
            "diff": "@@ -35,6 +35,16 @@ type keyingTransport interface {\n \t// direction will be effected if a msgNewKeys message is sent\n \t// or received.\n \tprepareKeyChange(*algorithms, *kexResult) error\n+\n+\t// setStrictMode sets the strict KEX mode, notably triggering\n+\t// sequence number resets on sending or receiving msgNewKeys.\n+\t// If the sequence number is already > 1 when setStrictMode\n+\t// is called, an error is returned.\n+\tsetStrictMode() error\n+\n+\t// setInitialKEXDone indicates to the transport that the initial key exchange\n+\t// was completed\n+\tsetInitialKEXDone()\n }\n \n // handshakeTransport implements rekeying on top of a keyingTransport\n@@ -100,6 +110,10 @@ type handshakeTransport struct {\n \n \t// The session ID or nil if first kex did not complete yet.\n \tsessionID []byte\n+\n+\t// strictMode indicates if the other side of the handshake indicated\n+\t// that we should be following the strict KEX protocol restrictions.\n+\tstrictMode bool\n }\n \n type pendingKex struct {\n@@ -209,7 +223,10 @@ func (t *handshakeTransport) readLoop() {\n \t\t\tclose(t.incoming)\n \t\t\tbreak\n \t\t}\n-\t\tif p[0] == msgIgnore || p[0] == msgDebug {\n+\t\t// If this is the first kex, and strict KEX mode is enabled,\n+\t\t// we don't ignore any messages, as they may be used to manipulate\n+\t\t// the packet sequence numbers.\n+\t\tif !(t.sessionID == nil && t.strictMode) && (p[0] == msgIgnore || p[0] == msgDebug) {\n \t\t\tcontinue\n \t\t}\n \t\tt.incoming <- p\n@@ -441,6 +458,11 @@ func (t *handshakeTransport) readOnePacket(first bool) ([]byte, error) {\n \treturn successPacket, nil\n }\n \n+const (\n+\tkexStrictClient = \"kex-strict-c-v00@openssh.com\"\n+\tkexStrictServer = \"kex-strict-s-v00@openssh.com\"\n+)\n+\n // sendKexInit sends a key change message.\n func (t *handshakeTransport) sendKexInit() error {\n \tt.mu.Lock()\n@@ -454,7 +476,6 @@ func (t *handshakeTransport) sendKexInit() error {\n \t}\n \n \tmsg := &kexInitMsg{\n-\t\tKexAlgos:                t.config.KeyExchanges,\n \t\tCiphersClientServer:     t.config.Ciphers,\n \t\tCiphersServerClient:     t.config.Ciphers,\n \t\tMACsClientServer:        t.config.MACs,\n@@ -464,6 +485,13 @@ func (t *handshakeTransport) sendKexInit() error {\n \t}\n \tio.ReadFull(rand.Reader, msg.Cookie[:])\n \n+\t// We mutate the KexAlgos slice, in order to add the kex-strict extension algorithm,\n+\t// and possibly to add the ext-info extension algorithm. Since the slice may be the\n+\t// user owned KeyExchanges, we create our own slice in order to avoid using user\n+\t// owned memory by mistake.\n+\tmsg.KexAlgos = make([]string, 0, len(t.config.KeyExchanges)+2) // room for kex-strict and ext-info\n+\tmsg.KexAlgos = append(msg.KexAlgos, t.config.KeyExchanges...)\n+\n \tisServer := len(t.hostKeys) > 0\n \tif isServer {\n \t\tfor _, k := range t.hostKeys {\n@@ -488,17 +516,24 @@ func (t *handshakeTransport) sendKexInit() error {\n \t\t\t\tmsg.ServerHostKeyAlgos = append(msg.ServerHostKeyAlgos, keyFormat)\n \t\t\t}\n \t\t}\n+\n+\t\tif t.sessionID == nil {\n+\t\t\tmsg.KexAlgos = append(msg.KexAlgos, kexStrictServer)\n+\t\t}\n \t} else {\n \t\tmsg.ServerHostKeyAlgos = t.hostKeyAlgorithms\n \n \t\t// As a client we opt in to receiving SSH_MSG_EXT_INFO so we know what\n \t\t// algorithms the server supports for public key authentication. See RFC\n \t\t// 8308, Section 2.1.\n+\t\t//\n+\t\t// We also send the strict KEX mode extension algorithm, in order to opt\n+\t\t// into the strict KEX mode.\n \t\tif firstKeyExchange := t.sessionID == nil; firstKeyExchange {\n-\t\t\tmsg.KexAlgos = make([]string, 0, len(t.config.KeyExchanges)+1)\n-\t\t\tmsg.KexAlgos = append(msg.KexAlgos, t.config.KeyExchanges...)\n \t\t\tmsg.KexAlgos = append(msg.KexAlgos, \"ext-info-c\")\n+\t\t\tmsg.KexAlgos = append(msg.KexAlgos, kexStrictClient)\n \t\t}\n+\n \t}\n \n \tpacket := Marshal(msg)\n@@ -604,6 +639,13 @@ func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {\n \t\treturn err\n \t}\n \n+\tif t.sessionID == nil && ((isClient && contains(serverInit.KexAlgos, kexStrictServer)) || (!isClient && contains(clientInit.KexAlgos, kexStrictClient))) {\n+\t\tt.strictMode = true\n+\t\tif err := t.conn.setStrictMode(); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n \t// We don't send FirstKexFollows, but we handle receiving it.\n \t//\n \t// RFC 4253 section 7 defines the kex and the agreement method for\n@@ -679,6 +721,12 @@ func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {\n \t\treturn unexpectedMessageError(msgNewKeys, packet[0])\n \t}\n \n+\tif firstKeyExchange {\n+\t\t// Indicates to the transport that the first key exchange is completed\n+\t\t// after receiving SSH_MSG_NEWKEYS.\n+\t\tt.conn.setInitialKEXDone()\n+\t}\n+\n \treturn nil\n }\n "
        },
        {
            "filename": "ssh/handshake_test.go",
            "diff": "@@ -395,6 +395,10 @@ func (n *errorKeyingTransport) readPacket() ([]byte, error) {\n \treturn n.packetConn.readPacket()\n }\n \n+func (n *errorKeyingTransport) setStrictMode() error { return nil }\n+\n+func (n *errorKeyingTransport) setInitialKEXDone() {}\n+\n func TestHandshakeErrorHandlingRead(t *testing.T) {\n \tfor i := 0; i < 20; i++ {\n \t\ttestHandshakeErrorHandlingN(t, i, -1, false)\n@@ -710,3 +714,308 @@ func TestPickIncompatibleHostKeyAlgo(t *testing.T) {\n \t\tt.Fatal(\"incompatible signer returned\")\n \t}\n }\n+\n+func TestStrictKEXResetSeqFirstKEX(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\tt.Skip(\"see golang.org/issue/7237\")\n+\t}\n+\n+\tchecker := &syncChecker{\n+\t\twaitCall: make(chan int, 10),\n+\t\tcalled:   make(chan int, 10),\n+\t}\n+\n+\tchecker.waitCall <- 1\n+\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: checker.Check}, \"addr\", false)\n+\tif err != nil {\n+\t\tt.Fatalf(\"handshakePair: %v\", err)\n+\t}\n+\t<-checker.called\n+\n+\tt.Cleanup(func() {\n+\t\ttrC.Close()\n+\t\ttrS.Close()\n+\t})\n+\n+\t// Throw away the msgExtInfo packet sent during the handshake by the server\n+\t_, err = trC.readPacket()\n+\tif err != nil {\n+\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t}\n+\n+\t// close the handshake transports before checking the sequence number to\n+\t// avoid races.\n+\ttrC.Close()\n+\ttrS.Close()\n+\n+\t// check that the sequence number counters. We reset after msgNewKeys, but\n+\t// then the server immediately writes msgExtInfo, and we close the\n+\t// transports so we expect read 2, write 0 on the client and read 1, write 1\n+\t// on the server.\n+\tif trC.conn.(*transport).reader.seqNum != 2 || trC.conn.(*transport).writer.seqNum != 0 ||\n+\t\ttrS.conn.(*transport).reader.seqNum != 1 || trS.conn.(*transport).writer.seqNum != 1 {\n+\t\tt.Errorf(\n+\t\t\t\"unexpected sequence counters:\\nclient: reader %d (expected 2), writer %d (expected 0)\\nserver: reader %d (expected 1), writer %d (expected 1)\",\n+\t\t\ttrC.conn.(*transport).reader.seqNum,\n+\t\t\ttrC.conn.(*transport).writer.seqNum,\n+\t\t\ttrS.conn.(*transport).reader.seqNum,\n+\t\t\ttrS.conn.(*transport).writer.seqNum,\n+\t\t)\n+\t}\n+}\n+\n+func TestStrictKEXResetSeqSuccessiveKEX(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\tt.Skip(\"see golang.org/issue/7237\")\n+\t}\n+\n+\tchecker := &syncChecker{\n+\t\twaitCall: make(chan int, 10),\n+\t\tcalled:   make(chan int, 10),\n+\t}\n+\n+\tchecker.waitCall <- 1\n+\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: checker.Check}, \"addr\", false)\n+\tif err != nil {\n+\t\tt.Fatalf(\"handshakePair: %v\", err)\n+\t}\n+\t<-checker.called\n+\n+\tt.Cleanup(func() {\n+\t\ttrC.Close()\n+\t\ttrS.Close()\n+\t})\n+\n+\t// Throw away the msgExtInfo packet sent during the handshake by the server\n+\t_, err = trC.readPacket()\n+\tif err != nil {\n+\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t}\n+\n+\t// write and read five packets on either side to bump the sequence numbers\n+\tfor i := 0; i < 5; i++ {\n+\t\tif err := trC.writePacket([]byte{msgRequestSuccess}); err != nil {\n+\t\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t\t}\n+\t\tif _, err := trS.readPacket(); err != nil {\n+\t\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t\t}\n+\t\tif err := trS.writePacket([]byte{msgRequestSuccess}); err != nil {\n+\t\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t\t}\n+\t\tif _, err := trC.readPacket(); err != nil {\n+\t\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t\t}\n+\t}\n+\n+\t// Request a key exchange, which should cause the sequence numbers to reset\n+\tchecker.waitCall <- 1\n+\ttrC.requestKeyExchange()\n+\t<-checker.called\n+\n+\t// write a packet on the client, and then read it, to verify the key change has actually happened, since\n+\t// the HostKeyCallback is called _during_ the handshake, so isn't actually indicative of the handshake\n+\t// finishing.\n+\tdummyPacket := []byte{99}\n+\tif err := trS.writePacket(dummyPacket); err != nil {\n+\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t}\n+\tif p, err := trC.readPacket(); err != nil {\n+\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t} else if !bytes.Equal(p, dummyPacket) {\n+\t\tt.Fatalf(\"unexpected packet: got %x, want %x\", p, dummyPacket)\n+\t}\n+\n+\t// close the handshake transports before checking the sequence number to\n+\t// avoid races.\n+\ttrC.Close()\n+\ttrS.Close()\n+\n+\tif trC.conn.(*transport).reader.seqNum != 2 || trC.conn.(*transport).writer.seqNum != 0 ||\n+\t\ttrS.conn.(*transport).reader.seqNum != 1 || trS.conn.(*transport).writer.seqNum != 1 {\n+\t\tt.Errorf(\n+\t\t\t\"unexpected sequence counters:\\nclient: reader %d (expected 2), writer %d (expected 0)\\nserver: reader %d (expected 1), writer %d (expected 1)\",\n+\t\t\ttrC.conn.(*transport).reader.seqNum,\n+\t\t\ttrC.conn.(*transport).writer.seqNum,\n+\t\t\ttrS.conn.(*transport).reader.seqNum,\n+\t\t\ttrS.conn.(*transport).writer.seqNum,\n+\t\t)\n+\t}\n+}\n+\n+func TestSeqNumIncrease(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\tt.Skip(\"see golang.org/issue/7237\")\n+\t}\n+\n+\tchecker := &syncChecker{\n+\t\twaitCall: make(chan int, 10),\n+\t\tcalled:   make(chan int, 10),\n+\t}\n+\n+\tchecker.waitCall <- 1\n+\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: checker.Check}, \"addr\", false)\n+\tif err != nil {\n+\t\tt.Fatalf(\"handshakePair: %v\", err)\n+\t}\n+\t<-checker.called\n+\n+\tt.Cleanup(func() {\n+\t\ttrC.Close()\n+\t\ttrS.Close()\n+\t})\n+\n+\t// Throw away the msgExtInfo packet sent during the handshake by the server\n+\t_, err = trC.readPacket()\n+\tif err != nil {\n+\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t}\n+\n+\t// write and read five packets on either side to bump the sequence numbers\n+\tfor i := 0; i < 5; i++ {\n+\t\tif err := trC.writePacket([]byte{msgRequestSuccess}); err != nil {\n+\t\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t\t}\n+\t\tif _, err := trS.readPacket(); err != nil {\n+\t\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t\t}\n+\t\tif err := trS.writePacket([]byte{msgRequestSuccess}); err != nil {\n+\t\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t\t}\n+\t\tif _, err := trC.readPacket(); err != nil {\n+\t\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t\t}\n+\t}\n+\n+\t// close the handshake transports before checking the sequence number to\n+\t// avoid races.\n+\ttrC.Close()\n+\ttrS.Close()\n+\n+\tif trC.conn.(*transport).reader.seqNum != 7 || trC.conn.(*transport).writer.seqNum != 5 ||\n+\t\ttrS.conn.(*transport).reader.seqNum != 6 || trS.conn.(*transport).writer.seqNum != 6 {\n+\t\tt.Errorf(\n+\t\t\t\"unexpected sequence counters:\\nclient: reader %d (expected 7), writer %d (expected 5)\\nserver: reader %d (expected 6), writer %d (expected 6)\",\n+\t\t\ttrC.conn.(*transport).reader.seqNum,\n+\t\t\ttrC.conn.(*transport).writer.seqNum,\n+\t\t\ttrS.conn.(*transport).reader.seqNum,\n+\t\t\ttrS.conn.(*transport).writer.seqNum,\n+\t\t)\n+\t}\n+}\n+\n+func TestStrictKEXUnexpectedMsg(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\tt.Skip(\"see golang.org/issue/7237\")\n+\t}\n+\n+\t// Check that unexpected messages during the handshake cause failure\n+\t_, _, err := handshakePair(&ClientConfig{HostKeyCallback: func(hostname string, remote net.Addr, key PublicKey) error { return nil }}, \"addr\", true)\n+\tif err == nil {\n+\t\tt.Fatal(\"handshake should fail when there are unexpected messages during the handshake\")\n+\t}\n+\n+\ttrC, trS, err := handshakePair(&ClientConfig{HostKeyCallback: func(hostname string, remote net.Addr, key PublicKey) error { return nil }}, \"addr\", false)\n+\tif err != nil {\n+\t\tt.Fatalf(\"handshake failed: %s\", err)\n+\t}\n+\n+\t// Check that ignore/debug pacekts are still ignored outside of the handshake\n+\tif err := trC.writePacket([]byte{msgIgnore}); err != nil {\n+\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t}\n+\tif err := trC.writePacket([]byte{msgDebug}); err != nil {\n+\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t}\n+\tdummyPacket := []byte{99}\n+\tif err := trC.writePacket(dummyPacket); err != nil {\n+\t\tt.Fatalf(\"writePacket failed: %s\", err)\n+\t}\n+\n+\tif p, err := trS.readPacket(); err != nil {\n+\t\tt.Fatalf(\"readPacket failed: %s\", err)\n+\t} else if !bytes.Equal(p, dummyPacket) {\n+\t\tt.Fatalf(\"unexpected packet: got %x, want %x\", p, dummyPacket)\n+\t}\n+}\n+\n+func TestStrictKEXMixed(t *testing.T) {\n+\t// Test that we still support a mixed connection, where one side sends kex-strict but the other\n+\t// side doesn't.\n+\n+\ta, b, err := netPipe()\n+\tif err != nil {\n+\t\tt.Fatalf(\"netPipe failed: %s\", err)\n+\t}\n+\n+\tvar trC, trS keyingTransport\n+\n+\ttrC = newTransport(a, rand.Reader, true)\n+\ttrS = newTransport(b, rand.Reader, false)\n+\ttrS = addNoiseTransport(trS)\n+\n+\tclientConf := &ClientConfig{HostKeyCallback: func(hostname string, remote net.Addr, key PublicKey) error { return nil }}\n+\tclientConf.SetDefaults()\n+\n+\tv := []byte(\"version\")\n+\tclient := newClientTransport(trC, v, v, clientConf, \"addr\", a.RemoteAddr())\n+\n+\tserverConf := &ServerConfig{}\n+\tserverConf.AddHostKey(testSigners[\"ecdsa\"])\n+\tserverConf.AddHostKey(testSigners[\"rsa\"])\n+\tserverConf.SetDefaults()\n+\n+\ttransport := newHandshakeTransport(trS, &serverConf.Config, []byte(\"version\"), []byte(\"version\"))\n+\ttransport.hostKeys = serverConf.hostKeys\n+\ttransport.publicKeyAuthAlgorithms = serverConf.PublicKeyAuthAlgorithms\n+\n+\treadOneFailure := make(chan error, 1)\n+\tgo func() {\n+\t\tif _, err := transport.readOnePacket(true); err != nil {\n+\t\t\treadOneFailure <- err\n+\t\t}\n+\t}()\n+\n+\t// Basically sendKexInit, but without the kex-strict extension algorithm\n+\tmsg := &kexInitMsg{\n+\t\tKexAlgos:                transport.config.KeyExchanges,\n+\t\tCiphersClientServer:     transport.config.Ciphers,\n+\t\tCiphersServerClient:     transport.config.Ciphers,\n+\t\tMACsClientServer:        transport.config.MACs,\n+\t\tMACsServerClient:        transport.config.MACs,\n+\t\tCompressionClientServer: supportedCompressions,\n+\t\tCompressionServerClient: supportedCompressions,\n+\t\tServerHostKeyAlgos:      []string{KeyAlgoRSASHA256, KeyAlgoRSASHA512, KeyAlgoRSA},\n+\t}\n+\tpacket := Marshal(msg)\n+\t// writePacket destroys the contents, so save a copy.\n+\tpacketCopy := make([]byte, len(packet))\n+\tcopy(packetCopy, packet)\n+\tif err := transport.pushPacket(packetCopy); err != nil {\n+\t\tt.Fatalf(\"pushPacket: %s\", err)\n+\t}\n+\ttransport.sentInitMsg = msg\n+\ttransport.sentInitPacket = packet\n+\n+\tif err := transport.getWriteError(); err != nil {\n+\t\tt.Fatalf(\"getWriteError failed: %s\", err)\n+\t}\n+\tvar request *pendingKex\n+\tselect {\n+\tcase err = <-readOneFailure:\n+\t\tt.Fatalf(\"server readOnePacket failed: %s\", err)\n+\tcase request = <-transport.startKex:\n+\t\tbreak\n+\t}\n+\n+\t// We expect the following calls to fail if the side which does not support\n+\t// kex-strict sends unexpected/ignored packets during the handshake, even if\n+\t// the other side does support kex-strict.\n+\n+\tif err := transport.enterKeyExchange(request.otherInit); err != nil {\n+\t\tt.Fatalf(\"enterKeyExchange failed: %s\", err)\n+\t}\n+\tif err := client.waitSession(); err != nil {\n+\t\tt.Fatalf(\"client.waitSession: %v\", err)\n+\t}\n+}"
        },
        {
            "filename": "ssh/transport.go",
            "diff": "@@ -49,6 +49,9 @@ type transport struct {\n \trand      io.Reader\n \tisClient  bool\n \tio.Closer\n+\n+\tstrictMode     bool\n+\tinitialKEXDone bool\n }\n \n // packetCipher represents a combination of SSH encryption/MAC\n@@ -74,6 +77,18 @@ type connectionState struct {\n \tpendingKeyChange chan packetCipher\n }\n \n+func (t *transport) setStrictMode() error {\n+\tif t.reader.seqNum != 1 {\n+\t\treturn errors.New(\"ssh: sequence number != 1 when strict KEX mode requested\")\n+\t}\n+\tt.strictMode = true\n+\treturn nil\n+}\n+\n+func (t *transport) setInitialKEXDone() {\n+\tt.initialKEXDone = true\n+}\n+\n // prepareKeyChange sets up key material for a keychange. The key changes in\n // both directions are triggered by reading and writing a msgNewKey packet\n // respectively.\n@@ -112,11 +127,12 @@ func (t *transport) printPacket(p []byte, write bool) {\n // Read and decrypt next packet.\n func (t *transport) readPacket() (p []byte, err error) {\n \tfor {\n-\t\tp, err = t.reader.readPacket(t.bufReader)\n+\t\tp, err = t.reader.readPacket(t.bufReader, t.strictMode)\n \t\tif err != nil {\n \t\t\tbreak\n \t\t}\n-\t\tif len(p) == 0 || (p[0] != msgIgnore && p[0] != msgDebug) {\n+\t\t// in strict mode we pass through DEBUG and IGNORE packets only during the initial KEX\n+\t\tif len(p) == 0 || (t.strictMode && !t.initialKEXDone) || (p[0] != msgIgnore && p[0] != msgDebug) {\n \t\t\tbreak\n \t\t}\n \t}\n@@ -127,7 +143,7 @@ func (t *transport) readPacket() (p []byte, err error) {\n \treturn p, err\n }\n \n-func (s *connectionState) readPacket(r *bufio.Reader) ([]byte, error) {\n+func (s *connectionState) readPacket(r *bufio.Reader, strictMode bool) ([]byte, error) {\n \tpacket, err := s.packetCipher.readCipherPacket(s.seqNum, r)\n \ts.seqNum++\n \tif err == nil && len(packet) == 0 {\n@@ -140,6 +156,9 @@ func (s *connectionState) readPacket(r *bufio.Reader) ([]byte, error) {\n \t\t\tselect {\n \t\t\tcase cipher := <-s.pendingKeyChange:\n \t\t\t\ts.packetCipher = cipher\n+\t\t\t\tif strictMode {\n+\t\t\t\t\ts.seqNum = 0\n+\t\t\t\t}\n \t\t\tdefault:\n \t\t\t\treturn nil, errors.New(\"ssh: got bogus newkeys message\")\n \t\t\t}\n@@ -170,10 +189,10 @@ func (t *transport) writePacket(packet []byte) error {\n \tif debugTransport {\n \t\tt.printPacket(packet, true)\n \t}\n-\treturn t.writer.writePacket(t.bufWriter, t.rand, packet)\n+\treturn t.writer.writePacket(t.bufWriter, t.rand, packet, t.strictMode)\n }\n \n-func (s *connectionState) writePacket(w *bufio.Writer, rand io.Reader, packet []byte) error {\n+func (s *connectionState) writePacket(w *bufio.Writer, rand io.Reader, packet []byte, strictMode bool) error {\n \tchangeKeys := len(packet) > 0 && packet[0] == msgNewKeys\n \n \terr := s.packetCipher.writeCipherPacket(s.seqNum, w, rand, packet)\n@@ -188,6 +207,9 @@ func (s *connectionState) writePacket(w *bufio.Writer, rand io.Reader, packet []\n \t\tselect {\n \t\tcase cipher := <-s.pendingKeyChange:\n \t\t\ts.packetCipher = cipher\n+\t\t\tif strictMode {\n+\t\t\t\ts.seqNum = 0\n+\t\t\t}\n \t\tdefault:\n \t\t\tpanic(\"ssh: no key material for msgNewKeys\")\n \t\t}"
        }
    ],
    "commitTime": "2023-12-18 16:33:08"
}