{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "REQUIRED",
        "scope": "UNCHANGED",
        "confidentiality": "LOW",
        "integrity": "LOW",
        "availability": "HIGH"
    },
    "credit": [
        "Zhiyi Zhang and Zhunki from Codesafe Team of Legendsec at Qi'anxin Group"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 8.8,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "REQUIRED",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "HIGH",
                "availability": "HIGH"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 7.6,
    "disclosureTime": "2023-12-14 22:46:53",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.28842",
        "probability": "0.00069"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-UNMANAGED-CHROMIUM-6129531",
    "identifiers": {
        "CVE": [
            "CVE-2023-6702"
        ],
        "CWE": [
            "CWE-843"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-17 14:42:44",
    "remediation": "Upgrade chromium to version 120.0.6099.109 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Type Confusion",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Type Confusion due to improper handling of objects in memory within the V8 engine. An attacker can potentially exploit heap corruption by crafting a malicious HTML page. "
    },
    "source_code": [
        {
            "filename": "patches/chromium/.patches",
            "diff": "@@ -148,3 +148,7 @@ cherry-pick-3f45b1af5e41.patch\n cherry-pick-e13061c50998.patch\n cherry-pick-5fde415e06f9.patch\n cherry-pick-8d607d3921b8.patch\n+cherry-pick-021598ea43c1.patch\n+cherry-pick-76340163a820.patch\n+cherry-pick-f15cfb9371c4.patch\n+cherry-pick-4ca62c7a8b88.patch"
        },
        {
            "filename": "patches/chromium/cherry-pick-021598ea43c1.patch",
            "diff": "@@ -0,0 +1,69 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Guido Urdaneta <guidou@chromium.org>\n+Date: Mon, 4 Dec 2023 23:00:41 +0000\n+Subject: Drop frames received on the wrong task runner\n+\n+It can happen during transfer that a frame is posted from the\n+background media thread to the task runner of the old execution\n+context, which can lead to races and UAF.\n+\n+This CL makes underlying sources drop frames received on the\n+wrong task runner to avoid the problem.\n+\n+(cherry picked from commit 9d042e0d498356185fe9eb33c53b69fab33d06bf)\n+\n+Bug: 1505708\n+Change-Id: I686228d88cb1c48bdf8c0b6bf85edd280a54300a\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5077845\n+Commit-Queue: Guido Urdaneta <guidou@chromium.org>\n+Reviewed-by: Tony Herre <toprice@chromium.org>\n+Cr-Original-Commit-Position: refs/heads/main@{#1231802}\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5082444\n+Commit-Queue: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>\n+Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>\n+Auto-Submit: Guido Urdaneta <guidou@chromium.org>\n+Cr-Commit-Position: refs/branch-heads/6099@{#1370}\n+Cr-Branched-From: e6ee4500f7d6549a9ac1354f8d056da49ef406be-refs/heads/main@{#1217362}\n+\n+diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_underlying_source.cc b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_underlying_source.cc\n+index b5a2f71bae81bba6e61d8f303d24a9df874ae885..4c7b0b982e3d314749e39178eb0fca706d11bd85 100644\n+--- a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_underlying_source.cc\n++++ b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_audio_underlying_source.cc\n+@@ -58,7 +58,15 @@ void RTCEncodedAudioUnderlyingSource::Trace(Visitor* visitor) const {\n+ \n+ void RTCEncodedAudioUnderlyingSource::OnFrameFromSource(\n+     std::unique_ptr<webrtc::TransformableAudioFrameInterface> webrtc_frame) {\n+-  DCHECK(task_runner_->BelongsToCurrentThread());\n++  // It can happen that a frame is posted to the task runner of the old\n++  // execution context during a stream transfer to a new context.\n++  // TODO(https://crbug.com/1506631): Make the state updates related to the\n++  // transfer atomic and turn this into a DCHECK.\n++  if (!task_runner_->BelongsToCurrentThread()) {\n++    DVLOG(1) << \"Dropped frame posted to incorrect task runner. This can \"\n++                \"happen during transfer.\";\n++    return;\n++  }\n+   // If the source is canceled or there are too many queued frames,\n+   // drop the new frame.\n+   if (!disconnect_callback_ || !GetExecutionContext()) {\n+diff --git a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_underlying_source.cc b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_underlying_source.cc\n+index 54ca7d1529b1772200c3691b56e847acc42d086d..8fb1d8460e289cd5e6764271f79dada7f121cb1b 100644\n+--- a/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_underlying_source.cc\n++++ b/third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_underlying_source.cc\n+@@ -58,7 +58,15 @@ void RTCEncodedVideoUnderlyingSource::Trace(Visitor* visitor) const {\n+ \n+ void RTCEncodedVideoUnderlyingSource::OnFrameFromSource(\n+     std::unique_ptr<webrtc::TransformableVideoFrameInterface> webrtc_frame) {\n+-  DCHECK(task_runner_->BelongsToCurrentThread());\n++  // It can happen that a frame is posted to the task runner of the old\n++  // execution context during a stream transfer to a new context.\n++  // TODO(https://crbug.com/1506631): Make the state updates related to the\n++  // transfer atomic and turn this into a DCHECK.\n++  if (!task_runner_->BelongsToCurrentThread()) {\n++    DVLOG(1) << \"Dropped frame posted to incorrect task runner. This can \"\n++                \"happen during transfer.\";\n++    return;\n++  }\n+   // If the source is canceled or there are too many queued frames,\n+   // drop the new frame.\n+   if (!disconnect_callback_ || !GetExecutionContext()) {"
        },
        {
            "filename": "patches/chromium/cherry-pick-4ca62c7a8b88.patch",
            "diff": "@@ -0,0 +1,43 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Vasiliy Telezhnikov <vasilyt@chromium.org>\n+Date: Thu, 7 Dec 2023 16:56:57 +0000\n+Subject: Check for slugs count before deserializing Slugs in DrawSlugOp\n+\n+Count is part of serialized data and while we never serialize values\n+less then 1, it can be any value when coming over IPC, we should check\n+that it's positive before substacting one.\n+\n+(cherry picked from commit 0527e0d5b08a13d63f4f1eeefa1b86ecfd0cb63b)\n+\n+Bug: 1506726\n+Change-Id: I244f50a682f2e852b22ba88f1e9cddddb0fdfcb9\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5078779\n+Reviewed-by: Peng Huang <penghuang@chromium.org>\n+Commit-Queue: Vasiliy Telezhnikov <vasilyt@chromium.org>\n+Cr-Original-Commit-Position: refs/heads/main@{#1232013}\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5096809\n+Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>\n+Cr-Commit-Position: refs/branch-heads/6099@{#1428}\n+Cr-Branched-From: e6ee4500f7d6549a9ac1354f8d056da49ef406be-refs/heads/main@{#1217362}\n+\n+diff --git a/cc/paint/paint_op.cc b/cc/paint/paint_op.cc\n+index ea103192096b1316f2a9a31cf3478e6dafe66788..5ff86b59f7b7b27e21bfdb95da637fed9cee0420 100644\n+--- a/cc/paint/paint_op.cc\n++++ b/cc/paint/paint_op.cc\n+@@ -974,10 +974,12 @@ PaintOp* DrawSlugOp::Deserialize(PaintOpReader& reader, void* output) {\n+   reader.Read(&op->flags);\n+   unsigned int count = 0;\n+   reader.Read(&count);\n+-  reader.Read(&op->slug);\n+-  op->extra_slugs.resize(count - 1);\n+-  for (auto& extra_slug : op->extra_slugs) {\n+-    reader.Read(&extra_slug);\n++  if (count > 0) {\n++    reader.Read(&op->slug);\n++    op->extra_slugs.resize(count - 1);\n++    for (auto& extra_slug : op->extra_slugs) {\n++      reader.Read(&extra_slug);\n++    }\n+   }\n+   return op;\n+ }"
        },
        {
            "filename": "patches/chromium/cherry-pick-76340163a820.patch",
            "diff": "@@ -0,0 +1,37 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Paul Semel <paulsemel@chromium.org>\n+Date: Wed, 6 Dec 2023 15:52:56 +0000\n+Subject: ImageBitmapFactory: fix empty context dcheck\n+\n+Approved by:\n+https://bugs.chromium.org/p/chromium/issues/detail?id=1502102#c34\n+\n+(cherry picked from commit c4d2f15b8f97076c8fd0f9aa5814b94db698b75c)\n+\n+Fixed: 1502102\n+Change-Id: Ib42d2897d62136ae835561bcf56884b5624060a5\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5071252\n+Commit-Queue: Paul Semel <paulsemel@chromium.org>\n+Reviewed-by: Jean-Philippe Gravel <jpgravel@chromium.org>\n+Cr-Original-Commit-Position: refs/heads/main@{#1230617}\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5088373\n+Auto-Submit: Arthur Sonzogni <arthursonzogni@google.com>\n+Reviewed-by: Paul Semel <paulsemel@chromium.org>\n+Cr-Commit-Position: refs/branch-heads/6099@{#1416}\n+Cr-Branched-From: e6ee4500f7d6549a9ac1354f8d056da49ef406be-refs/heads/main@{#1217362}\n+\n+diff --git a/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc b/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc\n+index 20d95536a945c67b9aba082c0ad1ff4aa46c240d..5028d3744619a14e23bba4006bf958478b5b53f8 100644\n+--- a/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc\n++++ b/third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.cc\n+@@ -155,7 +155,9 @@ ScriptPromise ImageBitmapFactories::CreateImageBitmapFromBlob(\n+     ImageBitmapSource* bitmap_source,\n+     absl::optional<gfx::Rect> crop_rect,\n+     const ImageBitmapOptions* options) {\n+-  DCHECK(script_state->ContextIsValid());\n++  if (!script_state->ContextIsValid()) {\n++    return ScriptPromise();\n++  }\n+ \n+   // imageOrientation: 'from-image' will be used to replace imageOrientation:\n+   // 'none'. Adding a deprecation warning when 'none' is called in"
        },
        {
            "filename": "patches/chromium/cherry-pick-f15cfb9371c4.patch",
            "diff": "@@ -0,0 +1,181 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Kai Ninomiya <kainino@chromium.org>\n+Date: Thu, 7 Dec 2023 14:31:32 +0000\n+Subject: Fix reinit order in\n+ ContextProviderCommandBuffer::BindToCurrentSequence\n+\n+See comments for explanation.\n+\n+(cherry picked from commit 7d8400ceb56db5fd97249f787251fe8b3928e6fd)\n+\n+Bug: 1505632\n+Change-Id: I0f43821a9708af91303048332e9fae5e100deee5\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5069480\n+Reviewed-by: Saifuddin Hitawala <hitawala@chromium.org>\n+Commit-Queue: Kai Ninomiya <kainino@chromium.org>\n+Reviewed-by: Brendon Tiszka <tiszka@chromium.org>\n+Cr-Original-Commit-Position: refs/heads/main@{#1230735}\n+Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/5095795\n+Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>\n+Commit-Queue: Saifuddin Hitawala <hitawala@chromium.org>\n+Auto-Submit: Kai Ninomiya <kainino@chromium.org>\n+Cr-Commit-Position: refs/branch-heads/6099@{#1424}\n+Cr-Branched-From: e6ee4500f7d6549a9ac1354f8d056da49ef406be-refs/heads/main@{#1217362}\n+\n+diff --git a/services/viz/public/cpp/gpu/context_provider_command_buffer.cc b/services/viz/public/cpp/gpu/context_provider_command_buffer.cc\n+index 5f0966ef839fae01ddadff64b9bde819dbfc7141..2bd94a0c94cd1aafe6ad21a8a7f2cb1f3afd8110 100644\n+--- a/services/viz/public/cpp/gpu/context_provider_command_buffer.cc\n++++ b/services/viz/public/cpp/gpu/context_provider_command_buffer.cc\n+@@ -172,13 +172,13 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+     }\n+ \n+     // The transfer buffer is used to serialize Dawn commands\n+-    transfer_buffer_ =\n++    auto transfer_buffer =\n+         std::make_unique<gpu::TransferBuffer>(webgpu_helper.get());\n+ \n+     // The WebGPUImplementation exposes the WebGPUInterface, as well as the\n+     // gpu::ContextSupport interface.\n+     auto webgpu_impl = std::make_unique<gpu::webgpu::WebGPUImplementation>(\n+-        webgpu_helper.get(), transfer_buffer_.get(), command_buffer_.get());\n++        webgpu_helper.get(), transfer_buffer.get(), command_buffer_.get());\n+     bind_result_ = webgpu_impl->Initialize(memory_limits_);\n+     if (bind_result_ != gpu::ContextResult::kSuccess) {\n+       DLOG(ERROR) << \"Failed to initialize WebGPUImplementation.\";\n+@@ -190,8 +190,11 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+     std::string unique_context_name =\n+         base::StringPrintf(\"%s-%p\", type_name.c_str(), webgpu_impl.get());\n+ \n++    // IMPORTANT: These hold raw_ptrs to each other, so must be set together.\n++    // See note in the header (and keep it up to date if things change).\n+     impl_ = webgpu_impl.get();\n+     webgpu_interface_ = std::move(webgpu_impl);\n++    transfer_buffer_ = std::move(transfer_buffer);\n+     helper_ = std::move(webgpu_helper);\n+   } else if (attributes_.enable_raster_interface &&\n+              !attributes_.enable_gles2_interface &&\n+@@ -209,14 +212,14 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+     }\n+     // The transfer buffer is used to copy resources between the client\n+     // process and the GPU process.\n+-    transfer_buffer_ =\n++    auto transfer_buffer =\n+         std::make_unique<gpu::TransferBuffer>(raster_helper.get());\n+ \n+     // The RasterImplementation exposes the RasterInterface, as well as the\n+     // gpu::ContextSupport interface.\n+     DCHECK(channel_);\n+     auto raster_impl = std::make_unique<gpu::raster::RasterImplementation>(\n+-        raster_helper.get(), transfer_buffer_.get(),\n++        raster_helper.get(), transfer_buffer.get(),\n+         attributes_.bind_generates_resource,\n+         attributes_.lose_context_when_out_of_memory, command_buffer_.get(),\n+         channel_->image_decode_accelerator_proxy());\n+@@ -233,8 +236,11 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+     raster_impl->TraceBeginCHROMIUM(\"gpu_toplevel\",\n+                                     unique_context_name.c_str());\n+ \n++    // IMPORTANT: These hold raw_ptrs to each other, so must be set together.\n++    // See note in the header (and keep it up to date if things change).\n+     impl_ = raster_impl.get();\n+     raster_interface_ = std::move(raster_impl);\n++    transfer_buffer_ = std::move(transfer_buffer);\n+     helper_ = std::move(raster_helper);\n+   } else {\n+     // The GLES2 helper writes the command buffer protocol.\n+@@ -249,7 +255,7 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+ \n+     // The transfer buffer is used to copy resources between the client\n+     // process and the GPU process.\n+-    transfer_buffer_ =\n++    auto transfer_buffer =\n+         std::make_unique<gpu::TransferBuffer>(gles2_helper.get());\n+ \n+     // The GLES2Implementation exposes the OpenGLES2 API, as well as the\n+@@ -262,13 +268,13 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+       // we only use it if grcontext_support was requested.\n+       gles2_impl = std::make_unique<\n+           skia_bindings::GLES2ImplementationWithGrContextSupport>(\n+-          gles2_helper.get(), /*share_group=*/nullptr, transfer_buffer_.get(),\n++          gles2_helper.get(), /*share_group=*/nullptr, transfer_buffer.get(),\n+           attributes_.bind_generates_resource,\n+           attributes_.lose_context_when_out_of_memory,\n+           support_client_side_arrays, command_buffer_.get());\n+     } else {\n+       gles2_impl = std::make_unique<gpu::gles2::GLES2Implementation>(\n+-          gles2_helper.get(), /*share_group=*/nullptr, transfer_buffer_.get(),\n++          gles2_helper.get(), /*share_group=*/nullptr, transfer_buffer.get(),\n+           attributes_.bind_generates_resource,\n+           attributes_.lose_context_when_out_of_memory,\n+           support_client_side_arrays, command_buffer_.get());\n+@@ -279,8 +285,11 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+       return bind_result_;\n+     }\n+ \n++    // IMPORTANT: These hold raw_ptrs to each other, so must be set together.\n++    // See note in the header (and keep it up to date if things change).\n+     impl_ = gles2_impl.get();\n+     gles2_impl_ = std::move(gles2_impl);\n++    transfer_buffer_ = std::move(transfer_buffer);\n+     helper_ = std::move(gles2_helper);\n+   }\n+ \n+@@ -314,6 +323,7 @@ gpu::ContextResult ContextProviderCommandBuffer::BindToCurrentSequence() {\n+             switches::kEnableGpuClientTracing)) {\n+       // This wraps the real GLES2Implementation and we should always use this\n+       // instead when it's present.\n++      // IMPORTANT: This holds a raw_ptr to gles2_impl_.\n+       trace_impl_ = std::make_unique<gpu::gles2::GLES2TraceImplementation>(\n+           gles2_impl_.get());\n+       gl = trace_impl_.get();\n+diff --git a/services/viz/public/cpp/gpu/context_provider_command_buffer.h b/services/viz/public/cpp/gpu/context_provider_command_buffer.h\n+index 93fd2dbd47fc8aca19ac8baffe62911cdc9efb6c..78aaa2b759e350a7a8ed58273cf910ab91c235ea 100644\n+--- a/services/viz/public/cpp/gpu/context_provider_command_buffer.h\n++++ b/services/viz/public/cpp/gpu/context_provider_command_buffer.h\n+@@ -159,19 +159,42 @@ class ContextProviderCommandBuffer\n+   // associated shared images are destroyed.\n+   std::unique_ptr<gpu::ClientSharedImageInterface> shared_image_interface_;\n+ \n+-  base::Lock context_lock_;  // Referenced by command_buffer_.\n++  //////////////////////////////////////////////////////////////////////////////\n++  // IMPORTANT NOTE: All of the objects in this block are part of a complex   //\n++  // graph of raw pointers (holder or pointee of various raw_ptrs). They are  //\n++  // defined in topological order: only later items point to earlier items.   //\n++  // - When writing any member, always ensure its pointers to earlier members\n++  //   are guaranteed to stay alive.\n++  // - When clearing OR overwriting any member, always ensure objects that\n++  //   point to it have already been cleared.\n++  //     - The topological order of definitions guarantees that the\n++  //       destructors will be called in the correct order (bottom to top).\n++  //     - When overwriting multiple members, similarly do so in reverse order.\n++  //\n++  // Please note these comments are likely not to stay perfectly up-to-date.\n++\n++  base::Lock context_lock_;\n++  // Points to the context_lock_ field of `this`.\n+   std::unique_ptr<gpu::CommandBufferProxyImpl> command_buffer_;\n++\n++  // Points to command_buffer_.\n+   std::unique_ptr<gpu::CommandBufferHelper> helper_;\n++  // Points to helper_.\n+   std::unique_ptr<gpu::TransferBuffer> transfer_buffer_;\n+ \n++  // Points to transfer_buffer_, helper_, and command_buffer_.\n+   std::unique_ptr<gpu::gles2::GLES2Implementation> gles2_impl_;\n++  // Points to gles2_impl_.\n+   std::unique_ptr<gpu::gles2::GLES2TraceImplementation> trace_impl_;\n++  // Points to transfer_buffer_, helper_, and command_buffer_.\n+   std::unique_ptr<gpu::raster::RasterInterface> raster_interface_;\n++  // Points to transfer_buffer_, helper_, and command_buffer_.\n+   std::unique_ptr<gpu::webgpu::WebGPUInterface> webgpu_interface_;\n++  // This is an alias for gles2_impl_, raster_interface_, or webgpu_interface_.\n++  raw_ptr<gpu::ImplementationBase> impl_ = nullptr;\n+ \n+-  // Owned by one of gles2_impl_, raster_interface_, or webgpu_interface_. It\n+-  // must be declared last and cleared first.\n+-  raw_ptr<gpu::ImplementationBase> impl_;\n++  // END IMPORTANT NOTE                                                       //\n++  //////////////////////////////////////////////////////////////////////////////\n+ \n+   std::unique_ptr<skia_bindings::GrContextForGLES2Interface> gr_context_;\n+ "
        },
        {
            "filename": "patches/libavif/.patches",
            "diff": "@@ -1,2 +1,3 @@\n remove_potential_out_of_bound_access_to_alphaitemindices.patch\n do_not_store_potentially_invalid_pointers.patch\n+do_not_store_colorproperties_until_alpha_item_is_found.patch"
        },
        {
            "filename": "patches/libavif/do_not_store_colorproperties_until_alpha_item_is_found.patch",
            "diff": "@@ -0,0 +1,31 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: Vignesh Venkatasubramanian <vigneshv@google.com>\n+Date: Tue, 28 Nov 2023 08:44:22 -0800\n+Subject: Do not store colorproperties until alpha item is found\n+\n+colorProperties could be pointing to a dangling pointer if\n+findAlphaItem() resizes the meta.items array.\n+\n+Manual cherry-pick of PR #1808 into the chromium-m118 branch.\n+\n+diff --git a/src/read.c b/src/read.c\n+index 73aa68eb0ad377e95038280fea1523dd909b6e87..ab490f6ddbd983321af8fae94cdf34dd32058160 100644\n+--- a/src/read.c\n++++ b/src/read.c\n+@@ -3918,7 +3918,6 @@ avifResult avifDecoderReset(avifDecoder * decoder)\n+             avifDiagnosticsPrintf(&decoder->diag, \"Primary item not found\");\n+             return AVIF_RESULT_MISSING_IMAGE_ITEM;\n+         }\n+-        colorProperties = &colorItem->properties;\n+         if (!memcmp(colorItem->type, \"grid\", 4)) {\n+             avifROData readData;\n+             AVIF_CHECKRES(avifDecoderItemRead(colorItem, decoder->io, &readData, 0, 0, data->diag));\n+@@ -3965,6 +3964,8 @@ avifResult avifDecoderReset(avifDecoder * decoder)\n+             }\n+         }\n+ \n++        colorProperties = &colorItem->properties;\n++\n+         // Find Exif and/or XMP metadata, if any\n+         AVIF_CHECKRES(avifDecoderFindMetadata(decoder, data->meta, decoder->image, colorItem->id));\n+ "
        },
        {
            "filename": "patches/v8/.patches",
            "diff": "@@ -4,3 +4,4 @@ fix_build_deprecated_attribute_for_older_msvc_versions.patch\n fix_disable_implies_dcheck_for_node_stream_array_buffers.patch\n chore_allow_customizing_microtask_policy_per_context.patch\n cherry-pick-57d372c3e399.patch\n+merged_promises_async_stack_traces_fix_the_case_when_the_closure.patch"
        },
        {
            "filename": "patches/v8/merged_promises_async_stack_traces_fix_the_case_when_the_closure.patch",
            "diff": "@@ -0,0 +1,75 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: =?UTF-8?q?Marja=20H=C3=B6ltt=C3=A4?= <marja@chromium.org>\n+Date: Tue, 14 Nov 2023 14:45:27 +0100\n+Subject: Merged: [promises, async stack traces] Fix the case when the closure\n+ has run\n+MIME-Version: 1.0\n+Content-Type: text/plain; charset=UTF-8\n+Content-Transfer-Encoding: 8bit\n+\n+We were using the closure pointing to NativeContext as a marker that the\n+closure has run, but async stack trace code was confused about it.\n+\n+(cherry picked from commit bde3d360097607f36cd1d17cbe8412b84eae0a7f)\n+\n+Bug: chromium:1501326\n+Change-Id: I30d438f3b2e3fdd7562ea9a79dde4561ce9b0083\n+Cr-Original-Commit-Position: refs/heads/main@{#90949}\n+Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/5110982\n+Commit-Queue: Marja H\u00f6ltt\u00e4 <marja@chromium.org>\n+Reviewed-by: Shu-yu Guo <syg@chromium.org>\n+Reviewed-by: Igor Sheludko <ishell@chromium.org>\n+Auto-Submit: Marja H\u00f6ltt\u00e4 <marja@chromium.org>\n+Cr-Commit-Position: refs/branch-heads/12.0@{#18}\n+Cr-Branched-From: ed7b4caf1fb8184ad9e24346c84424055d4d430a-refs/heads/12.0.267@{#1}\n+Cr-Branched-From: 210e75b19db4352c9b78dce0bae11c2dc3077df4-refs/heads/main@{#90651}\n+\n+diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc\n+index 3db3d7ed372b722de1b24a39093ddefc45d6963c..5942abb480b69935d14d1c6ef06d1f4e954275a2 100644\n+--- a/src/execution/isolate.cc\n++++ b/src/execution/isolate.cc\n+@@ -1013,7 +1013,13 @@ void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,\n+                                     isolate);\n+       builder->AppendPromiseCombinatorFrame(function, combinator);\n+ \n+-      // Now peak into the Promise.all() resolve element context to\n++      if (context->IsNativeContext()) {\n++        // NativeContext is used as a marker that the closure was already\n++        // called. We can't access the reject element context any more.\n++        return;\n++      }\n++\n++      // Now peek into the Promise.all() resolve element context to\n+       // find the promise capability that's being resolved when all\n+       // the concurrent promises resolve.\n+       int const index =\n+@@ -1032,7 +1038,13 @@ void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,\n+           context->native_context().promise_all_settled(), isolate);\n+       builder->AppendPromiseCombinatorFrame(function, combinator);\n+ \n+-      // Now peak into the Promise.allSettled() resolve element context to\n++      if (context->IsNativeContext()) {\n++        // NativeContext is used as a marker that the closure was already\n++        // called. We can't access the reject element context any more.\n++        return;\n++      }\n++\n++      // Now peek into the Promise.allSettled() resolve element context to\n+       // find the promise capability that's being resolved when all\n+       // the concurrent promises resolve.\n+       int const index =\n+@@ -1050,7 +1062,13 @@ void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,\n+                                     isolate);\n+       builder->AppendPromiseCombinatorFrame(function, combinator);\n+ \n+-      // Now peak into the Promise.any() reject element context to\n++      if (context->IsNativeContext()) {\n++        // NativeContext is used as a marker that the closure was already\n++        // called. We can't access the reject element context any more.\n++        return;\n++      }\n++\n++      // Now peek into the Promise.any() reject element context to\n+       // find the promise capability that's being resolved when any of\n+       // the concurrent promises resolve.\n+       int const index = PromiseBuiltins::kPromiseAnyRejectElementCapabilitySlot;"
        }
    ],
    "commitTime": "2023-12-21 23:55:01"
}