{
    "CVSSv3": {
        "CVSS": "3.1",
        "E": "P",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "Sandro Gauci",
        "Alfred Farrugia"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 5.9,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "HIGH",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "NONE",
                "availability": "HIGH"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 7.5,
    "disclosureTime": "2023-12-14 20:47:15",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.08209",
        "probability": "0.00044"
    },
    "exploitMaturity": "Proof of Concept",
    "id": "SNYK-UNMANAGED-ASTERISK-6129125",
    "identifiers": {
        "CVE": [
            "CVE-2023-49786"
        ],
        "CWE": [
            "CWE-362"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-15 15:22:59",
    "remediation": "Upgrade asterisk to version certified-18.9-cert6, 18.20.1, 20.5.1, 21.0.1 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Race Condition",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Race Condition via the hello handshake phase of the DTLS protocol, when handling DTLS-SRTP for media setup. This attack can be done continuously, thus denying new DTLS-SRTP encrypted calls during the attack. "
    },
    "source_code": [
        {
            "filename": "res/res_rtp_asterisk.c",
            "diff": "@@ -3207,6 +3207,61 @@ static int __rtp_recvfrom(struct ast_rtp_instance *instance, void *buf, size_t s\n \n \t\tast_debug_dtls(3, \"(%p) DTLS - __rtp_recvfrom rtp=%p - Got SSL packet '%d'\\n\", instance, rtp, *in);\n \n+\t\t/*\n+\t\t * If ICE is in use, we can prevent a possible DOS attack\n+\t\t * by allowing DTLS protocol messages (client hello, etc)\n+\t\t * only from sources that are in the active remote\n+\t\t * candidates list.\n+\t\t */\n+\n+\t\tif (rtp->ice) {\n+\t\t\tint pass_src_check = 0;\n+\t\t\tstruct ao2_iterator i;\n+\t\t\tstruct ast_rtp_engine_ice_candidate *candidate;\n+\t\t\tint cand_cnt = 0;\n+\n+\t\t\t/*\n+\t\t\t * You'd think that this check would cause a \"deadlock\"\n+\t\t\t * because ast_rtp_ice_start_media calls dtls_perform_handshake\n+\t\t\t * before it sets ice_media_started = 1 so how can we do a\n+\t\t\t * handshake if we're dropping packets before we send them\n+\t\t\t * to openssl.  Fortunately, dtls_perform_handshake just sets\n+\t\t\t * up openssl to do the handshake and doesn't actually perform it\n+\t\t\t * itself and the locking prevents __rtp_recvfrom from\n+\t\t\t * running before the ice_media_started flag is set.  So only\n+\t\t\t * unexpected DTLS packets can get dropped here.\n+\t\t\t */\n+\t\t\tif (!rtp->ice_media_started) {\n+\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. ICE not completed yet.\\n\",\n+\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n+\t\t\t\t\tast_sockaddr_stringify(sa));\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\n+\t\t\t/*\n+\t\t\t * If we got this far, then ice_active_remote_candidates\n+\t\t\t * can't be NULL.\n+\t\t\t */\n+\t\t\ti = ao2_iterator_init(rtp->ice_active_remote_candidates, 0);\n+\t\t\twhile ((candidate = ao2_iterator_next(&i)) && (cand_cnt < PJ_ICE_MAX_CAND)) {\n+\t\t\t\tres = ast_sockaddr_cmp_addr(&candidate->address, sa);\n+\t\t\t\tao2_ref(candidate, -1);\n+\t\t\t\tif (res == 0) {\n+\t\t\t\t\tpass_src_check = 1;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\tcand_cnt++;\n+\t\t\t}\n+\t\t\tao2_iterator_destroy(&i);\n+\n+\t\t\tif (!pass_src_check) {\n+\t\t\t\tast_log(LOG_WARNING, \"%s: DTLS packet from %s dropped. Source not in ICE active candidate list.\\n\",\n+\t\t\t\t\tast_rtp_instance_get_channel_id(instance),\n+\t\t\t\t\tast_sockaddr_stringify(sa));\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\n \t\t/*\n \t\t * A race condition is prevented between dtls_perform_handshake()\n \t\t * and this function because both functions have to get the"
        }
    ],
    "commitTime": "2023-12-14 18:48:17"
}