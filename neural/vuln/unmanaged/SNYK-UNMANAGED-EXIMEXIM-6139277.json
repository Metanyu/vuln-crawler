{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "SEC Consult"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 4.3,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "REQUIRED",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "LOW",
                "availability": "NONE"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 5.9,
    "disclosureTime": "2023-12-24 06:47:56",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.64211",
        "probability": "0.00267"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-UNMANAGED-EXIMEXIM-6139277",
    "identifiers": {
        "CVE": [
            "CVE-2023-51766"
        ],
        "CWE": [
            "CWE-924"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-25 13:46:53",
    "remediation": "A fix was pushed into the master branch but not yet published. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Improper Enforcement of Message Integrity During Transmission in a Communication Channel",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Improper Enforcement of Message Integrity During Transmission in a Communication Channel due to improper handling of SMTP protocol sequences, which allows header smuggling. An attacker can inject e-mail messages that appear to originate from the server, thus bypassing SPF protection mechanisms by exploiting the support for <LF>.<CR><LF> sequences, which are not universally handled by other e-mail servers. "
    },
    "source_code": [
        {
            "filename": "doc/doc-docbook/spec.xfpt",
            "diff": "@@ -36461,8 +36461,6 @@ other MTAs, the way Exim handles line endings for all messages is now as\n follows:\n \n .ilist\n-LF not preceded by CR is treated as a line ending.\n-.next\n CR is treated as a line ending; if it is immediately followed by LF, the LF\n is ignored.\n .next\n@@ -36477,7 +36475,10 @@ people trying to play silly games.\n .next\n If the first header line received in a message ends with CRLF, a subsequent\n bare LF in a header line is treated in the same way as a bare CR in a header\n-line.\n+line and a bare LF in a body line is replaced with a space.\n+.next\n+If the first header line received in a message does not end with CRLF, a subsequent\n+LF not preceded by CR is treated as a line ending.\n .endlist\n \n "
        },
        {
            "filename": "src/src/receive.c",
            "diff": "@@ -829,14 +829,20 @@ July 2003: Bare CRs cause trouble. We now treat them as line terminators as\n well, so that there are no CRs in spooled messages. However, the message\n terminating dot is not recognized between two bare CRs.\n \n+Dec 2023: getting a site to send a body including an \"LF . LF\" sequence\n+followed by SMTP commands is a possible \"smtp smuggling\" attack.  If\n+the first (header) line for the message has a proper CRLF then enforce\n+that for the body: convert bare LF to a space.\n+\n Arguments:\n-  fout      a FILE to which to write the message; NULL if skipping\n+  fout\t\ta FILE to which to write the message; NULL if skipping\n+  strict_crlf\trequire full CRLF sequence as a line ending\n \n Returns:    One of the END_xxx values indicating why it stopped reading\n */\n \n static int\n-read_message_data_smtp(FILE * fout)\n+read_message_data_smtp(FILE * fout, BOOL strict_crlf)\n {\n enum { s_linestart, s_normal, s_had_cr, s_had_nl_dot, s_had_dot_cr } ch_state =\n \t      s_linestart;\n@@ -863,14 +869,17 @@ while ((ch = (receive_getc)(GETC_BUFFER_UNLIMITED)) != EOF)\n \tch_state = s_had_cr;\n \tcontinue;\t\t\t/* Don't write the CR */\n \t}\n-      if (ch == '\\n')\t\t\t/* Bare NL ends line */\n-\t{\n-\tch_state = s_linestart;\n-\tbody_linecount++;\n-\tif (linelength > max_received_linelength)\n-\t  max_received_linelength = linelength;\n-\tlinelength = -1;\n-\t}\n+      if (ch == '\\n')\t\t\t/* Bare LF at end of line */\n+\tif (strict_crlf)\n+\t  ch = ' ';\t\t\t/* replace LF with space */\n+\telse\n+\t  {\t\t\t\t/* treat as line ending */\n+\t  ch_state = s_linestart;\n+\t  body_linecount++;\n+\t  if (linelength > max_received_linelength)\n+\t    max_received_linelength = linelength;\n+\t  linelength = -1;\n+\t  }\n       break;\n \n     case s_had_cr:\t\t\t/* After (unwritten) CR */\n@@ -893,16 +902,19 @@ while ((ch = (receive_getc)(GETC_BUFFER_UNLIMITED)) != EOF)\n \n     case s_had_nl_dot:\t\t\t/* After [CR] LF . */\n       if (ch == '\\n')\t\t\t/* [CR] LF . LF */\n-\treturn END_DOT;\n-      if (ch == '\\r')\t\t\t/* [CR] LF . CR */\n+\tif (strict_crlf)\n+\t  ch = ' ';\t\t\t/* replace LF with space */\n+\telse\n+\t  return END_DOT;\n+      else if (ch == '\\r')\t\t/* [CR] LF . CR */\n \t{\n \tch_state = s_had_dot_cr;\n \tcontinue;\t\t\t/* Don't write the CR */\n \t}\n       /* The dot was removed on reaching s_had_nl_dot. For a doubled dot, here,\n       reinstate it to cutthrough. The current ch, dot or not, is passed both to\n       cutthrough and to file below. */\n-      if (ch == '.')\n+      else if (ch == '.')\n \t{\n \tuschar c = ch;\n \tcutthrough_data_puts(&c, 1);\n@@ -1140,7 +1152,7 @@ receive_swallow_smtp(void)\n {\n if (message_ended >= END_NOTENDED)\n   message_ended = chunking_state <= CHUNKING_OFFERED\n-     ? read_message_data_smtp(NULL)\n+     ? read_message_data_smtp(NULL, FALSE)\n      : read_message_bdat_smtp_wire(NULL);\n }\n \n@@ -3241,7 +3253,7 @@ if (!ferror(spool_data_file) && !(receive_feof)() && message_ended != END_DOT)\n   if (smtp_input)\n     {\n     message_ended = chunking_state <= CHUNKING_OFFERED\n-      ? read_message_data_smtp(spool_data_file)\n+      ? read_message_data_smtp(spool_data_file, first_line_ended_crlf)\n       : spool_wireformat\n       ? read_message_bdat_smtp_wire(spool_data_file)\n       : read_message_bdat_smtp(spool_data_file);"
        }
    ],
    "commitTime": "2023-12-23 17:42:57"
}