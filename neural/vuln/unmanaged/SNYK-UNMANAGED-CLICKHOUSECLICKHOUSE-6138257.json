{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "malacupa"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 7.5,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "NONE",
                "availability": "HIGH"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 5.9,
    "disclosureTime": "2023-12-22 00:55:55",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.24987",
        "probability": "0.00062"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-UNMANAGED-CLICKHOUSECLICKHOUSE-6138257",
    "identifiers": {
        "CVE": [
            "CVE-2023-48298"
        ],
        "CWE": [
            "CWE-191"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-22 13:03:49",
    "remediation": "Upgrade clickhouse/clickhouse to version 23.3.17.13, 23.8.7.24, 23.9.5.29, 23.10.4.25, 23.11.1.2711 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Integer Underflow",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Integer Underflow in the CompressionCodecFPC.cpp file. An attacker can trigger and exploit this vulnerability resulting in crash due to stack buffer overflow in decompression of FPC codec. "
    },
    "source_code": [
        {
            "filename": "src/Compression/CompressionCodecFPC.cpp",
            "diff": "@@ -153,23 +153,23 @@ void registerCodecFPC(CompressionCodecFactory & factory)\n namespace\n {\n \n-template <std::unsigned_integral TUint>\n-requires (sizeof(TUint) >= 4)\n+template <std::unsigned_integral TUInt>\n+requires (sizeof(TUInt) >= 4)\n class DfcmPredictor\n {\n public:\n-    explicit DfcmPredictor(std::size_t table_size)\n+    explicit DfcmPredictor(size_t table_size)\n         : table(table_size, 0), prev_value{0}, hash{0}\n     {\n     }\n \n     [[nodiscard]]\n-    TUint predict() const noexcept\n+    TUInt predict() const noexcept\n     {\n         return table[hash] + prev_value;\n     }\n \n-    void add(TUint value) noexcept\n+    void add(TUInt value) noexcept\n     {\n         table[hash] = value - prev_value;\n         recalculateHash();\n@@ -180,38 +180,38 @@ class DfcmPredictor\n     void recalculateHash() noexcept\n     {\n         auto value = table[hash];\n-        if constexpr (sizeof(TUint) >= 8)\n+        if constexpr (sizeof(TUInt) >= 8)\n         {\n-            hash = ((hash << 2) ^ static_cast<std::size_t>(value >> 40)) & (table.size() - 1);\n+            hash = ((hash << 2) ^ static_cast<size_t>(value >> 40)) & (table.size() - 1);\n         }\n         else\n         {\n-            hash = ((hash << 4) ^ static_cast<std::size_t>(value >> 23)) & (table.size() - 1);\n+            hash = ((hash << 4) ^ static_cast<size_t>(value >> 23)) & (table.size() - 1);\n         }\n     }\n \n-    std::vector<TUint> table;\n-    TUint prev_value;\n-    std::size_t hash;\n+    std::vector<TUInt> table;\n+    TUInt prev_value;\n+    size_t hash;\n };\n \n-template <std::unsigned_integral TUint>\n-requires (sizeof(TUint) >= 4)\n+template <std::unsigned_integral TUInt>\n+requires (sizeof(TUInt) >= 4)\n class FcmPredictor\n {\n public:\n-    explicit FcmPredictor(std::size_t table_size)\n+    explicit FcmPredictor(size_t table_size)\n         : table(table_size, 0), hash{0}\n     {\n     }\n \n     [[nodiscard]]\n-    TUint predict() const noexcept\n+    TUInt predict() const noexcept\n     {\n         return table[hash];\n     }\n \n-    void add(TUint value) noexcept\n+    void add(TUInt value) noexcept\n     {\n         table[hash] = value;\n         recalculateHash();\n@@ -221,44 +221,44 @@ class FcmPredictor\n     void recalculateHash() noexcept\n     {\n         auto value = table[hash];\n-        if constexpr (sizeof(TUint) >= 8)\n+        if constexpr (sizeof(TUInt) >= 8)\n         {\n-            hash = ((hash << 6) ^ static_cast<std::size_t>(value >> 48)) & (table.size() - 1);\n+            hash = ((hash << 6) ^ static_cast<size_t>(value >> 48)) & (table.size() - 1);\n         }\n         else\n         {\n-            hash = ((hash << 1) ^ static_cast<std::size_t>(value >> 22)) & (table.size() - 1);\n+            hash = ((hash << 1) ^ static_cast<size_t>(value >> 22)) & (table.size() - 1);\n         }\n     }\n \n-    std::vector<TUint> table;\n-    std::size_t hash;\n+    std::vector<TUInt> table;\n+    size_t hash;\n };\n \n-template <std::unsigned_integral TUint>\n+template <std::unsigned_integral TUInt>\n class FPCOperation\n {\n-    static constexpr auto VALUE_SIZE = sizeof(TUint);\n+    static constexpr size_t VALUE_SIZE = sizeof(TUInt);\n     static constexpr std::byte FCM_BIT{0};\n     static constexpr std::byte DFCM_BIT{1u << 3};\n-    static constexpr auto DFCM_BIT_1 = DFCM_BIT << 4;\n-    static constexpr auto DFCM_BIT_2 = DFCM_BIT;\n-    static constexpr unsigned MAX_ZERO_BYTE_COUNT = 0b111u;\n+    static constexpr std::byte DFCM_BIT_1 = DFCM_BIT << 4;\n+    static constexpr std::byte DFCM_BIT_2 = DFCM_BIT;\n+    static constexpr UInt32 MAX_ZERO_BYTE_COUNT = 0b111u;\n     static constexpr std::endian ENDIAN = std::endian::little;\n-    static constexpr std::size_t CHUNK_SIZE = 64;\n+    static constexpr size_t CHUNK_SIZE = 64;\n \n public:\n     FPCOperation(std::span<std::byte> destination, UInt8 compression_level)\n         : dfcm_predictor(1u << compression_level), fcm_predictor(1u << compression_level), chunk{}, result{destination}\n     {\n     }\n \n-    std::size_t encode(std::span<const std::byte> data) &&\n+    size_t encode(std::span<const std::byte> data) &&\n     {\n         auto initial_size = result.size();\n \n         std::span chunk_view(chunk);\n-        for (std::size_t i = 0; i < data.size(); i += chunk_view.size_bytes())\n+        for (size_t i = 0; i < data.size(); i += chunk_view.size_bytes())\n         {\n             auto written_values_count = importChunk(data.subspan(i), chunk_view);\n             encodeChunk(chunk_view.subspan(0, written_values_count));\n@@ -267,12 +267,12 @@ class FPCOperation\n         return initial_size - result.size();\n     }\n \n-    void decode(std::span<const std::byte> values, std::size_t decoded_size) &&\n+    void decode(std::span<const std::byte> values, size_t decoded_size) &&\n     {\n-        std::size_t read_bytes = 0;\n+        size_t read_bytes = 0;\n \n-        std::span<TUint> chunk_view(chunk);\n-        for (std::size_t i = 0; i < decoded_size; i += chunk_view.size_bytes())\n+        std::span<TUInt> chunk_view(chunk);\n+        for (size_t i = 0; i < decoded_size; i += chunk_view.size_bytes())\n         {\n             if (i + chunk_view.size_bytes() > decoded_size)\n                 chunk_view = chunk_view.first(ceilBytesToEvenValues(decoded_size - i));\n@@ -282,50 +282,50 @@ class FPCOperation\n     }\n \n private:\n-    static std::size_t ceilBytesToEvenValues(std::size_t bytes_count)\n+    static size_t ceilBytesToEvenValues(size_t bytes_count)\n     {\n-        auto values_count = (bytes_count + VALUE_SIZE - 1) / VALUE_SIZE;\n+        size_t values_count = (bytes_count + VALUE_SIZE - 1) / VALUE_SIZE;\n         return values_count % 2 == 0 ? values_count : values_count + 1;\n     }\n \n-    std::size_t importChunk(std::span<const std::byte> values, std::span<TUint> chnk)\n+    size_t importChunk(std::span<const std::byte> values, std::span<TUInt> current_chunk)\n     {\n-        if (auto chunk_view = std::as_writable_bytes(chnk); chunk_view.size() <= values.size())\n+        if (auto chunk_view = std::as_writable_bytes(current_chunk); chunk_view.size() <= values.size())\n         {\n-            std::memcpy(chunk_view.data(), values.data(), chunk_view.size());\n+            memcpy(chunk_view.data(), values.data(), chunk_view.size());\n             return chunk_view.size() / VALUE_SIZE;\n         }\n         else\n         {\n-            std::memset(chunk_view.data(), 0, chunk_view.size());\n-            std::memcpy(chunk_view.data(), values.data(), values.size());\n+            memset(chunk_view.data(), 0, chunk_view.size());\n+            memcpy(chunk_view.data(), values.data(), values.size());\n             return ceilBytesToEvenValues(values.size());\n         }\n     }\n \n-    void exportChunk(std::span<const TUint> chnk)\n+    void exportChunk(std::span<const TUInt> current_chunk)\n     {\n-        auto chunk_view = std::as_bytes(chnk).first(std::min(result.size(), chnk.size_bytes()));\n-        std::memcpy(result.data(), chunk_view.data(), chunk_view.size());\n+        auto chunk_view = std::as_bytes(current_chunk).first(std::min(result.size(), current_chunk.size_bytes()));\n+        memcpy(result.data(), chunk_view.data(), chunk_view.size());\n         result = result.subspan(chunk_view.size());\n     }\n \n-    void encodeChunk(std::span<const TUint> seq)\n+    void encodeChunk(std::span<const TUInt> sequence)\n     {\n-        for (std::size_t i = 0; i < seq.size(); i += 2)\n+        for (size_t i = 0; i < sequence.size(); i += 2)\n         {\n-            encodePair(seq[i], seq[i + 1]);\n+            encodePair(sequence[i], sequence[i + 1]);\n         }\n     }\n \n     struct CompressedValue\n     {\n-        TUint value;\n-        unsigned compressed_size;\n+        TUInt value;\n+        UInt32 compressed_size;\n         std::byte predictor;\n     };\n \n-    unsigned encodeCompressedZeroByteCount(unsigned compressed)\n+    UInt32 encodeCompressedZeroByteCount(UInt32 compressed)\n     {\n         if constexpr (VALUE_SIZE == MAX_ZERO_BYTE_COUNT + 1)\n         {\n@@ -335,7 +335,7 @@ class FPCOperation\n         return std::min(compressed, MAX_ZERO_BYTE_COUNT);\n     }\n \n-    unsigned decodeCompressedZeroByteCount(unsigned encoded_size)\n+    UInt32 decodeCompressedZeroByteCount(UInt32 encoded_size)\n     {\n         if constexpr (VALUE_SIZE == MAX_ZERO_BYTE_COUNT + 1)\n         {\n@@ -345,22 +345,22 @@ class FPCOperation\n         return encoded_size;\n     }\n \n-    CompressedValue compressValue(TUint value) noexcept\n+    CompressedValue compressValue(TUInt value) noexcept\n     {\n         static constexpr auto BITS_PER_BYTE = std::numeric_limits<unsigned char>::digits;\n \n-        TUint compressed_dfcm = dfcm_predictor.predict() ^ value;\n-        TUint compressed_fcm = fcm_predictor.predict() ^ value;\n+        TUInt compressed_dfcm = dfcm_predictor.predict() ^ value;\n+        TUInt compressed_fcm = fcm_predictor.predict() ^ value;\n         dfcm_predictor.add(value);\n         fcm_predictor.add(value);\n         auto zeroes_dfcm = std::countl_zero(compressed_dfcm);\n         auto zeroes_fcm = std::countl_zero(compressed_fcm);\n         if (zeroes_dfcm > zeroes_fcm)\n-            return {compressed_dfcm, encodeCompressedZeroByteCount(static_cast<unsigned>(zeroes_dfcm) / BITS_PER_BYTE), DFCM_BIT};\n-        return {compressed_fcm, encodeCompressedZeroByteCount(static_cast<unsigned>(zeroes_fcm) / BITS_PER_BYTE), FCM_BIT};\n+            return {compressed_dfcm, encodeCompressedZeroByteCount(static_cast<UInt32>(zeroes_dfcm) / BITS_PER_BYTE), DFCM_BIT};\n+        return {compressed_fcm, encodeCompressedZeroByteCount(static_cast<UInt32>(zeroes_fcm) / BITS_PER_BYTE), FCM_BIT};\n     }\n \n-    void encodePair(TUint first, TUint second)\n+    void encodePair(TUInt first, TUInt second)\n     {\n         auto [compressed_value1, zero_byte_count1, predictor1] = compressValue(first);\n         auto [compressed_value2, zero_byte_count2, predictor2] = compressValue(second);\n@@ -374,24 +374,24 @@ class FPCOperation\n         auto tail_size1 = VALUE_SIZE - zero_byte_count1;\n         auto tail_size2 = VALUE_SIZE - zero_byte_count2;\n \n-        std::memcpy(result.data() + 1, valueTail(compressed_value1, zero_byte_count1), tail_size1);\n-        std::memcpy(result.data() + 1 + tail_size1, valueTail(compressed_value2, zero_byte_count2), tail_size2);\n+        memcpy(result.data() + 1, valueTail(compressed_value1, zero_byte_count1), tail_size1);\n+        memcpy(result.data() + 1 + tail_size1, valueTail(compressed_value2, zero_byte_count2), tail_size2);\n         result = result.subspan(1 + tail_size1 + tail_size2);\n     }\n \n-    std::size_t decodeChunk(std::span<const std::byte> values, std::span<TUint> seq)\n+    size_t decodeChunk(std::span<const std::byte> values, std::span<TUInt> sequence)\n     {\n-        std::size_t read_bytes = 0;\n-        for (std::size_t i = 0; i < seq.size(); i += 2)\n+        size_t read_bytes = 0;\n+        for (size_t i = 0; i < sequence.size(); i += 2)\n         {\n-            read_bytes += decodePair(values.subspan(read_bytes), seq[i], seq[i + 1]);\n+            read_bytes += decodePair(values.subspan(read_bytes), sequence[i], sequence[i + 1]);\n         }\n         return read_bytes;\n     }\n \n-    TUint decompressValue(TUint value, bool isDfcmPredictor)\n+    TUInt decompressValue(TUInt value, bool isDfcmPredictor)\n     {\n-        TUint decompressed;\n+        TUInt decompressed;\n         if (isDfcmPredictor)\n         {\n             decompressed = dfcm_predictor.predict() ^ value;\n@@ -405,37 +405,45 @@ class FPCOperation\n         return decompressed;\n     }\n \n-    std::size_t decodePair(std::span<const std::byte> bytes, TUint& first, TUint& second)\n+    size_t decodePair(std::span<const std::byte> bytes, TUInt & first, TUInt & second)\n     {\n         if (bytes.empty()) [[unlikely]]\n             throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Unexpected end of encoded sequence\");\n \n-        auto zero_byte_count1 = decodeCompressedZeroByteCount(\n-            std::to_integer<unsigned>(bytes.front() >> 4) & MAX_ZERO_BYTE_COUNT);\n-        auto zero_byte_count2 = decodeCompressedZeroByteCount(\n-            std::to_integer<unsigned>(bytes.front()) & MAX_ZERO_BYTE_COUNT);\n+        UInt32 zero_byte_count1 = decodeCompressedZeroByteCount(\n+            std::to_integer<UInt32>(bytes.front() >> 4) & MAX_ZERO_BYTE_COUNT);\n+        UInt32 zero_byte_count2 = decodeCompressedZeroByteCount(\n+            std::to_integer<UInt32>(bytes.front()) & MAX_ZERO_BYTE_COUNT);\n \n-        auto tail_size1 = VALUE_SIZE - zero_byte_count1;\n-        auto tail_size2 = VALUE_SIZE - zero_byte_count2;\n+        if (zero_byte_count1 > VALUE_SIZE || zero_byte_count2 > VALUE_SIZE) [[unlikely]]\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Invalid compressed data\");\n+\n+        size_t tail_size1 = VALUE_SIZE - zero_byte_count1;\n+        size_t tail_size2 = VALUE_SIZE - zero_byte_count2;\n+\n+        size_t expected_size = 0;\n+        if (__builtin_add_overflow(tail_size1, tail_size2, &expected_size)\n+            || __builtin_add_overflow(expected_size, 1, &expected_size)) [[unlikely]]\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Invalid compressed data\");\n \n-        if (bytes.size() < 1 + tail_size1 + tail_size2) [[unlikely]]\n+        if (bytes.size() < expected_size) [[unlikely]]\n             throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Unexpected end of encoded sequence\");\n \n-        TUint value1 = 0;\n-        TUint value2 = 0;\n+        TUInt value1 = 0;\n+        TUInt value2 = 0;\n \n-        std::memcpy(valueTail(value1, zero_byte_count1), bytes.data() + 1, tail_size1);\n-        std::memcpy(valueTail(value2, zero_byte_count2), bytes.data() + 1 + tail_size1, tail_size2);\n+        memcpy(valueTail(value1, zero_byte_count1), bytes.data() + 1, tail_size1);\n+        memcpy(valueTail(value2, zero_byte_count2), bytes.data() + 1 + tail_size1, tail_size2);\n \n         auto is_dfcm_predictor1 = std::to_integer<unsigned char>(bytes.front() & DFCM_BIT_1) != 0;\n         auto is_dfcm_predictor2 = std::to_integer<unsigned char>(bytes.front() & DFCM_BIT_2) != 0;\n         first = decompressValue(value1, is_dfcm_predictor1);\n         second = decompressValue(value2, is_dfcm_predictor2);\n \n-        return 1 + tail_size1 + tail_size2;\n+        return expected_size;\n     }\n \n-    static void* valueTail(TUint& value, unsigned compressed_size)\n+    static void* valueTail(TUInt& value, UInt32 compressed_size)\n     {\n         if constexpr (ENDIAN == std::endian::little)\n         {\n@@ -447,11 +455,11 @@ class FPCOperation\n         }\n     }\n \n-    DfcmPredictor<TUint> dfcm_predictor;\n-    FcmPredictor<TUint> fcm_predictor;\n+    DfcmPredictor<TUInt> dfcm_predictor;\n+    FcmPredictor<TUInt> fcm_predictor;\n \n     // memcpy the input into this buffer to align reads, this improves performance compared to unaligned reads (bit_cast) by ~10%\n-    std::array<TUint, CHUNK_SIZE> chunk{};\n+    std::array<TUInt, CHUNK_SIZE> chunk{};\n \n     std::span<std::byte> result{};\n };"
        },
        {
            "filename": "tests/queries/0_stateless/02915_fpc_overflow.reference",
            "diff": "@@ -0,0 +1,2 @@\n+Exc\n+Exc"
        },
        {
            "filename": "tests/queries/0_stateless/02915_fpc_overflow.sh",
            "diff": "@@ -0,0 +1,11 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+echo -ne 'checksumchecksum\\x98\\x90\\x00\\x00\\x00\\x11\\x11\\x11\\x11\\x04\\x0f\\x51                                                                                                                                       ' |\n+    ${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}&decompress=1&http_native_compression_disable_checksumming_on_decompress=1\" --data-binary @- 2>&1 | grep -oF 'Exc'\n+\n+echo -ne 'checksumchecksum\\x98\\x90\\x00\\x00\\x00\\x11\\x11\\x11\\x11\\x04\\x0f\\x16                                                                                                                                       ' |\n+    ${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}&decompress=1&http_native_compression_disable_checksumming_on_decompress=1\" --data-binary @- 2>&1 | grep -oF 'Exc'"
        }
    ],
    "commitTime": "2023-11-16 08:48:45"
}