{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 9.8,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "HIGH",
                "availability": "HIGH"
            },
            "severity": "critical"
        }
    ],
    "cvssScore": 9.8,
    "disclosureTime": "2020-08-18 17:15:00",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.57420",
        "probability": "0.00196"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-UNMANAGED-CONTIKINGCONTIKING-6137938",
    "identifiers": {
        "CVE": [
            "CVE-2020-14936"
        ],
        "CWE": [
            "CWE-787"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-22 09:05:10",
    "remediation": "Upgrade contiki-ng/contiki-ng to version 4.6 or higher. ",
    "severity": "critical",
    "socialTrendAlert": false,
    "title": "Out-of-bounds Write",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Out-of-bounds Write. Buffer overflows were discovered in Contiki-NG 4.4 through 4.5, in the SNMP agent. Functions parsing the OIDs in SNMP requests lack sufficient allocated target-buffer capacity verification when writing parsed OID values. The function snmp_oid_decode_oid() may overwrite memory areas beyond the provided target buffer, when called from snmp_message_decode() upon an SNMP request reception. Because the content of the write operations is externally provided in the SNMP requests, it enables a remote overwrite of an IoT device's memory regions beyond the allocated buffer. This overflow may allow remote overwrite of stack and statically allocated variables memory regions by sending a crafted SNMP request. "
    },
    "source_code": [
        {
            "filename": "examples/snmp-server/project-conf.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -30,4 +30,9 @@\n  */\n /*---------------------------------------------------------------------------*/\n \n+/*\n+ * In order to test SNMP compliance,\n+ * at least three OID's in the same package are necessary\n+ */\n+#define SNMP_CONF_MAX_NR_VALUES 3\n #define LOG_CONF_LEVEL_SNMP     LOG_LEVEL_NONE"
        },
        {
            "filename": "examples/snmp-server/resources/snmp-SNMP-MIB-2-System.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -33,91 +33,91 @@\n \n /*---------------------------------------------------------------------------*/\n static void\n-sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid);\n+sysDescr_handler(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n MIB_RESOURCE(sysDescr, sysDescr_handler, 1, 3, 6, 1, 2, 1, 1, 1, 0);\n \n static void\n-sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n+sysDescr_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n {\n   snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n }\n /*---------------------------------------------------------------------------*/\n \n /*---------------------------------------------------------------------------*/\n static void\n-sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid);\n+sysObjectID_handler(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n MIB_RESOURCE(sysObjectID, sysObjectID_handler, 1, 3, 6, 1, 2, 1, 1, 2, 0);\n \n static void\n-sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n+sysObjectID_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n {\n   OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n-  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n+  snmp_api_set_oid(varbind, oid, &sysObjectID_oid);\n }\n /*---------------------------------------------------------------------------*/\n \n /*---------------------------------------------------------------------------*/\n static void\n-sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid);\n+sysUpTime_handler(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n MIB_RESOURCE(sysUpTime, sysUpTime_handler, 1, 3, 6, 1, 2, 1, 1, 3, 0);\n \n static void\n-sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n+sysUpTime_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n {\n   snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n }\n /*---------------------------------------------------------------------------*/\n \n /*---------------------------------------------------------------------------*/\n static void\n-sysContact_handler(snmp_varbind_t *varbind, uint32_t *oid);\n+sysContact_handler(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n MIB_RESOURCE(sysContact, sysContact_handler, 1, 3, 6, 1, 2, 1, 1, 4, 0);\n \n static void\n-sysContact_handler(snmp_varbind_t *varbind, uint32_t *oid)\n+sysContact_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n {\n   snmp_api_set_string(varbind, oid, \"Contiki-NG, https://github.com/contiki-ng/contiki-ng\");\n }\n /*---------------------------------------------------------------------------*/\n \n /*---------------------------------------------------------------------------*/\n static void\n-sysName_handler(snmp_varbind_t *varbind, uint32_t *oid);\n+sysName_handler(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n MIB_RESOURCE(sysName, sysName_handler, 1, 3, 6, 1, 2, 1, 1, 5, 0);\n \n static void\n-sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n+sysName_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n {\n   snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n }\n /*---------------------------------------------------------------------------*/\n \n /*---------------------------------------------------------------------------*/\n static void\n-sysLocation_handler(snmp_varbind_t *varbind, uint32_t *oid);\n+sysLocation_handler(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n MIB_RESOURCE(sysLocation, sysLocation_handler, 1, 3, 6, 1, 2, 1, 1, 6, 0);\n \n static void\n-sysLocation_handler(snmp_varbind_t *varbind, uint32_t *oid)\n+sysLocation_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n {\n   snmp_api_set_string(varbind, oid, \"\");\n }\n /*---------------------------------------------------------------------------*/\n \n /*---------------------------------------------------------------------------*/\n static void\n-sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid);\n+sysServices_handler(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n MIB_RESOURCE(sysServices, sysServices_handler, 1, 3, 6, 1, 2, 1, 1, 7, 0);\n \n static void\n-sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n+sysServices_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n {\n   snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n }"
        },
        {
            "filename": "examples/snmp-server/snmp-server.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-api.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the public API\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -43,47 +43,31 @@\n \n #include \"snmp-message.h\"\n #include \"snmp-ber.h\"\n-#include \"snmp-oid.h\"\n \n-static void\n-snmp_api_replace_oid(snmp_varbind_t *varbind, uint32_t *oid)\n-{\n-  uint8_t i;\n-\n-  i = 0;\n-  while(oid[i] != ((uint32_t)-1)) {\n-    varbind->oid[i] = oid[i];\n-    i++;\n-  }\n-  varbind->oid[i] = ((uint32_t)-1);\n-}\n /*---------------------------------------------------------------------------*/\n void\n-snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string)\n+snmp_api_set_string(snmp_varbind_t *varbind, snmp_oid_t *oid, char *string)\n {\n-\n-  snmp_api_replace_oid(varbind, oid);\n+  memcpy(&varbind->oid, oid, sizeof(snmp_oid_t));\n   varbind->value_type = BER_DATA_TYPE_OCTET_STRING;\n   varbind->value.string.string = string;\n   varbind->value.string.length = strlen(string);\n }\n /*---------------------------------------------------------------------------*/\n void\n-snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n+snmp_api_set_time_ticks(snmp_varbind_t *varbind, snmp_oid_t *oid, uint32_t integer)\n {\n-\n-  snmp_api_replace_oid(varbind, oid);\n-  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n+  memcpy(&varbind->oid, oid, sizeof(snmp_oid_t));\n+  varbind->value_type = BER_DATA_TYPE_TIMETICKS;\n   varbind->value.integer = integer;\n }\n /*---------------------------------------------------------------------------*/\n void\n-snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n+snmp_api_set_oid(snmp_varbind_t *varbind, snmp_oid_t *oid, snmp_oid_t *ret_oid)\n {\n-\n-  snmp_api_replace_oid(varbind, oid);\n-  varbind->value_type = BER_DATA_TYPE_OID;\n-  varbind->value.oid = ret_oid;\n+  memcpy(&varbind->oid, oid, sizeof(snmp_oid_t));\n+  varbind->value_type = BER_DATA_TYPE_OBJECT_IDENTIFIER;\n+  memcpy(&varbind->value.oid, ret_oid, sizeof(snmp_oid_t));\n }\n /*---------------------------------------------------------------------------*/\n void"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-api.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      The public API for the Contiki-NG SNMP implementation\n+ *      SNMP Implementation of the public API\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -49,11 +49,10 @@\n #include \"snmp-mib.h\"\n \n /**\n- * \\defgroup SNMPAPI This is the SNMP Public API\n+ * \\addtogroup SNMPAPI SNMP Public API\n  * @{\n  *\n  * This group contains all the functions that can be used outside the OS level.\n- * The function outside this header can be changed without notice\n  */\n \n /**\n@@ -62,7 +61,7 @@\n  * @param varbind The varbind that is being changed\n  * @param oid The oid from the resource\n  */\n-typedef void (*snmp_mib_resource_handler_t)(snmp_varbind_t *varbind, uint32_t *oid);\n+typedef void (*snmp_mib_resource_handler_t)(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n /**\n  * @brief The MIB Resource struct\n@@ -78,7 +77,10 @@ typedef struct snmp_mib_resource_s snmp_mib_resource_t;\n  * @param ... The Oid (comma-separeted)\n  */\n #define OID(name, ...) \\\n-  static uint32_t name[] = { __VA_ARGS__, -1 };\n+  static snmp_oid_t name = { \\\n+    .data = __VA_ARGS__, \\\n+    .length = (sizeof((uint32_t[]){ __VA_ARGS__ }) / sizeof(uint32_t)) \\\n+  };\n \n /**\n  * @brief Declare a MIB resource\n@@ -88,8 +90,14 @@ typedef struct snmp_mib_resource_s snmp_mib_resource_t;\n  * @param ... The OID (comma-separated)\n  */\n #define MIB_RESOURCE(name, handler, ...) \\\n-  uint32_t name##_oid[] = { __VA_ARGS__, -1 }; \\\n-  snmp_mib_resource_t name = { NULL, name##_oid, handler };\n+  snmp_mib_resource_t name = { \\\n+    NULL, \\\n+    { \\\n+      .data = __VA_ARGS__, \\\n+      .length = (sizeof((uint32_t[]){ __VA_ARGS__ }) / sizeof(uint32_t)) \\\n+    }, \\\n+    handler \\\n+  };\n \n /**\n  * @brief Function to set a varbind with a string\n@@ -101,7 +109,7 @@ typedef struct snmp_mib_resource_s snmp_mib_resource_t;\n  * @param string The string\n  */\n void\n-snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string);\n+snmp_api_set_string(snmp_varbind_t *varbind, snmp_oid_t *oid, char *string);\n \n /**\n  * @brief Function to set a varbind with a time tick\n@@ -113,7 +121,7 @@ snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string);\n  * @param integer The time tick value\n  */\n void\n-snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer);\n+snmp_api_set_time_ticks(snmp_varbind_t *varbind, snmp_oid_t *oid, uint32_t integer);\n \n /**\n  * @brief Function to set a varbind with a oid\n@@ -125,7 +133,7 @@ snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer\n  * @param ret_oid The oid value\n  */\n void\n-snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid);\n+snmp_api_set_oid(snmp_varbind_t *varbind, snmp_oid_t *oid, snmp_oid_t *ret_oid);\n \n /**\n  * @brief Function to add a new resource"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-ber.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the BER encoding\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -46,245 +46,465 @@\n #define LOG_LEVEL LOG_LEVEL_SNMP\n \n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_encode_type(unsigned char *out, uint32_t *out_len, uint8_t type)\n+static inline int\n+snmp_ber_encode_unsigned_integer(snmp_packet_t *snmp_packet, uint8_t type, uint32_t number)\n {\n-  *out-- = type;\n-  (*out_len)++;\n-  return out;\n-}\n-/*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n-{\n-  *out-- = length;\n-  (*out_len)++;\n-  return out;\n-}\n-/*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n-{\n-  uint32_t original_out_len;\n+  uint16_t original_out_len;\n \n-  original_out_len = *out_len;\n+  original_out_len = snmp_packet->used;\n   do {\n-    (*out_len)++;\n-    *out-- = (uint8_t)(number & 0xFF);\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)number & 0xFF;\n+    snmp_packet->used++;\n+    /* I'm not sure why but on MSPGCC the >> 8 operation goes haywire here */\n+#ifdef __MSPGCC__\n+    number >>= 4;\n+    number >>= 4;\n+#else /* __MSPGCC__ */\n     number >>= 8;\n+#endif /* __MSPGCC__ */\n   } while(number);\n \n-  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n-  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n+  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used - original_out_len)) {\n+    return 0;\n+  }\n+\n+  if(!snmp_ber_encode_type(snmp_packet, type)) {\n+    return 0;\n+  }\n \n-  return out;\n+  return 1;\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_encode_unsigned_integer(unsigned char *out, uint32_t *out_len, uint8_t type, uint32_t number)\n+int\n+snmp_ber_encode_type(snmp_packet_t *snmp_packet, uint8_t type)\n {\n-  uint32_t original_out_len;\n+  if(snmp_packet->used == snmp_packet->max) {\n+    return 0;\n+  }\n \n-  original_out_len = *out_len;\n-  do {\n-    (*out_len)++;\n-    *out-- = (uint8_t)(number & 0xFF);\n-    number >>= 8;\n-  } while(number);\n+  *snmp_packet->out-- = type;\n+  snmp_packet->used++;\n+\n+  return 1;\n+}\n+/*---------------------------------------------------------------------------*/\n+int\n+snmp_ber_encode_length(snmp_packet_t *snmp_packet, uint16_t length)\n+{\n+  if(length > 0xFF) {\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)length & 0xFF;\n+    snmp_packet->used++;\n+\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)(length >> 8) & 0xFF;\n+    snmp_packet->used++;\n+\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = 0x82;\n+    snmp_packet->used++;\n+  } else if(length > 0x7F) {\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)length & 0xFF;\n+    snmp_packet->used++;\n \n-  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n-  out = snmp_ber_encode_type(out, out_len, type);\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n \n-  return out;\n+    *snmp_packet->out-- = 0x81;\n+    snmp_packet->used++;\n+  } else {\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)length & 0x7F;\n+    snmp_packet->used++;\n+  }\n+\n+  return 1;\n+}\n+/*---------------------------------------------------------------------------*/\n+int\n+snmp_ber_encode_timeticks(snmp_packet_t *snmp_packet, uint32_t timeticks)\n+{\n+  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n+}\n+/*---------------------------------------------------------------------------*/\n+int\n+snmp_ber_encode_integer(snmp_packet_t *snmp_packet, uint32_t number)\n+{\n+  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_INTEGER, number);\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n+int\n+snmp_ber_encode_string_len(snmp_packet_t *snmp_packet, const char *str, uint32_t length)\n {\n   uint32_t i;\n \n   str += length - 1;\n   for(i = 0; i < length; ++i) {\n-    (*out_len)++;\n-    *out-- = (uint8_t)*str--;\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)*str--;\n+    snmp_packet->used++;\n   }\n \n-  out = snmp_ber_encode_length(out, out_len, length);\n-  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n+  if(!snmp_ber_encode_length(snmp_packet, length)) {\n+    return 0;\n+  }\n \n-  return out;\n-}\n-/*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n-{\n-  (*out_len)++;\n-  *out-- = 0x00;\n-  out = snmp_ber_encode_type(out, out_len, type);\n+  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OCTET_STRING)) {\n+    return 0;\n+  }\n \n-  return out;\n+  return 1;\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n+int\n+snmp_ber_encode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n {\n-  if(*buff_len == 0) {\n-    return NULL;\n+  uint32_t val;\n+  uint16_t original_out_len;\n+  uint8_t pos;\n+\n+  original_out_len = snmp_packet->used;\n+\n+  pos = oid->length - 1;\n+  while(pos) {\n+    val = oid->data[pos];\n+\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n+    snmp_packet->used++;\n+    val >>= 7;\n+\n+    while(val) {\n+      if(snmp_packet->used == snmp_packet->max) {\n+        return 0;\n+      }\n+\n+      *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n+      snmp_packet->used++;\n+\n+      val >>= 7;\n+    }\n+    pos--;\n+  }\n+\n+  if(snmp_packet->used == snmp_packet->max) {\n+    return 0;\n+  }\n+\n+  val = *(snmp_packet->out + 1) + 40 * oid->data[pos];\n+  snmp_packet->used--;\n+  snmp_packet->out++;\n+\n+  if(snmp_packet->used == snmp_packet->max) {\n+    return 0;\n+  }\n+\n+  *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n+  snmp_packet->used++;\n+\n+  val >>= 7;\n+\n+  while(val) {\n+    if(snmp_packet->used == snmp_packet->max) {\n+      return 0;\n+    }\n+\n+    *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n+    snmp_packet->used++;\n+\n+    val >>= 7;\n+  }\n+\n+  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used - original_out_len)) {\n+    return 0;\n   }\n \n-  *type = *buff++;\n-  (*buff_len)--;\n+  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OBJECT_IDENTIFIER)) {\n+    return 0;\n+  }\n \n-  return buff;\n+  return 1;\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len, uint8_t *length)\n+int\n+snmp_ber_encode_null(snmp_packet_t *snmp_packet, uint8_t type)\n {\n-  if(*buff_len == 0) {\n-    return NULL;\n+\n+  if(snmp_packet->used == snmp_packet->max) {\n+    return 0;\n   }\n \n-  *length = *buff++;\n-  (*buff_len)--;\n+  *snmp_packet->out-- = 0x00;\n+  snmp_packet->used++;\n \n-  return buff;\n+  return snmp_ber_encode_type(snmp_packet, type);\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_decode_integer(unsigned char *buf, uint32_t *buff_len, uint32_t *num)\n+static inline int\n+snmp_ber_decode_unsigned_integer(snmp_packet_t *snmp_packet, uint8_t expected_type, uint32_t *num)\n {\n   uint8_t i, len, type;\n \n-  buf = snmp_ber_decode_type(buf, buff_len, &type);\n+  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n+    return 0;\n+  }\n \n-  if(buf == NULL || type != BER_DATA_TYPE_INTEGER) {\n+  if(type != expected_type) {\n     /*\n      * Sanity check\n      * Invalid type in buffer\n      */\n-    return NULL;\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_length(buf, buff_len, &len);\n+  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n+    return 0;\n+  }\n \n-  if(buf == NULL || len > 4) {\n+  if(len > 4) {\n     /*\n      * Sanity check\n      * It will not fit in the uint32_t\n      */\n-    return NULL;\n+    return 0;\n   }\n \n-  if(*buff_len < len) {\n-    return NULL;\n+  if(snmp_packet->used == 0) {\n+    return 0;\n   }\n \n-  *num = (uint32_t)(*buf++ & 0xFF);\n-  (*buff_len)--;\n+  *num = (uint32_t)(*snmp_packet->in++ & 0xFF);\n+  snmp_packet->used--;\n+\n   for(i = 1; i < len; ++i) {\n     *num <<= 8;\n-    *num |= (uint8_t)(*buf++ & 0xFF);\n-    (*buff_len)--;\n+    if(snmp_packet->used == 0) {\n+      return 0;\n+    }\n+    *num |= (uint8_t)(*snmp_packet->in++ & 0xFF);\n+    snmp_packet->used--;\n   }\n \n-  return buf;\n+  return 1;\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n+int\n+snmp_ber_decode_type(snmp_packet_t *snmp_packet, uint8_t *type)\n {\n-  uint8_t i, len, type;\n-\n-  buf = snmp_ber_decode_type(buf, buff_len, &type);\n-\n-  if(buf == NULL || type != expected_type) {\n-    /*\n-     * Sanity check\n-     * Invalid type in buffer\n-     */\n-    return NULL;\n+  if(snmp_packet->used == 0) {\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_length(buf, buff_len, &len);\n-\n-  if(buf == NULL || len > 4) {\n-    /*\n-     * Sanity check\n-     * It will not fit in the uint32_t\n-     */\n-    return NULL;\n-  }\n+  *type = *snmp_packet->in++;\n+  snmp_packet->used--;\n \n-  if(*buff_len < len) {\n-    return NULL;\n+  return 1;\n+}\n+/*---------------------------------------------------------------------------*/\n+int\n+snmp_ber_decode_length(snmp_packet_t *snmp_packet, uint8_t *length)\n+{\n+  if(snmp_packet->used == 0) {\n+    return 0;\n   }\n \n-  *num = (uint32_t)(*buf++ & 0xFF);\n-  (*buff_len)--;\n-  for(i = 1; i < len; ++i) {\n-    *num <<= 8;\n-    *num |= (uint8_t)(*buf++ & 0xFF);\n-    (*buff_len)--;\n-  }\n+  *length = *snmp_packet->in++;\n+  snmp_packet->used--;\n \n-  return buf;\n+  return 1;\n+}\n+/*---------------------------------------------------------------------------*/\n+int\n+snmp_ber_decode_timeticks(snmp_packet_t *snmp_packet, uint32_t *timeticks)\n+{\n+  return snmp_ber_decode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n+int\n+snmp_ber_decode_integer(snmp_packet_t *snmp_packet, uint32_t *num)\n+{\n+  return snmp_ber_decode_unsigned_integer(snmp_packet, BER_DATA_TYPE_INTEGER, num);\n+}\n+/*---------------------------------------------------------------------------*/\n+int\n+snmp_ber_decode_string_len_buffer(snmp_packet_t *snmp_packet, const char **str, uint32_t *length)\n {\n   uint8_t type, i, length_bytes;\n \n-  buf = snmp_ber_decode_type(buf, buff_len, &type);\n+  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n+    return 0;\n+  }\n \n-  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n+  if(type != BER_DATA_TYPE_OCTET_STRING) {\n     /*\n      * Sanity check\n      * Invalid type in buffer\n      */\n-    return NULL;\n+    return 0;\n   }\n \n-  if((*buf & 0x80) == 0) {\n-    *length = (uint32_t)*buf++;\n-    (*buff_len)--;\n+  if((*snmp_packet->in & 0x80) == 0) {\n+\n+    if(snmp_packet->used == 0) {\n+      return 0;\n+    }\n+\n+    *length = (uint32_t)*snmp_packet->in++;\n+    snmp_packet->used--;\n   } else {\n \n-    length_bytes = (uint8_t)(*buf++ & 0x7F);\n-    (*buff_len)--;\n+    if(snmp_packet->used == 0) {\n+      return 0;\n+    }\n+\n+    length_bytes = (uint8_t)(*snmp_packet->in++ & 0x7F);\n+    snmp_packet->used--;\n+\n     if(length_bytes > 4) {\n       /*\n        * Sanity check\n        * It will not fit in the uint32_t\n        */\n-      return NULL;\n+      return 0;\n+    }\n+\n+    if(snmp_packet->used == 0) {\n+      return 0;\n     }\n \n-    *length = (uint32_t)*buf++;\n-    (*buff_len)--;\n+    *length = (uint32_t)*snmp_packet->in++;\n+    snmp_packet->used--;\n+\n     for(i = 1; i < length_bytes; ++i) {\n       *length <<= 8;\n-      *length |= *buf++;\n-      (*buff_len)--;\n+\n+      if(snmp_packet->used == 0) {\n+        return 0;\n+      }\n+\n+      *length |= *snmp_packet->in++;\n+      snmp_packet->used--;\n     }\n   }\n \n-  *str = (const char *)buf;\n-  *buff_len -= *length;\n+  *str = (const char *)snmp_packet->in;\n+\n+  if(snmp_packet->used == 0 || snmp_packet->used - *length <= 0) {\n+    return 0;\n+  }\n+\n+  snmp_packet->used -= *length;\n+  snmp_packet->in += *length;\n+\n+  return 1;\n+}\n+/*---------------------------------------------------------------------------*/\n+int\n+snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n+{\n+  uint8_t *buf_end, type;\n+  uint8_t len, j;\n+  div_t first;\n+\n+  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n+    return 0;\n+  }\n+\n+  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n+    return 0;\n+  }\n+\n+  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n+    return 0;\n+  }\n+\n+  buf_end = snmp_packet->in + len;\n+\n+  if(snmp_packet->used == 0) {\n+    return 0;\n+  }\n+\n+  snmp_packet->used--;\n+  first = div(*snmp_packet->in++, 40);\n+\n+  oid->length = 0;\n+\n+  oid->data[oid->length++] = (uint32_t)first.quot;\n+  oid->data[oid->length++] = (uint32_t)first.rem;\n+\n+  while(snmp_packet->in != buf_end) {\n+    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n+      return 0;\n+    }\n \n-  return buf + *length;\n+    if(snmp_packet->used == 0) {\n+      return 0;\n+    }\n+    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n+    for(j = 0; j < 4; j++) {\n+      snmp_packet->used--;\n+      if((*snmp_packet->in++ & 0x80) == 0) {\n+        break;\n+      }\n+\n+      if(snmp_packet->used == 0) {\n+        return 0;\n+      }\n+\n+      oid->data[oid->length] <<= 7;\n+      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n+    }\n+\n+    oid->length++;\n+  }\n+\n+  return 1;\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_ber_decode_null(unsigned char *buf, uint32_t *buff_len)\n+int\n+snmp_ber_decode_null(snmp_packet_t *snmp_packet)\n {\n-  buf++;\n-  (*buff_len)--;\n+  if(snmp_packet->used == 0) {\n+    return 0;\n+  }\n+\n+  snmp_packet->in++;\n+  snmp_packet->used--;\n+\n+  if(snmp_packet->used == 0) {\n+    return 0;\n+  }\n \n-  buf++;\n-  (*buff_len)--;\n+  snmp_packet->in++;\n+  snmp_packet->used--;\n \n-  return buf;\n+  return 1;\n }\n /*---------------------------------------------------------------------------*/"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-ber.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the BER encoding\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -45,158 +45,269 @@\n #ifndef SNMP_BER_H_\n #define SNMP_BER_H_\n \n-#define BER_DATA_TYPE_INTEGER           0x02\n-#define BER_DATA_TYPE_OCTET_STRING      0x04\n-#define BER_DATA_TYPE_NULL              0x05\n-#define BER_DATA_TYPE_OID               0x06\n-#define BER_DATA_TYPE_SEQUENCE          0x30\n+/**\n+ * \\addtogroup SNMPInternal SNMP Internal API\n+ * @{\n+ *\n+ * This group contains all the functions that can be used inside the OS level.\n+ */\n+\n+/**\n+ * \\addtogroup SNMPBER SNMP BER\n+ * @{\n+ *\n+ * This group contains the BER implementation\n+ */\n+\n+/**\n+ * @brief End-of-Content\n+ *\n+ */\n+#define BER_DATA_TYPE_EOC                   0x00\n+\n+/**\n+ * @brief Integer\n+ *\n+ */\n+#define BER_DATA_TYPE_INTEGER               0x02\n+\n+/**\n+ * @brief Octet String\n+ *\n+ */\n+#define BER_DATA_TYPE_OCTET_STRING          0x04\n+\n+/**\n+ * @brief Null\n+ *\n+ */\n+#define BER_DATA_TYPE_NULL                  0x05\n+\n+/**\n+ * @brief Object Identifier\n+ *\n+ */\n+#define BER_DATA_TYPE_OBJECT_IDENTIFIER     0x06\n+\n+/**\n+ * @brief Sequence\n+ *\n+ */\n+#define BER_DATA_TYPE_SEQUENCE              0x30\n+\n+/**\n+ * @brief TimeTicks\n+ *\n+ */\n+#define BER_DATA_TYPE_TIMETICKS             0x43\n+\n+/**\n+ * @brief No Such Instance\n+ *\n+ */\n+#define BER_DATA_TYPE_NO_SUCH_INSTANCE      0x81\n+\n+/**\n+ * @brief End of MIB View\n+ *\n+ */\n+#define BER_DATA_TYPE_END_OF_MIB_VIEW       0x82\n+\n+/**\n+ * @brief PDU Get Request\n+ *\n+ */\n+#define BER_DATA_TYPE_PDU_GET_REQUEST       0xA0\n+\n+/**\n+ * @brief PDU Get Next Request\n+ *\n+ */\n+#define BER_DATA_TYPE_PDU_GET_NEXT_REQUEST  0xA1\n+\n+/**\n+ * @brief PDU Get Reponse\n+ *\n+ */\n+#define BER_DATA_TYPE_PDU_GET_RESPONSE      0xA2\n+\n+/**\n+ * @brief PDU Set Request\n+ *\n+ */\n+#define BER_DATA_TYPE_PDU_SET_REQUEST       0xA3\n+\n+/**\n+ * @brief PDU Trap\n+ *\n+ */\n+#define BER_DATA_TYPE_PDU_TRAP              0xA4\n+\n+/**\n+ * @brief PDU Get Bulk\n+ *\n+ */\n+#define BER_DATA_TYPE_PDU_GET_BULK          0xA5\n \n /**\n  * @brief Encodes a type\n  *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param type A type\n  *\n- * @return NULL if error or the next entry in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_encode_type(unsigned char *out, uint32_t *out_len, uint8_t type);\n+int\n+snmp_ber_encode_type(snmp_packet_t *snmp_packet, uint8_t type);\n \n /**\n  * @brief Encodes the length\n  *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param length A length\n  *\n- * @return NULL if error or the next entry in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length);\n+int\n+snmp_ber_encode_length(snmp_packet_t *snmp_packet, uint16_t length);\n \n /**\n  * @brief Encodes an integer\n  *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param integer A integer\n  *\n- * @return NULL if error or the next entry in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t integer);\n+int\n+snmp_ber_encode_integer(snmp_packet_t *snmp_packet, uint32_t integer);\n \n /**\n- * @brief Encodes an unsigned integer\n+ * @brief Encodes a timeticks\n  *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n- * @param type A type that represents an unsigned integer\n- * @param number A number\n+ * @param snmp_packet A pointer to the snmp packet\n+ * @param timeticks A TimeTicks\n  *\n- * @return NULL if error or the next entry in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_encode_unsigned_integer(unsigned char *out, uint32_t *out_len, uint8_t type, uint32_t number);\n+int\n+snmp_ber_encode_timeticks(snmp_packet_t *snmp_packet, uint32_t timeticks);\n \n /**\n  * @brief Encodes a string\n  *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param str A string\n  * @param length The string length\n  *\n- * @return NULL if error or the next entry in the buffer\n+ * @return 0 if error or 1 if success\n+ */\n+int\n+snmp_ber_encode_string_len(snmp_packet_t *snmp_packet, const char *str, uint32_t length);\n+\n+/**\n+ * @brief Encodes a Oid\n+ *\n+ * @param snmp_packet A pointer to the snmp packet\n+ * @param oid A OID\n+ *\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length);\n+int\n+snmp_ber_encode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid);\n \n /**\n  * @brief Encodes a null\n  *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param type A type\n  *\n- * @return NULL if error or the next entry in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type);\n+int\n+snmp_ber_encode_null(snmp_packet_t *snmp_packet, uint8_t type);\n \n /**\n  * @brief Decodes a type\n  *\n- * @param buff A pointer to the beginning of the buffer\n- * @param buff_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param type A pointer to the type\n  *\n- * @return NULL if error or the first entry after the oid in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type);\n+int\n+snmp_ber_decode_type(snmp_packet_t *snmp_packet, uint8_t *type);\n \n /**\n  * @brief Decodes a length\n  *\n- * @param buff A pointer to the beginning of the buffer\n- * @param buff_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param length A pointer to the length\n  *\n- * @return NULL if error or the first entry after the oid in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len, uint8_t *length);\n+int\n+snmp_ber_decode_length(snmp_packet_t *snmp_packet, uint8_t *length);\n \n /**\n  * @brief Decodes an integer\n  *\n- * @param buff A pointer to the beginning of the buffer\n- * @param buff_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param integer A pointer to the integer\n  *\n- * @return NULL if error or the first entry after the oid in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_decode_integer(unsigned char *buff, uint32_t *buff_len, uint32_t *integer);\n+int\n+snmp_ber_decode_integer(snmp_packet_t *snmp_packet, uint32_t *integer);\n \n /**\n- * @brief Decodes an unsigned number\n+ * @brief Decodes a timeticks\n  *\n- * @param buff A pointer to the beginning of the buffer\n- * @param buff_len A pointer to the buffer length\n- * @param expected_type The expected type that represents an unsingned integer\n- * @param number A pointer to the number\n+ * @param snmp_packet A pointer to the snmp packet\n+ * @param timeticks A pointer to the timeticks\n  *\n- * @return NULL if error or the first entry after the oid in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_decode_unsigned_integer(unsigned char *buff, uint32_t *buff_len, uint8_t expected_type, uint32_t *number);\n+int\n+snmp_ber_decode_timeticks(snmp_packet_t *snmp_packet, uint32_t *timeticks);\n \n /**\n  * @brief Decodes a string\n  *\n- * @param buff A pointer to the beginning of the buffer\n- * @param buff_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param str A pointer to the string\n  * @param length A pointer to the string length\n  *\n- * @return NULL if error or the first entry after the oid in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_decode_string_len_buffer(unsigned char *buff, uint32_t *buff_len, const char **str, uint32_t *length);\n+int\n+snmp_ber_decode_string_len_buffer(snmp_packet_t *snmp_packet, const char **str, uint32_t *length);\n \n /**\n  * @brief Decodes a null\n  *\n- * @param buff A pointer to the beginning of the buffer\n- * @param buff_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  *\n- * @return NULL if error or the first entry after the oid in the buffer\n+ * @return 0 if error or 1 if success\n  */\n-unsigned char *\n-snmp_ber_decode_null(unsigned char *buff, uint32_t *buff_len);\n+int\n+snmp_ber_decode_null(snmp_packet_t *snmp_packet);\n+\n+/**\n+ * @brief Decodes an OID\n+ *\n+ * @param snmp_packet  pointer to the snmp packet\n+ * @param oid A pointer to the OID\n+ *\n+ * @return 0 if error or 1 if success\n+ */\n+int\n+snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid);\n+\n+/** @} */\n+\n+/** @} */\n \n #endif /* SNMP_BER_H_ */\n+\n /** @} */"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-conf.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      SNMP Configurable Macros\n+ *      SNMP Implementation of the configurable macros\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -46,8 +46,17 @@\n #define SNMP_CONF_H_\n \n /**\n- * \\defgroup SNMPConfs SNMP Configurable Defines\n+ * \\addtogroup SNMPInternal SNMP Internal API\n  * @{\n+ *\n+ * This group contains all the functions that can be used inside the OS level.\n+ */\n+\n+/**\n+ * \\addtogroup SNMPConfs SNMP Configurable\n+ * @{\n+ *\n+ * This group contains all the defines that can be configurable following the Contiki standard\n  */\n \n #ifdef SNMP_CONF_COMMUNITY\n@@ -63,6 +72,9 @@\n #endif\n \n #ifdef SNMP_CONF_MSG_OID_MAX_LEN\n+#if SNMP_CONF_MSG_OID_MAX_LEN > 128\n+#error \"OID is limited to 128 in the standard\"\n+#endif\n /**\n  * \\brief Configurable maximum number of IDs in one OID\n  */\n@@ -75,6 +87,9 @@\n #endif\n \n #ifdef SNMP_CONF_MAX_NR_VALUES\n+#if SNMP_CONF_MAX_NR_VALUES > 255\n+#error \"Number of OID's per packet is limited to 255 in this implementation\"\n+#endif\n /**\n  * \\brief Configurable maximum number of OIDs in one response\n  */\n@@ -87,16 +102,8 @@\n #endif\n \n #ifdef SNMP_CONF_MAX_PACKET_SIZE\n-/**\n- * \\brief Configurable maximum size of the packet in bytes\n- */\n-#define SNMP_MAX_PACKET_SIZE SNMP_CONF_MAX_PACKET_SIZE\n-#else\n-/**\n- * \\brief Default maximum size of the packet in bytes\n- */\n-#define SNMP_MAX_PACKET_SIZE 512\n-#endif\n+#error \"SNMP_CONF_MAX_PACKET_SIZE is obsolete. Use UIP_CONF_BUFFER_SIZE\"\n+#endif /* SNMP_CONF_MAX_PACKET_SIZE */\n \n #ifdef SNMP_CONF_PORT\n /**\n@@ -110,7 +117,10 @@\n #define SNMP_PORT 161\n #endif\n \n-/*@}*/\n+/** @} */\n+\n+/** @} */\n \n #endif /* SNMP_CONF_H_ */\n+\n /** @} */"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-engine.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the protocol engine\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -42,154 +42,168 @@\n #include \"snmp-engine.h\"\n #include \"snmp-message.h\"\n #include \"snmp-mib.h\"\n-#include \"snmp-oid.h\"\n+#include \"snmp-ber.h\"\n \n #define LOG_MODULE \"SNMP [engine]\"\n #define LOG_LEVEL LOG_LEVEL_SNMP\n \n /*---------------------------------------------------------------------------*/\n-int\n-snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n+static inline int\n+snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds)\n {\n   snmp_mib_resource_t *resource;\n-  uint32_t i;\n+  uint8_t i;\n \n-  for(i = 0; i < varbinds_length; i++) {\n-    resource = snmp_mib_find(varbinds[i].oid);\n+  i = 0;\n+  while(varbinds[i].value_type != BER_DATA_TYPE_EOC && i < SNMP_MAX_NR_VALUES) {\n+    resource = snmp_mib_find(&varbinds[i].oid);\n     if(!resource) {\n       switch(header->version) {\n       case SNMP_VERSION_1:\n-        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n+        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n         /*\n          * Varbinds are 1 indexed\n          */\n-        header->error_index_max_repetitions.error_index = i + 1;\n+        header->error_index = i + 1;\n         break;\n       case SNMP_VERSION_2C:\n-        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n+        (&varbinds[i])->value_type = BER_DATA_TYPE_NO_SUCH_INSTANCE;\n         break;\n       default:\n-        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n-        header->error_index_max_repetitions.error_index = 0;\n+        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n+        header->error_index = 0;\n       }\n     } else {\n-      resource->handler(&varbinds[i], resource->oid);\n+      resource->handler(&varbinds[i], &resource->oid);\n     }\n+\n+    i++;\n   }\n \n   return 0;\n }\n /*---------------------------------------------------------------------------*/\n-int\n-snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n+static inline int\n+snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds)\n {\n   snmp_mib_resource_t *resource;\n-  uint32_t i;\n+  uint8_t i;\n \n-  for(i = 0; i < varbinds_length; i++) {\n-    resource = snmp_mib_find_next(varbinds[i].oid);\n+  i = 0;\n+  while(varbinds[i].value_type != BER_DATA_TYPE_EOC && i < SNMP_MAX_NR_VALUES) {\n+    resource = snmp_mib_find_next(&varbinds[i].oid);\n     if(!resource) {\n       switch(header->version) {\n       case SNMP_VERSION_1:\n-        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n+        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n         /*\n          * Varbinds are 1 indexed\n          */\n-        header->error_index_max_repetitions.error_index = i + 1;\n+        header->error_index = i + 1;\n         break;\n       case SNMP_VERSION_2C:\n-        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n+        (&varbinds[i])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n         break;\n       default:\n-        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n-        header->error_index_max_repetitions.error_index = 0;\n+        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n+        header->error_index = 0;\n       }\n     } else {\n-      resource->handler(&varbinds[i], resource->oid);\n+      resource->handler(&varbinds[i], &resource->oid);\n     }\n+\n+    i++;\n   }\n \n   return 0;\n }\n /*---------------------------------------------------------------------------*/\n-int\n-snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t *varbinds_length)\n+static inline int\n+snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds)\n {\n   snmp_mib_resource_t *resource;\n-  uint32_t i, j, original_varbinds_length;\n-  uint32_t oid[SNMP_MAX_NR_VALUES][SNMP_MSG_OID_MAX_LEN];\n+  snmp_oid_t oids[SNMP_MAX_NR_VALUES];\n+  uint32_t j, original_varbinds_length;\n   uint8_t repeater;\n+  uint8_t i, varbinds_length;\n \n   /*\n    * A local copy of the requested oids must be kept since\n    *  the varbinds are modified on the fly\n    */\n-  original_varbinds_length = *varbinds_length;\n-  for(i = 0; i < original_varbinds_length; i++) {\n-    snmp_oid_copy(oid[i], varbinds[i].oid);\n+  original_varbinds_length = 0;\n+  while(varbinds[original_varbinds_length].value_type != BER_DATA_TYPE_EOC && original_varbinds_length < SNMP_MAX_NR_VALUES) {\n+    memcpy(&oids[original_varbinds_length], &varbinds[original_varbinds_length].oid, sizeof(snmp_oid_t));\n+    original_varbinds_length++;\n   }\n \n-  *varbinds_length = 0;\n+  varbinds_length = 0;\n   for(i = 0; i < original_varbinds_length; i++) {\n-    if(i >= header->error_status_non_repeaters.non_repeaters) {\n+    if(i >= header->non_repeaters) {\n       break;\n     }\n \n-    resource = snmp_mib_find_next(oid[i]);\n+    resource = snmp_mib_find_next(&oids[i]);\n     if(!resource) {\n       switch(header->version) {\n       case SNMP_VERSION_1:\n-        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n+        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n         /*\n          * Varbinds are 1 indexed\n          */\n-        header->error_index_max_repetitions.error_index = i + 1;\n+        header->error_index = i + 1;\n         break;\n       case SNMP_VERSION_2C:\n-        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n+        (&varbinds[i])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n         break;\n       default:\n-        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n-        header->error_index_max_repetitions.error_index = 0;\n+        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n+        header->error_index = 0;\n       }\n     } else {\n-      if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n-        resource->handler(&varbinds[*varbinds_length], resource->oid);\n-        (*varbinds_length)++;\n+      if(varbinds_length < SNMP_MAX_NR_VALUES) {\n+        resource->handler(&varbinds[varbinds_length], &resource->oid);\n+        (varbinds_length)++;\n+      } else {\n+        return -1;\n       }\n     }\n   }\n \n-  for(i = 0; i < header->error_index_max_repetitions.max_repetitions; i++) {\n+  for(i = 0; i < header->max_repetitions; i++) {\n     repeater = 0;\n-    for(j = header->error_status_non_repeaters.non_repeaters; j < original_varbinds_length; j++) {\n-      resource = snmp_mib_find_next(oid[j]);\n+    for(j = header->non_repeaters; j < original_varbinds_length; j++) {\n+      resource = snmp_mib_find_next(&oids[j]);\n       if(!resource) {\n         switch(header->version) {\n         case SNMP_VERSION_1:\n-          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n+          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n           /*\n            * Varbinds are 1 indexed\n            */\n-          header->error_index_max_repetitions.error_index = *varbinds_length + 1;\n+          header->error_index = varbinds_length + 1;\n           break;\n         case SNMP_VERSION_2C:\n-          if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n-            (&varbinds[*varbinds_length])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n-            snmp_oid_copy((&varbinds[*varbinds_length])->oid, oid[j]);\n-            (*varbinds_length)++;\n+          if(varbinds_length < SNMP_MAX_NR_VALUES) {\n+            (&varbinds[varbinds_length])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n+            memcpy(&varbinds[varbinds_length].oid, &oids[j], sizeof(snmp_oid_t));\n+            (varbinds_length)++;\n+          } else {\n+            return -1;\n           }\n           break;\n         default:\n-          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n-          header->error_index_max_repetitions.error_index = 0;\n+          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n+          header->error_index = 0;\n         }\n       } else {\n-        if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n-          resource->handler(&varbinds[*varbinds_length], resource->oid);\n-          (*varbinds_length)++;\n-          snmp_oid_copy(oid[j], resource->oid);\n+        if(varbinds_length < SNMP_MAX_NR_VALUES) {\n+          resource->handler(&varbinds[varbinds_length], &resource->oid);\n+          (varbinds_length)++;\n+          memcpy(&oids[j], &resource->oid, sizeof(snmp_oid_t));\n           repeater++;\n+        } else {\n+          return -1;\n         }\n       }\n     }\n@@ -201,54 +215,54 @@ snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t *\n   return 0;\n }\n /*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)\n+int\n+snmp_engine(snmp_packet_t *snmp_packet)\n {\n-  static snmp_header_t header;\n-  static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];\n-  static uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n+  snmp_header_t header;\n+  snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];\n+\n+  memset(&header, 0, sizeof(header));\n+  memset(varbinds, 0, sizeof(varbinds));\n \n-  buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);\n-  if(buff == NULL) {\n-    return NULL;\n+  if(!snmp_message_decode(snmp_packet, &header, varbinds)) {\n+    return 0;\n   }\n \n   if(header.version != SNMP_VERSION_1) {\n     if(strncmp(header.community.community, SNMP_COMMUNITY, header.community.length)) {\n       LOG_ERR(\"Request with invalid community\\n\");\n-      return NULL;\n+      return 0;\n     }\n   }\n \n   /*\n    * Now handle the SNMP requests depending on their type\n    */\n   switch(header.pdu_type) {\n-  case SNMP_DATA_TYPE_PDU_GET_REQUEST:\n-    if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {\n-      return NULL;\n+  case BER_DATA_TYPE_PDU_GET_REQUEST:\n+    if(snmp_engine_get(&header, varbinds) == -1) {\n+      return 0;\n     }\n     break;\n \n-  case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n-    if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {\n-      return NULL;\n+  case BER_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n+    if(snmp_engine_get_next(&header, varbinds) == -1) {\n+      return 0;\n     }\n     break;\n \n-  case SNMP_DATA_TYPE_PDU_GET_BULK:\n-    if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {\n-      return NULL;\n+  case BER_DATA_TYPE_PDU_GET_BULK:\n+    if(snmp_engine_get_bulk(&header, varbinds) == -1) {\n+      return 0;\n     }\n     break;\n \n   default:\n     LOG_ERR(\"Invalid request type\");\n-    return NULL;\n+    return 0;\n   }\n \n-  header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;\n-  out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);\n+  header.pdu_type = BER_DATA_TYPE_PDU_GET_RESPONSE;\n \n-  return ++out;\n+  return snmp_message_encode(snmp_packet, &header, varbinds);\n }"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-engine.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the protocol engine\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -45,20 +45,32 @@\n #ifndef SNMP_ENGINE_H_\n #define SNMP_ENGINE_H_\n \n+/**\n+ * \\addtogroup SNMPInternal SNMP Internal API\n+ * @{\n+ *\n+ * This group contains all the functions that can be used inside the OS level.\n+ */\n #include \"snmp.h\"\n \n /**\n- * @brief Process the SNMP packet and prepares the response\n+ * \\addtogroup SNMPEngine SNMP Engine\n+ * @{\n  *\n- * @param buff A pointer to the beginning of the packet buffer\n- * @param buff_len The packet length\n- * @param out A pointer to the end of the response buffer\n- * @param out_len A pointer to the length of the response buffer\n+ * This group contains the Engine implementation\n+ */\n+\n+/**\n+ * @brief Process the SNMP packet and prepares the response\n  *\n- * @return NULL in case of fail or the first element in the response buffer\n+ * @param snmp_packet A pointer to the snmp packet\n  */\n-unsigned char *\n-snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len);\n+int\n+snmp_engine(snmp_packet_t *snmp_packet);\n+\n+/** @} */\n+\n+/** @} */\n \n #endif /* SNMP_ENGINE_H_ */\n "
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-message.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the messages\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -41,243 +41,314 @@\n \n #include \"snmp-message.h\"\n #include \"snmp-ber.h\"\n-#include \"snmp-oid.h\"\n \n #define LOG_MODULE \"SNMP [message]\"\n #define LOG_LEVEL LOG_LEVEL_SNMP\n \n-unsigned char *\n-snmp_message_encode(unsigned char *out, uint32_t *out_len, snmp_header_t *header,\n-                    snmp_varbind_t *varbinds, uint32_t varbind_num)\n+int\n+snmp_message_encode(snmp_packet_t *snmp_packet, snmp_header_t *header, snmp_varbind_t *varbinds)\n {\n-  snmp_varbind_t *varbind;\n-  uint32_t original_out_len, last_out_len;\n+  uint32_t last_out_len;\n   int8_t i;\n \n-  original_out_len = *out_len;\n-  for(i = varbind_num - 1; i >= 0; i--) {\n-    varbind = &varbinds[i];\n+  for(i = SNMP_MAX_NR_VALUES - 1; i >= 0; i--) {\n+    if(varbinds[i].value_type == BER_DATA_TYPE_EOC) {\n+      continue;\n+    }\n \n-    last_out_len = *out_len;\n+    last_out_len = snmp_packet->used;\n \n-    switch(varbind->value_type) {\n+    switch(varbinds[i].value_type) {\n     case BER_DATA_TYPE_INTEGER:\n-      out = snmp_ber_encode_integer(out, out_len, varbind->value.integer);\n+      if(!snmp_ber_encode_integer(snmp_packet, varbinds[i].value.integer)) {\n+        LOG_DBG(\"Could not encode integer type\\n\");\n+        return 0;\n+      }\n       break;\n-    case SNMP_DATA_TYPE_TIME_TICKS:\n-      out = snmp_ber_encode_unsigned_integer(out, out_len, varbind->value_type, varbind->value.integer);\n+    case BER_DATA_TYPE_TIMETICKS:\n+      if(!snmp_ber_encode_timeticks(snmp_packet, varbinds[i].value.integer)) {\n+        LOG_DBG(\"Could not encode timeticks type\\n\");\n+        return 0;\n+      }\n       break;\n     case BER_DATA_TYPE_OCTET_STRING:\n-      out = snmp_ber_encode_string_len(out, out_len, varbind->value.string.string, varbind->value.string.length);\n+      if(!snmp_ber_encode_string_len(snmp_packet, varbinds[i].value.string.string, varbinds[i].value.string.length)) {\n+        LOG_DBG(\"Could not encode octet string type\\n\");\n+        return 0;\n+      }\n       break;\n-    case BER_DATA_TYPE_OID:\n-      out = snmp_oid_encode_oid(out, out_len, varbind->value.oid);\n+    case BER_DATA_TYPE_OBJECT_IDENTIFIER:\n+      if(!snmp_ber_encode_oid(snmp_packet, &varbinds[i].value.oid)) {\n+        LOG_DBG(\"Could not encode oid type\\n\");\n+        return 0;\n+      }\n       break;\n     case BER_DATA_TYPE_NULL:\n-    case SNMP_DATA_TYPE_NO_SUCH_INSTANCE:\n-    case SNMP_DATA_TYPE_END_OF_MIB_VIEW:\n-      out = snmp_ber_encode_null(out, out_len, varbind->value_type);\n+    case BER_DATA_TYPE_NO_SUCH_INSTANCE:\n+    case BER_DATA_TYPE_END_OF_MIB_VIEW:\n+      if(!snmp_ber_encode_null(snmp_packet, varbinds[i].value_type)) {\n+        LOG_DBG(\"Could not encode null type\\n\");\n+        return 0;\n+      }\n       break;\n     default:\n-      return NULL;\n+      LOG_DBG(\"Could not encode invlid type\\n\");\n+      return 0;\n+    }\n+\n+    if(!snmp_ber_encode_oid(snmp_packet, &varbinds[i].oid)) {\n+      LOG_DBG(\"Could not encode oid\\n\");\n+      return 0;\n+    }\n+\n+    if(!snmp_ber_encode_length(snmp_packet, (snmp_packet->used - last_out_len))) {\n+      LOG_DBG(\"Could not encode length\\n\");\n+      return 0;\n     }\n \n-    out = snmp_oid_encode_oid(out, out_len, varbind->oid);\n-    out = snmp_ber_encode_length(out, out_len, ((*out_len - last_out_len) & 0xFF));\n-    out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_SEQUENCE);\n+    if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_SEQUENCE)) {\n+      LOG_DBG(\"Could not encode type\\n\");\n+      return 0;\n+    }\n   }\n \n-  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n-  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_SEQUENCE);\n+  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used)) {\n+    LOG_DBG(\"Could not encode length\\n\");\n+    return 0;\n+  }\n+  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_SEQUENCE)) {\n+    LOG_DBG(\"Could not encode type\\n\");\n+    return 0;\n+  }\n \n-  if(header->pdu_type == SNMP_DATA_TYPE_PDU_GET_BULK) {\n-    out = snmp_ber_encode_integer(out, out_len, header->error_index_max_repetitions.max_repetitions);\n-    out = snmp_ber_encode_integer(out, out_len, header->error_status_non_repeaters.non_repeaters);\n-  } else {\n-    out = snmp_ber_encode_integer(out, out_len, header->error_index_max_repetitions.error_index);\n-    out = snmp_ber_encode_integer(out, out_len, header->error_status_non_repeaters.error_status);\n+  switch(header->pdu_type) {\n+  case BER_DATA_TYPE_PDU_GET_BULK:\n+    if(!snmp_ber_encode_integer(snmp_packet, header->max_repetitions)) {\n+      LOG_DBG(\"Could not encode max repetition\\n\");\n+      return 0;\n+    }\n+\n+    if(!snmp_ber_encode_integer(snmp_packet, header->non_repeaters)) {\n+      LOG_DBG(\"Could not encode non repeaters\\n\");\n+      return 0;\n+    }\n+    break;\n+  default:\n+    if(!snmp_ber_encode_integer(snmp_packet, header->error_index)) {\n+      LOG_DBG(\"Could not encode error index\\n\");\n+      return 0;\n+    }\n+\n+    if(!snmp_ber_encode_integer(snmp_packet, header->error_status)) {\n+      LOG_DBG(\"Could not encode error status\\n\");\n+      return 0;\n+    }\n+    break;\n   }\n-  out = snmp_ber_encode_integer(out, out_len, header->request_id);\n \n-  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n-  out = snmp_ber_encode_type(out, out_len, header->pdu_type);\n+  if(!snmp_ber_encode_integer(snmp_packet, header->request_id)) {\n+    LOG_DBG(\"Could not encode request id\\n\");\n+    return 0;\n+  }\n \n-  out = snmp_ber_encode_string_len(out, out_len, header->community.community, header->community.length);\n-  out = snmp_ber_encode_integer(out, out_len, header->version);\n+  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used)) {\n+    LOG_DBG(\"Could not encode length\\n\");\n+    return 0;\n+  }\n \n-  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n-  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_SEQUENCE);\n+  if(!snmp_ber_encode_type(snmp_packet, header->pdu_type)) {\n+    LOG_DBG(\"Could not encode pdu type\\n\");\n+    return 0;\n+  }\n \n-  return out;\n+  if(!snmp_ber_encode_string_len(snmp_packet, header->community.community, header->community.length)) {\n+    LOG_DBG(\"Could not encode community\\n\");\n+    return 0;\n+  }\n+\n+  if(!snmp_ber_encode_integer(snmp_packet, header->version)) {\n+    LOG_DBG(\"Could not encode version\\n\");\n+    return 0;\n+  }\n+\n+  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used)) {\n+    LOG_DBG(\"Could not encode length\\n\");\n+    return 0;\n+  }\n+\n+  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_SEQUENCE)) {\n+    LOG_DBG(\"Could not encode type\\n\");\n+    return 0;\n+  }\n+\n+  /* Move the pointer to the last position */\n+  snmp_packet->out++;\n+  return 1;\n }\n-uint8_t *\n-snmp_message_decode(uint8_t *buf, uint32_t buf_len, snmp_header_t *header,\n-                    snmp_varbind_t *varbinds, uint32_t *varbind_num)\n+int\n+snmp_message_decode(snmp_packet_t *snmp_packet, snmp_header_t *header, snmp_varbind_t *varbinds)\n {\n-  uint8_t type, len;\n-  uint32_t i, oid_len = SNMP_MSG_OID_MAX_LEN;\n+  uint8_t type, len, i;\n \n-  buf = snmp_ber_decode_type(buf, &buf_len, &type);\n-  if(buf == NULL) {\n+  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n     LOG_DBG(\"Could not decode type\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n   if(type != BER_DATA_TYPE_SEQUENCE) {\n     LOG_DBG(\"Invalid type\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_length(buf, &buf_len, &len);\n-  if(buf == NULL) {\n+  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n     LOG_DBG(\"Could not decode length\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_integer(buf, &buf_len, &header->version);\n-  if(buf == NULL) {\n+  if(!snmp_ber_decode_integer(snmp_packet, &header->version)) {\n     LOG_DBG(\"Could not decode version\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_string_len_buffer(buf, &buf_len, &header->community.community, &header->community.length);\n-  if(buf == NULL) {\n-    LOG_DBG(\"Could not decode community\\n\");\n-    return NULL;\n+  switch(header->version) {\n+  case SNMP_VERSION_1:\n+  case SNMP_VERSION_2C:\n+    break;\n+  default:\n+    LOG_DBG(\"Invalid version\\n\");\n+    return 0;\n   }\n \n-  if(header->version != SNMP_VERSION_1 &&\n-     header->version != SNMP_VERSION_2C) {\n-    LOG_DBG(\"Invalid version\\n\");\n-    return NULL;\n+  if(!snmp_ber_decode_string_len_buffer(snmp_packet, &header->community.community, &header->community.length)) {\n+    LOG_DBG(\"Could not decode community\\n\");\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_type(buf, &buf_len, &type);\n-  if(buf == NULL) {\n-    LOG_DBG(\"Could not decode type\\n\");\n-    return NULL;\n+  if(!snmp_ber_decode_type(snmp_packet, &header->pdu_type)) {\n+    LOG_DBG(\"Could not decode pdu type\\n\");\n+    return 0;\n   }\n \n-  header->pdu_type = type;\n-  if(header->pdu_type != SNMP_DATA_TYPE_PDU_GET_REQUEST &&\n-     header->pdu_type != SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST &&\n-     header->pdu_type != SNMP_DATA_TYPE_PDU_GET_RESPONSE &&\n-     header->pdu_type != SNMP_DATA_TYPE_PDU_SET_REQUEST &&\n-     header->pdu_type != SNMP_DATA_TYPE_PDU_GET_BULK) {\n-    LOG_DBG(\"Invalid pdu type\\n\");\n-    return NULL;\n+  switch(header->pdu_type) {\n+  case BER_DATA_TYPE_PDU_GET_REQUEST:\n+  case BER_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n+  case BER_DATA_TYPE_PDU_GET_RESPONSE:\n+  case BER_DATA_TYPE_PDU_SET_REQUEST:\n+  case BER_DATA_TYPE_PDU_GET_BULK:\n+    break;\n+  default:\n+    LOG_DBG(\"Invalid version\\n\");\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_length(buf, &buf_len, &len);\n-  if(buf == NULL) {\n+  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n     LOG_DBG(\"Could not decode length\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_integer(buf, &buf_len, &header->request_id);\n-  if(buf == NULL) {\n+  if(!snmp_ber_decode_integer(snmp_packet, &header->request_id)) {\n     LOG_DBG(\"Could not decode request id\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n-  if(header->pdu_type == SNMP_DATA_TYPE_PDU_GET_BULK) {\n-    buf = snmp_ber_decode_integer(buf, &buf_len, &header->error_status_non_repeaters.non_repeaters);\n-    if(buf == NULL) {\n-      LOG_DBG(\"Could not decode error status\\n\");\n-      return NULL;\n+  switch(header->pdu_type) {\n+  case BER_DATA_TYPE_PDU_GET_BULK:\n+    if(!snmp_ber_decode_integer(snmp_packet, &header->non_repeaters)) {\n+      LOG_DBG(\"Could not decode non repeaters\\n\");\n+      return 0;\n     }\n \n-    buf = snmp_ber_decode_integer(buf, &buf_len, &header->error_index_max_repetitions.max_repetitions);\n-    if(buf == NULL) {\n-      LOG_DBG(\"Could not decode error index\\n\");\n-      return NULL;\n+    if(!snmp_ber_decode_integer(snmp_packet, &header->max_repetitions)) {\n+      LOG_DBG(\"Could not decode max repetition\\n\");\n+      return 0;\n     }\n-  } else {\n-    buf = snmp_ber_decode_integer(buf, &buf_len, &header->error_status_non_repeaters.error_status);\n-    if(buf == NULL) {\n+    break;\n+  default:\n+    if(!snmp_ber_decode_integer(snmp_packet, &header->error_status)) {\n       LOG_DBG(\"Could not decode error status\\n\");\n-      return NULL;\n+      return 0;\n     }\n \n-    buf = snmp_ber_decode_integer(buf, &buf_len, &header->error_index_max_repetitions.error_index);\n-    if(buf == NULL) {\n+    if(!snmp_ber_decode_integer(snmp_packet, &header->error_index)) {\n       LOG_DBG(\"Could not decode error index\\n\");\n-      return NULL;\n+      return 0;\n     }\n+    break;\n   }\n \n-  buf = snmp_ber_decode_type(buf, &buf_len, &type);\n-  if(buf == NULL) {\n+  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n     LOG_DBG(\"Could not decode type\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n   if(type != BER_DATA_TYPE_SEQUENCE) {\n     LOG_DBG(\"Invalid type\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n-  buf = snmp_ber_decode_length(buf, &buf_len, &len);\n-  if(buf == NULL) {\n+  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n     LOG_DBG(\"Could not decode length\\n\");\n-    return NULL;\n+    return 0;\n   }\n \n-  for(i = 0; buf_len > 0; ++i) {\n-    if(i >= *varbind_num) {\n-      return NULL;\n+  for(i = 0; snmp_packet->used > 0; ++i) {\n+    if(i >= SNMP_MAX_NR_VALUES) {\n+      LOG_DBG(\"OID's overflow\\n\");\n+      return 0;\n     }\n \n-    buf = snmp_ber_decode_type(buf, &buf_len, &type);\n-    if(buf == NULL) {\n+    if(!snmp_ber_decode_type(snmp_packet, &type)) {\n       LOG_DBG(\"Could not decode type\\n\");\n-      return NULL;\n+      return 0;\n     }\n \n     if(type != BER_DATA_TYPE_SEQUENCE) {\n       LOG_DBG(\"Invalid (%X) type\\n\", type);\n-      return NULL;\n+      return 0;\n     }\n \n-    buf = snmp_ber_decode_length(buf, &buf_len, &len);\n-    if(buf == NULL) {\n+    if(!snmp_ber_decode_length(snmp_packet, &len)) {\n       LOG_DBG(\"Could not decode length\\n\");\n-      return NULL;\n+      return 0;\n     }\n \n-    buf = snmp_oid_decode_oid(buf, &buf_len, varbinds[i].oid, &oid_len);\n-    if(buf == NULL) {\n+    if(!snmp_ber_decode_oid(snmp_packet, &varbinds[i].oid)) {\n       LOG_DBG(\"Could not decode oid\\n\");\n-      return NULL;\n+      return 0;\n     }\n \n-    varbinds[i].value_type = *buf;\n+    varbinds[i].value_type = *snmp_packet->in;\n \n     switch(varbinds[i].value_type) {\n     case BER_DATA_TYPE_INTEGER:\n-      buf = snmp_ber_decode_integer(buf, &buf_len, &varbinds[i].value.integer);\n+      if(!snmp_ber_decode_integer(snmp_packet, &varbinds[i].value.integer)) {\n+        LOG_DBG(\"Could not decode integer type\\n\");\n+        return 0;\n+      }\n       break;\n-    case SNMP_DATA_TYPE_TIME_TICKS:\n-      buf = snmp_ber_decode_unsigned_integer(buf, &buf_len, varbinds[i].value_type, &varbinds[i].value.integer);\n+    case BER_DATA_TYPE_TIMETICKS:\n+      if(!snmp_ber_decode_timeticks(snmp_packet, &varbinds[i].value.integer)) {\n+        LOG_DBG(\"Could not decode timeticks type\\n\");\n+        return 0;\n+      }\n       break;\n     case BER_DATA_TYPE_OCTET_STRING:\n-      buf = snmp_ber_decode_string_len_buffer(buf, &buf_len, &varbinds[i].value.string.string, &varbinds[i].value.string.length);\n+      if(!snmp_ber_decode_string_len_buffer(snmp_packet, &varbinds[i].value.string.string, &varbinds[i].value.string.length)) {\n+        LOG_DBG(\"Could not decode octed string type\\n\");\n+        return 0;\n+      }\n       break;\n     case BER_DATA_TYPE_NULL:\n-      buf = snmp_ber_decode_null(buf, &buf_len);\n+      if(!snmp_ber_decode_null(snmp_packet)) {\n+        LOG_DBG(\"Could not decode null type\\n\");\n+        return 0;\n+      }\n       break;\n     default:\n       LOG_DBG(\"Invalid varbind type\\n\");\n-      return NULL;\n-    }\n-\n-    if(buf == NULL) {\n-      LOG_DBG(\"Could varbind type\\n\");\n-      return NULL;\n+      return 0;\n     }\n   }\n \n-  *varbind_num = i;\n-\n-  return buf;\n+  return 1;\n }"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-message.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the messages\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -45,47 +45,48 @@\n #ifndef SNMP_MESSAGE_H_\n #define SNMP_MESSAGE_H_\n \n-#include \"snmp.h\"\n+/**\n+ * \\addtogroup SNMPInternal SNMP Internal API\n+ * @{\n+ *\n+ * This group contains all the functions that can be used inside the OS level.\n+ */\n \n-#define SNMP_DATA_TYPE_TIME_TICKS               0x43\n-#define SNMP_DATA_TYPE_NO_SUCH_INSTANCE         0x81\n-#define SNMP_DATA_TYPE_END_OF_MIB_VIEW          0x82\n+#include \"snmp.h\"\n \n-#define SNMP_DATA_TYPE_PDU_GET_REQUEST          0xA0\n-#define SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST     0xA1\n-#define SNMP_DATA_TYPE_PDU_GET_RESPONSE         0xA2\n-#define SNMP_DATA_TYPE_PDU_SET_REQUEST          0xA3\n-#define SNMP_DATA_TYPE_PDU_TRAP                 0xA4\n-#define SNMP_DATA_TYPE_PDU_GET_BULK             0xA5\n+/**\n+ * \\addtogroup SNMPMessage SNMP Message\n+ * @{\n+ *\n+ * This group contains the Message implementation\n+ */\n \n /**\n  * @brief Encodes a SNMP message\n  *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param header The SNMP header struct\n  * @param varbinds The varbinds array\n- * @param varbinds_length The number of varbinds\n  *\n  * @return\n  */\n-unsigned char *\n-snmp_message_encode(unsigned char *out, uint32_t *out_len, snmp_header_t *header,\n-                    snmp_varbind_t *varbinds, uint32_t varbinds_length);\n+int\n+snmp_message_encode(snmp_packet_t *snmp_packet, snmp_header_t *header, snmp_varbind_t *varbinds);\n /**\n  * @brief\n  *\n- * @param buf A pointer to the beginning of the buffer\n- * @param buf_len A pointer to the buffer length\n+ * @param snmp_packet A pointer to the snmp packet\n  * @param header The SNMP header struct\n  * @param varbinds The varbinds array\n- * @param varbinds_length A pointer to the number of varbinds\n  *\n  * @return\n  */\n-uint8_t *\n-snmp_message_decode(uint8_t *buf, uint32_t buf_len, snmp_header_t *header,\n-                    snmp_varbind_t *varbinds, uint32_t *varbinds_length);\n+int\n+snmp_message_decode(snmp_packet_t *snmp_packet, snmp_header_t *header, snmp_varbind_t *varbinds);\n+\n+/** @} */\n+\n+/** @} */\n \n #endif /* SNMP_MESSAGE_H_ */\n "
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-mib.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,63 +32,103 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the MIB\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n \n #include \"contiki.h\"\n \n #include \"snmp-mib.h\"\n-#include \"snmp-oid.h\"\n #include \"lib/list.h\"\n \n #define LOG_MODULE \"SNMP [mib]\"\n #define LOG_LEVEL LOG_LEVEL_SNMP\n \n LIST(snmp_mib);\n \n+/*---------------------------------------------------------------------------*/\n+/**\n+ * @brief Compares to oids\n+ *\n+ * @param oid1 First Oid\n+ * @param oid2 Second Oid\n+ *\n+ * @return < 0 if oid1 < oid2, > 0 if oid1 > oid2 and 0 if they are equal\n+ */\n+static inline int\n+snmp_mib_cmp_oid(snmp_oid_t *oid1, snmp_oid_t *oid2)\n+{\n+  uint8_t i;\n+\n+  i = 0;\n+  while(i < oid1->length && i < oid2->length) {\n+    if(oid1->data[i] != oid2->data[i]) {\n+      if(oid1->data[i] < oid2->data[i]) {\n+        return -1;\n+      }\n+      return 1;\n+    }\n+    i++;\n+  }\n+\n+  if(i == oid1->length &&\n+     i < oid2->length) {\n+    return -1;\n+  }\n+\n+  if(i < oid1->length &&\n+     i == oid2->length) {\n+    return 1;\n+  }\n+\n+  return 0;\n+}\n+/*---------------------------------------------------------------------------*/\n snmp_mib_resource_t *\n-snmp_mib_find(uint32_t *oid)\n+snmp_mib_find(snmp_oid_t *oid)\n {\n   snmp_mib_resource_t *resource;\n \n   resource = NULL;\n   for(resource = list_head(snmp_mib);\n       resource; resource = resource->next) {\n \n-    if(!snmp_oid_cmp_oid(oid, resource->oid)) {\n+    if(!snmp_mib_cmp_oid(oid, &resource->oid)) {\n       return resource;\n     }\n   }\n \n   return NULL;\n }\n+/*---------------------------------------------------------------------------*/\n snmp_mib_resource_t *\n-snmp_mib_find_next(uint32_t *oid)\n+snmp_mib_find_next(snmp_oid_t *oid)\n {\n   snmp_mib_resource_t *resource;\n \n   resource = NULL;\n   for(resource = list_head(snmp_mib);\n       resource; resource = resource->next) {\n \n-    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n+    if(snmp_mib_cmp_oid(&resource->oid, oid) > 0) {\n       return resource;\n     }\n   }\n \n   return NULL;\n }\n+/*---------------------------------------------------------------------------*/\n void\n snmp_mib_add(snmp_mib_resource_t *new_resource)\n {\n   snmp_mib_resource_t *resource;\n+  uint8_t i;\n \n   for(resource = list_head(snmp_mib);\n       resource; resource = resource->next) {\n \n-    if(snmp_oid_cmp_oid(resource->oid, new_resource->oid) > 0) {\n+    if(snmp_mib_cmp_oid(&resource->oid, &new_resource->oid) > 0) {\n       break;\n     }\n   }\n@@ -98,18 +138,28 @@ snmp_mib_add(snmp_mib_resource_t *new_resource)\n     list_insert(snmp_mib, new_resource, resource);\n   }\n \n-#if LOG_LEVEL == LOG_LEVEL_DBG\n-  /*\n-   * We print the entire resource table\n-   */\n-  LOG_DBG(\"Table after insert.\\n\");\n-  for(resource = list_head(snmp_mib);\n-      resource; resource = resource->next) {\n-\n-    snmp_oid_print(resource->oid);\n+  if(LOG_DBG_ENABLED) {\n+    /*\n+     * We print the entire resource table\n+     */\n+    LOG_DBG(\"Table after insert.\\n\");\n+    for(resource = list_head(snmp_mib);\n+        resource; resource = resource->next) {\n+\n+      i = 0;\n+      LOG_DBG(\"{\");\n+      while(i < resource->oid.length) {\n+        LOG_DBG_(\"%lu\", (unsigned long)resource->oid.data[i]);\n+        i++;\n+        if(i < resource->oid.length) {\n+          LOG_DBG_(\".\");\n+        }\n+      }\n+      LOG_DBG_(\"}\\n\");\n+    }\n   }\n-#endif /* LOG_LEVEL == LOG_LEVEL_DBG  */\n }\n+/*---------------------------------------------------------------------------*/\n void\n snmp_mib_init(void)\n {"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-mib.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the MIB\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -45,15 +45,29 @@\n #ifndef SNMP_MIB_H_\n #define SNMP_MIB_H_\n \n+/**\n+ * \\addtogroup SNMPInternal SNMP Internal API\n+ * @{\n+ *\n+ * This group contains all the functions that can be used inside the OS level.\n+ */\n+\n #include \"snmp.h\"\n \n+/**\n+ * \\addtogroup SNMPMIB SNMP MIB\n+ * @{\n+ *\n+ * This group contains the MIB implementation\n+ */\n+\n /**\n  * @brief The MIB resource handler typedef\n  *\n  * @param varbind The varbind that is being changed\n  * @param oid The oid from the resource\n  */\n-typedef void (*snmp_mib_resource_handler_t)(snmp_varbind_t *varbind, uint32_t *oid);\n+typedef void (*snmp_mib_resource_handler_t)(snmp_varbind_t *varbind, snmp_oid_t *oid);\n \n /**\n  * @brief The MIB Resource struct\n@@ -66,11 +80,9 @@ typedef struct snmp_mib_resource_s {\n    */\n   struct snmp_mib_resource_s *next;\n   /**\n-   * @brief A array that represents the OID\n-   *\n-   * @remarks This array is \"null\" terminated. In this case the -1 is used.\n+   * @brief A OID struct\n    */\n-  uint32_t *oid;\n+  snmp_oid_t oid;\n   /**\n    * @brief The function handler that is called for this resource\n    */\n@@ -85,7 +97,7 @@ typedef struct snmp_mib_resource_s {\n  * @return In case of success a pointer to the resouce or NULL in case of fail\n  */\n snmp_mib_resource_t *\n-snmp_mib_find(uint32_t *oid);\n+snmp_mib_find(snmp_oid_t *oid);\n \n /**\n  * @brief Finds the next MIB Resource after this OID\n@@ -95,7 +107,7 @@ snmp_mib_find(uint32_t *oid);\n  * @return In case of success a pointer to the resouce or NULL in case of fail\n  */\n snmp_mib_resource_t *\n-snmp_mib_find_next(uint32_t *oid);\n+snmp_mib_find_next(snmp_oid_t *oid);\n \n /**\n  * @brief Adds a resource into the linked list\n@@ -111,5 +123,10 @@ snmp_mib_add(snmp_mib_resource_t *resource);\n void\n snmp_mib_init(void);\n \n+/** @} */\n+\n+/** @} */\n+\n #endif /* SNMP_MIB_H_ */\n+\n /** @} */"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-oid.c",
            "diff": "@@ -1,217 +0,0 @@\n-/*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- *\n- * 3. Neither the name of the copyright holder nor the names of its\n- *    contributors may be used to endorse or promote products derived\n- *    from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE\n- * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n- * OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-/*---------------------------------------------------------------------------*/\n-\n-/**\n- * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n- * \\author\n- *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n- */\n-\n-#include \"contiki.h\"\n-\n-#include \"snmp-oid.h\"\n-#include \"snmp-ber.h\"\n-\n-#define LOG_MODULE \"SNMP [oid]\"\n-#define LOG_LEVEL LOG_LEVEL_SNMP\n-\n-/*---------------------------------------------------------------------------*/\n-int\n-snmp_oid_cmp_oid(uint32_t *oid1, uint32_t *oid2)\n-{\n-  uint8_t i;\n-\n-  i = 0;\n-  while(oid1[i] != ((uint32_t)-1) &&\n-        oid2[i] != ((uint32_t)-1)) {\n-    if(oid1[i] != oid2[i]) {\n-      if(oid1[i] < oid2[i]) {\n-        return -1;\n-      }\n-      return 1;\n-    }\n-    i++;\n-  }\n-\n-  if(oid1[i] == ((uint32_t)-1) &&\n-     oid2[i] != ((uint32_t)-1)) {\n-    return -1;\n-  }\n-\n-  if(oid1[i] != ((uint32_t)-1) &&\n-     oid2[i] == ((uint32_t)-1)) {\n-    return 1;\n-  }\n-\n-  return 0;\n-}\n-/*---------------------------------------------------------------------------*/\n-unsigned char *\n-snmp_oid_encode_oid(unsigned char *out, uint32_t *out_len, uint32_t *oid)\n-{\n-  uint32_t original_out_len;\n-  uint32_t *oid_start = oid;\n-  uint32_t num;\n-\n-  original_out_len = *out_len;\n-  while(*oid != ((uint32_t)-1)) {\n-    ++oid;\n-  }\n-  --oid;\n-\n-  while(oid != oid_start) {\n-    num = *oid;\n-    (*out_len)++;\n-    *out-- = (uint8_t)(num & 0x7F);\n-    num >>= 7;\n-\n-    while(num) {\n-      (*out_len)++;\n-      *out-- = (uint8_t)((num & 0x7F) | 0x80);\n-      num >>= 7;\n-    }\n-    --oid;\n-  }\n-\n-  num = *(out + 1) + 40 * *oid;\n-  (*out_len)--;\n-  out++;\n-  (*out_len)++;\n-  *out-- = (uint8_t)(num & 0x7F);\n-  num >>= 7;\n-\n-  while(num) {\n-    (*out_len)++;\n-    *out-- = (uint8_t)((num & 0x7F) | 0x80);\n-    num >>= 7;\n-  }\n-\n-  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n-  out = snmp_ber_encode_type(out, out_len, SNMP_DATA_TYPE_OBJECT);\n-\n-  return out;\n-}\n-/*---------------------------------------------------------------------------*/\n-uint8_t *\n-snmp_oid_decode_oid(uint8_t *buf, uint32_t *buff_len, uint32_t *oid, uint32_t *oid_len)\n-{\n-  uint32_t *start;\n-  uint8_t *buf_end, type;\n-  uint8_t len;\n-  div_t first;\n-\n-  start = oid;\n-\n-  buf = snmp_ber_decode_type(buf, buff_len, &type);\n-  if(buf == NULL) {\n-    return NULL;\n-  }\n-\n-  if(type != SNMP_DATA_TYPE_OBJECT) {\n-    return NULL;\n-  }\n-\n-  buf = snmp_ber_decode_length(buf, buff_len, &len);\n-  if(buf == NULL) {\n-    return NULL;\n-  }\n-\n-  buf_end = buf + len;\n-\n-  (*buff_len)--;\n-  first = div(*buf++, 40);\n-  *oid++ = (uint32_t)first.quot;\n-  *oid++ = (uint32_t)first.rem;\n-\n-  while(buf != buf_end) {\n-    --(*oid_len);\n-    if(*oid_len == 0) {\n-      return NULL;\n-    }\n-\n-    int i;\n-\n-    *oid = (uint32_t)(*buf & 0x7F);\n-    for(i = 0; i < 4; i++) {\n-      (*buff_len)--;\n-      if((*buf++ & 0x80) == 0) {\n-        break;\n-      }\n-\n-      *oid <<= 7;\n-      *oid |= (*buf & 0x7F);\n-    }\n-\n-    ++oid;\n-  }\n-\n-  *oid++ = ((uint32_t)-1);\n-  *oid_len = (uint32_t)(oid - start);\n-\n-  return buf;\n-}\n-/*---------------------------------------------------------------------------*/\n-void\n-snmp_oid_copy(uint32_t *dst, uint32_t *src)\n-{\n-  uint8_t i;\n-\n-  i = 0;\n-  while(src[i] != ((uint32_t)-1)) {\n-    dst[i] = src[i];\n-    i++;\n-  }\n-  /*\n-   * Copy the \"null\" terminator\n-   */\n-  dst[i] = src[i];\n-}\n-/*---------------------------------------------------------------------------*/\n-#if LOG_LEVEL == LOG_LEVEL_DBG\n-void\n-snmp_oid_print(uint32_t *oid)\n-{\n-  uint8_t i;\n-\n-  i = 0;\n-  LOG_DBG(\"{\");\n-  while(oid[i] != ((uint32_t)-1)) {\n-    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n-    i++;\n-    if(oid[i] != ((uint32_t)-1)) {\n-      LOG_DBG_(\".\");\n-    }\n-  }\n-  LOG_DBG_(\"}\\n\");\n-}\n-#endif /* LOG_LEVEL == LOG_LEVEL_DBG  */"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp-oid.h",
            "diff": "@@ -1,108 +0,0 @@\n-/*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- *\n- * 3. Neither the name of the copyright holder nor the names of its\n- *    contributors may be used to endorse or promote products derived\n- *    from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE\n- * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n- * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n- * OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-/*---------------------------------------------------------------------------*/\n-\n-/**\n- * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n- * \\author\n- *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n- */\n-\n-/**\n- * \\addtogroup snmp\n- * @{\n- */\n-\n-#ifndef SNMP_OID_H_\n-#define SNMP_OID_H_\n-\n-#include \"snmp.h\"\n-\n-#define SNMP_DATA_TYPE_OBJECT                   0x06\n-\n-/**\n- * @brief Compares to oids\n- *\n- * @param oid1 First Oid\n- * @param oid2 Second Oid\n- *\n- * @return < 0 if oid1 < oid2, > 0 if oid1 > oid2 and 0 if they are equal\n- */\n-int\n-snmp_oid_cmp_oid(uint32_t *oid1, uint32_t *oid2);\n-\n-/**\n- * @brief Encodes a Oid\n- *\n- * @param out A pointer to the end of the buffer\n- * @param out_len A pointer to the buffer length\n- * @param oid The Oid\n- *\n- * @return NULL if error or the next entry in the buffer\n- */\n-unsigned char *\n-snmp_oid_encode_oid(unsigned char *out, uint32_t *out_len, uint32_t *oid);\n-\n-/**\n- * @brief Decodes a Oid\n- *\n- * @param buf A pointer to the beginning of the buffer\n- * @param buf_len A pointer to the buffer length\n- * @param oid A pointer to the oid array\n- * @param oid_len A pointer to the oid length\n- *\n- * @return NULL if error or the first entry after the oid in the buffer\n- */\n-unsigned char *\n-snmp_oid_decode_oid(unsigned char *buf, uint32_t *buf_len, uint32_t *oid, uint32_t *oid_len);\n-\n-/**\n- * @brief Copies a Oid\n- *\n- * @param dst A pointer to the destination array\n- * @param src A pointer to the source array\n- */\n-void\n-snmp_oid_copy(uint32_t *dst, uint32_t *src);\n-\n-#if LOG_LEVEL == LOG_LEVEL_DBG\n-/**\n- * @brief Prints a oid\n- *\n- * @param oid A oid\n- */\n-void\n-snmp_oid_print(uint32_t *oid);\n-#endif /* LOG_LEVEL == LOG_LEVEL_DBG */\n-\n-#endif /* SNMP_OID_H_ */\n-/** @} */"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp.c",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,12 +32,13 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the process\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n \n #include \"contiki.h\"\n+#include \"contiki-net.h\"\n \n #include \"snmp.h\"\n #include \"snmp-mib.h\"\n@@ -50,37 +51,7 @@\n #define SNMP_SERVER_PORT UIP_HTONS(SNMP_PORT)\n PROCESS(snmp_process, \"SNMP Process\");\n \n-static struct uip_udp_conn *snmp_udp_conn = NULL;\n-\n-/*---------------------------------------------------------------------------*/\n-static void\n-snmp_process_data(void)\n-{\n-  static unsigned char packet[SNMP_MAX_PACKET_SIZE];\n-  unsigned char *packet_end;\n-  static uint32_t packet_len;\n-\n-  packet_end = packet + sizeof(packet) - 1;\n-  packet_len = 0;\n-\n-  LOG_DBG(\"receiving UDP datagram from [\");\n-  LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr);\n-  LOG_DBG_(\"]:%u\", uip_ntohs(UIP_UDP_BUF->srcport));\n-  LOG_DBG_(\" Length: %u\\n\", uip_datalen());\n-\n-  /*\n-   * Handle the request\n-   */\n-  if((packet_end = snmp_engine(uip_appdata, uip_datalen(), packet_end, &packet_len)) == NULL) {\n-    LOG_DBG(\"Error while handling the request\\n\");\n-  } else {\n-    LOG_DBG(\"Sending response\\n\");\n-    /*\n-     * Send the response\n-     */\n-    uip_udp_packet_sendto(snmp_udp_conn, packet_end, packet_len, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport);\n-  }\n-}\n+static struct uip_udp_conn *snmp_udp_conn;\n /*---------------------------------------------------------------------------*/\n void\n snmp_init()\n@@ -95,6 +66,8 @@ PROCESS_THREAD(snmp_process, ev, data)\n {\n   PROCESS_BEGIN();\n \n+  snmp_packet_t snmp_packet;\n+\n   /* new connection with remote host */\n   snmp_udp_conn = udp_new(NULL, 0, NULL);\n   udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n@@ -103,11 +76,35 @@ PROCESS_THREAD(snmp_process, ev, data)\n   while(1) {\n     PROCESS_YIELD();\n \n-    if(ev == tcpip_event) {\n-      if(uip_newdata()) {\n-        snmp_process_data();\n-      }\n+    if(ev != tcpip_event) {\n+      continue;\n+    }\n+\n+    if(!uip_newdata()) {\n+      continue;\n     }\n+\n+    LOG_DBG(\"receiving UDP datagram from [\");\n+    LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr);\n+    LOG_DBG_(\"]:%u\", uip_ntohs(UIP_UDP_BUF->srcport));\n+    LOG_DBG_(\" Length: %u\\n\", uip_datalen());\n+\n+    /* Setup SNMP packet */\n+    snmp_packet.in = (uint8_t *)uip_appdata;\n+    snmp_packet.used = uip_datalen();\n+\n+    snmp_packet.out = (uint8_t *)(uip_appdata + UIP_BUFSIZE - UIP_IPUDPH_LEN);\n+    snmp_packet.max = UIP_BUFSIZE - UIP_IPUDPH_LEN;\n+\n+    /* Handle the request */\n+    if(!snmp_engine(&snmp_packet)) {\n+      LOG_DBG(\"Error while handling the request\\n\");\n+      continue;\n+    }\n+\n+    LOG_DBG(\"Sending response\\n\");\n+    /* Send the response */\n+    uip_udp_packet_sendto(snmp_udp_conn, snmp_packet.out, snmp_packet.used, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport);\n   } /* while (1) */\n \n   PROCESS_END();"
        },
        {
            "filename": "os/net/app-layer/snmp/snmp.h",
            "diff": "@@ -1,5 +1,5 @@\n /*\n- * Copyright (C) 2019 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n+ * Copyright (C) 2019-2020 Yago Fontoura do Rosario <yago.rosario@hotmail.com.br>\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n@@ -32,7 +32,7 @@\n \n /**\n  * \\file\n- *      An implementation of the Simple Network Management Protocol (RFC 3411-3418)\n+ *      SNMP Implementation of the process\n  * \\author\n  *      Yago Fontoura do Rosario <yago.rosario@hotmail.com.br\n  */\n@@ -41,7 +41,7 @@\n  * \\addtogroup apps\n  * @{\n  *\n- * \\defgroup snmp SNMP (Simple Network Management Protocol)\n+ * \\addtogroup snmp An implementation of SNMP\n  * @{\n  *\n  * This is an implementation of the Simple Network Management Protocol\n@@ -50,8 +50,14 @@\n #ifndef SNMP_H_\n #define SNMP_H_\n \n+/**\n+ * \\addtogroup SNMPInternal SNMP Internal API\n+ * @{\n+ *\n+ * This group contains all the functions that can be used inside the OS level.\n+ */\n+\n #include \"contiki.h\"\n-#include \"contiki-net.h\"\n \n #include \"sys/log.h\"\n \n@@ -61,8 +67,10 @@\n #include <stdint.h>\n \n /**\n- * \\defgroup SNMPDefine SNMP Defines\n+ * \\addtogroup SNMPCore SNMP Core\n  * @{\n+ *\n+ * This group contains the SNMP MIB implementation\n  */\n \n /**\n@@ -79,13 +87,6 @@\n  */\n #define SNMP_STATUS_NO_SUCH_NAME 2\n \n-/** @} */\n-\n-/**\n- * \\defgroup SNMPStructs SNMP Structs\n- * @{\n- */\n-\n /**\n  * @brief The SNMP header struct\n  */\n@@ -120,47 +121,46 @@ typedef struct snmp_header_s {\n    */\n   uint32_t request_id;\n   /**\n-   * @brief Union to hold the error status or the non repeaters\n-   *\n-   * @remarks A union was used since these values cannot co-exist\n+   * @brief The error status\n    */\n-  union error_status_non_repeaters_u {\n-    /**\n-     * @brief The error status\n-     */\n-    uint32_t error_status;\n-    /**\n-     * @brief The non repeaters\n-     */\n-    uint32_t non_repeaters;\n-  } error_status_non_repeaters;\n+  uint32_t error_status;\n   /**\n-   * @brief Union to hold the error index or the max repetitions\n-   *\n-   * @remarks A union was used since these values cannot co-exist\n+   * @brief The non repeaters\n    */\n-  union error_index_max_repetitions_u {\n-    /**\n-     * @brief The error index\n-     */\n-    uint32_t error_index;\n-    /**\n-     * @brief The max repetitions\n-     */\n-    uint32_t max_repetitions;\n-  } error_index_max_repetitions;\n+  uint32_t non_repeaters;\n+  /**\n+   * @brief The error index\n+   */\n+  uint32_t error_index;\n+  /**\n+   * @brief The max repetitions\n+   */\n+  uint32_t max_repetitions;\n } snmp_header_t;\n \n+/**\n+ * @brief The OID struct\n+ */\n+typedef struct snmp_oid_s {\n+  /**\n+   * @brief The OID\n+   */\n+  uint32_t data[SNMP_MSG_OID_MAX_LEN];\n+  /**\n+   * @brief The OID length\n+   *\n+   */\n+  uint8_t length;\n+} snmp_oid_t;\n+\n /**\n  * @brief The varbind struct\n  */\n typedef struct snmp_varbind_s {\n   /**\n    * @brief The OID\n-   *\n-   * @remarks The length is configurable\n    */\n-  uint32_t oid[SNMP_MSG_OID_MAX_LEN];\n+  snmp_oid_t oid;\n   /**\n    * @brief The type in this varbind\n    */\n@@ -170,15 +170,15 @@ typedef struct snmp_varbind_s {\n    *\n    * @remarks A union is used since the varbind can only have one value of one type\n    */\n-  union snmp_varbind_val_u {\n+  union {\n     /**\n      * @brief The integer value\n      */\n     uint32_t integer;\n     /**\n      * @brief A struct that contains the string\n      */\n-    struct snmp_varbind_string_s {\n+    struct {\n       /**\n        * @brief A pointer to the string value from this varbind\n        *\n@@ -193,18 +193,38 @@ typedef struct snmp_varbind_s {\n       uint32_t length;\n     } string;\n     /**\n-     * @brief A pointer to the beggining of a oid array\n+     * @brief The OID value\n      */\n-    uint32_t *oid;\n+    snmp_oid_t oid;\n   } value;\n } snmp_varbind_t;\n \n-/** @}*/\n-\n /**\n- * \\defgroup SNMPFunctions SNMP Functions\n- * @{\n+ * @brief The packet struct\n+ *\n  */\n+typedef struct {\n+  /**\n+   * @brief The number os bytes used\n+   *\n+   */\n+  uint16_t used;\n+  /**\n+   * @brief The maximum number of bytes\n+   *\n+   */\n+  uint16_t max;\n+  /**\n+   * @brief The pointer used for the incoming packet\n+   *\n+   */\n+  uint8_t *in;\n+  /**\n+   * @brief The pointer used for the outgoing packet\n+   *\n+   */\n+  uint8_t *out;\n+} snmp_packet_t;\n \n /**\n  * @brief Initializes the SNMP engine\n@@ -214,6 +234,10 @@ snmp_init();\n \n /** @}*/\n \n+/** @}*/\n+\n #endif /* SNMP_H_ */\n+\n /** @} */\n+\n /** @} */"
        },
        {
            "filename": "tests/08-native-runs/10-snmp-server.sh",
            "diff": "@@ -8,40 +8,74 @@ BASENAME=$(basename $0 .sh)\n \n IPADDR=fd00::302:304:506:708\n \n-# Starting Contiki-NG native node\n-echo \"Starting native node\"\n-make -C $CONTIKI/examples/snmp-server > make.log 2> make.err\n-sudo $CONTIKI/examples/snmp-server/snmp-server.native > node.log 2> node.err &\n-CPID=$!\n-sleep 2\n-\n-# Do Walk\n-echo \"WALK!\"\n-snmpwalk -t 4 -v 2c -c public udp6:[$IPADDR]:161 1 | tee $BASENAME.log\n-# Fetch snmpwalk status code (not $? because this is piped)\n-STATUS=${PIPESTATUS[0]}\n-\n-echo \"Closing native node\"\n-sleep 2\n-kill_bg $CPID\n-\n-if [ $STATUS -eq 0 ] ; then\n-  cp $BASENAME.log $BASENAME.testlog\n-  printf \"%-32s TEST OK\\n\" \"$BASENAME\" | tee $BASENAME.testlog;\n-else\n-  echo \"==== make.log ====\" ; cat make.log;\n-  echo \"==== make.err ====\" ; cat make.err;\n-  echo \"==== node.log ====\" ; cat node.log;\n-  echo \"==== node.err ====\" ; cat node.err;\n-  echo \"==== $BASENAME.log ====\" ; cat $BASENAME.log;\n-\n-  printf \"%-32s TEST FAIL\\n\" \"$BASENAME\" | tee $BASENAME.testlog;\n-fi\n-\n-rm make.log\n-rm make.err\n-rm node.log\n-rm node.err\n+test_handler () {\n+  # Starting Contiki-NG native node\n+  make -C $CONTIKI/examples/snmp-server > make.log 2> make.err\n+  sudo $CONTIKI/examples/snmp-server/snmp-server.native > node.log 2> node.err &\n+  CPID=$!\n+  sleep 2\n+\n+  $1 2>&1 | grep -z -E \"$2\" >> $BASENAME.log 2>&1 \n+  STATUS=$?\n+  \n+  sleep 2\n+  kill_bg $CPID > /dev/null 2>&1\n+  wait $CPID > /dev/null 2>&1\n+\n+  if [ $STATUS -eq 0 ] ; then\n+    cp $BASENAME.log $BASENAME.testlog\n+    printf \"%-32s TEST OK\\n\" \"$BASENAME\" | tee $BASENAME.testlog;\n+  else\n+    echo \"==== make.log ====\" ; cat make.log;\n+    echo \"==== make.err ====\" ; cat make.err;\n+    echo \"==== node.log ====\" ; cat node.log;\n+    echo \"==== node.err ====\" ; cat node.err;\n+    echo \"==== $BASENAME.log ====\" ; cat $BASENAME.log;\n+    \n+    printf \"%-32s TEST FAIL\\n\" \"$BASENAME\" | tee $BASENAME.testlog;\n+  fi\n+\n+  rm make.log\n+  rm make.err\n+  rm node.log\n+  rm node.err\n+}\n+\n+# v1\n+## snmpget - pass\n+test_handler \"snmpget -t2 -v1 -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1.0\" \"iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0\"\n+## snmpwalk - pass\n+test_handler \"snmpwalk -t2 -v1 -c public udp6:[$IPADDR]:161 1\" \"iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.2\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.3\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.4\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.5\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.6\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.7\\.0.*End of MIB\"\n+\n+## snmpget - fail - noSuchName\n+test_handler \"snmpget -t2 -v1 -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1\" \".*noSuchName.*\"\n+## snmpget - fail - timeout - 16 Ids in OID\n+test_handler \"snmpget -t2 -v1 -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1.1.3.6.1.2.1.1.1.1\" \"Timeout.*\"\n+## snmpget - fail - timeout - 4 OIDs\n+test_handler \"snmpget -t2 -v1 -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1.0 1.3.6.1.2.1.1.1.0 1.3.6.1.2.1.1.1.0 1.3.6.1.2.1.1.1.0\" \"Timeout.*\"\n+\n+# v2\n+## snmpget - pass\n+test_handler \"snmpget -t2 -v2c -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1.0\" \"iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0\"\n+## snmpwalk - pass\n+test_handler \"snmpwalk -t2 -v2c -c public udp6:[$IPADDR]:161 1\" \"iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.2\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.3\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.4\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.5\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.6\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.7\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.7\\.0\"\n+## snmpbulkget two non-repeater - pass\n+test_handler \"snmpbulkget -v2c -Cn2 -c public udp6:[$IPADDR]:161 1 1\" \"iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0\"\n+## snmpbulkget two max-repetitions - pass\n+test_handler \"snmpbulkget -t2 -v2c -Cr2 -c public udp6:[$IPADDR]:161 1\" \"iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.2\\.0\"\n+## snmpbulkget one non-repeater and two max-repetitions - pass\n+test_handler \"snmpbulkget -t2 -v2c -Cn1 -Cr2 -c public udp6:[$IPADDR]:161 1 1\" \"iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.1\\.0.*iso\\.3\\.6\\.1\\.2\\.1\\.1\\.2\\.0\"\n+\n+## snmpget - fail - noSuchName\n+test_handler \"snmpget -t2 -v2c -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1\" \".*No Such Instance currently.*\"\n+## snmpget - fail - timeout - 16 Ids in OID\n+test_handler \"snmpget -t2 -v2c -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1.1.3.6.1.2.1.1.1.1\" \"Timeout.*\"\n+## snmpget - fail - timeout - 4 OIDs\n+test_handler \"snmpget -t2 -v2c -c public udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1.0 1.3.6.1.2.1.1.1.0 1.3.6.1.2.1.1.1.0 1.3.6.1.2.1.1.1.0\" \"Timeout.*\"\n+\n+#v3\n+## snmpget - fail - timeout - v3 not implemented\n+test_handler \"snmpget -t2 -v3 -l authPriv -u snmp-poller -a SHA -A \\\"PASSWORD1\\\" -x AES -X \\\"PASSWORD1\\\" udp6:[$IPADDR]:161 1.3.6.1.2.1.1.1.0\" \".*Timeout.*\"\n \n # We do not want Make to stop -> Return 0\n # The Makefile will check if a log contains FAIL at the end"
        }
    ],
    "commitTime": "2020-10-19 00:01:44"
}