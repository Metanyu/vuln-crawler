{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "LOCAL",
        "attackComplexity": "LOW",
        "privilegesRequired": "LOW",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "NONE",
        "availability": "NONE"
    },
    "credit": [
        "Xingyuan Mo"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 5.5,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "LOCAL",
                "attackComplexity": "LOW",
                "privilegesRequired": "LOW",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "NONE",
                "availability": "NONE"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 5.5,
    "disclosureTime": "2023-12-09 23:44:12",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.06910",
        "probability": "0.00043"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-UNMANAGED-TORVALDSLINUX-6115217",
    "identifiers": {
        "CVE": [
            "CVE-2023-50431"
        ],
        "CWE": [
            "CWE-200"
        ]
    },
    "language": "cpp",
    "malicious": false,
    "packageManager": "unmanaged",
    "publicationTime": "2023-12-11 17:00:29",
    "remediation": "Upgrade torvalds/linux to version 6.1-rc1 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Information Exposure",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Information Exposure in the habanalabs_ioctl.c file. An attacker can obtain sensitive information from a leakage of kernel heap data to user mode. "
    },
    "source_code": [
        {
            "filename": "drivers/misc/habanalabs/common/firmware_if.c",
            "diff": "@@ -2988,3 +2988,49 @@ void hl_fw_set_max_power(struct hl_device *hdev)\n \tif (rc)\n \t\tdev_err(hdev->dev, \"Failed to set max power, error %d\\n\", rc);\n }\n+\n+static int hl_fw_get_sec_attest_data(struct hl_device *hdev, u32 packet_id, void *data, u32 size,\n+\t\t\t\t\tu32 nonce, u32 timeout)\n+{\n+\tstruct cpucp_packet pkt = {};\n+\tdma_addr_t req_dma_addr;\n+\tvoid *req_cpu_addr;\n+\tint rc;\n+\n+\treq_cpu_addr = hl_cpu_accessible_dma_pool_alloc(hdev, size, &req_dma_addr);\n+\tif (!data) {\n+\t\tdev_err(hdev->dev,\n+\t\t\t\"Failed to allocate DMA memory for CPU-CP packet %u\\n\", packet_id);\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\tmemset(data, 0, size);\n+\n+\tpkt.ctl = cpu_to_le32(packet_id << CPUCP_PKT_CTL_OPCODE_SHIFT);\n+\tpkt.addr = cpu_to_le64(req_dma_addr);\n+\tpkt.data_max_size = cpu_to_le32(size);\n+\tpkt.nonce = cpu_to_le32(nonce);\n+\n+\trc = hdev->asic_funcs->send_cpu_message(hdev, (u32 *) &pkt, sizeof(pkt),\n+\t\t\t\t\ttimeout, NULL);\n+\tif (rc) {\n+\t\tdev_err(hdev->dev,\n+\t\t\t\"Failed to handle CPU-CP pkt %u, error %d\\n\", packet_id, rc);\n+\t\tgoto out;\n+\t}\n+\n+\tmemcpy(data, req_cpu_addr, size);\n+\n+out:\n+\thl_cpu_accessible_dma_pool_free(hdev, size, req_cpu_addr);\n+\n+\treturn rc;\n+}\n+\n+int hl_fw_get_sec_attest_info(struct hl_device *hdev, struct cpucp_sec_attest_info *sec_attest_info,\n+\t\t\t\tu32 nonce)\n+{\n+\treturn hl_fw_get_sec_attest_data(hdev, CPUCP_PACKET_SEC_ATTEST_GET, sec_attest_info,\n+\t\t\t\t\tsizeof(struct cpucp_sec_attest_info), nonce,\n+\t\t\t\t\tHL_CPUCP_SEC_ATTEST_INFO_TINEOUT_USEC);\n+}"
        },
        {
            "filename": "drivers/misc/habanalabs/common/habanalabs.h",
            "diff": "@@ -66,6 +66,7 @@ struct hl_fpriv;\n #define HL_CPUCP_INFO_TIMEOUT_USEC\t10000000 /* 10s */\n #define HL_CPUCP_EEPROM_TIMEOUT_USEC\t10000000 /* 10s */\n #define HL_CPUCP_MON_DUMP_TIMEOUT_USEC\t10000000 /* 10s */\n+#define HL_CPUCP_SEC_ATTEST_INFO_TINEOUT_USEC 10000000 /* 10s */\n \n #define HL_FW_STATUS_POLL_INTERVAL_USEC\t\t10000 /* 10ms */\n #define HL_FW_COMMS_STATUS_PLDM_POLL_INTERVAL_USEC\t1000000 /* 1s */\n@@ -3748,6 +3749,8 @@ int hl_get_pwm_info(struct hl_device *hdev, int sensor_index, u32 attr, long *va\n void hl_set_pwm_info(struct hl_device *hdev, int sensor_index, u32 attr, long value);\n long hl_fw_get_max_power(struct hl_device *hdev);\n void hl_fw_set_max_power(struct hl_device *hdev);\n+int hl_fw_get_sec_attest_info(struct hl_device *hdev, struct cpucp_sec_attest_info *sec_attest_info,\n+\t\t\t\tu32 nonce);\n int hl_set_voltage(struct hl_device *hdev, int sensor_index, u32 attr, long value);\n int hl_set_current(struct hl_device *hdev, int sensor_index, u32 attr, long value);\n int hl_set_power(struct hl_device *hdev, int sensor_index, u32 attr, long value);"
        },
        {
            "filename": "drivers/misc/habanalabs/common/habanalabs_ioctl.c",
            "diff": "@@ -662,6 +662,55 @@ static int dev_mem_alloc_page_sizes_info(struct hl_fpriv *hpriv, struct hl_info_\n \treturn copy_to_user(out, &info, min_t(size_t, max_size, sizeof(info))) ? -EFAULT : 0;\n }\n \n+static int sec_attest_info(struct hl_fpriv *hpriv, struct hl_info_args *args)\n+{\n+\tvoid __user *out = (void __user *) (uintptr_t) args->return_pointer;\n+\tstruct cpucp_sec_attest_info *sec_attest_info;\n+\tstruct hl_info_sec_attest *info;\n+\tu32 max_size = args->return_size;\n+\tint rc;\n+\n+\tif ((!max_size) || (!out))\n+\t\treturn -EINVAL;\n+\n+\tsec_attest_info = kmalloc(sizeof(*sec_attest_info), GFP_KERNEL);\n+\tif (!sec_attest_info)\n+\t\treturn -ENOMEM;\n+\n+\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n+\tif (!info) {\n+\t\trc = -ENOMEM;\n+\t\tgoto free_sec_attest_info;\n+\t}\n+\n+\trc = hl_fw_get_sec_attest_info(hpriv->hdev, sec_attest_info, args->sec_attest_nonce);\n+\tif (rc)\n+\t\tgoto free_info;\n+\n+\tinfo->nonce = le32_to_cpu(sec_attest_info->nonce);\n+\tinfo->pcr_quote_len = le16_to_cpu(sec_attest_info->pcr_quote_len);\n+\tinfo->pub_data_len = le16_to_cpu(sec_attest_info->pub_data_len);\n+\tinfo->certificate_len = le16_to_cpu(sec_attest_info->certificate_len);\n+\tinfo->pcr_num_reg = sec_attest_info->pcr_num_reg;\n+\tinfo->pcr_reg_len = sec_attest_info->pcr_reg_len;\n+\tinfo->quote_sig_len = sec_attest_info->quote_sig_len;\n+\tmemcpy(&info->pcr_data, &sec_attest_info->pcr_data, sizeof(info->pcr_data));\n+\tmemcpy(&info->pcr_quote, &sec_attest_info->pcr_quote, sizeof(info->pcr_quote));\n+\tmemcpy(&info->public_data, &sec_attest_info->public_data, sizeof(info->public_data));\n+\tmemcpy(&info->certificate, &sec_attest_info->certificate, sizeof(info->certificate));\n+\tmemcpy(&info->quote_sig, &sec_attest_info->quote_sig, sizeof(info->quote_sig));\n+\n+\trc = copy_to_user(out, info,\n+\t\t\t\tmin_t(size_t, max_size, sizeof(*info))) ? -EFAULT : 0;\n+\n+free_info:\n+\tkfree(info);\n+free_sec_attest_info:\n+\tkfree(sec_attest_info);\n+\n+\treturn rc;\n+}\n+\n static int eventfd_register(struct hl_fpriv *hpriv, struct hl_info_args *args)\n {\n \tint rc;\n@@ -844,6 +893,9 @@ static int _hl_info_ioctl(struct hl_fpriv *hpriv, void *data,\n \tcase HL_INFO_DRAM_PENDING_ROWS:\n \t\treturn dram_pending_rows_info(hpriv, args);\n \n+\tcase HL_INFO_SECURED_ATTESTATION:\n+\t\treturn sec_attest_info(hpriv, args);\n+\n \tcase HL_INFO_REGISTER_EVENTFD:\n \t\treturn eventfd_register(hpriv, args);\n "
        },
        {
            "filename": "drivers/misc/habanalabs/include/common/cpucp_if.h",
            "diff": "@@ -629,6 +629,12 @@ enum pq_init_status {\n  * CPUCP_PACKET_ENGINE_CORE_ASID_SET -\n  *       Packet to perform engine core ASID configuration\n  *\n+ * CPUCP_PACKET_SEC_ATTEST_GET -\n+ *       Get the attestaion data that is collected during various stages of the\n+ *       boot sequence. the attestation data is also hashed with some unique\n+ *       number (nonce) provided by the host to prevent replay attacks.\n+ *       public key and certificate also provided as part of the FW response.\n+ *\n  * CPUCP_PACKET_MONITOR_DUMP_GET -\n  *       Get monitors registers dump from the CpuCP kernel.\n  *       The CPU will put the registers dump in the a buffer allocated by the driver\n@@ -691,15 +697,15 @@ enum cpucp_packet_id {\n \tCPUCP_PACKET_RESERVED,\t\t\t/* not used */\n \tCPUCP_PACKET_ENGINE_CORE_ASID_SET,\t/* internal */\n \tCPUCP_PACKET_RESERVED2,\t\t\t/* not used */\n+\tCPUCP_PACKET_SEC_ATTEST_GET,\t\t/* internal */\n \tCPUCP_PACKET_RESERVED3,\t\t\t/* not used */\n \tCPUCP_PACKET_RESERVED4,\t\t\t/* not used */\n-\tCPUCP_PACKET_RESERVED5,\t\t\t/* not used */\n \tCPUCP_PACKET_MONITOR_DUMP_GET,\t\t/* debugfs */\n+\tCPUCP_PACKET_RESERVED5,\t\t\t/* not used */\n \tCPUCP_PACKET_RESERVED6,\t\t\t/* not used */\n \tCPUCP_PACKET_RESERVED7,\t\t\t/* not used */\n \tCPUCP_PACKET_RESERVED8,\t\t\t/* not used */\n \tCPUCP_PACKET_RESERVED9,\t\t\t/* not used */\n-\tCPUCP_PACKET_RESERVED10,\t\t/* not used */\n \tCPUCP_PACKET_ACTIVE_STATUS_SET,\t\t/* internal */\n \tCPUCP_PACKET_ID_MAX\t\t\t/* must be last */\n };\n@@ -794,6 +800,9 @@ struct cpucp_packet {\n \t\t * result cannot be used to hold general purpose data.\n \t\t */\n \t\t__le32 status_mask;\n+\n+\t\t/* random, used once number, for security packets */\n+\t\t__le32 nonce;\n \t};\n \n \t/* For NIC requests */\n@@ -1219,6 +1228,70 @@ enum cpu_reset_status {\n \tCPU_RST_STATUS_SOFT_RST_DONE = 1,\n };\n \n+#define SEC_PCR_DATA_BUF_SZ\t256\n+#define SEC_PCR_QUOTE_BUF_SZ\t510\t/* (512 - 2) 2 bytes used for size */\n+#define SEC_SIGNATURE_BUF_SZ\t255\t/* (256 - 1) 1 byte used for size */\n+#define SEC_PUB_DATA_BUF_SZ\t510\t/* (512 - 2) 2 bytes used for size */\n+#define SEC_CERTIFICATE_BUF_SZ\t2046\t/* (2048 - 2) 2 bytes used for size */\n+\n+/*\n+ * struct cpucp_sec_attest_info - attestation report of the boot\n+ * @pcr_data: raw values of the PCR registers\n+ * @pcr_num_reg: number of PCR registers in the pcr_data array\n+ * @pcr_reg_len: length of each PCR register in the pcr_data array (bytes)\n+ * @nonce: number only used once. random number provided by host. this also\n+ *\t    passed to the quote command as a qualifying data.\n+ * @pcr_quote_len: length of the attestation quote data (bytes)\n+ * @pcr_quote: attestation report data structure\n+ * @quote_sig_len: length of the attestation report signature (bytes)\n+ * @quote_sig: signature structure of the attestation report\n+ * @pub_data_len: length of the public data (bytes)\n+ * @public_data: public key for the signed attestation\n+ *\t\t (outPublic + name + qualifiedName)\n+ * @certificate_len: length of the certificate (bytes)\n+ * @certificate: certificate for the attestation signing key\n+ */\n+struct cpucp_sec_attest_info {\n+\t__u8 pcr_data[SEC_PCR_DATA_BUF_SZ];\n+\t__u8 pcr_num_reg;\n+\t__u8 pcr_reg_len;\n+\t__le16 pad0;\n+\t__le32 nonce;\n+\t__le16 pcr_quote_len;\n+\t__u8 pcr_quote[SEC_PCR_QUOTE_BUF_SZ];\n+\t__u8 quote_sig_len;\n+\t__u8 quote_sig[SEC_SIGNATURE_BUF_SZ];\n+\t__le16 pub_data_len;\n+\t__u8 public_data[SEC_PUB_DATA_BUF_SZ];\n+\t__le16 certificate_len;\n+\t__u8 certificate[SEC_CERTIFICATE_BUF_SZ];\n+};\n+\n+/*\n+ * struct cpucp_dev_info_signed - device information signed by a secured device\n+ * @info: device information structure as defined above\n+ * @nonce: number only used once. random number provided by host. this number is\n+ *\t   hashed and signed along with the device information.\n+ * @info_sig_len: length of the attestation signature (bytes)\n+ * @info_sig: signature of the info + nonce data.\n+ * @pub_data_len: length of the public data (bytes)\n+ * @public_data: public key info signed info data\n+ *\t\t (outPublic + name + qualifiedName)\n+ * @certificate_len: length of the certificate (bytes)\n+ * @certificate: certificate for the signing key\n+ */\n+struct cpucp_dev_info_signed {\n+\tstruct cpucp_info info;\t/* assumed to be 64bit aligned */\n+\t__le32 nonce;\n+\t__le32 pad0;\n+\t__u8 info_sig_len;\n+\t__u8 info_sig[SEC_SIGNATURE_BUF_SZ];\n+\t__le16 pub_data_len;\n+\t__u8 public_data[SEC_PUB_DATA_BUF_SZ];\n+\t__le16 certificate_len;\n+\t__u8 certificate[SEC_CERTIFICATE_BUF_SZ];\n+};\n+\n /*\n  * struct dcore_monitor_regs_data - DCORE monitor regs data.\n  * the structure follows sync manager block layout. relevant only to Gaudi."
        },
        {
            "filename": "include/uapi/misc/habanalabs.h",
            "diff": "@@ -773,6 +773,7 @@ enum hl_server_type {\n  *                            Razwi initiator.\n  *                            Razwi cause, was it a page fault or MMU access error.\n  * HL_INFO_DEV_MEM_ALLOC_PAGE_SIZES - Retrieve valid page sizes for device memory allocation\n+ * HL_INFO_SECURED_ATTESTATION - Retrieve attestation report of the boot.\n  * HL_INFO_REGISTER_EVENTFD   - Register eventfd for event notifications.\n  * HL_INFO_UNREGISTER_EVENTFD - Unregister eventfd\n  * HL_INFO_GET_EVENTS         - Retrieve the last occurred events\n@@ -802,6 +803,7 @@ enum hl_server_type {\n #define HL_INFO_CS_TIMEOUT_EVENT\t\t24\n #define HL_INFO_RAZWI_EVENT\t\t\t25\n #define HL_INFO_DEV_MEM_ALLOC_PAGE_SIZES\t26\n+#define HL_INFO_SECURED_ATTESTATION\t\t27\n #define HL_INFO_REGISTER_EVENTFD\t\t28\n #define HL_INFO_UNREGISTER_EVENTFD\t\t29\n #define HL_INFO_GET_EVENTS\t\t\t30\n@@ -1133,6 +1135,45 @@ struct hl_info_dev_memalloc_page_sizes {\n \t__u64 page_order_bitmask;\n };\n \n+#define SEC_PCR_DATA_BUF_SZ\t256\n+#define SEC_PCR_QUOTE_BUF_SZ\t510\t/* (512 - 2) 2 bytes used for size */\n+#define SEC_SIGNATURE_BUF_SZ\t255\t/* (256 - 1) 1 byte used for size */\n+#define SEC_PUB_DATA_BUF_SZ\t510\t/* (512 - 2) 2 bytes used for size */\n+#define SEC_CERTIFICATE_BUF_SZ\t2046\t/* (2048 - 2) 2 bytes used for size */\n+\n+/*\n+ * struct hl_info_sec_attest - attestation report of the boot\n+ * @nonce: number only used once. random number provided by host. this also passed to the quote\n+ *         command as a qualifying data.\n+ * @pcr_quote_len: length of the attestation quote data (bytes)\n+ * @pub_data_len: length of the public data (bytes)\n+ * @certificate_len: length of the certificate (bytes)\n+ * @pcr_num_reg: number of PCR registers in the pcr_data array\n+ * @pcr_reg_len: length of each PCR register in the pcr_data array (bytes)\n+ * @quote_sig_len: length of the attestation report signature (bytes)\n+ * @pcr_data: raw values of the PCR registers\n+ * @pcr_quote: attestation report data structure\n+ * @quote_sig: signature structure of the attestation report\n+ * @public_data: public key for the signed attestation\n+ *\t\t (outPublic + name + qualifiedName)\n+ * @certificate: certificate for the attestation signing key\n+ */\n+struct hl_info_sec_attest {\n+\t__u32 nonce;\n+\t__u16 pcr_quote_len;\n+\t__u16 pub_data_len;\n+\t__u16 certificate_len;\n+\t__u8 pcr_num_reg;\n+\t__u8 pcr_reg_len;\n+\t__u8 quote_sig_len;\n+\t__u8 pcr_data[SEC_PCR_DATA_BUF_SZ];\n+\t__u8 pcr_quote[SEC_PCR_QUOTE_BUF_SZ];\n+\t__u8 quote_sig[SEC_SIGNATURE_BUF_SZ];\n+\t__u8 public_data[SEC_PUB_DATA_BUF_SZ];\n+\t__u8 certificate[SEC_CERTIFICATE_BUF_SZ];\n+\t__u8 pad0[2];\n+};\n+\n enum gaudi_dcores {\n \tHL_GAUDI_WS_DCORE,\n \tHL_GAUDI_WN_DCORE,\n@@ -1158,6 +1199,7 @@ enum gaudi_dcores {\n  *                           driver. It is possible for the user to allocate buffer larger than\n  *                           needed, hence updating this variable so user will know the exact amount\n  *                           of bytes copied by the kernel to the buffer.\n+ * @sec_attest_nonce: Nonce number used for attestation report.\n  * @pad: Padding to 64 bit.\n  */\n struct hl_info_args {\n@@ -1172,6 +1214,7 @@ struct hl_info_args {\n \t\t__u32 pll_index;\n \t\t__u32 eventfd;\n \t\t__u32 user_buffer_actual_size;\n+\t\t__u32 sec_attest_nonce;\n \t};\n \n \t__u32 pad;"
        }
    ],
    "commitTime": "2022-09-19 12:08:40"
}