{
    "CVSSv3": {
        "CVSS": "3.1",
        "E": "P",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "LOW",
        "availability": "NONE"
    },
    "credit": [
        "PinkDraconian"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 3.7,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "HIGH",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "LOW",
                "availability": "NONE"
            },
            "severity": "low"
        }
    ],
    "cvssScore": 3.7,
    "disclosureTime": "2023-11-24 18:44:03",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.14021",
        "probability": "0.00046"
    },
    "exploitMaturity": "Proof of Concept",
    "id": "SNYK-JAVA-ORGWEBJARSNPM-6097155",
    "identifiers": {
        "CVE": [
            "CVE-2023-48711"
        ],
        "CWE": [
            "CWE-918"
        ]
    },
    "language": "java",
    "malicious": false,
    "packageManager": "maven",
    "publicationTime": "2023-12-07 06:32:01",
    "remediation": "There is no fixed version for org.webjars.npm:google-translate-api-browser . ",
    "severity": "low",
    "socialTrendAlert": false,
    "title": "Server-Side Request Forgery (SSRF)",
    "vulnDescription": {
        "Overview": "org.webjars.npm:google-translate-api-browser is an A free and unlimited API for Google Translate that works in browser Affected versions of this package are vulnerable to Server-Side Request Forgery (SSRF) when input to translateOptions is accepted from the end user. An attacker can manipulate the tld field, causing the application to generate unsafe URLs that point to local resources. This is due to the translateOptions.tld field not being properly sanitized before being included in the Google translate URL. An attacker with control over the translateOptions can set the tld to a payload such as @127.0.0.1 , which results in the full URL becoming https://translate.google.@127.0.0.1/... , where translate.google. is the username used to connect to localhost. This allows the attacker to send requests within internal networks and the local host. If there is an HTTPS application on the internal network with a vulnerability that can be exploited via a GET call, it could be exploited using this vulnerability. "
    },
    "source_code": [
        {
            "filename": "package.json",
            "diff": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"google-translate-api-browser\",\n-  \"version\": \"4.1.1\",\n+  \"version\": \"4.1.3\",\n   \"description\": \"A free and unlimited API for Google Translate that works in browser\",\n   \"repository\": {\n     \"type\": \"git\","
        },
        {
            "filename": "src/generateRequestUrl.ts",
            "diff": "@@ -1,9 +1,17 @@\n import { defaultTranslateOptions } from \"./defaultTranslateOptions\";\n import { TranslateOptions } from \"./TranslateOptions\";\n \n+function validateTLD(tld: string) {\n+  return Boolean(tld.match(/^[a-zA-Z]{2,63}$/));\n+}\n+\n export function generateRequestUrl(options: Partial<Omit<TranslateOptions, 'raw'>> = {}): string {\n   const translateOptions = { ...defaultTranslateOptions, ...options };\n \n+  if (!validateTLD(translateOptions.tld)) {\n+    throw new Error(\"Invalid TLD: Must be 2-63 letters only\")\n+  }\n+\n   const queryParams = {\n     rpcids: translateOptions.rpcids,\n     'source-path': '/',"
        },
        {
            "filename": "src/normaliseResponse.ts",
            "diff": "@@ -29,7 +29,7 @@ export function normaliseResponse(rawBody: string, raw = false): TranslationResu\n   }\n \n   if (!data) {\n-    throw new Error('No data')\n+    throw new Error('Data is either empty or corrupted')\n   }\n \n   const result: TranslationResult = {"
        },
        {
            "filename": "src/translate.server.ts",
            "diff": "@@ -4,13 +4,16 @@ import { TranslateOptions } from \"./TranslateOptions\";\n import { normaliseResponse, TranslationResult } from \"./normaliseResponse\";\n import * as https from 'node:https';\n \n+export function createRequestBody(text: string, translateOptions: Pick<TranslateOptions, \"to\" | \"from\" | \"rpcids\">) {\n+    const encodedData = encodeURIComponent(`[[[\"${translateOptions.rpcids}\",\"[[\\\\\"${text}\\\\\",\\\\\"${translateOptions.from}\\\\\",\\\\\"${translateOptions.to}\\\\\",true],[1]]\",null,\"generic\"]]]`);\n+    return `f.req=${encodedData}&`;\n+}\n+\n export function translate(text: string, options: Partial<TranslateOptions> = {}): Promise<TranslationResult> {\n   const translateOptions = { ...defaultTranslateOptions, ...options };\n \n   return new Promise((resolve, reject) => {\n-    const encodedData = encodeURIComponent(`[[[\"${translateOptions.rpcids}\",\"[[\\\\\"${text}\\\\\",\\\\\"${translateOptions.from}\\\\\",\\\\\"${translateOptions.to}\\\\\",true],[1]]\",null,\"generic\"]]]`);\n-    const body = `f.req=${encodedData}&`;\n-\n+    const body = createRequestBody(text, translateOptions);\n     const url = generateRequestUrl(translateOptions);\n \n     const req = https.request(url, {\n@@ -29,9 +32,7 @@ export function translate(text: string, options: Partial<TranslateOptions> = {})\n       resp.on('end', () => {\n         resolve(normaliseResponse(data))\n       });\n-    }).on('error', (err) => {\n-      reject(err)\n-    })\n+    }).on('error', reject);\n \n     req.write(body);\n     req.end();"
        }
    ],
    "commitTime": "2023-11-22 21:54:10"
}