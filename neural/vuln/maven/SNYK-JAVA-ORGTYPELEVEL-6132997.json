{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 7.5,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "NONE",
                "availability": "HIGH"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 7.5,
    "disclosureTime": "2023-12-18 23:26:52",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.28078",
        "probability": "0.00068"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-JAVA-ORGTYPELEVEL-6132997",
    "identifiers": {
        "CVE": [
            "CVE-2023-50730"
        ],
        "CWE": [
            "CWE-400"
        ]
    },
    "language": "java",
    "malicious": false,
    "packageManager": "maven",
    "publicationTime": "2023-12-20 14:52:18",
    "remediation": "Upgrade org.typelevel:grackle-core_native0.4_3 to version 0.18.0 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Uncontrolled Resource Consumption ('Resource Exhaustion')",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Uncontrolled Resource Consumption ('Resource Exhaustion') via the GraphQL query processing. An attacker can cause a denial of service by sending specially crafted queries that trigger a StackOverflowError . This is only exploitable if the application has untrusted users. Note: No specific knowledge of an application's GraphQL schema would be required to construct a pathological query. ",
        "Workaround": "This vulnerability can be mitigated by interposing a sanitizing layer between untrusted input and Grackle query processing. "
    },
    "source_code": [
        {
            "filename": "build.sbt",
            "diff": "@@ -30,7 +30,7 @@ ThisBuild / scalaVersion        := Scala2\n ThisBuild / crossScalaVersions  := Seq(Scala2, Scala3)\n ThisBuild / tlJdkRelease        := Some(11)\n \n-ThisBuild / tlBaseVersion    := \"0.17\"\n+ThisBuild / tlBaseVersion    := \"0.18\"\n ThisBuild / startYear        := Some(2019)\n ThisBuild / licenses         := Seq(License.Apache2)\n ThisBuild / developers       := List("
        },
        {
            "filename": "modules/core/src/main/scala-2/syntax2.scala",
            "diff": "@@ -19,7 +19,6 @@ import cats.data.NonEmptyChain\n import cats.syntax.all._\n import org.typelevel.literally.Literally\n import grackle.Ast.Document\n-import grackle.GraphQLParser.Document.parseAll\n import grackle.Schema\n \n trait VersionSpecificSyntax {\n@@ -32,26 +31,31 @@ class StringContextOps(val sc: StringContext) extends AnyVal {\n   def doc(args: Any*): Document = macro DocumentLiteral.make\n }\n \n-object SchemaLiteral extends Literally[Schema] {\n+private object SchemaLiteral extends Literally[Schema] {\n   def validate(c: Context)(s: String): Either[String,c.Expr[Schema]] = {\n     import c.universe._\n     def mkError(err: Either[Throwable, NonEmptyChain[Problem]]) =\n       err.fold(\n         t  => s\"Internal error: ${t.getMessage}\",\n         ps => s\"Invalid schema: ${ps.toList.distinct.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")}\",\n       )\n-    Schema(s).toEither.bimap(mkError, _ => c.Expr(q\"_root_.grackle.Schema($s).toOption.get\"))\n+    Schema(s, CompiletimeParsers.schemaParser).toEither.bimap(mkError, _ => c.Expr(q\"_root_.grackle.Schema($s, _root_.grackle.CompiletimeParsers.schemaParser).toOption.get\"))\n   }\n   def make(c: Context)(args: c.Expr[Any]*): c.Expr[Schema] = apply(c)(args: _*)\n }\n \n-object DocumentLiteral extends Literally[Document] {\n+private object DocumentLiteral extends Literally[Document] {\n   def validate(c: Context)(s: String): Either[String,c.Expr[Document]] = {\n     import c.universe._\n-    parseAll(s).bimap(\n-      pf => show\"Invalid document: $pf\",\n-      _  => c.Expr(q\"_root_.grackle.GraphQLParser.Document.parseAll($s).toOption.get\"),\n+    CompiletimeParsers.parser.parseText(s).toEither.bimap(\n+      _.fold(thr => show\"Invalid document: ${thr.getMessage}\", _.toList.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")),\n+      _  => c.Expr(q\"_root_.grackle.CompiletimeParsers.parser.parseText($s).toOption.get\"),\n     )\n   }\n   def make(c: Context)(args: c.Expr[Any]*): c.Expr[Document] = apply(c)(args: _*)\n }\n+\n+object CompiletimeParsers {\n+  val parser: GraphQLParser = GraphQLParser(GraphQLParser.defaultConfig)\n+  val schemaParser: SchemaParser = SchemaParser(parser)\n+}"
        },
        {
            "filename": "modules/core/src/main/scala-3/syntax3.scala",
            "diff": "@@ -18,24 +18,27 @@ package grackle\n import cats.syntax.all._\n import org.typelevel.literally.Literally\n import grackle.Ast.Document\n-import grackle.GraphQLParser.Document.parseAll\n \n trait VersionSpecificSyntax:\n \n   extension (inline ctx: StringContext)\n     inline def schema(inline args: Any*): Schema = ${SchemaLiteral('ctx, 'args)}\n-    inline def doc(inline args: Any*): Document = ${ DocumentLiteral('ctx, 'args) }\n+    inline def doc(inline args: Any*): Document = ${DocumentLiteral('ctx, 'args) }\n \n object SchemaLiteral extends Literally[Schema]:\n   def validate(s: String)(using Quotes) =\n-    Schema(s).toEither.bimap(\n+    Schema(s, CompiletimeParsers.schemaParser).toEither.bimap(\n       nec => s\"Invalid schema:${nec.toList.distinct.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")}\",\n-      _   => '{Schema(${Expr(s)}).toOption.get}\n+      _   => '{Schema(${Expr(s)}, CompiletimeParsers.schemaParser).toOption.get}\n     )\n \n object DocumentLiteral extends Literally[Document]:\n   def validate(s: String)(using Quotes) =\n-    parseAll(s).bimap(\n-      pf => show\"Invalid document: $pf\",\n-      _ => '{parseAll(${Expr(s)}).toOption.get}\n+    CompiletimeParsers.parser.parseText(s).toEither.bimap(\n+      _.fold(thr => show\"Invalid document: ${thr.getMessage}\", _.toList.mkString(\"\\n  \ud83d\udc1e \", \"\\n  \ud83d\udc1e \", \"\\n\")),\n+      _ => '{CompiletimeParsers.parser.parseText(${Expr(s)}).toOption.get}\n     )\n+\n+object CompiletimeParsers:\n+  val parser: GraphQLParser = GraphQLParser(GraphQLParser.defaultConfig)\n+  val schemaParser: SchemaParser = SchemaParser(parser)"
        },
        {
            "filename": "modules/core/src/main/scala/compiler.scala",
            "diff": "@@ -31,151 +31,172 @@ import ScalarType._\n /**\n  * GraphQL query parser\n  */\n-object QueryParser {\n-  import Ast.{ Directive => _, Type => _, Value => _, _ }, OperationDefinition._, Selection._\n-\n+trait QueryParser {\n   /**\n    *  Parse a String to query algebra operations and fragments.\n    *\n    *  GraphQL errors and warnings are accumulated in the result.\n    */\n-  def parseText(text: String): Result[(List[UntypedOperation], List[UntypedFragment])] =\n-    for {\n-      doc <- GraphQLParser.toResult(text, GraphQLParser.Document.parseAll(text))\n-      res <- parseDocument(doc)\n-      _   <- Result.failure(\"At least one operation required\").whenA(res._1.isEmpty)\n-    } yield res\n+  def parseText(text: String): Result[(List[UntypedOperation], List[UntypedFragment])]\n \n   /**\n    *  Parse a document AST to query algebra operations and fragments.\n    *\n    *  GraphQL errors and warnings are accumulated in the result.\n    */\n-  def parseDocument(doc: Document): Result[(List[UntypedOperation], List[UntypedFragment])] = {\n-    val ops0 = doc.collect { case op: OperationDefinition => op }\n-    val fragments0 = doc.collect { case frag: FragmentDefinition => frag }\n+  def parseDocument(doc: Ast.Document): Result[(List[UntypedOperation], List[UntypedFragment])]\n+}\n \n-    for {\n-      ops    <- ops0.traverse {\n-                  case op: Operation => parseOperation(op)\n-                  case qs: QueryShorthand => parseQueryShorthand(qs)\n-                }\n-      frags  <- fragments0.traverse { frag =>\n-                  val tpnme = frag.typeCondition.name\n-                  for {\n-                    sels <- parseSelections(frag.selectionSet)\n-                    dirs <- parseDirectives(frag.directives)\n-                  } yield UntypedFragment(frag.name.value, tpnme, dirs, sels)\n-                }\n-    } yield (ops, frags)\n-  }\n+object QueryParser {\n+  def apply(parser: GraphQLParser): QueryParser =\n+    new Impl(parser)\n \n-  /**\n-   *  Parse an operation AST to a query algebra operation.\n-   *\n-   *  GraphQL errors and warnings are accumulated in the result.\n-   */\n-  def parseOperation(op: Operation): Result[UntypedOperation] = {\n-    val Operation(opType, name, vds, dirs0, sels) = op\n-    for {\n-      vs   <- parseVariableDefinitions(vds)\n-      q    <- parseSelections(sels)\n-      dirs <- parseDirectives(dirs0)\n-    } yield {\n-      val name0 = name.map(_.value)\n-      opType match {\n-        case OperationType.Query => UntypedQuery(name0, q, vs, dirs)\n-        case OperationType.Mutation => UntypedMutation(name0, q, vs, dirs)\n-        case OperationType.Subscription => UntypedSubscription(name0, q, vs, dirs)\n-      }\n-    }\n-  }\n+  private final class Impl(parser: GraphQLParser) extends QueryParser {\n+    import Ast.{ Directive => _, Type => _, Value => _, _ }, OperationDefinition._, Selection._\n \n-  /**\n-    * Parse variable definition ASTs to query algebra variable definitions.\n+    /**\n+    *  Parse a String to query algebra operations and fragments.\n     *\n-    * GraphQL errors and warnings are accumulated in the result.\n+    *  GraphQL errors and warnings are accumulated in the result.\n     */\n-  def parseVariableDefinitions(vds: List[VariableDefinition]): Result[List[UntypedVarDef]] =\n-    vds.traverse {\n-      case VariableDefinition(Name(nme), tpe, dv0, dirs0) =>\n-        for {\n-          dv   <- dv0.traverse(SchemaParser.parseValue)\n-          dirs <- parseDirectives(dirs0)\n-        } yield UntypedVarDef(nme, tpe, dv, dirs)\n-    }\n+    def parseText(text: String): Result[(List[UntypedOperation], List[UntypedFragment])] =\n+      for {\n+        doc <- parser.parseText(text)\n+        res <- parseDocument(doc)\n+        _   <- Result.failure(\"At least one operation required\").whenA(res._1.isEmpty)\n+      } yield res\n \n-  /**\n-    * Parse a query shorthand AST to query algebra operation.\n+    /**\n+    *  Parse a document AST to query algebra operations and fragments.\n     *\n-    * GraphQL errors and warnings are accumulated in the result.\n+    *  GraphQL errors and warnings are accumulated in the result.\n     */\n-  def parseQueryShorthand(qs: QueryShorthand): Result[UntypedOperation] =\n-    parseSelections(qs.selectionSet).map(q => UntypedQuery(None, q, Nil, Nil))\n+    def parseDocument(doc: Document): Result[(List[UntypedOperation], List[UntypedFragment])] = {\n+      val ops0 = doc.collect { case op: OperationDefinition => op }\n+      val fragments0 = doc.collect { case frag: FragmentDefinition => frag }\n \n-  /**\n-    * Parse selection ASTs to query algebra terms.\n-    *\n-    * GraphQL errors and warnings are accumulated in the result\n-    */\n-  def parseSelections(sels: List[Selection]): Result[Query] =\n-    sels.traverse(parseSelection).map { sels0 =>\n-      if (sels0.sizeCompare(1) == 0) sels0.head else Group(sels0)\n+      for {\n+        ops    <- ops0.traverse {\n+                    case op: Operation => parseOperation(op)\n+                    case qs: QueryShorthand => parseQueryShorthand(qs)\n+                  }\n+        frags  <- fragments0.traverse { frag =>\n+                    val tpnme = frag.typeCondition.name\n+                    for {\n+                      sels <- parseSelections(frag.selectionSet)\n+                      dirs <- parseDirectives(frag.directives)\n+                    } yield UntypedFragment(frag.name.value, tpnme, dirs, sels)\n+                  }\n+      } yield (ops, frags)\n     }\n \n-  /**\n-    * Parse a selection AST to a query algebra term.\n+    /**\n+    *  Parse an operation AST to a query algebra operation.\n     *\n-    * GraphQL errors and warnings are accumulated in the result.\n+    *  GraphQL errors and warnings are accumulated in the result.\n     */\n-  def parseSelection(sel: Selection): Result[Query] = sel match {\n-    case Field(alias, name, args, directives, sels) =>\n+    def parseOperation(op: Operation): Result[UntypedOperation] = {\n+      val Operation(opType, name, vds, dirs0, sels) = op\n       for {\n-        args0 <- parseArgs(args)\n-        sels0 <- parseSelections(sels)\n-        dirs  <- parseDirectives(directives)\n+        vs   <- parseVariableDefinitions(vds)\n+        q    <- parseSelections(sels)\n+        dirs <- parseDirectives(dirs0)\n       } yield {\n-        val nme = name.value\n-        val alias0 = alias.map(_.value).flatMap(n => if (n == nme) None else Some(n))\n-        if (sels.isEmpty) UntypedSelect(nme, alias0, args0, dirs, Empty)\n-        else UntypedSelect(nme, alias0, args0, dirs, sels0)\n+        val name0 = name.map(_.value)\n+        opType match {\n+          case OperationType.Query => UntypedQuery(name0, q, vs, dirs)\n+          case OperationType.Mutation => UntypedMutation(name0, q, vs, dirs)\n+          case OperationType.Subscription => UntypedSubscription(name0, q, vs, dirs)\n+        }\n       }\n+    }\n \n-    case FragmentSpread(Name(name), directives) =>\n-      for {\n-        dirs <- parseDirectives(directives)\n-      } yield UntypedFragmentSpread(name, dirs)\n+    /**\n+      * Parse variable definition ASTs to query algebra variable definitions.\n+      *\n+      * GraphQL errors and warnings are accumulated in the result.\n+      */\n+    def parseVariableDefinitions(vds: List[VariableDefinition]): Result[List[UntypedVarDef]] =\n+      vds.traverse {\n+        case VariableDefinition(Name(nme), tpe, dv0, dirs0) =>\n+          for {\n+            dv   <- dv0.traverse(Value.fromAst)\n+            dirs <- parseDirectives(dirs0)\n+          } yield UntypedVarDef(nme, tpe, dv, dirs)\n+      }\n \n-    case InlineFragment(typeCondition, directives, sels) =>\n-      for {\n-        dirs  <- parseDirectives(directives)\n-        sels0 <- parseSelections(sels)\n-      } yield UntypedInlineFragment(typeCondition.map(_.name), dirs, sels0)\n-  }\n+    /**\n+      * Parse a query shorthand AST to query algebra operation.\n+      *\n+      * GraphQL errors and warnings are accumulated in the result.\n+      */\n+    def parseQueryShorthand(qs: QueryShorthand): Result[UntypedOperation] =\n+      parseSelections(qs.selectionSet).map(q => UntypedQuery(None, q, Nil, Nil))\n \n-  /**\n-    * Parse directive ASTs to query algebra directives.\n-    *\n-    * GraphQL errors and warnings are accumulated in the result.\n-    */\n-  def parseDirectives(directives: List[Ast.Directive]): Result[List[Directive]] =\n-    directives.traverse(SchemaParser.mkDirective)\n+    /**\n+      * Parse selection ASTs to query algebra terms.\n+      *\n+      * GraphQL errors and warnings are accumulated in the result\n+      */\n+    def parseSelections(sels: List[Selection]): Result[Query] =\n+      sels.traverse(parseSelection).map { sels0 =>\n+        if (sels0.sizeCompare(1) == 0) sels0.head else Group(sels0)\n+      }\n \n-  /**\n-    * Parse argument ASTs to query algebra bindings.\n-    *\n-    * GraphQL errors and warnings are accumulated in the result.\n-    */\n-  def parseArgs(args: List[(Name, Ast.Value)]): Result[List[Binding]] =\n-    args.traverse((parseArg _).tupled)\n+    /**\n+      * Parse a selection AST to a query algebra term.\n+      *\n+      * GraphQL errors and warnings are accumulated in the result.\n+      */\n+    def parseSelection(sel: Selection): Result[Query] = sel match {\n+      case Field(alias, name, args, directives, sels) =>\n+        for {\n+          args0 <- parseArgs(args)\n+          sels0 <- parseSelections(sels)\n+          dirs  <- parseDirectives(directives)\n+        } yield {\n+          val nme = name.value\n+          val alias0 = alias.map(_.value).flatMap(n => if (n == nme) None else Some(n))\n+          if (sels.isEmpty) UntypedSelect(nme, alias0, args0, dirs, Empty)\n+          else UntypedSelect(nme, alias0, args0, dirs, sels0)\n+        }\n \n-  /**\n-    * Parse an argument AST to a query algebra binding.\n-    *\n-    * GraphQL errors and warnings are accumulated in the result.\n-    */\n-  def parseArg(name: Name, value: Ast.Value): Result[Binding] =\n-    SchemaParser.parseValue(value).map(v => Binding(name.value, v))\n+      case FragmentSpread(Name(name), directives) =>\n+        for {\n+          dirs <- parseDirectives(directives)\n+        } yield UntypedFragmentSpread(name, dirs)\n+\n+      case InlineFragment(typeCondition, directives, sels) =>\n+        for {\n+          dirs  <- parseDirectives(directives)\n+          sels0 <- parseSelections(sels)\n+        } yield UntypedInlineFragment(typeCondition.map(_.name), dirs, sels0)\n+    }\n+\n+    /**\n+      * Parse directive ASTs to query algebra directives.\n+      *\n+      * GraphQL errors and warnings are accumulated in the result.\n+      */\n+    def parseDirectives(directives: List[Ast.Directive]): Result[List[Directive]] =\n+      directives.traverse(Directive.fromAst)\n+\n+    /**\n+      * Parse argument ASTs to query algebra bindings.\n+      *\n+      * GraphQL errors and warnings are accumulated in the result.\n+      */\n+    def parseArgs(args: List[(Name, Ast.Value)]): Result[List[Binding]] =\n+      args.traverse((parseArg _).tupled)\n+\n+    /**\n+      * Parse an argument AST to a query algebra binding.\n+      *\n+      * GraphQL errors and warnings are accumulated in the result.\n+      */\n+    def parseArg(name: Name, value: Ast.Value): Result[Binding] =\n+      Value.fromAst(value).map(v => Binding(name.value, v))\n+  }\n }\n \n /**\n@@ -185,7 +206,7 @@ object QueryParser {\n  * applies a collection of transformation phases in sequence, yielding a\n  * query algebra term which can be directly interpreted.\n  */\n-class QueryCompiler(schema: Schema, phases: List[Phase]) {\n+class QueryCompiler(parser: QueryParser, schema: Schema, phases: List[Phase]) {\n   import IntrospectionLevel._\n \n   /**\n@@ -194,27 +215,31 @@ class QueryCompiler(schema: Schema, phases: List[Phase]) {\n    *\n    * GraphQL errors and warnings are accumulated in the result.\n    */\n-  def compile(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty): Result[Operation] =\n-    QueryParser.parseText(text).flatMap { case (ops, frags) =>\n-      (ops, name) match {\n-        case (Nil, _) =>\n-          Result.failure(\"At least one operation required\")\n-        case (List(op), None) =>\n-          compileOperation(op, untypedVars, frags, introspectionLevel, env)\n-        case (_, None) =>\n-          Result.failure(\"Operation name required to select unique operation\")\n-        case (ops, _) if ops.exists(_.name.isEmpty) =>\n-          Result.failure(\"Query shorthand cannot be combined with multiple operations\")\n-        case (ops, name) =>\n-          ops.filter(_.name == name) match {\n-            case List(op) =>\n-              compileOperation(op, untypedVars, frags, introspectionLevel, env)\n-            case Nil =>\n-              Result.failure(s\"No operation named '$name'\")\n-            case _ =>\n-              Result.failure(s\"Multiple operations named '$name'\")\n-          }\n-      }\n+  def compile(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, reportUnused: Boolean = true, env: Env = Env.empty): Result[Operation] =\n+    parser.parseText(text).flatMap { case (ops, frags) =>\n+      for {\n+        _    <- Result.fromProblems(validateVariablesAndFragments(ops, frags, reportUnused))\n+        ops0 <- ops.traverse(op => compileOperation(op, untypedVars, frags, introspectionLevel, env).map(op0 => (op.name, op0)))\n+        res  <- (ops0, name) match {\n+                  case (List((_, op)), None) =>\n+                    op.success\n+                  case (Nil, _) =>\n+                    Result.failure(\"At least one operation required\")\n+                  case (_, None) =>\n+                    Result.failure(\"Operation name required to select unique operation\")\n+                  case (ops, _) if ops.lengthCompare(1) > 0 && ops.exists(_._1.isEmpty) =>\n+                    Result.failure(\"Query shorthand cannot be combined with multiple operations\")\n+                  case (ops, name) =>\n+                    ops.filter(_._1 == name) match {\n+                      case List((_, op)) =>\n+                        op.success\n+                      case Nil =>\n+                        Result.failure(s\"No operation named '$name'\")\n+                      case _ =>\n+                        Result.failure(s\"Multiple operations named '$name'\")\n+                    }\n+                }\n+      } yield res\n     }\n \n   /**\n@@ -297,6 +322,159 @@ class QueryCompiler(schema: Schema, phases: List[Phase]) {\n     }\n     loop(tpe, false)\n   }\n+\n+  def validateVariablesAndFragments(ops: List[UntypedOperation], frags: List[UntypedFragment], reportUnused: Boolean): List[Problem] = {\n+    val (uniqueFrags, duplicateFrags) = frags.map(_.name).foldLeft((Set.empty[String], Set.empty[String])) {\n+      case ((unique, duplicate), nme) =>\n+        if (unique.contains(nme)) (unique, duplicate + nme)\n+        else (unique + nme, duplicate)\n+    }\n+\n+    if (duplicateFrags.nonEmpty)\n+      duplicateFrags.toList.map(nme => Problem(s\"Fragment '$nme' is defined more than once\"))\n+    else {\n+      def collectQueryRefs(query: Query): (Set[String], Set[String]) = {\n+        @tailrec\n+        def loop(queries: Iterator[Query], vars: Set[String], frags: Set[String]): (Set[String], Set[String]) =\n+          if (!queries.hasNext) (vars, frags)\n+          else\n+            queries.next() match {\n+              case UntypedSelect(_, _, args, dirs, child) =>\n+                val v0 = args.iterator.flatMap(arg => collectValueRefs(arg.value)).toSet\n+                val v1 = dirs.iterator.flatMap(dir => dir.args.iterator.flatMap(arg => collectValueRefs(arg.value))).toSet\n+                loop(Iterator.single(child) ++ queries, vars ++ v0 ++ v1, frags)\n+              case UntypedFragmentSpread(nme, dirs) =>\n+                val v0 = dirs.iterator.flatMap(dir => dir.args.iterator.flatMap(arg => collectValueRefs(arg.value))).toSet\n+                loop(queries, vars ++ v0, frags + nme)\n+              case UntypedInlineFragment(_, dirs, child) =>\n+                val v0 = dirs.iterator.flatMap(dir => dir.args.iterator.flatMap(arg => collectValueRefs(arg.value))).toSet\n+                loop(Iterator.single(child) ++ queries, vars ++ v0, frags)\n+              case Group(children) =>\n+                loop(children.iterator ++ queries, vars, frags)\n+              case Select(_, _, child)       => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Narrow(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Unique(child)             => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Filter(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Limit(_, child)           => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Offset(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case OrderBy(_, child)         => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Introspect(_, child)      => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Environment(_, child)     => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Component(_, _, child)    => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Effect(_, child)          => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case TransformCursor(_, child) => loop(Iterator.single(child) ++ queries, vars, frags)\n+              case Count(_)                  => loop(queries, vars, frags)\n+              case Empty                     => loop(queries, vars, frags)\n+            }\n+\n+        loop(Iterator.single(query), Set.empty[String], Set.empty[String])\n+      }\n+\n+      def collectValueRefs(value: Value): Set[String] = {\n+        @tailrec\n+        def loop(values: Iterator[Value], vars: Set[String]): Set[String] =\n+          if (!values.hasNext) vars\n+          else\n+            values.next() match {\n+              case VariableRef(nme) =>\n+                loop(values, Set(nme))\n+              case ObjectValue(fields) =>\n+                loop(fields.iterator.map(_._2) ++ values, vars)\n+              case ListValue(elems) =>\n+                loop(elems.iterator ++ values, vars)\n+              case _ => loop(values, vars)\n+            }\n+\n+        loop(Iterator.single(value), Set.empty[String])\n+      }\n+\n+      val fragRefs: Map[String, (Set[String], Set[String])] =\n+        frags.map { frag =>\n+          (frag.name, collectQueryRefs(frag.child))\n+        }.toMap\n+\n+      @tailrec\n+      def checkCycle(pendingFrags: Set[String], seen: Set[String]): Option[Set[String]] = {\n+        if (pendingFrags.isEmpty) Some(seen)\n+        else {\n+          val hd = pendingFrags.head\n+          if (seen.contains(hd)) None\n+          else checkCycle(fragRefs(hd)._2 ++ pendingFrags.tail, seen + hd)\n+        }\n+      }\n+\n+      def findCycle: Option[String] = {\n+        @tailrec\n+        def loop(pendingFrags: Set[String]): Either[Set[String], String] = {\n+          if(pendingFrags.isEmpty) Left(Set.empty[String])\n+          else {\n+            val hd = pendingFrags.head\n+            checkCycle(Set(hd), Set.empty[String]) match {\n+              case None => Right(hd)\n+              case Some(seen) => loop(pendingFrags.tail.diff(seen))\n+            }\n+          }\n+        }\n+\n+        if (uniqueFrags.isEmpty) None\n+        else loop(uniqueFrags).toOption\n+      }\n+\n+      findCycle match {\n+        case Some(from) => List(Problem(s\"Fragment cycle starting from '$from'\"))\n+        case _ =>\n+          def validateOp(op: UntypedOperation, pendingFrags: Set[String]): (List[Problem], Set[String]) = {\n+            val pendingVars = op.variables.map(_.name).toSet\n+            val (dqv, dqf) = collectQueryRefs(op.query)\n+\n+            val (qv, qf) = {\n+              dqf.foldLeft((dqv, dqf)) {\n+                case ((v, f), nme) => fragRefs.get(nme) match {\n+                  case None => (v, f)\n+                  case Some((fv, ff)) => (v ++ fv, f ++ ff)\n+                }\n+              }\n+            }\n+\n+            val varProblems =\n+              if (qv == pendingVars) Nil\n+              else {\n+                val undefinedProblems =\n+                  qv.diff(pendingVars).toList.map(nme => Problem(s\"Variable '$nme' is undefined\"))\n+\n+                val unusedProblems =\n+                  if (!reportUnused) Nil\n+                  else pendingVars.diff(qv).toList.map(nme => Problem(s\"Variable '$nme' is unused\"))\n+\n+                undefinedProblems ++ unusedProblems\n+              }\n+\n+            val fragProblems =\n+              if (qf.subsetOf(uniqueFrags)) Nil\n+              else {\n+                val undefined = qf.diff(uniqueFrags)\n+                val undefinedProblems = undefined.toList.map(nme => Problem(s\"Fragment '$nme' is undefined\"))\n+                undefinedProblems\n+              }\n+\n+            (varProblems ++ fragProblems, pendingFrags.diff(qf))\n+          }\n+\n+          val (opProblems, unreferencedFrags) =\n+            ops.foldLeft((List.empty[Problem], uniqueFrags)) {\n+              case ((acc, pendingFrags), op) =>\n+                val (problems, pendingFrags0) = validateOp(op, pendingFrags)\n+                (acc ++ problems, pendingFrags0)\n+              }\n+\n+          val unreferencedFragProblems =\n+            if (!reportUnused) Nil\n+            else unreferencedFrags.toList.map(nme => Problem(s\"Fragment '$nme' is unused\"))\n+\n+          opProblems ++ unreferencedFragProblems\n+      }\n+    }\n+  }\n }\n \n object QueryCompiler {\n@@ -710,7 +888,7 @@ object QueryCompiler {\n         case VariableRef(varName) =>\n           for {\n             v  <- Elab.vars\n-            tv <- Elab.liftR(Result.fromOption(v.get(varName), s\"Undefined variable '$varName'\"))\n+            tv <- Elab.liftR(Result.fromOption(v.get(varName), s\"Variable '$varName' is undefined\"))\n             b  <- tv match {\n                     case (tpe, BooleanValue(value)) if tpe.nonNull =:= BooleanType => Elab.pure(value)\n                     case _ => Elab.failure(s\"Argument of skip/include must be boolean\")"
        },
        {
            "filename": "modules/core/src/main/scala/mapping.scala",
            "diff": "@@ -47,10 +47,10 @@ abstract class Mapping[F[_]] {\n     *\n     * Yields a JSON response containing the result of the query or mutation.\n     */\n-  def compileAndRun(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty)(\n+  def compileAndRun(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, reportUnused: Boolean = true, env: Env = Env.empty)(\n     implicit sc: Compiler[F,F]\n   ): F[Json] =\n-    compileAndRunSubscription(text, name, untypedVars, introspectionLevel, env).compile.toList.flatMap {\n+    compileAndRunSubscription(text, name, untypedVars, introspectionLevel, reportUnused, env).compile.toList.flatMap {\n       case List(j) => j.pure[F]\n       case Nil     => M.raiseError(new IllegalStateException(\"Result stream was empty.\"))\n       case js      => M.raiseError(new IllegalStateException(s\"Result stream contained ${js.length} results; expected exactly one.\"))\n@@ -61,8 +61,8 @@ abstract class Mapping[F[_]] {\n    *\n    * Yields a stream of JSON responses containing the results of the subscription.\n    */\n-  def compileAndRunSubscription(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, env: Env = Env.empty): Stream[F,Json] = {\n-    val compiled = compiler.compile(text, name, untypedVars, introspectionLevel, env)\n+  def compileAndRunSubscription(text: String, name: Option[String] = None, untypedVars: Option[Json] = None, introspectionLevel: IntrospectionLevel = Full, reportUnused: Boolean = true, env: Env = Env.empty): Stream[F,Json] = {\n+    val compiled = compiler.compile(text, name, untypedVars, introspectionLevel, reportUnused, env)\n     Stream.eval(compiled.pure[F]).flatMap(_.flatTraverse(op => interpreter.run(op.query, op.rootTpe, env))).evalMap(mkResponse)\n   }\n \n@@ -480,7 +480,11 @@ abstract class Mapping[F[_]] {\n \n   def compilerPhases: List[QueryCompiler.Phase] = List(selectElaborator, componentElaborator, effectElaborator)\n \n-  lazy val compiler = new QueryCompiler(schema, compilerPhases)\n+  def parserConfig: GraphQLParser.Config = GraphQLParser.defaultConfig\n+  lazy val graphQLParser: GraphQLParser = GraphQLParser(parserConfig)\n+  lazy val queryParser: QueryParser = QueryParser(graphQLParser)\n+\n+  lazy val compiler: QueryCompiler = new QueryCompiler(queryParser, schema, compilerPhases)\n \n   val interpreter: QueryInterpreter[F] = new QueryInterpreter(this)\n "
        },
        {
            "filename": "modules/core/src/main/scala/minimizer.scala",
            "diff": "@@ -15,126 +15,133 @@\n \n package grackle\n \n-import cats.implicits._\n+trait QueryMinimizer {\n+  def minimizeText(text: String): Result[String]\n+  def minimizeDocument(doc: Ast.Document): String\n+}\n \n object QueryMinimizer {\n-  import Ast._\n-\n-  def minimizeText(text: String): Either[String, String] = {\n-    for {\n-      doc <- GraphQLParser.Document.parseAll(text).leftMap(_.expected.toList.mkString(\",\"))\n-    } yield minimizeDocument(doc)\n-  }\n-\n-  def minimizeDocument(doc: Document): String = {\n-    import OperationDefinition._\n-    import OperationType._\n-    import Selection._\n-    import Value._\n-\n-    def renderDefinition(defn: Definition): String =\n-      defn match {\n-        case e: ExecutableDefinition => renderExecutableDefinition(e)\n-        case _ => \"\"\n-      }\n-\n-    def renderExecutableDefinition(ex: ExecutableDefinition): String =\n-      ex match {\n-        case op: OperationDefinition => renderOperationDefinition(op)\n-        case frag: FragmentDefinition => renderFragmentDefinition(frag)\n-      }\n-\n-    def renderOperationDefinition(op: OperationDefinition): String =\n-      op match {\n-        case qs: QueryShorthand => renderSelectionSet(qs.selectionSet)\n-        case op: Operation => renderOperation(op)\n-      }\n-\n-    def renderOperation(op: Operation): String =\n-      renderOperationType(op.operationType) +\n-      op.name.map(nme => s\" ${nme.value}\").getOrElse(\"\") +\n-      renderVariableDefns(op.variables)+\n-      renderDirectives(op.directives)+\n-      renderSelectionSet(op.selectionSet)\n-\n-    def renderOperationType(op: OperationType): String =\n-      op match {\n-        case Query => \"query\"\n-        case Mutation => \"mutation\"\n-        case Subscription => \"subscription\"\n-      }\n-\n-    def renderDirectives(dirs: List[Directive]): String =\n-      dirs.map { case Directive(name, args) => s\"@${name.value}${renderArguments(args)}\" }.mkString(\"\")\n-\n-    def renderVariableDefns(vars: List[VariableDefinition]): String =\n-      vars match {\n-        case Nil => \"\"\n-        case _ =>\n-          vars.map {\n-            case VariableDefinition(name, tpe, default, dirs) =>\n-              s\"$$${name.value}:${tpe.name}${default.map(v => s\"=${renderValue(v)}\").getOrElse(\"\")}${renderDirectives(dirs)}\"\n-          }.mkString(\"(\", \",\", \")\")\n-      }\n-\n-    def renderSelectionSet(sels: List[Selection]): String =\n-      sels match {\n-        case Nil => \"\"\n-        case _ => sels.map(renderSelection).mkString(\"{\", \",\", \"}\")\n+  def apply(parser: GraphQLParser): QueryMinimizer =\n+    new Impl(parser)\n+\n+  private final class Impl(parser: GraphQLParser) extends QueryMinimizer {\n+    import Ast._\n+\n+    def minimizeText(text: String): Result[String] =\n+      for {\n+        doc <- parser.parseText(text)\n+      } yield minimizeDocument(doc)\n+\n+    def minimizeDocument(doc: Document): String = {\n+      import OperationDefinition._\n+      import OperationType._\n+      import Selection._\n+      import Value._\n+\n+      def renderDefinition(defn: Definition): String =\n+        defn match {\n+          case e: ExecutableDefinition => renderExecutableDefinition(e)\n+          case _ => \"\"\n+        }\n+\n+      def renderExecutableDefinition(ex: ExecutableDefinition): String =\n+        ex match {\n+          case op: OperationDefinition => renderOperationDefinition(op)\n+          case frag: FragmentDefinition => renderFragmentDefinition(frag)\n+        }\n+\n+      def renderOperationDefinition(op: OperationDefinition): String =\n+        op match {\n+          case qs: QueryShorthand => renderSelectionSet(qs.selectionSet)\n+          case op: Operation => renderOperation(op)\n+        }\n+\n+      def renderOperation(op: Operation): String =\n+        renderOperationType(op.operationType) +\n+        op.name.map(nme => s\" ${nme.value}\").getOrElse(\"\") +\n+        renderVariableDefns(op.variables)+\n+        renderDirectives(op.directives)+\n+        renderSelectionSet(op.selectionSet)\n+\n+      def renderOperationType(op: OperationType): String =\n+        op match {\n+          case Query => \"query\"\n+          case Mutation => \"mutation\"\n+          case Subscription => \"subscription\"\n+        }\n+\n+      def renderDirectives(dirs: List[Directive]): String =\n+        dirs.map { case Directive(name, args) => s\"@${name.value}${renderArguments(args)}\" }.mkString(\"\")\n+\n+      def renderVariableDefns(vars: List[VariableDefinition]): String =\n+        vars match {\n+          case Nil => \"\"\n+          case _ =>\n+            vars.map {\n+              case VariableDefinition(name, tpe, default, dirs) =>\n+                s\"$$${name.value}:${tpe.name}${default.map(v => s\"=${renderValue(v)}\").getOrElse(\"\")}${renderDirectives(dirs)}\"\n+            }.mkString(\"(\", \",\", \")\")\n+        }\n+\n+      def renderSelectionSet(sels: List[Selection]): String =\n+        sels match {\n+          case Nil => \"\"\n+          case _ => sels.map(renderSelection).mkString(\"{\", \",\", \"}\")\n+        }\n+\n+      def renderSelection(sel: Selection): String =\n+        sel match {\n+          case f: Field => renderField(f)\n+          case s: FragmentSpread => renderFragmentSpread(s)\n+          case i: InlineFragment => renderInlineFragment(i)\n+        }\n+\n+      def renderField(f: Field) = {\n+        f.alias.map(a => s\"${a.value}:\").getOrElse(\"\")+\n+        f.name.value+\n+        renderArguments(f.arguments)+\n+        renderDirectives(f.directives)+\n+        renderSelectionSet(f.selectionSet)\n       }\n \n-    def renderSelection(sel: Selection): String =\n-      sel match {\n-        case f: Field => renderField(f)\n-        case s: FragmentSpread => renderFragmentSpread(s)\n-        case i: InlineFragment => renderInlineFragment(i)\n-      }\n-\n-    def renderField(f: Field) = {\n-      f.alias.map(a => s\"${a.value}:\").getOrElse(\"\")+\n-      f.name.value+\n-      renderArguments(f.arguments)+\n-      renderDirectives(f.directives)+\n-      renderSelectionSet(f.selectionSet)\n+      def renderArguments(args: List[(Name, Value)]): String =\n+        args match {\n+          case Nil => \"\"\n+          case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"(\", \",\", \")\")\n+        }\n+\n+      def renderInputObject(args: List[(Name, Value)]): String =\n+        args match {\n+          case Nil => \"\"\n+          case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"{\", \",\", \"}\")\n+        }\n+\n+      def renderTypeCondition(tpe: Type): String =\n+        s\"on ${tpe.name}\"\n+\n+      def renderFragmentDefinition(frag: FragmentDefinition): String =\n+        s\"fragment ${frag.name.value} ${renderTypeCondition(frag.typeCondition)}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n+\n+      def renderFragmentSpread(spread: FragmentSpread): String =\n+        s\"...${spread.name.value}${renderDirectives(spread.directives)}\"\n+\n+      def renderInlineFragment(frag: InlineFragment): String =\n+        s\"...${frag.typeCondition.map(renderTypeCondition).getOrElse(\"\")}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n+\n+      def renderValue(v: Value): String =\n+        v match {\n+          case Variable(name) => s\"$$${name.value}\"\n+          case IntValue(value) => value.toString\n+          case FloatValue(value) => value.toString\n+          case StringValue(value) => s\"\"\"\"$value\"\"\"\"\n+          case BooleanValue(value) => value.toString\n+          case NullValue => \"null\"\n+          case EnumValue(name) => name.value\n+          case ListValue(values) => values.map(renderValue).mkString(\"[\", \",\", \"]\")\n+          case ObjectValue(fields) => renderInputObject(fields)\n+        }\n+\n+      doc.map(renderDefinition).mkString(\",\")\n     }\n-\n-    def renderArguments(args: List[(Name, Value)]): String =\n-      args match {\n-        case Nil => \"\"\n-        case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"(\", \",\", \")\")\n-      }\n-\n-    def renderInputObject(args: List[(Name, Value)]): String =\n-      args match {\n-        case Nil => \"\"\n-        case _ => args.map { case (n, v) => s\"${n.value}:${renderValue(v)}\" }.mkString(\"{\", \",\", \"}\")\n-      }\n-\n-    def renderTypeCondition(tpe: Type): String =\n-      s\"on ${tpe.name}\"\n-\n-    def renderFragmentDefinition(frag: FragmentDefinition): String =\n-      s\"fragment ${frag.name.value} ${renderTypeCondition(frag.typeCondition)}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n-\n-    def renderFragmentSpread(spread: FragmentSpread): String =\n-      s\"...${spread.name.value}${renderDirectives(spread.directives)}\"\n-\n-    def renderInlineFragment(frag: InlineFragment): String =\n-      s\"...${frag.typeCondition.map(renderTypeCondition).getOrElse(\"\")}${renderDirectives(frag.directives)}${renderSelectionSet(frag.selectionSet)}\"\n-\n-    def renderValue(v: Value): String =\n-      v match {\n-        case Variable(name) => s\"$$${name.value}\"\n-        case IntValue(value) => value.toString\n-        case FloatValue(value) => value.toString\n-        case StringValue(value) => s\"\"\"\"$value\"\"\"\"\n-        case BooleanValue(value) => value.toString\n-        case NullValue => \"null\"\n-        case EnumValue(name) => name.value\n-        case ListValue(values) => values.map(renderValue).mkString(\"[\", \",\", \"]\")\n-        case ObjectValue(fields) => renderInputObject(fields)\n-      }\n-\n-    doc.map(renderDefinition).mkString(\",\")\n   }\n }"
        },
        {
            "filename": "modules/core/src/main/scala/parser.scala",
            "diff": "@@ -15,278 +15,315 @@\n \n package grackle\n \n-import cats.parse.{LocationMap, Parser, Parser0}\n+import scala.util.matching.Regex\n+\n+import cats.implicits._\n+import cats.parse.{Parser, Parser0}\n import cats.parse.Parser._\n import cats.parse.Numbers._\n import cats.parse.Rfc5234.{cr, crlf, digit, hexdig, lf}\n-import cats.implicits._\n-import CommentedText._\n-import Literals._\n-import scala.util.matching.Regex\n+\n+trait GraphQLParser {\n+  def parseText(text: String): Result[Ast.Document]\n+}\n \n object GraphQLParser {\n+  case class Config(\n+    maxSelectionDepth: Int,\n+    maxSelectionWidth: Int,\n+    maxInputValueDepth: Int,\n+    maxListTypeDepth: Int,\n+    terseError: Boolean\n+  )\n+\n+  val defaultConfig: Config =\n+    Config(\n+      maxSelectionDepth = 100,\n+      maxSelectionWidth = 1000,\n+      maxInputValueDepth = 5,\n+      maxListTypeDepth = 5,\n+      terseError = true\n+    )\n \n-  val nameInitial    = ('A' to 'Z') ++ ('a' to 'z') ++ Seq('_')\n-  val nameSubsequent = nameInitial ++ ('0' to '9')\n+  def apply(config: Config): GraphQLParser =\n+    new Impl(config)\n \n-  def keyword(s: String) = token(string(s) <* not(charIn(nameSubsequent)))\n+  def toResult[T](pr: Either[Parser.Error, T]): Result[T] =\n+    Result.fromEither(pr.leftMap(_.show))\n \n-  def punctuation(s: String) = token(string(s))\n+  def toResultTerseError[T](pr: Either[Parser.Error, T]): Result[T] =\n+    Result.fromEither(pr.leftMap(_.copy().show))\n \n-  lazy val Document: Parser0[Ast.Document] =\n-    (whitespace.void | comment).rep0 *> Definition.rep0 <* Parser.end\n+  import CommentedText._\n+  import Literals._\n \n-  lazy val Definition: Parser[Ast.Definition] =\n-    ExecutableDefinition | TypeSystemDefinition | TypeSystemExtension\n+  private final class Impl(config: Config) extends GraphQLParser {\n+    import config._\n \n-  lazy val TypeSystemDefinition: Parser[Ast.TypeSystemDefinition] = {\n-    val SchemaDefinition: Parser[Ast.SchemaDefinition] =\n-      ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0)).map {\n-        case (dirs, rootdefs) => Ast.SchemaDefinition(rootdefs, dirs.getOrElse(Nil))\n-      }\n+    def parseText(text: String): Result[Ast.Document] = {\n+      val res = Document.parseAll(text)\n+      if (config.terseError) toResultTerseError(res) else toResult(res)\n+    }\n \n-    def typeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.TypeDefinition] = {\n+    val nameInitial    = ('A' to 'Z') ++ ('a' to 'z') ++ Seq('_')\n+    val nameSubsequent = nameInitial ++ ('0' to '9')\n \n-      def scalarTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ScalarTypeDefinition] =\n-        ((keyword(\"scalar\") *> Name) ~ Directives.?).map {\n-          case (name, dirs) => Ast.ScalarTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n-        }\n+    def keyword(s: String) = token(string(s) <* not(charIn(nameSubsequent)))\n \n-      def objectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ObjectTypeDefinition] =\n-        ((keyword(\"type\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n-          case (((name, ifs), dirs), fields) => Ast.ObjectTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n-        }\n+    def punctuation(s: String) = token(string(s))\n \n-      def interfaceTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InterfaceTypeDefinition] =\n-        ((keyword(\"interface\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n-          case (((name, ifs), dirs), fields) => Ast.InterfaceTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n-        }\n+    lazy val Document: Parser0[Ast.Document] =\n+      (whitespace.void | comment).rep0 *> Definition.rep0 <* Parser.end\n \n-      def unionTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.UnionTypeDefinition] =\n-        ((keyword(\"union\") *> Name) ~ Directives.? ~ UnionMemberTypes).map {\n-          case ((name, dirs), members) => Ast.UnionTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), members)\n-        }\n+    lazy val Definition: Parser[Ast.Definition] =\n+      ExecutableDefinition | TypeSystemDefinition | TypeSystemExtension\n \n-      def enumTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.EnumTypeDefinition] =\n-        ((keyword(\"enum\") *> Name) ~ Directives.? ~ EnumValuesDefinition).map {\n-          case ((name, dirs), values) => Ast.EnumTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), values)\n+    lazy val TypeSystemDefinition: Parser[Ast.TypeSystemDefinition] = {\n+      val SchemaDefinition: Parser[Ast.SchemaDefinition] =\n+        ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0)).map {\n+          case (dirs, rootdefs) => Ast.SchemaDefinition(rootdefs, dirs.getOrElse(Nil))\n         }\n \n-      def inputObjectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InputObjectTypeDefinition] =\n-        ((keyword(\"input\") *> Name) ~ Directives.? ~ InputFieldsDefinition).map {\n-          case ((name, dirs), fields) => Ast.InputObjectTypeDefinition(name, desc.map(_.value), fields, dirs.getOrElse(Nil))\n-        }\n+      def typeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.TypeDefinition] = {\n \n-      scalarTypeDefinition(desc)|\n-        objectTypeDefinition(desc) |\n-        interfaceTypeDefinition(desc) |\n-        unionTypeDefinition(desc) |\n-        enumTypeDefinition(desc) |\n-        inputObjectTypeDefinition(desc)\n-    }\n+        def scalarTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ScalarTypeDefinition] =\n+          ((keyword(\"scalar\") *> Name) ~ Directives.?).map {\n+            case (name, dirs) => Ast.ScalarTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n+          }\n \n-    def directiveDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.DirectiveDefinition] =\n-      ((keyword(\"directive\") *> punctuation(\"@\") *> Name) ~\n-         ArgumentsDefinition.? ~ (keyword(\"repeatable\").? <* keyword(\"on\")) ~ DirectiveLocations).map {\n-        case (((name, args), rpt), locs) => Ast.DirectiveDefinition(name, desc.map(_.value), args.getOrElse(Nil), rpt.isDefined, locs)\n-      }\n+        def objectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.ObjectTypeDefinition] =\n+          ((keyword(\"type\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n+            case (((name, ifs), dirs), fields) => Ast.ObjectTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n+          }\n \n-    SchemaDefinition |\n-      Description.?.with1.flatMap { desc =>\n-        typeDefinition(desc) | directiveDefinition(desc)\n-      }\n-  }\n+        def interfaceTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InterfaceTypeDefinition] =\n+          ((keyword(\"interface\") *> Name) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition).map {\n+            case (((name, ifs), dirs), fields) => Ast.InterfaceTypeDefinition(name, desc.map(_.value), fields, ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n+          }\n \n-  lazy val TypeSystemExtension: Parser[Ast.TypeSystemExtension] = {\n+        def unionTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.UnionTypeDefinition] =\n+          ((keyword(\"union\") *> Name) ~ Directives.? ~ UnionMemberTypes).map {\n+            case ((name, dirs), members) => Ast.UnionTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), members)\n+          }\n \n-    val SchemaExtension: Parser[Ast.SchemaExtension] =\n-      ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0).?).map {\n-        case (dirs, rootdefs) => Ast.SchemaExtension(rootdefs.getOrElse(Nil), dirs.getOrElse(Nil))\n-      }\n+        def enumTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.EnumTypeDefinition] =\n+          ((keyword(\"enum\") *> Name) ~ Directives.? ~ EnumValuesDefinition).map {\n+            case ((name, dirs), values) => Ast.EnumTypeDefinition(name, desc.map(_.value), dirs.getOrElse(Nil), values)\n+          }\n \n-    val TypeExtension: Parser[Ast.TypeExtension] = {\n+        def inputObjectTypeDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.InputObjectTypeDefinition] =\n+          ((keyword(\"input\") *> Name) ~ Directives.? ~ InputFieldsDefinition).map {\n+            case ((name, dirs), fields) => Ast.InputObjectTypeDefinition(name, desc.map(_.value), fields, dirs.getOrElse(Nil))\n+          }\n \n-      val ScalarTypeExtension: Parser[Ast.ScalarTypeExtension] =\n-        ((keyword(\"scalar\") *> NamedType) ~ Directives.?).map {\n-          case (((name), dirs)) => Ast.ScalarTypeExtension(name, dirs.getOrElse(Nil))\n-        }\n+        scalarTypeDefinition(desc)|\n+          objectTypeDefinition(desc) |\n+          interfaceTypeDefinition(desc) |\n+          unionTypeDefinition(desc) |\n+          enumTypeDefinition(desc) |\n+          inputObjectTypeDefinition(desc)\n+      }\n \n-      val ObjectTypeExtension: Parser[Ast.ObjectTypeExtension] =\n-        ((keyword(\"type\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n-          case (((name, ifs), dirs), fields) => Ast.ObjectTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n+      def directiveDefinition(desc: Option[Ast.Value.StringValue]): Parser[Ast.DirectiveDefinition] =\n+        ((keyword(\"directive\") *> punctuation(\"@\") *> Name) ~\n+          ArgumentsDefinition.? ~ (keyword(\"repeatable\").? <* keyword(\"on\")) ~ DirectiveLocations).map {\n+          case (((name, args), rpt), locs) => Ast.DirectiveDefinition(name, desc.map(_.value), args.getOrElse(Nil), rpt.isDefined, locs)\n         }\n \n-      val InterfaceTypeExtension: Parser[Ast.InterfaceTypeExtension] =\n-        ((keyword(\"interface\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n-          case (((name, ifs), dirs), fields) => Ast.InterfaceTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n+      SchemaDefinition |\n+        Description.?.with1.flatMap { desc =>\n+          typeDefinition(desc) | directiveDefinition(desc)\n         }\n+    }\n \n-      val UnionTypeExtension: Parser[Ast.UnionTypeExtension] =\n-        ((keyword(\"union\") *> NamedType) ~ Directives.? ~ UnionMemberTypes.?).map {\n-          case (((name), dirs), members) => Ast.UnionTypeExtension(name, dirs.getOrElse(Nil), members.getOrElse(Nil))\n-        }\n+    lazy val TypeSystemExtension: Parser[Ast.TypeSystemExtension] = {\n \n-      val EnumTypeExtension: Parser[Ast.EnumTypeExtension] =\n-        ((keyword(\"enum\") *> NamedType) ~ Directives.? ~ EnumValuesDefinition.?).map {\n-          case (((name), dirs), values) => Ast.EnumTypeExtension(name, dirs.getOrElse(Nil), values.getOrElse(Nil))\n+      val SchemaExtension: Parser[Ast.SchemaExtension] =\n+        ((keyword(\"schema\") *> Directives.?) ~ braces(RootOperationTypeDefinition.rep0).?).map {\n+          case (dirs, rootdefs) => Ast.SchemaExtension(rootdefs.getOrElse(Nil), dirs.getOrElse(Nil))\n         }\n \n-      val InputObjectTypeExtension: Parser[Ast.InputObjectTypeExtension] =\n-        ((keyword(\"input\") *> NamedType) ~ Directives.? ~ InputFieldsDefinition.?).map {\n-          case (((name), dirs), fields) => Ast.InputObjectTypeExtension(name, dirs.getOrElse(Nil), fields.getOrElse(Nil))\n-        }\n+      val TypeExtension: Parser[Ast.TypeExtension] = {\n \n-      ScalarTypeExtension|\n-      ObjectTypeExtension|\n-      InterfaceTypeExtension|\n-      UnionTypeExtension|\n-      EnumTypeExtension|\n-      InputObjectTypeExtension\n-    }\n+        val ScalarTypeExtension: Parser[Ast.ScalarTypeExtension] =\n+          ((keyword(\"scalar\") *> NamedType) ~ Directives.?).map {\n+            case (((name), dirs)) => Ast.ScalarTypeExtension(name, dirs.getOrElse(Nil))\n+          }\n \n-    keyword(\"extend\") *> (SchemaExtension | TypeExtension)\n-  }\n+        val ObjectTypeExtension: Parser[Ast.ObjectTypeExtension] =\n+          ((keyword(\"type\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n+            case (((name, ifs), dirs), fields) => Ast.ObjectTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n+          }\n \n-  lazy val RootOperationTypeDefinition: Parser[Ast.RootOperationTypeDefinition] =\n-    (OperationType ~ punctuation(\":\") ~ NamedType ~ Directives).map {\n-      case (((optpe, _), tpe), dirs) => Ast.RootOperationTypeDefinition(optpe, tpe, dirs)\n-    }\n+        val InterfaceTypeExtension: Parser[Ast.InterfaceTypeExtension] =\n+          ((keyword(\"interface\") *> NamedType) ~ ImplementsInterfaces.? ~ Directives.? ~ FieldsDefinition.?).map {\n+            case (((name, ifs), dirs), fields) => Ast.InterfaceTypeExtension(name, fields.getOrElse(Nil), ifs.getOrElse(Nil), dirs.getOrElse(Nil))\n+          }\n \n+        val UnionTypeExtension: Parser[Ast.UnionTypeExtension] =\n+          ((keyword(\"union\") *> NamedType) ~ Directives.? ~ UnionMemberTypes.?).map {\n+            case (((name), dirs), members) => Ast.UnionTypeExtension(name, dirs.getOrElse(Nil), members.getOrElse(Nil))\n+          }\n \n-  lazy val Description = StringValue\n+        val EnumTypeExtension: Parser[Ast.EnumTypeExtension] =\n+          ((keyword(\"enum\") *> NamedType) ~ Directives.? ~ EnumValuesDefinition.?).map {\n+            case (((name), dirs), values) => Ast.EnumTypeExtension(name, dirs.getOrElse(Nil), values.getOrElse(Nil))\n+          }\n \n-  lazy val ImplementsInterfaces =\n-    (keyword(\"implements\") ~ punctuation(\"&\").?) *> NamedType.repSep0(punctuation(\"&\"))\n+        val InputObjectTypeExtension: Parser[Ast.InputObjectTypeExtension] =\n+          ((keyword(\"input\") *> NamedType) ~ Directives.? ~ InputFieldsDefinition.?).map {\n+            case (((name), dirs), fields) => Ast.InputObjectTypeExtension(name, dirs.getOrElse(Nil), fields.getOrElse(Nil))\n+          }\n \n-  lazy val FieldsDefinition: Parser[List[Ast.FieldDefinition]] =\n-    braces(FieldDefinition.rep0)\n+        ScalarTypeExtension|\n+        ObjectTypeExtension|\n+        InterfaceTypeExtension|\n+        UnionTypeExtension|\n+        EnumTypeExtension|\n+        InputObjectTypeExtension\n+      }\n \n-  lazy val FieldDefinition: Parser[Ast.FieldDefinition] =\n-    (Description.?.with1 ~ Name ~ ArgumentsDefinition.? ~ punctuation(\":\") ~ Type ~ Directives.?).map {\n-      case (((((desc, name), args), _), tpe), dirs) => Ast.FieldDefinition(name, desc.map(_.value), args.getOrElse(Nil), tpe, dirs.getOrElse(Nil))\n+      keyword(\"extend\") *> (SchemaExtension | TypeExtension)\n     }\n \n-  lazy val ArgumentsDefinition: Parser[List[Ast.InputValueDefinition]] =\n-    parens(InputValueDefinition.rep0)\n+    lazy val RootOperationTypeDefinition: Parser[Ast.RootOperationTypeDefinition] =\n+      (OperationType ~ punctuation(\":\") ~ NamedType ~ Directives).map {\n+        case (((optpe, _), tpe), dirs) => Ast.RootOperationTypeDefinition(optpe, tpe, dirs)\n+      }\n \n-  lazy val InputFieldsDefinition: Parser[List[Ast.InputValueDefinition]] =\n-    braces(InputValueDefinition.rep0)\n \n-  lazy val InputValueDefinition: Parser[Ast.InputValueDefinition] =\n-    (Description.?.with1 ~ (Name <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n-      case ((((desc, name), tpe), dv), dirs) => Ast.InputValueDefinition(name, desc.map(_.value), tpe, dv, dirs.getOrElse(Nil))\n-    }\n+    lazy val Description = StringValue\n \n-  lazy val UnionMemberTypes: Parser[List[Ast.Type.Named]] =\n-    (punctuation(\"=\") *> punctuation(\"|\").?) *> NamedType.repSep0(punctuation(\"|\"))\n+    lazy val ImplementsInterfaces =\n+      (keyword(\"implements\") ~ punctuation(\"&\").?) *> NamedType.repSep0(punctuation(\"&\"))\n \n-  lazy val EnumValuesDefinition: Parser[List[Ast.EnumValueDefinition]] =\n-    braces(EnumValueDefinition.rep0)\n+    lazy val FieldsDefinition: Parser[List[Ast.FieldDefinition]] =\n+      braces(FieldDefinition.rep0)\n \n-  lazy val EnumValueDefinition: Parser[Ast.EnumValueDefinition] =\n-    (Description.?.with1 ~ Name ~ Directives.?).map {\n-      case ((desc, name), dirs) => Ast.EnumValueDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n-    }\n+    lazy val FieldDefinition: Parser[Ast.FieldDefinition] =\n+      (Description.?.with1 ~ Name ~ ArgumentsDefinition.? ~ punctuation(\":\") ~ Type ~ Directives.?).map {\n+        case (((((desc, name), args), _), tpe), dirs) => Ast.FieldDefinition(name, desc.map(_.value), args.getOrElse(Nil), tpe, dirs.getOrElse(Nil))\n+      }\n \n-  lazy val DirectiveLocations: Parser0[List[Ast.DirectiveLocation]] =\n-    punctuation(\"|\").? *> DirectiveLocation.repSep0(punctuation(\"|\"))\n-\n-  lazy val DirectiveLocation: Parser[Ast.DirectiveLocation] =\n-    keyword(\"QUERY\")       .as(Ast.DirectiveLocation.QUERY) |\n-    keyword(\"MUTATION\")    .as(Ast.DirectiveLocation.MUTATION) |\n-    keyword(\"SUBSCRIPTION\").as(Ast.DirectiveLocation.SUBSCRIPTION) |\n-    keyword(\"FIELD_DEFINITION\").as(Ast.DirectiveLocation.FIELD_DEFINITION) |\n-    keyword(\"FIELD\").as(Ast.DirectiveLocation.FIELD) |\n-    keyword(\"FRAGMENT_DEFINITION\").as(Ast.DirectiveLocation.FRAGMENT_DEFINITION) |\n-    keyword(\"FRAGMENT_SPREAD\").as(Ast.DirectiveLocation.FRAGMENT_SPREAD) |\n-    keyword(\"INLINE_FRAGMENT\").as(Ast.DirectiveLocation.INLINE_FRAGMENT) |\n-    keyword(\"VARIABLE_DEFINITION\").as(Ast.DirectiveLocation.VARIABLE_DEFINITION) |\n-    keyword(\"SCHEMA\").as(Ast.DirectiveLocation.SCHEMA) |\n-    keyword(\"SCALAR\").as(Ast.DirectiveLocation.SCALAR) |\n-    keyword(\"OBJECT\").as(Ast.DirectiveLocation.OBJECT) |\n-    keyword(\"ARGUMENT_DEFINITION\").as(Ast.DirectiveLocation.ARGUMENT_DEFINITION) |\n-    keyword(\"INTERFACE\").as(Ast.DirectiveLocation.INTERFACE) |\n-    keyword(\"UNION\").as(Ast.DirectiveLocation.UNION) |\n-    keyword(\"ENUM_VALUE\").as(Ast.DirectiveLocation.ENUM_VALUE) |\n-    keyword(\"ENUM\").as(Ast.DirectiveLocation.ENUM) |\n-    keyword(\"INPUT_OBJECT\").as(Ast.DirectiveLocation.INPUT_OBJECT) |\n-    keyword(\"INPUT_FIELD_DEFINITION\").as(Ast.DirectiveLocation.INPUT_FIELD_DEFINITION)\n-\n-  lazy val ExecutableDefinition: Parser[Ast.ExecutableDefinition] =\n-    OperationDefinition | FragmentDefinition\n-\n-  lazy val OperationDefinition: Parser[Ast.OperationDefinition] =\n-    QueryShorthand | Operation\n-\n-  lazy val QueryShorthand: Parser[Ast.OperationDefinition.QueryShorthand] =\n-    SelectionSet.map(Ast.OperationDefinition.QueryShorthand.apply)\n-\n-  lazy val Operation: Parser[Ast.OperationDefinition.Operation] =\n-    (OperationType ~ Name.? ~ VariableDefinitions.? ~ Directives ~ SelectionSet).map {\n-      case ((((op, name), vars), dirs), sels) => Ast.OperationDefinition.Operation(op, name, vars.orEmpty, dirs, sels)\n-    }\n+    lazy val ArgumentsDefinition: Parser[List[Ast.InputValueDefinition]] =\n+      parens(InputValueDefinition.rep0)\n \n-  lazy val OperationType: Parser[Ast.OperationType] =\n-    keyword(\"query\")       .as(Ast.OperationType.Query) |\n-    keyword(\"mutation\")    .as(Ast.OperationType.Mutation) |\n-    keyword(\"subscription\").as(Ast.OperationType.Subscription)\n+    lazy val InputFieldsDefinition: Parser[List[Ast.InputValueDefinition]] =\n+      braces(InputValueDefinition.rep0)\n \n-  lazy val SelectionSet: Parser[List[Ast.Selection]] = recursive[List[Ast.Selection]] { rec =>\n+    lazy val InputValueDefinition: Parser[Ast.InputValueDefinition] =\n+      (Description.?.with1 ~ (Name <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n+        case ((((desc, name), tpe), dv), dirs) => Ast.InputValueDefinition(name, desc.map(_.value), tpe, dv, dirs.getOrElse(Nil))\n+      }\n \n-    val Alias: Parser[Ast.Name] =\n-      Name <* punctuation(\":\")\n+    lazy val UnionMemberTypes: Parser[List[Ast.Type.Named]] =\n+      (punctuation(\"=\") *> punctuation(\"|\").?) *> NamedType.repSep0(punctuation(\"|\"))\n \n-    val Field: Parser[Ast.Selection.Field] =\n-      (Alias.backtrack.?.with1 ~ Name ~ Arguments.? ~ Directives ~ rec.?).map {\n-        case ((((alias, name), args), dirs), sel) => Ast.Selection.Field(alias, name, args.orEmpty, dirs, sel.orEmpty)\n+    lazy val EnumValuesDefinition: Parser[List[Ast.EnumValueDefinition]] =\n+      braces(EnumValueDefinition.rep0)\n+\n+    lazy val EnumValueDefinition: Parser[Ast.EnumValueDefinition] =\n+      (Description.?.with1 ~ Name ~ Directives.?).map {\n+        case ((desc, name), dirs) => Ast.EnumValueDefinition(name, desc.map(_.value), dirs.getOrElse(Nil))\n+      }\n+\n+    lazy val DirectiveLocations: Parser0[List[Ast.DirectiveLocation]] =\n+      punctuation(\"|\").? *> DirectiveLocation.repSep0(punctuation(\"|\"))\n+\n+    lazy val DirectiveLocation: Parser[Ast.DirectiveLocation] =\n+      keyword(\"QUERY\")       .as(Ast.DirectiveLocation.QUERY) |\n+      keyword(\"MUTATION\")    .as(Ast.DirectiveLocation.MUTATION) |\n+      keyword(\"SUBSCRIPTION\").as(Ast.DirectiveLocation.SUBSCRIPTION) |\n+      keyword(\"FIELD_DEFINITION\").as(Ast.DirectiveLocation.FIELD_DEFINITION) |\n+      keyword(\"FIELD\").as(Ast.DirectiveLocation.FIELD) |\n+      keyword(\"FRAGMENT_DEFINITION\").as(Ast.DirectiveLocation.FRAGMENT_DEFINITION) |\n+      keyword(\"FRAGMENT_SPREAD\").as(Ast.DirectiveLocation.FRAGMENT_SPREAD) |\n+      keyword(\"INLINE_FRAGMENT\").as(Ast.DirectiveLocation.INLINE_FRAGMENT) |\n+      keyword(\"VARIABLE_DEFINITION\").as(Ast.DirectiveLocation.VARIABLE_DEFINITION) |\n+      keyword(\"SCHEMA\").as(Ast.DirectiveLocation.SCHEMA) |\n+      keyword(\"SCALAR\").as(Ast.DirectiveLocation.SCALAR) |\n+      keyword(\"OBJECT\").as(Ast.DirectiveLocation.OBJECT) |\n+      keyword(\"ARGUMENT_DEFINITION\").as(Ast.DirectiveLocation.ARGUMENT_DEFINITION) |\n+      keyword(\"INTERFACE\").as(Ast.DirectiveLocation.INTERFACE) |\n+      keyword(\"UNION\").as(Ast.DirectiveLocation.UNION) |\n+      keyword(\"ENUM_VALUE\").as(Ast.DirectiveLocation.ENUM_VALUE) |\n+      keyword(\"ENUM\").as(Ast.DirectiveLocation.ENUM) |\n+      keyword(\"INPUT_OBJECT\").as(Ast.DirectiveLocation.INPUT_OBJECT) |\n+      keyword(\"INPUT_FIELD_DEFINITION\").as(Ast.DirectiveLocation.INPUT_FIELD_DEFINITION)\n+\n+    lazy val ExecutableDefinition: Parser[Ast.ExecutableDefinition] =\n+      OperationDefinition | FragmentDefinition\n+\n+    lazy val OperationDefinition: Parser[Ast.OperationDefinition] =\n+      QueryShorthand | Operation\n+\n+    lazy val QueryShorthand: Parser[Ast.OperationDefinition.QueryShorthand] =\n+      SelectionSet.map(Ast.OperationDefinition.QueryShorthand.apply)\n+\n+    lazy val Operation: Parser[Ast.OperationDefinition.Operation] =\n+      (OperationType ~ Name.? ~ VariableDefinitions.? ~ Directives ~ SelectionSet).map {\n+        case ((((op, name), vars), dirs), sels) => Ast.OperationDefinition.Operation(op, name, vars.orEmpty, dirs, sels)\n       }\n \n-    val FragmentSpread: Parser[Ast.Selection.FragmentSpread] =\n+    lazy val OperationType: Parser[Ast.OperationType] =\n+      keyword(\"query\")       .as(Ast.OperationType.Query) |\n+      keyword(\"mutation\")    .as(Ast.OperationType.Mutation) |\n+      keyword(\"subscription\").as(Ast.OperationType.Subscription)\n+\n+    lazy val Alias: Parser[Ast.Name] =\n+      Name <* punctuation(\":\")\n+\n+    lazy val FragmentSpread: Parser[Ast.Selection.FragmentSpread] =\n       (FragmentName ~ Directives).map{ case (name, dirs) => Ast.Selection.FragmentSpread.apply(name, dirs)}\n \n-    val InlineFragment: Parser[Ast.Selection.InlineFragment] =\n-      ((TypeCondition.? ~ Directives).with1 ~ rec).map {\n+    def Field(n: Int): Parser[Ast.Selection.Field] =\n+      (Alias.backtrack.?.with1 ~ Name ~ Arguments.? ~ Directives ~ SelectionSetN(n).?).map {\n+        case ((((alias, name), args), dirs), sel) => Ast.Selection.Field(alias, name, args.orEmpty, dirs, sel.orEmpty)\n+      }\n+\n+    def InlineFragment(n: Int): Parser[Ast.Selection.InlineFragment] =\n+      ((TypeCondition.? ~ Directives).with1 ~ SelectionSetN(n)).map {\n         case ((cond, dirs), sel) => Ast.Selection.InlineFragment(cond, dirs, sel)\n       }\n \n-    val Selection: Parser[Ast.Selection] =\n-      Field |\n-      (punctuation(\"...\") *> (InlineFragment | FragmentSpread))\n+    def Selection(n: Int): Parser[Ast.Selection] =\n+      Field(n) |\n+      (punctuation(\"...\") *> (InlineFragment(n) | FragmentSpread))\n \n-    braces(Selection.rep0)\n-  }\n+    lazy val SelectionSet: Parser[List[Ast.Selection]] =\n+      SelectionSetN(maxSelectionDepth)\n \n-  lazy val Arguments: Parser[List[(Ast.Name, Ast.Value)]] =\n-    parens(Argument.rep0)\n+    def SelectionSetN(n: Int): Parser[List[Ast.Selection]] =\n+      braces(guard0(n, \"exceeded maximum selection depth\")(Selection(_).repAs0(max = maxSelectionWidth)))\n \n-  lazy val Argument: Parser[(Ast.Name, Ast.Value)] =\n-    (Name <* punctuation(\":\")) ~ Value\n+    lazy val Arguments: Parser[List[(Ast.Name, Ast.Value)]] =\n+      parens(Argument.rep0)\n \n-  lazy val FragmentName: Parser[Ast.Name] =\n-    not(string(\"on\")).with1 *> Name\n+    lazy val Argument: Parser[(Ast.Name, Ast.Value)] =\n+      (Name <* punctuation(\":\")) ~ Value\n \n-  lazy val FragmentDefinition: Parser[Ast.FragmentDefinition] =\n-    ((keyword(\"fragment\") *> FragmentName) ~ TypeCondition ~ Directives ~ SelectionSet).map {\n-      case (((name, cond), dirs), sel) => Ast.FragmentDefinition(name, cond, dirs, sel)\n-    }\n+    lazy val FragmentName: Parser[Ast.Name] =\n+      not(string(\"on\")).with1 *> Name\n \n-  lazy val TypeCondition: Parser[Ast.Type.Named] =\n-    keyword(\"on\") *> NamedType\n+    lazy val FragmentDefinition: Parser[Ast.FragmentDefinition] =\n+      ((keyword(\"fragment\") *> FragmentName) ~ TypeCondition ~ Directives ~ SelectionSet).map {\n+        case (((name, cond), dirs), sel) => Ast.FragmentDefinition(name, cond, dirs, sel)\n+      }\n \n-  lazy val Value: Parser[Ast.Value] = recursive[Ast.Value] { rec =>\n+    lazy val TypeCondition: Parser[Ast.Type.Named] =\n+      keyword(\"on\") *> NamedType\n \n-    val NullValue: Parser[Ast.Value.NullValue.type] =\n+    lazy val NullValue: Parser[Ast.Value.NullValue.type] =\n       keyword(\"null\").as(Ast.Value.NullValue)\n \n     lazy val EnumValue: Parser[Ast.Value.EnumValue] =\n       (not(string(\"true\") | string(\"false\") | string(\"null\")).with1 *> Name)\n         .map(Ast.Value.EnumValue.apply)\n \n-    val ListValue: Parser[Ast.Value.ListValue] =\n-      token(squareBrackets(rec.rep0).map(Ast.Value.ListValue.apply))\n-\n-    val NumericLiteral: Parser[Ast.Value] = {\n+    def ListValue(n: Int): Parser[Ast.Value.ListValue] =\n+      token(squareBrackets(guard0(n, \"exceeded maximum input value depth\")(ValueN(_).rep0)).map(Ast.Value.ListValue.apply))\n \n+    lazy val NumericLiteral: Parser[Ast.Value] = {\n       def narrow(d: BigDecimal): Ast.Value.FloatValue =\n         Ast.Value.FloatValue(d.toDouble)\n \n@@ -301,204 +338,199 @@ object GraphQLParser {\n       )\n     }\n \n-    val BooleanValue: Parser[Ast.Value.BooleanValue] =\n+    lazy val BooleanValue: Parser[Ast.Value.BooleanValue] =\n       token(booleanLiteral).map(Ast.Value.BooleanValue.apply)\n \n-    val ObjectField: Parser[(Ast.Name, Ast.Value)] =\n-      (Name <* punctuation(\":\")) ~ rec\n+    def ObjectField(n: Int): Parser[(Ast.Name, Ast.Value)] =\n+      (Name <* punctuation(\":\")) ~ ValueN(n)\n \n-    val ObjectValue: Parser[Ast.Value.ObjectValue] =\n-      braces(ObjectField.rep0).map(Ast.Value.ObjectValue.apply)\n+    def ObjectValue(n: Int): Parser[Ast.Value.ObjectValue] =\n+      braces(guard0(n, \"exceeded maximum input value depth\")(ObjectField(_).rep0)).map(Ast.Value.ObjectValue.apply)\n \n-    Variable |\n-      NumericLiteral |\n-      StringValue |\n-      BooleanValue |\n-      NullValue |\n-      EnumValue |\n-      ListValue |\n-      ObjectValue\n-  }\n+    lazy val StringValue: Parser[Ast.Value.StringValue] =\n+      token(stringLiteral).map(Ast.Value.StringValue.apply)\n \n-  lazy val StringValue: Parser[Ast.Value.StringValue] =\n-    token(stringLiteral).map(Ast.Value.StringValue.apply)\n+    def ValueN(n: Int): Parser[Ast.Value] =\n+      Variable |\n+        NumericLiteral |\n+        StringValue |\n+        BooleanValue |\n+        NullValue |\n+        EnumValue |\n+        ListValue(n) |\n+        ObjectValue(n)\n \n-  lazy val VariableDefinitions: Parser[List[Ast.VariableDefinition]] =\n-    parens(VariableDefinition.rep0)\n+    lazy val Value: Parser[Ast.Value] =\n+      ValueN(maxInputValueDepth)\n \n-  lazy val VariableDefinition: Parser[Ast.VariableDefinition] =\n-    ((Variable <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n-      case (((v, tpe), dv), dirs) => Ast.VariableDefinition(v.name, tpe, dv, dirs.getOrElse(Nil))\n-    }\n+    lazy val VariableDefinitions: Parser[List[Ast.VariableDefinition]] =\n+      parens(VariableDefinition.rep0)\n \n-  lazy val Variable: Parser[Ast.Value.Variable] =\n-    punctuation(\"$\") *> Name.map(Ast.Value.Variable.apply)\n+    lazy val VariableDefinition: Parser[Ast.VariableDefinition] =\n+      ((Variable <* punctuation(\":\")) ~ Type ~ DefaultValue.? ~ Directives.?).map {\n+        case (((v, tpe), dv), dirs) => Ast.VariableDefinition(v.name, tpe, dv, dirs.getOrElse(Nil))\n+      }\n \n-  lazy val DefaultValue: Parser[Ast.Value] =\n-    punctuation(\"=\") *> Value\n+    lazy val Variable: Parser[Ast.Value.Variable] =\n+      punctuation(\"$\") *> Name.map(Ast.Value.Variable.apply)\n \n-  lazy val Type: Parser[Ast.Type] = recursive[Ast.Type] { rec =>\n+    lazy val DefaultValue: Parser[Ast.Value] =\n+      punctuation(\"=\") *> Value\n \n-    lazy val ListType: Parser[Ast.Type.List] =\n-      squareBrackets(rec).map(Ast.Type.List.apply)\n+    def ListType(n: Int): Parser[Ast.Type.List] =\n+      squareBrackets(guard(n, \"exceeded maximum list type depth\")(TypeN)).map(Ast.Type.List.apply)\n \n-    val namedMaybeNull: Parser[Ast.Type] = (NamedType ~ punctuation(\"!\").?).map {\n+    lazy val namedMaybeNull: Parser[Ast.Type] = (NamedType ~ punctuation(\"!\").?).map {\n       case (t, None) => t\n       case (t, _) => Ast.Type.NonNull(Left(t))\n     }\n \n-    val listMaybeNull: Parser[Ast.Type] = (ListType ~ punctuation(\"!\").?).map {\n+    def listMaybeNull(n: Int): Parser[Ast.Type] = (ListType(n) ~ punctuation(\"!\").?).map {\n       case (t, None) => t\n       case (t, _) => Ast.Type.NonNull(Right(t))\n     }\n \n-    namedMaybeNull | listMaybeNull\n-  }\n+    def TypeN(n: Int): Parser[Ast.Type] =\n+      namedMaybeNull | listMaybeNull(n)\n \n-  lazy val NamedType: Parser[Ast.Type.Named] =\n-    Name.map(Ast.Type.Named.apply)\n+    lazy val Type: Parser[Ast.Type] =\n+      TypeN(maxListTypeDepth)\n \n-  lazy val Directives: Parser0[List[Ast.Directive]] =\n-    Directive.rep0\n+    lazy val NamedType: Parser[Ast.Type.Named] =\n+      Name.map(Ast.Type.Named.apply)\n \n-  lazy val Directive: Parser[Ast.Directive] =\n-    punctuation(\"@\") *> (Name ~ Arguments.?).map { case (n, ods) => Ast.Directive(n, ods.orEmpty)}\n+    lazy val Directives: Parser0[List[Ast.Directive]] =\n+      Directive.rep0\n \n-  lazy val Name: Parser[Ast.Name] =\n-    token(charIn(nameInitial) ~ charIn(nameSubsequent).rep0).map {\n-      case (h, t) => Ast.Name((h :: t).mkString)\n-    }\n+    lazy val Directive: Parser[Ast.Directive] =\n+      punctuation(\"@\") *> (Name ~ Arguments.?).map { case (n, ods) => Ast.Directive(n, ods.orEmpty)}\n \n-  def toResult[T](text: String, pr: Either[Parser.Error, T]): Result[T] =\n-    Result.fromEither(pr.leftMap { e =>\n-      val lm = LocationMap(text)\n-      lm.toLineCol(e.failedAtOffset) match {\n-        case Some((row, col)) =>\n-          lm.getLine(row) match {\n-            case Some(line) =>\n-              s\"\"\"Parse error at line $row column $col\n-                  |$line\n-                  |${List.fill(col)(\" \").mkString}^\"\"\".stripMargin\n-            case None => \"Malformed query\" //This is probably a bug in Cats Parse as it has given us the (row, col) index\n-          }\n-        case None => \"Truncated query\"\n+    lazy val Name: Parser[Ast.Name] =\n+      token(charIn(nameInitial) ~ charIn(nameSubsequent).rep0).map {\n+        case (h, t) => Ast.Name((h :: t).mkString)\n       }\n-    })\n-}\n \n-object CommentedText {\n+    def guard0[T](n: Int, msg: String)(p: Int => Parser0[T]): Parser0[T] =\n+      if (n <= 0) Parser.failWith(msg) else defer0(p(n-1))\n \n-  val whitespace: Parser[Char] = charWhere(_.isWhitespace)\n+    def guard[T](n: Int, msg: String)(p: Int => Parser[T]): Parser[T] =\n+      if (n <= 0) Parser.failWith(msg) else defer(p(n-1))\n+  }\n \n-  val skipWhitespace: Parser0[Unit] =\n-    charsWhile0(c => c.isWhitespace || c == ',').void.withContext(\"whitespace\")\n+  private object CommentedText {\n \n-  /** Parser that consumes a comment */\n-  val comment: Parser[Unit] =\n-    (char('#') *> (charWhere(c => c != '\\n' && c != '\\r')).rep0 <* charIn('\\n', '\\r') <* skipWhitespace).void.withContext(\"comment\")\n+    val whitespace: Parser[Char] = charWhere(_.isWhitespace)\n \n-  /** Turns a parser into one that skips trailing whitespace and comments */\n-  def token[A](p: Parser[A]): Parser[A] =\n-    p <* skipWhitespace <* comment.rep0\n+    val skipWhitespace: Parser0[Unit] =\n+      charsWhile0(c => c.isWhitespace || c == ',').void\n \n-  def token0[A](p: Parser0[A]): Parser0[A] =\n-    p <* skipWhitespace <* comment.rep0\n+    /** Parser that consumes a comment */\n+    val comment: Parser[Unit] =\n+      (char('#') *> (charWhere(c => c != '\\n' && c != '\\r')).rep0 <* charIn('\\n', '\\r') <* skipWhitespace).void\n \n-  /**\n-   * Consumes `left` and `right`, including the trailing and preceding whitespace,\n-   * respectively, and returns the value of `p`.\n-   */\n-  private def _bracket[A,B,C](left: Parser[B], p: Parser0[A], right: Parser[C]): Parser[A] =\n-    token(left) *> token0(p) <* token(right)\n+    /** Turns a parser into one that skips trailing whitespace and comments */\n+    def token[A](p: Parser[A]): Parser[A] =\n+      p <* skipWhitespace <* comment.rep0\n \n-  /** Turns a parser into one that consumes surrounding parentheses `()` */\n-  def parens[A](p: Parser0[A]): Parser[A] =\n-    _bracket(char('('), p, char(')')).withContext(s\"parens(${p.toString})\")\n+    def token0[A](p: Parser0[A]): Parser0[A] =\n+      p <* skipWhitespace <* comment.rep0\n \n-  /** Turns a parser into one that consumes surrounding curly braces `{}` */\n-  def braces[A](p: Parser0[A]): Parser[A] =\n-    _bracket(char('{'), p, char('}')).withContext(s\"braces(${p.toString})\")\n+    /**\n+    * Consumes `left` and `right`, including the trailing and preceding whitespace,\n+    * respectively, and returns the value of `p`.\n+    */\n+    private def _bracket[A,B,C](left: Parser[B], p: Parser0[A], right: Parser[C]): Parser[A] =\n+      token(left) *> token0(p) <* token(right)\n \n-  /** Turns a parser into one that consumes surrounding square brackets `[]` */\n-  def squareBrackets[A](p: Parser0[A]): Parser[A] =\n-    _bracket(char('['), p, char(']')).withContext(s\"squareBrackets(${p.toString})\")\n-}\n+    /** Turns a parser into one that consumes surrounding parentheses `()` */\n+    def parens[A](p: Parser0[A]): Parser[A] =\n+      _bracket(char('('), p, char(')'))\n \n-object Literals {\n+    /** Turns a parser into one that consumes surrounding curly braces `{}` */\n+    def braces[A](p: Parser0[A]): Parser[A] =\n+      _bracket(char('{'), p, char('}'))\n \n-  val stringLiteral: Parser[String] = {\n+    /** Turns a parser into one that consumes surrounding square brackets `[]` */\n+    def squareBrackets[A](p: Parser0[A]): Parser[A] =\n+      _bracket(char('['), p, char(']'))\n+  }\n \n-    val lineTerminator: Parser[String] = (lf | cr | crlf).string\n+  private object Literals {\n \n-    val sourceCharacter: Parser[String] = (charIn(0x0009.toChar, 0x000A.toChar, 0x000D.toChar) | charIn(0x0020.toChar to 0xFFFF.toChar)).string\n+    val stringLiteral: Parser[String] = {\n \n-    val escapedUnicode: Parser[String] = string(\"\\\\u\") *>\n-      hexdig\n-        .repExactlyAs[String](4)\n-        .map(hex => Integer.parseInt(hex, 16).toChar.toString)\n+      val lineTerminator: Parser[String] = (lf | cr | crlf).string\n \n-    val escapedCharacter: Parser[String] = char('\\\\') *>\n-      (\n-        char('\"').as(\"\\\"\") |\n-          char('\\\\').as(\"\\\\\") |\n-          char('/').as(\"/\") |\n-          char('b').as(\"\\b\") |\n-          char('f').as(\"\\f\") |\n-          char('n').as(\"\\n\") |\n-          char('r').as(\"\\r\") |\n-          char('t').as(\"\\t\")\n-      )\n+      val sourceCharacter: Parser[String] = (charIn(0x0009.toChar, 0x000A.toChar, 0x000D.toChar) | charIn(0x0020.toChar to 0xFFFF.toChar)).string\n \n-    val stringCharacter: Parser[String] = (\n-      (not(charIn('\"', '\\\\') | lineTerminator).with1 *> sourceCharacter) |\n-        escapedUnicode |\n-       escapedCharacter\n-    )\n+      val escapedUnicode: Parser[String] = string(\"\\\\u\") *>\n+        hexdig\n+          .repExactlyAs[String](4)\n+          .map(hex => Integer.parseInt(hex, 16).toChar.toString)\n+\n+      val escapedCharacter: Parser[String] = char('\\\\') *>\n+        (\n+          char('\"').as(\"\\\"\") |\n+            char('\\\\').as(\"\\\\\") |\n+            char('/').as(\"/\") |\n+            char('b').as(\"\\b\") |\n+            char('f').as(\"\\f\") |\n+            char('n').as(\"\\n\") |\n+            char('r').as(\"\\r\") |\n+            char('t').as(\"\\t\")\n+        )\n \n-    val blockStringCharacter: Parser[String] = string(\"\\\\\\\"\\\"\\\"\").as(\"\\\"\\\"\\\"\") |\n-      (not(string(\"\\\"\\\"\\\"\")).with1 *> sourceCharacter)\n-\n-    //https://spec.graphql.org/June2018/#BlockStringValue()\n-    //TODO this traverses over lines a hideous number of times(but matching the\n-    //algorithm in the spec). Can it be optimized?\n-    val blockQuotesInner: Parser0[String] = blockStringCharacter.repAs0[String].map { str =>\n-      val isWhitespace: Regex = \"[ \\t]*\".r\n-      var commonIndent: Int = -1\n-      var lineNum: Int = 0\n-      for (line <- str.linesIterator) {\n-        if (lineNum != 0) {\n-          val len = line.length()\n-          val indent = line.takeWhile(c => c == ' ' || c == '\\t').length()\n-          if (indent < len) {\n-            if (commonIndent < 0 || indent < commonIndent) {\n-              commonIndent = indent\n+      val stringCharacter: Parser[String] = (\n+        (not(charIn('\"', '\\\\') | lineTerminator).with1 *> sourceCharacter) |\n+          escapedUnicode |\n+        escapedCharacter\n+      )\n+\n+      val blockStringCharacter: Parser[String] = string(\"\\\\\\\"\\\"\\\"\").as(\"\\\"\\\"\\\"\") |\n+        (not(string(\"\\\"\\\"\\\"\")).with1 *> sourceCharacter)\n+\n+      //https://spec.graphql.org/June2018/#BlockStringValue()\n+      //TODO this traverses over lines a hideous number of times(but matching the\n+      //algorithm in the spec). Can it be optimized?\n+      val blockQuotesInner: Parser0[String] = blockStringCharacter.repAs0[String].map { str =>\n+        val isWhitespace: Regex = \"[ \\t]*\".r\n+        var commonIndent: Int = -1\n+        var lineNum: Int = 0\n+        for (line <- str.linesIterator) {\n+          if (lineNum != 0) {\n+            val len = line.length()\n+            val indent = line.takeWhile(c => c == ' ' || c == '\\t').length()\n+            if (indent < len) {\n+              if (commonIndent < 0 || indent < commonIndent) {\n+                commonIndent = indent\n+              }\n             }\n           }\n+          lineNum = lineNum + 1\n         }\n-        lineNum = lineNum + 1\n-      }\n-      val formattedReversed: List[String] = if ( commonIndent >= 0) {\n-        str.linesIterator.foldLeft[List[String]](Nil) {\n-          (acc, l) => if (acc == Nil) l :: acc else l.drop(commonIndent) :: acc\n+        val formattedReversed: List[String] = if ( commonIndent >= 0) {\n+          str.linesIterator.foldLeft[List[String]](Nil) {\n+            (acc, l) => if (acc == Nil) l :: acc else l.drop(commonIndent) :: acc\n+          }\n+        } else {\n+          str.linesIterator.toList\n         }\n-      } else {\n-        str.linesIterator.toList\n+        val noTrailingEmpty = formattedReversed.dropWhile(isWhitespace.matches(_)).reverse\n+        noTrailingEmpty.dropWhile(isWhitespace.matches(_)).mkString(\"\\n\")\n       }\n-      val noTrailingEmpty = formattedReversed.dropWhile(isWhitespace.matches(_)).reverse\n-      noTrailingEmpty.dropWhile(isWhitespace.matches(_)).mkString(\"\\n\")\n-    }\n \n \n-    (not(string(\"\\\"\\\"\\\"\")).with1 *> stringCharacter.repAs0[String].with1.surroundedBy(char('\"'))) | blockQuotesInner.with1.surroundedBy(string(\"\\\"\\\"\\\"\"))\n+      (not(string(\"\\\"\\\"\\\"\")).with1 *> stringCharacter.repAs0[String].with1.surroundedBy(char('\"'))) | blockQuotesInner.with1.surroundedBy(string(\"\\\"\\\"\\\"\"))\n \n-  }\n-\n-  val intLiteral: Parser[Int] =\n-    bigInt.flatMap {\n-      case v if v.isValidInt => pure(v.toInt)\n-      case v => failWith(s\"$v is larger than max int\")\n     }\n \n-  val booleanLiteral: Parser[Boolean] = string(\"true\").as(true) | string(\"false\").as(false)\n+    val intLiteral: Parser[Int] =\n+      bigInt.flatMap {\n+        case v if v.isValidInt => pure(v.toInt)\n+        case v => failWith(s\"$v is larger than max int\")\n+      }\n \n+    val booleanLiteral: Parser[Boolean] = string(\"true\").as(true) | string(\"false\").as(false)\n+\n+  }\n }"
        },
        {
            "filename": "modules/core/src/main/scala/schema.scala",
            "diff": "@@ -228,7 +228,10 @@ trait Schema {\n \n object Schema {\n   def apply(schemaText: String)(implicit pos: SourcePos): Result[Schema] =\n-    SchemaParser.parseText(schemaText)\n+    apply(schemaText, SchemaParser(GraphQLParser(GraphQLParser.defaultConfig)))\n+\n+  def apply(schemaText: String, parser: SchemaParser)(implicit pos: SourcePos): Result[Schema] =\n+    parser.parseText(schemaText)\n }\n \n case class SchemaExtension(\n@@ -940,6 +943,23 @@ object Value {\n \n   case object AbsentValue extends Value\n \n+  def fromAst(value: Ast.Value): Result[Value] = {\n+    value match {\n+      case Ast.Value.IntValue(i) => IntValue(i).success\n+      case Ast.Value.FloatValue(d) => FloatValue(d).success\n+      case Ast.Value.StringValue(s) => StringValue(s).success\n+      case Ast.Value.BooleanValue(b) => BooleanValue(b).success\n+      case Ast.Value.EnumValue(e) => EnumValue(e.value).success\n+      case Ast.Value.Variable(v) => VariableRef(v.value).success\n+      case Ast.Value.NullValue => NullValue.success\n+      case Ast.Value.ListValue(vs) => vs.traverse(fromAst).map(ListValue(_))\n+      case Ast.Value.ObjectValue(fs) =>\n+        fs.traverse { case (name, value) =>\n+          fromAst(value).map(v => (name.value, v))\n+        }.map(ObjectValue(_))\n+    }\n+  }\n+\n   object StringListValue {\n     def apply(ss: List[String]): Value =\n       ListValue(ss.map(StringValue(_)))\n@@ -961,7 +981,7 @@ object Value {\n     def loop(value: Value): Result[Value] =\n       value match {\n         case VariableRef(varName) =>\n-          Result.fromOption(vars.get(varName).map(_._2), s\"Undefined variable '$varName'\")\n+          Result.fromOption(vars.get(varName).map(_._2), s\"Variable '$varName' is undefined\")\n         case ObjectValue(fields) =>\n           val (keys, values) = fields.unzip\n           values.traverse(loop).map(evs => ObjectValue(keys.zip(evs)))\n@@ -1166,6 +1186,13 @@ case class Directive(\n )\n \n object Directive {\n+  def fromAst(d: Ast.Directive): Result[Directive] = {\n+    val Ast.Directive(Ast.Name(nme), args) = d\n+    args.traverse {\n+      case (Ast.Name(nme), value) => Value.fromAst(value).map(Binding(nme, _))\n+    }.map(Directive(nme, _))\n+  }\n+\n   def validateDirectivesForSchema(schema: Schema): List[Problem] = {\n     def validateTypeDirectives(tpe: NamedType): List[Problem] =\n       tpe match {\n@@ -1325,268 +1352,254 @@ object Directive {\n /**\n  * GraphQL schema parser\n  */\n+trait SchemaParser {\n+    def parseText(text: String)(implicit pos: SourcePos): Result[Schema]\n+    def parseDocument(doc: Ast.Document)(implicit sourcePos: SourcePos): Result[Schema]\n+}\n+\n object SchemaParser {\n+  def apply(parser: GraphQLParser): SchemaParser =\n+    new Impl(parser)\n \n-  import Ast.{Directive => _, EnumValueDefinition => _, SchemaExtension => _, Type => _, TypeExtension => _, Value => _, _}\n+  private final class Impl(parser: GraphQLParser) extends SchemaParser {\n \n-  /**\n-   * Parse a query String to a query algebra term.\n-   *\n-   * Yields a Query value on the right and accumulates errors on the left.\n-   */\n-  def parseText(text: String)(implicit pos: SourcePos): Result[Schema] =\n-    for {\n-      doc <- GraphQLParser.toResult(text, GraphQLParser.Document.parseAll(text))\n-      query <- parseDocument(doc)\n-    } yield query\n-\n-  def parseDocument(doc: Document)(implicit sourcePos: SourcePos): Result[Schema] = {\n-    object schema extends Schema {\n-      var baseTypes: List[NamedType] = Nil\n-      var baseSchemaType1: Option[NamedType] = null\n-      var pos: SourcePos = sourcePos\n-\n-      override def baseSchemaType: NamedType = baseSchemaType1.getOrElse(super.baseSchemaType)\n-\n-      var directives: List[DirectiveDef] = Nil\n-      var schemaExtensions: List[SchemaExtension] = Nil\n-      var typeExtensions: List[TypeExtension] = Nil\n-\n-      def complete(types0: List[NamedType], baseSchemaType0: Option[NamedType], directives0: List[DirectiveDef], schemaExtensions0: List[SchemaExtension], typeExtensions0: List[TypeExtension]): Unit = {\n-        baseTypes = types0\n-        baseSchemaType1 = baseSchemaType0\n-        directives = directives0 ++ DirectiveDef.builtIns\n-        schemaExtensions = schemaExtensions0\n-        typeExtensions = typeExtensions0\n-      }\n-    }\n+    import Ast.{Directive => _, EnumValueDefinition => _, SchemaExtension => _, Type => _, TypeExtension => _, Value => _, _}\n \n-    val schemaExtnDefns: List[Ast.SchemaExtension] = doc.collect { case tpe: Ast.SchemaExtension => tpe }\n-    val typeDefns: List[TypeDefinition] = doc.collect { case tpe: TypeDefinition => tpe }\n-    val dirDefns: List[DirectiveDefinition] = doc.collect { case dir: DirectiveDefinition => dir }\n-    val extnDefns: List[Ast.TypeExtension] = doc.collect { case tpe: Ast.TypeExtension => tpe }\n+    /**\n+    * Parse a query String to a query algebra term.\n+    *\n+    * Yields a Query value on the right and accumulates errors on the left.\n+    */\n+    def parseText(text: String)(implicit pos: SourcePos): Result[Schema] =\n+      for {\n+        doc <- parser.parseText(text)\n+        query <- parseDocument(doc)\n+      } yield query\n+\n+    def parseDocument(doc: Document)(implicit sourcePos: SourcePos): Result[Schema] = {\n+      object schema extends Schema {\n+        var baseTypes: List[NamedType] = Nil\n+        var baseSchemaType1: Option[NamedType] = null\n+        var pos: SourcePos = sourcePos\n+\n+        override def baseSchemaType: NamedType = baseSchemaType1.getOrElse(super.baseSchemaType)\n+\n+        var directives: List[DirectiveDef] = Nil\n+        var schemaExtensions: List[SchemaExtension] = Nil\n+        var typeExtensions: List[TypeExtension] = Nil\n+\n+        def complete(types0: List[NamedType], baseSchemaType0: Option[NamedType], directives0: List[DirectiveDef], schemaExtensions0: List[SchemaExtension], typeExtensions0: List[TypeExtension]): Unit = {\n+          baseTypes = types0\n+          baseSchemaType1 = baseSchemaType0\n+          directives = directives0 ++ DirectiveDef.builtIns\n+          schemaExtensions = schemaExtensions0\n+          typeExtensions = typeExtensions0\n+        }\n+      }\n \n-    for {\n-      baseTypes   <- mkTypeDefs(schema, typeDefns)\n-      schemaExtns <- mkSchemaExtensions(schema, schemaExtnDefns)\n-      typeExtns   <- mkExtensions(schema, extnDefns)\n-      directives  <- mkDirectiveDefs(schema, dirDefns)\n-      schemaType  <- mkSchemaType(schema, doc)\n-      _           =  schema.complete(baseTypes, schemaType, directives, schemaExtns, typeExtns)\n-      _           <- Result.fromProblems(SchemaValidator.validateSchema(schema, typeDefns, extnDefns))\n-    } yield schema\n-  }\n+      val schemaExtnDefns: List[Ast.SchemaExtension] = doc.collect { case tpe: Ast.SchemaExtension => tpe }\n+      val typeDefns: List[TypeDefinition] = doc.collect { case tpe: TypeDefinition => tpe }\n+      val dirDefns: List[DirectiveDefinition] = doc.collect { case dir: DirectiveDefinition => dir }\n+      val extnDefns: List[Ast.TypeExtension] = doc.collect { case tpe: Ast.TypeExtension => tpe }\n \n-  // explicit Schema type, if any\n-  def mkSchemaType(schema: Schema, doc: Document): Result[Option[NamedType]] = {\n-    def build(dirs: List[Directive], ops: List[Field]): NamedType = {\n-      val query = ops.find(_.name == \"query\").getOrElse(Field(\"query\", None, Nil, defaultQueryType, Nil))\n-      ObjectType(\n-        name = \"Schema\",\n-        description = None,\n-        fields = query :: List(ops.find(_.name == \"mutation\"), ops.find(_.name == \"subscription\")).flatten,\n-        interfaces = Nil,\n-        directives = dirs\n-      )\n+      for {\n+        baseTypes   <- mkTypeDefs(schema, typeDefns)\n+        schemaExtns <- mkSchemaExtensions(schema, schemaExtnDefns)\n+        typeExtns   <- mkExtensions(schema, extnDefns)\n+        directives  <- mkDirectiveDefs(schema, dirDefns)\n+        schemaType  <- mkSchemaType(schema, doc)\n+        _           =  schema.complete(baseTypes, schemaType, directives, schemaExtns, typeExtns)\n+        _           <- Result.fromProblems(SchemaValidator.validateSchema(schema, typeDefns, extnDefns))\n+      } yield schema\n     }\n \n-    def defaultQueryType = schema.ref(\"Query\")\n+    // explicit Schema type, if any\n+    def mkSchemaType(schema: Schema, doc: Document): Result[Option[NamedType]] = {\n+      def build(dirs: List[Directive], ops: List[Field]): NamedType = {\n+        val query = ops.find(_.name == \"query\").getOrElse(Field(\"query\", None, Nil, defaultQueryType, Nil))\n+        ObjectType(\n+          name = \"Schema\",\n+          description = None,\n+          fields = query :: List(ops.find(_.name == \"mutation\"), ops.find(_.name == \"subscription\")).flatten,\n+          interfaces = Nil,\n+          directives = dirs\n+        )\n+      }\n+\n+      def defaultQueryType = schema.ref(\"Query\")\n \n-    val defns = doc.collect { case schema: SchemaDefinition => schema }\n-    defns match {\n-      case Nil => None.success\n-      case SchemaDefinition(rootOpTpes, dirs0) :: Nil =>\n-        for {\n-          ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n-          dirs <- dirs0.traverse(mkDirective)\n-        } yield Some(build(dirs, ops))\n+      val defns = doc.collect { case schema: SchemaDefinition => schema }\n+      defns match {\n+        case Nil => None.success\n+        case SchemaDefinition(rootOpTpes, dirs0) :: Nil =>\n+          for {\n+            ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n+            dirs <- dirs0.traverse(Directive.fromAst)\n+          } yield Some(build(dirs, ops))\n \n-      case _ => Result.failure(\"At most one schema definition permitted\")\n+        case _ => Result.failure(\"At most one schema definition permitted\")\n+      }\n     }\n-  }\n \n-  def mkSchemaExtensions(schema: Schema, extnDefns: List[Ast.SchemaExtension]): Result[List[SchemaExtension]] =\n-    extnDefns.traverse(mkSchemaExtension(schema))\n+    def mkSchemaExtensions(schema: Schema, extnDefns: List[Ast.SchemaExtension]): Result[List[SchemaExtension]] =\n+      extnDefns.traverse(mkSchemaExtension(schema))\n \n-  def mkSchemaExtension(schema: Schema)(se: Ast.SchemaExtension): Result[SchemaExtension] = {\n-    val Ast.SchemaExtension(rootOpTpes, dirs0) = se\n-    for {\n-      ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n-      dirs <- dirs0.traverse(mkDirective)\n-    } yield SchemaExtension(ops, dirs)\n-  }\n+    def mkSchemaExtension(schema: Schema)(se: Ast.SchemaExtension): Result[SchemaExtension] = {\n+      val Ast.SchemaExtension(rootOpTpes, dirs0) = se\n+      for {\n+        ops  <- rootOpTpes.traverse(mkRootOperation(schema))\n+        dirs <- dirs0.traverse(Directive.fromAst)\n+      } yield SchemaExtension(ops, dirs)\n+    }\n \n-  def mkRootOperation(schema: Schema)(rootTpe: RootOperationTypeDefinition): Result[Field] = {\n-    val RootOperationTypeDefinition(optype, tpe, dirs0) = rootTpe\n-    for {\n-      dirs <- dirs0.traverse(mkDirective)\n-      tpe  <- mkType(schema)(tpe)\n-      _    <- Result.failure(s\"Root operation types must be named types, found '$tpe'\").whenA(!tpe.nonNull.isNamed)\n-    } yield Field(optype.name, None, Nil, tpe, dirs)\n-  }\n+    def mkRootOperation(schema: Schema)(rootTpe: RootOperationTypeDefinition): Result[Field] = {\n+      val RootOperationTypeDefinition(optype, tpe, dirs0) = rootTpe\n+      for {\n+        dirs <- dirs0.traverse(Directive.fromAst)\n+        tpe  <- mkType(schema)(tpe)\n+        _    <- Result.failure(s\"Root operation types must be named types, found '$tpe'\").whenA(!tpe.nonNull.isNamed)\n+      } yield Field(optype.name, None, Nil, tpe, dirs)\n+    }\n \n-  def mkExtensions(schema: Schema, extnDefns: List[Ast.TypeExtension]): Result[List[TypeExtension]] =\n-    extnDefns.traverse(mkExtension(schema))\n+    def mkExtensions(schema: Schema, extnDefns: List[Ast.TypeExtension]): Result[List[TypeExtension]] =\n+      extnDefns.traverse(mkExtension(schema))\n+\n+    def mkExtension(schema: Schema)(ed: Ast.TypeExtension): Result[TypeExtension] =\n+      ed match {\n+        case ScalarTypeExtension(Ast.Type.Named(Name(name)), dirs0) =>\n+          for {\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield ScalarExtension(name, dirs)\n+        case InterfaceTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n+          for {\n+            fields <- fields0.traverse(mkField(schema))\n+            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield InterfaceExtension(name, fields, ifs, dirs)\n+        case ObjectTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n+          for {\n+            fields <- fields0.traverse(mkField(schema))\n+            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield ObjectExtension(name, fields, ifs, dirs)\n+        case UnionTypeExtension(Ast.Type.Named(Name(name)), dirs0, members0) =>\n+          for {\n+            dirs    <- dirs0.traverse(Directive.fromAst)\n+            members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n+          } yield UnionExtension(name, members, dirs)\n+        case EnumTypeExtension(Ast.Type.Named(Name(name)), dirs0, values0) =>\n+          for {\n+            values  <- values0.traverse(mkEnumValue)\n+            dirs    <- dirs0.traverse(Directive.fromAst)\n+          } yield EnumExtension(name, values, dirs)\n+        case InputObjectTypeExtension(Ast.Type.Named(Name(name)), dirs0, fields0) =>\n+          for {\n+            fields <- fields0.traverse(mkInputValue(schema))\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield InputObjectExtension(name, fields, dirs)\n+      }\n \n-  def mkExtension(schema: Schema)(ed: Ast.TypeExtension): Result[TypeExtension] =\n-    ed match {\n-      case ScalarTypeExtension(Ast.Type.Named(Name(name)), dirs0) =>\n-        for {\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield ScalarExtension(name, dirs)\n-      case InterfaceTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n-        for {\n-          fields <- fields0.traverse(mkField(schema))\n-          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield InterfaceExtension(name, fields, ifs, dirs)\n-      case ObjectTypeExtension(Ast.Type.Named(Name(name)), fields0, ifs0, dirs0) =>\n-        for {\n-          fields <- fields0.traverse(mkField(schema))\n-          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield ObjectExtension(name, fields, ifs, dirs)\n-      case UnionTypeExtension(Ast.Type.Named(Name(name)), dirs0, members0) =>\n-        for {\n-          dirs    <- dirs0.traverse(mkDirective)\n-          members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n-        } yield UnionExtension(name, members, dirs)\n-      case EnumTypeExtension(Ast.Type.Named(Name(name)), dirs0, values0) =>\n-        for {\n-          values  <- values0.traverse(mkEnumValue)\n-          dirs    <- dirs0.traverse(mkDirective)\n-        } yield EnumExtension(name, values, dirs)\n-      case InputObjectTypeExtension(Ast.Type.Named(Name(name)), dirs0, fields0) =>\n+    def mkTypeDefs(schema: Schema, defns: List[TypeDefinition]): Result[List[NamedType]] =\n+      defns.traverse(mkTypeDef(schema))\n+\n+    def mkTypeDef(schema: Schema)(td: TypeDefinition): Result[NamedType] = td match {\n+      case ScalarTypeDefinition(Name(\"Int\"), _, _) => IntType.success\n+      case ScalarTypeDefinition(Name(\"Float\"), _, _) => FloatType.success\n+      case ScalarTypeDefinition(Name(\"String\"), _, _) => StringType.success\n+      case ScalarTypeDefinition(Name(\"Boolean\"), _, _) => BooleanType.success\n+      case ScalarTypeDefinition(Name(\"ID\"), _, _) => IDType.success\n+      case ScalarTypeDefinition(Name(nme), desc, dirs0) =>\n         for {\n-          fields <- fields0.traverse(mkInputValue(schema))\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield InputObjectExtension(name, fields, dirs)\n+          dirs <- dirs0.traverse(Directive.fromAst)\n+        } yield ScalarType(nme, desc, dirs)\n+      case ObjectTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n+        if (fields0.isEmpty) Result.failure(s\"object type $nme must define at least one field\")\n+        else\n+          for {\n+            fields <- fields0.traverse(mkField(schema))\n+            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield ObjectType(nme, desc, fields, ifs, dirs)\n+      case InterfaceTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n+        if (fields0.isEmpty) Result.failure(s\"interface type $nme must define at least one field\")\n+        else\n+          for {\n+            fields <- fields0.traverse(mkField(schema))\n+            ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield InterfaceType(nme, desc, fields, ifs, dirs)\n+      case UnionTypeDefinition(Name(nme), desc, dirs0, members0) =>\n+        if (members0.isEmpty) Result.failure(s\"union type $nme must define at least one member\")\n+        else {\n+          for {\n+            dirs    <- dirs0.traverse(Directive.fromAst)\n+            members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n+          } yield UnionType(nme, desc, members, dirs)\n+        }\n+      case EnumTypeDefinition(Name(nme), desc, dirs0, values0) =>\n+        if (values0.isEmpty) Result.failure(s\"enum type $nme must define at least one enum value\")\n+        else\n+          for {\n+            values <- values0.traverse(mkEnumValue)\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield EnumType(nme, desc, values, dirs)\n+      case InputObjectTypeDefinition(Name(nme), desc, fields0, dirs0) =>\n+        if (fields0.isEmpty) Result.failure(s\"input object type $nme must define at least one input field\")\n+        else\n+          for {\n+            fields <- fields0.traverse(mkInputValue(schema))\n+            dirs   <- dirs0.traverse(Directive.fromAst)\n+          } yield InputObjectType(nme, desc, fields, dirs)\n     }\n \n-  def mkTypeDefs(schema: Schema, defns: List[TypeDefinition]): Result[List[NamedType]] =\n-    defns.traverse(mkTypeDef(schema))\n-\n-  def mkTypeDef(schema: Schema)(td: TypeDefinition): Result[NamedType] = td match {\n-    case ScalarTypeDefinition(Name(\"Int\"), _, _) => IntType.success\n-    case ScalarTypeDefinition(Name(\"Float\"), _, _) => FloatType.success\n-    case ScalarTypeDefinition(Name(\"String\"), _, _) => StringType.success\n-    case ScalarTypeDefinition(Name(\"Boolean\"), _, _) => BooleanType.success\n-    case ScalarTypeDefinition(Name(\"ID\"), _, _) => IDType.success\n-    case ScalarTypeDefinition(Name(nme), desc, dirs0) =>\n+    def mkField(schema: Schema)(f: FieldDefinition): Result[Field] = {\n+      val FieldDefinition(Name(nme), desc, args0, tpe0, dirs0) = f\n       for {\n-        dirs <- dirs0.traverse(mkDirective)\n-      } yield ScalarType(nme, desc, dirs)\n-    case ObjectTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n-      if (fields0.isEmpty) Result.failure(s\"object type $nme must define at least one field\")\n-      else\n-        for {\n-          fields <- fields0.traverse(mkField(schema))\n-          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield ObjectType(nme, desc, fields, ifs, dirs)\n-    case InterfaceTypeDefinition(Name(nme), desc, fields0, ifs0, dirs0) =>\n-      if (fields0.isEmpty) Result.failure(s\"interface type $nme must define at least one field\")\n-      else\n-        for {\n-          fields <- fields0.traverse(mkField(schema))\n-          ifs    =  ifs0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield InterfaceType(nme, desc, fields, ifs, dirs)\n-    case UnionTypeDefinition(Name(nme), desc, dirs0, members0) =>\n-      if (members0.isEmpty) Result.failure(s\"union type $nme must define at least one member\")\n-      else {\n-        for {\n-          dirs    <- dirs0.traverse(mkDirective)\n-          members =  members0.map { case Ast.Type.Named(Name(nme)) => schema.ref(nme) }\n-        } yield UnionType(nme, desc, members, dirs)\n-      }\n-    case EnumTypeDefinition(Name(nme), desc, dirs0, values0) =>\n-      if (values0.isEmpty) Result.failure(s\"enum type $nme must define at least one enum value\")\n-      else\n-        for {\n-          values <- values0.traverse(mkEnumValue)\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield EnumType(nme, desc, values, dirs)\n-    case InputObjectTypeDefinition(Name(nme), desc, fields0, dirs0) =>\n-      if (fields0.isEmpty) Result.failure(s\"input object type $nme must define at least one input field\")\n-      else\n-        for {\n-          fields <- fields0.traverse(mkInputValue(schema))\n-          dirs   <- dirs0.traverse(mkDirective)\n-        } yield InputObjectType(nme, desc, fields, dirs)\n-  }\n-\n-  def mkDirective(d: Ast.Directive): Result[Directive] = {\n-    val Ast.Directive(Name(nme), args) = d\n-    args.traverse {\n-      case (Name(nme), value) => parseValue(value).map(Binding(nme, _))\n-    }.map(Directive(nme, _))\n-  }\n-\n-  def mkField(schema: Schema)(f: FieldDefinition): Result[Field] = {\n-    val FieldDefinition(Name(nme), desc, args0, tpe0, dirs0) = f\n-    for {\n-      args <- args0.traverse(mkInputValue(schema))\n-      tpe  <- mkType(schema)(tpe0)\n-      dirs <- dirs0.traverse(mkDirective)\n-    } yield Field(nme, desc, args, tpe, dirs)\n-  }\n+        args <- args0.traverse(mkInputValue(schema))\n+        tpe  <- mkType(schema)(tpe0)\n+        dirs <- dirs0.traverse(Directive.fromAst)\n+      } yield Field(nme, desc, args, tpe, dirs)\n+    }\n \n-  def mkType(schema: Schema)(tpe: Ast.Type): Result[Type] = {\n-    def loop(tpe: Ast.Type, nullable: Boolean): Result[Type] = {\n-      def wrap(tpe: Type): Type = if (nullable) NullableType(tpe) else tpe\n+    def mkType(schema: Schema)(tpe: Ast.Type): Result[Type] = {\n+      def loop(tpe: Ast.Type, nullable: Boolean): Result[Type] = {\n+        def wrap(tpe: Type): Type = if (nullable) NullableType(tpe) else tpe\n \n-      tpe match {\n-        case Ast.Type.List(tpe) => loop(tpe, true).map(tpe => wrap(ListType(tpe)))\n-        case Ast.Type.NonNull(Left(tpe)) => loop(tpe, false)\n-        case Ast.Type.NonNull(Right(tpe)) => loop(tpe, false)\n-        case Ast.Type.Named(Name(nme)) => wrap(ScalarType.builtIn(nme).getOrElse(schema.ref(nme))).success\n+        tpe match {\n+          case Ast.Type.List(tpe) => loop(tpe, true).map(tpe => wrap(ListType(tpe)))\n+          case Ast.Type.NonNull(Left(tpe)) => loop(tpe, false)\n+          case Ast.Type.NonNull(Right(tpe)) => loop(tpe, false)\n+          case Ast.Type.Named(Name(nme)) => wrap(ScalarType.builtIn(nme).getOrElse(schema.ref(nme))).success\n+        }\n       }\n-    }\n-\n-    loop(tpe, true)\n-  }\n \n-  def mkDirectiveDefs(schema: Schema, defns: List[DirectiveDefinition]): Result[List[DirectiveDef]] =\n-    defns.traverse(mkDirectiveDef(schema))\n+      loop(tpe, true)\n+    }\n \n-  def mkDirectiveDef(schema: Schema)(dd: DirectiveDefinition): Result[DirectiveDef] = {\n-    val DirectiveDefinition(Name(nme), desc, args0, repeatable, locations) = dd\n-    for {\n-      args <- args0.traverse(mkInputValue(schema))\n-    } yield DirectiveDef(nme, desc, args, repeatable, locations)\n-  }\n+    def mkDirectiveDefs(schema: Schema, defns: List[DirectiveDefinition]): Result[List[DirectiveDef]] =\n+      defns.traverse(mkDirectiveDef(schema))\n \n-  def mkInputValue(schema: Schema)(f: InputValueDefinition): Result[InputValue] = {\n-    val InputValueDefinition(Name(nme), desc, tpe0, default0, dirs0) = f\n-    for {\n-      tpe <- mkType(schema)(tpe0)\n-      dflt <- default0.traverse(parseValue)\n-      dirs <- dirs0.traverse(mkDirective)\n-    } yield InputValue(nme, desc, tpe, dflt, dirs)\n-  }\n+    def mkDirectiveDef(schema: Schema)(dd: DirectiveDefinition): Result[DirectiveDef] = {\n+      val DirectiveDefinition(Name(nme), desc, args0, repeatable, locations) = dd\n+      for {\n+        args <- args0.traverse(mkInputValue(schema))\n+      } yield DirectiveDef(nme, desc, args, repeatable, locations)\n+    }\n \n-  def mkEnumValue(e: Ast.EnumValueDefinition): Result[EnumValueDefinition] = {\n-    val Ast.EnumValueDefinition(Name(nme), desc, dirs0) = e\n-    for {\n-      dirs <- dirs0.traverse(mkDirective)\n-    } yield EnumValueDefinition(nme, desc, dirs)\n-  }\n+    def mkInputValue(schema: Schema)(f: InputValueDefinition): Result[InputValue] = {\n+      val InputValueDefinition(Name(nme), desc, tpe0, default0, dirs0) = f\n+      for {\n+        tpe <- mkType(schema)(tpe0)\n+        dflt <- default0.traverse(Value.fromAst)\n+        dirs <- dirs0.traverse(Directive.fromAst)\n+      } yield InputValue(nme, desc, tpe, dflt, dirs)\n+    }\n \n-  def parseValue(value: Ast.Value): Result[Value] = {\n-    value match {\n-      case Ast.Value.IntValue(i) => IntValue(i).success\n-      case Ast.Value.FloatValue(d) => FloatValue(d).success\n-      case Ast.Value.StringValue(s) => StringValue(s).success\n-      case Ast.Value.BooleanValue(b) => BooleanValue(b).success\n-      case Ast.Value.EnumValue(e) => EnumValue(e.value).success\n-      case Ast.Value.Variable(v) => VariableRef(v.value).success\n-      case Ast.Value.NullValue => NullValue.success\n-      case Ast.Value.ListValue(vs) => vs.traverse(parseValue).map(ListValue(_))\n-      case Ast.Value.ObjectValue(fs) =>\n-        fs.traverse { case (name, value) =>\n-          parseValue(value).map(v => (name.value, v))\n-        }.map(ObjectValue(_))\n+    def mkEnumValue(e: Ast.EnumValueDefinition): Result[EnumValueDefinition] = {\n+      val Ast.EnumValueDefinition(Name(nme), desc, dirs0) = e\n+      for {\n+        dirs <- dirs0.traverse(Directive.fromAst)\n+      } yield EnumValueDefinition(nme, desc, dirs)\n     }\n   }\n }"
        },
        {
            "filename": "modules/core/src/test/scala/compiler/CompilerSuite.scala",
            "diff": "@@ -26,6 +26,8 @@ import Predicate._, Value._, UntypedOperation._\n import QueryCompiler._, ComponentElaborator.TrivialJoin\n \n final class CompilerSuite extends CatsEffectSuite {\n+  val queryParser = QueryParser(GraphQLParser(GraphQLParser.defaultConfig.copy(terseError = false)))\n+\n   test(\"simple query\") {\n     val query = \"\"\"\n       query {\n@@ -40,7 +42,7 @@ final class CompilerSuite extends CatsEffectSuite {\n         UntypedSelect(\"name\", None, Nil, Nil, Empty)\n       )\n \n-    val res = QueryParser.parseText(query).map(_._1)\n+    val res = queryParser.parseText(query).map(_._1)\n     assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n   }\n \n@@ -62,7 +64,7 @@ final class CompilerSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = QueryParser.parseText(query).map(_._1)\n+    val res = queryParser.parseText(query).map(_._1)\n     assertEquals(res, Result.Success(List(UntypedMutation(None, expected, Nil, Nil))))\n   }\n \n@@ -80,7 +82,7 @@ final class CompilerSuite extends CatsEffectSuite {\n         UntypedSelect(\"name\", None, Nil, Nil, Empty)\n       )\n \n-    val res = QueryParser.parseText(query).map(_._1)\n+    val res = queryParser.parseText(query).map(_._1)\n     assertEquals(res, Result.Success(List(UntypedSubscription(None, expected, Nil, Nil))))\n   }\n \n@@ -106,7 +108,7 @@ final class CompilerSuite extends CatsEffectSuite {\n           )\n       )\n \n-    val res = QueryParser.parseText(query).map(_._1)\n+    val res = queryParser.parseText(query).map(_._1)\n     assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n   }\n \n@@ -137,7 +139,7 @@ final class CompilerSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = QueryParser.parseText(query).map(_._1)\n+    val res = queryParser.parseText(query).map(_._1)\n     assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n   }\n \n@@ -163,7 +165,7 @@ final class CompilerSuite extends CatsEffectSuite {\n         ))\n       )\n \n-    val res = QueryParser.parseText(query).map(_._1)\n+    val res = queryParser.parseText(query).map(_._1)\n     assertEquals(res, Result.Success(List(UntypedQuery(None, expected, Nil, Nil))))\n   }\n \n@@ -192,7 +194,7 @@ final class CompilerSuite extends CatsEffectSuite {\n         UntypedSelect(\"subscriptionType\", None, Nil, Nil, UntypedSelect(\"name\", None, Nil, Nil, Empty))\n       )\n \n-    val res = QueryParser.parseText(query).map(_._1)\n+    val res = queryParser.parseText(query).map(_._1)\n     assertEquals(res, Result.Success(List(UntypedQuery(Some(\"IntrospectionQuery\"), expected, Nil, Nil))))\n   }\n \n@@ -355,46 +357,55 @@ final class CompilerSuite extends CatsEffectSuite {\n   }\n \n   test(\"malformed query (1)\") {\n-    val query = \"\"\"\n-      query {\n-        character(id: \"1000\" {\n-          name\n-        }\n-      }\n-    \"\"\"\n+    val query =\n+      \"\"\"|query {\n+         |  character(id: \"1000\" {\n+         |    name\n+         |  }\n+         |}\"\"\".stripMargin\n \n-    val res = QueryParser.parseText(query)\n+    val expected =\n+      \"\"\"|query {\n+         |  character(id: \"1000\" {\n+         |                       ^\n+         |expectation:\n+         |* must be char: ')'\n+         |    name\n+         |  }\"\"\".stripMargin\n \n-    val error =\n-      \"\"\"Parse error at line 2 column 29\n-        |        character(id: \"1000\" {\n-        |                             ^\"\"\".stripMargin\n+    val res = queryParser.parseText(query)\n \n-    assertEquals(res, Result.failure(error))\n+    assertEquals(res, Result.failure(expected))\n   }\n \n   test(\"malformed query (2)\") {\n     val query = \"\"\n \n-    val res = QueryParser.parseText(query)\n+    val res = queryParser.parseText(query)\n \n     assertEquals(res, Result.failure(\"At least one operation required\"))\n   }\n \n   test(\"malformed query (3)\") {\n-    val query = \"\"\"\n-      query {\n-        character(id: \"1000\") {\n-          name\n-        }\n-    \"\"\"\n-\n-    val res = QueryParser.parseText(query)\n+    val query =\n+      \"\"\"|query {\n+         |  character(id: \"1000\") {\n+         |    name\n+         |  }\"\"\".stripMargin\n \n-    val error =\n-      \"Parse error at line 5 column 4\\n    \\n    ^\"\n-\n-    assertEquals(res, Result.failure(error))\n+    val expected =\n+      \"\"\"|...\n+         |  character(id: \"1000\") {\n+         |    name\n+         |  }\n+         |   ^\n+         |expectation:\n+         |* must be char: '}'\"\"\".stripMargin\n+\n+    val res = queryParser.parseText(query)\n+    //println(res.toProblems.toList.head.message)\n+\n+    assertEquals(res, Result.failure(expected))\n   }\n }\n "
        },
        {
            "filename": "modules/core/src/test/scala/compiler/DirectivesSuite.scala",
            "diff": "@@ -23,6 +23,8 @@ import Ast.DirectiveLocation._\n import Query._\n \n final class DirectivesSuite extends CatsEffectSuite {\n+  val schemaParser = SchemaParser(GraphQLParser(GraphQLParser.defaultConfig))\n+\n   def testDirectiveDefs(s: Schema): List[DirectiveDef] =\n     s.directives.filter {\n       case DirectiveDef(\"skip\"|\"include\"|\"deprecated\", _, _, _, _) => false\n@@ -169,7 +171,7 @@ final class DirectivesSuite extends CatsEffectSuite {\n        |directive @foo on SCHEMA|SCALAR|OBJECT|FIELD_DEFINITION|ARGUMENT_DEFINITION|INTERFACE|UNION|ENUM|ENUM_VALUE|INPUT_OBJECT|INPUT_FIELD_DEFINITION\n        |\"\"\".stripMargin\n \n-    val res = SchemaParser.parseText(schema)\n+    val res = schemaParser.parseText(schema)\n     val ser = res.map(_.toString)\n \n     assertEquals(ser, schema.success)"
        },
        {
            "filename": "modules/core/src/test/scala/compiler/FragmentSuite.scala",
            "diff": "@@ -790,6 +790,303 @@ final class FragmentSuite extends CatsEffectSuite {\n \n     assertIO(res, expected)\n   }\n+\n+  test(\"fragment defined\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          friends {\n+            ...friendFields\n+          }\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"errors\" : [\n+          {\n+            \"message\" : \"Fragment 'friendFields' is undefined\"\n+          }\n+        ]\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n+\n+  test(\"fragment unused (1)\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          friends {\n+            id\n+            name\n+            profilePic\n+          }\n+        }\n+      }\n+\n+      fragment friendFields on User {\n+        id\n+        name\n+        profilePic\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"errors\" : [\n+          {\n+            \"message\" : \"Fragment 'friendFields' is unused\"\n+          }\n+        ]\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n+\n+  test(\"fragment unused (2)\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          friends {\n+            id\n+            name\n+            profilePic\n+          }\n+        }\n+      }\n+\n+      fragment friendFields on User {\n+        id\n+        name\n+        profilePic\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"data\" : {\n+          \"user\" : {\n+            \"friends\" : [\n+              {\n+                \"id\" : \"2\",\n+                \"name\" : \"Bob\",\n+                \"profilePic\" : \"B\"\n+              },\n+              {\n+                \"id\" : \"3\",\n+                \"name\" : \"Carol\",\n+                \"profilePic\" : \"C\"\n+              }\n+            ]\n+          }\n+        }\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query, reportUnused = false)\n+\n+    assertIO(res, expected)\n+  }\n+\n+  test(\"fragment duplication\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          ...userFields\n+        }\n+      }\n+\n+      fragment userFields on User {\n+        name\n+      }\n+\n+      fragment userFields on User {\n+        name\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"errors\" : [\n+          {\n+            \"message\" : \"Fragment 'userFields' is defined more than once\"\n+          }\n+        ]\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n+\n+\n+  test(\"fragment recursion (1)\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          ...userFields\n+        }\n+      }\n+\n+      fragment userFields on User {\n+        name\n+        friends {\n+          ...userFields\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"errors\" : [\n+          {\n+            \"message\" : \"Fragment cycle starting from 'userFields'\"\n+          }\n+        ]\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n+\n+  test(\"fragment recursion (2)\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          ...userFields\n+        }\n+      }\n+\n+      fragment userFields on User {\n+        name\n+        favourite {\n+          ...pageFields\n+        }\n+      }\n+\n+      fragment pageFields on Page {\n+        title\n+        likers {\n+          ...userFields\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"errors\" : [\n+          {\n+            \"message\" : \"Fragment cycle starting from 'userFields'\"\n+          }\n+        ]\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n+\n+  test(\"fragment recursion (3)\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          ...userFields\n+        }\n+      }\n+\n+      fragment userFields on User {\n+        name\n+        favourite {\n+          ...pageFields\n+        }\n+      }\n+\n+      fragment pageFields on Page {\n+        title\n+        likers {\n+          ...userFields2\n+        }\n+      }\n+\n+      fragment userFields2 on User {\n+        profilePic\n+        favourite {\n+          ...userFields\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"errors\" : [\n+          {\n+            \"message\" : \"Fragment cycle starting from 'userFields'\"\n+          }\n+        ]\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n+\n+  test(\"fragment recursion (4)\") {\n+    val query = \"\"\"\n+      query withFragments {\n+        user(id: 1) {\n+          ...userFields\n+        }\n+      }\n+\n+      fragment pageFields on Page {\n+        title\n+        likers {\n+          ...userFields2\n+        }\n+      }\n+\n+      fragment userFields2 on User {\n+        profilePic\n+        favourite {\n+          ...pageFields\n+        }\n+      }\n+\n+      fragment userFields on User {\n+        name\n+        favourite {\n+          ...pageFields\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"errors\" : [\n+          {\n+            \"message\" : \"Fragment cycle starting from 'pageFields'\"\n+          }\n+        ]\n+      }\n+    \"\"\"\n+\n+    val res = FragmentMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n }\n \n object FragmentData {"
        },
        {
            "filename": "modules/core/src/test/scala/compiler/VariablesSuite.scala",
            "diff": "@@ -378,6 +378,169 @@ final class VariablesSuite extends CatsEffectSuite {\n \n     assertEquals(compiled.map(_.query), Result.Success(expected))\n   }\n+\n+  test(\"variables in directive argument\") {\n+    val query = \"\"\"\n+      query getZuckProfile($skipName: Boolean) {\n+        user(id: 4) {\n+          id\n+          name @skip(if: $skipName)\n+        }\n+      }\n+    \"\"\"\n+\n+    val variables = json\"\"\"\n+      {\n+        \"skipName\": true\n+      }\n+    \"\"\"\n+\n+    val expected =\n+      UntypedSelect(\"user\", None, List(Binding(\"id\", IDValue(\"4\"))), Nil,\n+        UntypedSelect(\"id\", None, Nil, Nil, Empty)\n+      )\n+\n+    val compiled = VariablesMapping.compiler.compile(query, untypedVars = Some(variables))\n+\n+    assertEquals(compiled.map(_.query), Result.Success(expected))\n+  }\n+\n+  test(\"variable not defined (1)\") {\n+    val query = \"\"\"\n+      query getZuckProfile {\n+        user(id: 4) {\n+          id\n+          name\n+          profilePic(size: $devicePicSize)\n+        }\n+      }\n+    \"\"\"\n+\n+    val compiled = VariablesMapping.compiler.compile(query)\n+\n+    val expected = Result.failure(\"Variable 'devicePicSize' is undefined\")\n+\n+    assertEquals(compiled, expected)\n+  }\n+\n+\n+  test(\"variable not defined (2)\") {\n+    val query = \"\"\"\n+      query getZuckProfile($devicePicSize: Int) {\n+        user(id: 4) {\n+          id\n+          name\n+          profilePic(size: $devicePicSize)\n+        }\n+      }\n+    \"\"\"\n+\n+    val compiled = VariablesMapping.compiler.compile(query)\n+\n+    val expected = Result.failure(\"Variable 'devicePicSize' is undefined\")\n+\n+    assertEquals(compiled, expected)\n+  }\n+\n+  test(\"variable not defined (3)\") {\n+    val query = \"\"\"\n+      query getZuckProfile($skipPic: Boolean) {\n+        user(id: 4) {\n+          id\n+          name\n+          profilePic(size: $devicePicSize) @skip(if: $skipPic)\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = Result.failure(\"Variable 'devicePicSize' is undefined\")\n+\n+    val compiled = VariablesMapping.compiler.compile(query)\n+\n+    assertEquals(compiled.map(_.query), expected)\n+  }\n+\n+  test(\"variable not defined (4)\") {\n+    val query = \"\"\"\n+      query getZuckProfile {\n+        user(id: 4) {\n+          id\n+          name @skip(if: $skipName)\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = Result.failure(\"Variable 'skipName' is undefined\")\n+\n+    val compiled = VariablesMapping.compiler.compile(query)\n+\n+    assertEquals(compiled.map(_.query), expected)\n+  }\n+\n+\n+  test(\"variable not defined (5)\") {\n+    val query = \"\"\"\n+      query getZuckProfile($skipName: Boolean) {\n+        user(id: 4) {\n+          id\n+          name @skip(if: $skipName)\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = Result.failure(\"Variable 'skipName' is undefined\")\n+\n+    val compiled = VariablesMapping.compiler.compile(query)\n+\n+    assertEquals(compiled.map(_.query), expected)\n+  }\n+\n+  test(\"variable unused (1)\") {\n+    val query = \"\"\"\n+      query getZuckProfile($devicePicSize: Int) {\n+        user(id: 4) {\n+          id\n+          name\n+        }\n+      }\n+    \"\"\"\n+\n+    val compiled = VariablesMapping.compiler.compile(query)\n+\n+    val expected = Result.failure(\"Variable 'devicePicSize' is unused\")\n+\n+    assertEquals(compiled, expected)\n+  }\n+\n+  test(\"variable unused (2)\") {\n+    val query = \"\"\"\n+      query getZuckProfile($devicePicSize: Int) {\n+        user(id: 4) {\n+          id\n+          name\n+        }\n+      }\n+    \"\"\"\n+\n+    val compiled = VariablesMapping.compiler.compile(query, reportUnused = false)\n+    println(compiled)\n+\n+    val expected =\n+      Operation(\n+        UntypedSelect(\"user\", None, List(Binding(\"id\", IDValue(\"4\"))), Nil,\n+          Group(\n+            List(\n+              UntypedSelect(\"id\", None, Nil, Nil, Empty),\n+              UntypedSelect(\"name\", None, Nil, Nil, Empty)\n+            )\n+          )\n+        ),\n+        VariablesMapping.QueryType,\n+        Nil\n+      )\n+\n+    assertEquals(compiled, Result.success(expected))\n+  }\n }\n \n object VariablesMapping extends TestMapping {\n@@ -411,5 +574,7 @@ object VariablesMapping extends TestMapping {\n       scalar BigDecimal\n     \"\"\"\n \n+  val QueryType = schema.ref(\"Query\").dealias\n+\n   override val selectElaborator = PreserveArgsElaborator\n }"
        },
        {
            "filename": "modules/core/src/test/scala/directives/DirectiveValidationSuite.scala",
            "diff": "@@ -375,7 +375,7 @@ object ExecutableDirectiveMapping extends Mapping[IO] {\n   override val selectElaborator = PreserveArgsElaborator\n \n   def compileAllOperations(text: String): Result[List[Operation]] =\n-    QueryParser.parseText(text).flatMap {\n+    queryParser.parseText(text).flatMap {\n       case (ops, frags) => ops.parTraverse(compiler.compileOperation(_, None, frags))\n     }\n }"
        },
        {
            "filename": "modules/core/src/test/scala/minimizer/MinimizerSuite.scala",
            "diff": "@@ -17,18 +17,22 @@ package minimizer\n \n import munit.CatsEffectSuite\n \n-import grackle.{ GraphQLParser, QueryMinimizer }\n+import grackle.{ GraphQLParser, QueryMinimizer, Result }\n \n final class MinimizerSuite extends CatsEffectSuite {\n+  val parser = GraphQLParser(GraphQLParser.defaultConfig)\n+  val minimizer = QueryMinimizer(parser)\n+\n   def run(query: String, expected: String, echo: Boolean = false): Unit = {\n-    val Right(minimized) = QueryMinimizer.minimizeText(query) : @unchecked\n+\n+    val Result.Success(minimized) = minimizer.minimizeText(query) : @unchecked\n     if (echo)\n       println(minimized)\n \n     assert(minimized == expected)\n \n-    val Some(parsed0) = GraphQLParser.Document.parseAll(query).toOption : @unchecked\n-    val Some(parsed1) = GraphQLParser.Document.parseAll(minimized).toOption : @unchecked\n+    val Some(parsed0) = parser.parseText(query).toOption : @unchecked\n+    val Some(parsed1) = parser.parseText(minimized).toOption : @unchecked\n \n     assertEquals(parsed0, parsed1)\n   }"
        },
        {
            "filename": "modules/core/src/test/scala/parser/ParserSuite.scala",
            "diff": "@@ -15,14 +15,15 @@\n \n package parser\n \n-import cats.data.NonEmptyChain\n import munit.CatsEffectSuite\n \n-import grackle.{Ast, GraphQLParser, Problem, Result}\n+import grackle.{Ast, GraphQLParser, Result}\n import grackle.syntax._\n import Ast._, OperationType._, OperationDefinition._, Selection._, Value._, Type.Named\n \n final class ParserSuite extends CatsEffectSuite {\n+  val parser = mkParser()\n+\n   test(\"simple query\") {\n     val query = doc\"\"\"\n       query {\n@@ -72,7 +73,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -104,7 +105,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -152,7 +153,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -194,7 +195,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -226,7 +227,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -258,7 +259,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -290,7 +291,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -322,7 +323,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -354,7 +355,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -406,14 +407,14 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n   }\n \n   test(\"invalid document\") {\n-    GraphQLParser.Document.parseAll(\"scalar Foo woozle\").toOption match {\n+    parser.parseText(\"scalar Foo woozle\").toOption match {\n       case Some(_) => fail(\"should have failed\")\n       case None    => ()\n     }\n@@ -463,7 +464,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(xs) => assertEquals(xs, expected)\n       case _ => assert(false)\n     }\n@@ -502,7 +503,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -540,7 +541,7 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    GraphQLParser.Document.parseAll(query).toOption match {\n+    parser.parseText(query).toOption match {\n       case Some(List(q)) => assertEquals(q, expected)\n       case _ => assert(false)\n     }\n@@ -549,8 +550,9 @@ final class ParserSuite extends CatsEffectSuite {\n   test(\"value literals\") {\n \n     def assertParse(input: String, expected: Value) =\n-      GraphQLParser.Value.parseAll(input).toOption match {\n-        case Some(v) => assertEquals(v, expected)\n+      parser.parseText(s\"query { foo(bar: $input) }\").toOption match {\n+        case Some(List(Operation(_, _, _, _,List(Field(_, _, List((_, v)), _, _))))) =>\n+          assertEquals(v, expected)\n         case _ => assert(false)\n       }\n \n@@ -580,6 +582,32 @@ final class ParserSuite extends CatsEffectSuite {\n     assertParse(\"\\\"\\\"\\\"    \\n\\n   first\\n   \\t\u03bb\\n  123\\n\\n\\n   \\t\\n\\n\\\"\\\"\\\"\", StringValue(\" first\\n \\t\u03bb\\n123\"))\n   }\n \n+  test(\"outsized int\") {\n+    val query =\n+      \"\"\"|query {\n+         |  foo {\n+         |    bar {\n+         |      baz(id: 2147483648)\n+         |    }\n+         |  }\n+         |}\"\"\".stripMargin\n+\n+    val expected =\n+      \"\"\"|...\n+         |  foo {\n+         |    bar {\n+         |      baz(id: 2147483648)\n+         |                        ^\n+         |expectation:\n+         |* must fail: 2147483648 is larger than max int\n+         |    }\n+         |  }\"\"\".stripMargin\n+\n+    val res = parser.parseText(query)\n+\n+    assertEquals(res, Result.failure(expected))\n+  }\n+\n   test(\"parse object type extension\") {\n     val schema = \"\"\"\n       extend type Foo {\n@@ -592,7 +620,7 @@ final class ParserSuite extends CatsEffectSuite {\n         ObjectTypeExtension(Named(Name(\"Foo\")), List(FieldDefinition(Name(\"bar\"),None,Nil,Named(Name(\"Int\")),Nil)), Nil, Nil)\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema).toOption\n+    val res = parser.parseText(schema).toOption\n     assert(res == Some(expected))\n   }\n \n@@ -608,7 +636,7 @@ final class ParserSuite extends CatsEffectSuite {\n         SchemaExtension(List(RootOperationTypeDefinition(OperationType.Query, Named(Name(\"Query\")), Nil)), Nil)\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema).toOption\n+    val res = parser.parseText(schema).toOption\n     assert(res == Some(expected))\n   }\n \n@@ -630,26 +658,158 @@ final class ParserSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema).toOption\n+    val res = parser.parseText(schema).toOption\n     assertEquals(res, Some(expected))\n   }\n \n   test(\"keywords parsed non-greedily (2)\") {\n     val schema =\n       \"\"\"|extendtypeName {\n-         |  value:String\n+         |  value: String\n          |}\"\"\".stripMargin\n \n     val expected =\n-      NonEmptyChain(\n-        Problem(\n-          \"\"\"|Parse error at line 0 column 6\n-            |extendtypeName {\n-            |      ^\"\"\".stripMargin\n-        )\n-      )\n+      \"\"\"|extendtypeName {\n+         |      ^\n+         |expectation:\n+         |* must fail but matched with t\n+         |  value: String\n+         |}\"\"\".stripMargin\n \n-    val res = GraphQLParser.toResult(schema, GraphQLParser.Document.parseAll(schema))\n-    assertEquals(res, Result.Failure(expected))\n+    val res = parser.parseText(schema)\n+    assertEquals(res, Result.failure(expected))\n   }\n+\n+  test(\"deep query\") {\n+    def mkQuery(depth: Int): String = {\n+      val depth0 = depth - 1\n+      \"query{\" + (\"f{\" *depth0) + \"f\" + (\"}\" * depth0) + \"}\"\n+    }\n+\n+    val limit = 5\n+    val limitedParser = mkParser(maxSelectionDepth = limit)\n+\n+    val queryOk = mkQuery(limit)\n+    val queryFail = mkQuery(limit + 1)\n+\n+    val expectedFail =\n+      \"\"\"|query{f{f{f{f{f{f}}}}}}\n+         |                ^\n+         |expectation:\n+         |* must fail: exceeded maximum selection depth\"\"\".stripMargin\n+\n+    val resOk = limitedParser.parseText(queryOk)\n+    assert(resOk.hasValue)\n+\n+    val resFail = limitedParser.parseText(queryFail)\n+    assertEquals(resFail, Result.failure(expectedFail))\n+  }\n+\n+  test(\"wide query\") {\n+    def mkQuery(width: Int): String =\n+      \"query{r{\" + (\"f,\" * (width - 1) + \"f\") + \"}}\"\n+\n+    val limit = 5\n+    val limitedParser = mkParser(maxSelectionWidth = limit)\n+\n+    val queryOk = mkQuery(limit)\n+    val queryFail = mkQuery(limit + 1)\n+\n+    val expectedFail =\n+      \"\"\"|query{r{f,f,f,f,f,f}}\n+         |                  ^\n+         |expectation:\n+         |* must be char: '}'\"\"\".stripMargin\n+\n+    val resOk = limitedParser.parseText(queryOk)\n+    assert(resOk.hasValue)\n+\n+    val resFail = limitedParser.parseText(queryFail)\n+    assertEquals(resFail, Result.failure(expectedFail))\n+  }\n+\n+  test(\"deep list value\") {\n+    def mkQuery(depth: Int): String =\n+      \"query{f(l: \" + (\"[\" *depth) + \"0\" + (\"]\" * depth) + \"){f}}\"\n+\n+    val limit = 5\n+    val limitedParser = mkParser(maxInputValueDepth = limit)\n+\n+    val queryOk = mkQuery(limit)\n+    val queryFail = mkQuery(limit + 1)\n+\n+    val expectedFail =\n+      \"\"\"|query{f(l: [[[[[[0]]]]]]){f}}\n+         |                 ^\n+         |expectation:\n+         |* must fail: exceeded maximum input value depth\"\"\".stripMargin\n+\n+    val resOk = limitedParser.parseText(queryOk)\n+    assert(resOk.hasValue)\n+\n+    val resFail = limitedParser.parseText(queryFail)\n+    assertEquals(resFail, Result.failure(expectedFail))\n+  }\n+\n+  test(\"deep input object value\") {\n+    def mkQuery(depth: Int): String =\n+      \"query{f(l: \" + (\"{m:\" *depth) + \"0\" + (\"}\" * depth) + \"){f}}\"\n+\n+    val limit = 5\n+    val limitedParser = mkParser(maxInputValueDepth = limit)\n+\n+    val queryOk = mkQuery(limit)\n+    val queryFail = mkQuery(limit + 1)\n+\n+    val expectedFail =\n+      \"\"\"|query{f(l: {m:{m:{m:{m:{m:{m:0}}}}}}){f}}\n+         |                           ^\n+         |expectation:\n+         |* must fail: exceeded maximum input value depth\"\"\".stripMargin\n+\n+    val resOk = limitedParser.parseText(queryOk)\n+    assert(resOk.hasValue)\n+\n+    val resFail = limitedParser.parseText(queryFail)\n+    assertEquals(resFail, Result.failure(expectedFail))\n+  }\n+\n+  test(\"deep variable type\") {\n+    def mkQuery(depth: Int): String =\n+      \"query($l: \" + (\"[\" *depth) + \"Int\" + (\"]\" * depth) + \"){f(a:$l)}\"\n+\n+    val limit = 5\n+    val limitedParser = mkParser(maxListTypeDepth = limit)\n+\n+    val queryOk = mkQuery(limit)\n+    val queryFail = mkQuery(limit + 1)\n+\n+    val expectedFail =\n+      \"\"\"|query($l: [[[[[[Int]]]]]]){f(a:$l)}\n+         |                ^\n+         |expectation:\n+         |* must fail: exceeded maximum list type depth\"\"\".stripMargin\n+\n+    val resOk = limitedParser.parseText(queryOk)\n+    assert(resOk.hasValue)\n+\n+    val resFail = limitedParser.parseText(queryFail)\n+    assertEquals(resFail, Result.failure(expectedFail))\n+  }\n+\n+  def mkParser(\n+    maxSelectionDepth: Int = GraphQLParser.defaultConfig.maxSelectionDepth,\n+    maxSelectionWidth: Int = GraphQLParser.defaultConfig.maxSelectionWidth,\n+    maxInputValueDepth: Int = GraphQLParser.defaultConfig.maxInputValueDepth,\n+    maxListTypeDepth: Int = GraphQLParser.defaultConfig.maxListTypeDepth,\n+  ): GraphQLParser =\n+    GraphQLParser(\n+      GraphQLParser.Config(\n+        maxSelectionDepth = maxSelectionDepth,\n+        maxSelectionWidth = maxSelectionWidth,\n+        maxInputValueDepth = maxInputValueDepth,\n+        maxListTypeDepth = maxListTypeDepth,\n+        terseError = false\n+      )\n+    )\n }"
        },
        {
            "filename": "modules/core/src/test/scala/sdl/SDLSuite.scala",
            "diff": "@@ -22,6 +22,9 @@ import grackle.syntax._\n import Ast._, OperationType._, Type.{ List => _, _ }\n \n final class SDLSuite extends CatsEffectSuite {\n+  val parser = GraphQLParser(GraphQLParser.defaultConfig)\n+  val schemaParser = SchemaParser(parser)\n+\n   test(\"parse schema definition\") {\n     val schema = \"\"\"\n       schema {\n@@ -43,9 +46,9 @@ final class SDLSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema)\n+    val res = parser.parseText(schema)\n \n-    assertEquals(res, Right(expected))\n+    assertEquals(res, expected.success)\n   }\n \n   test(\"parse scalar type definition\") {\n@@ -63,9 +66,9 @@ final class SDLSuite extends CatsEffectSuite {\n         ScalarTypeDefinition(Name(\"Time\"), Some(\"A scalar type\"), List(Directive(Name(\"deprecated\"), Nil)))\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema)\n+    val res = parser.parseText(schema)\n \n-    assertEquals(res, Right(expected))\n+    assertEquals(res, expected.success)\n   }\n \n   test(\"parse object type definition\") {\n@@ -95,9 +98,9 @@ final class SDLSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema)\n+    val res = parser.parseText(schema)\n \n-    assertEquals(res, Right(expected))\n+    assertEquals(res, expected.success)\n   }\n \n   test(\"parse interface type definition\") {\n@@ -127,9 +130,9 @@ final class SDLSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema)\n+    val res = parser.parseText(schema)\n \n-    assertEquals(res, Right(expected))\n+    assertEquals(res, expected.success)\n   }\n \n   test(\"parse union type definition\") {\n@@ -148,9 +151,9 @@ final class SDLSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema)\n+    val res = parser.parseText(schema)\n \n-    assertEquals(res, Right(expected))\n+    assertEquals(res, expected.success)\n   }\n \n   test(\"parse enum type definition\") {\n@@ -176,9 +179,9 @@ final class SDLSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema)\n+    val res = parser.parseText(schema)\n \n-    assertEquals(res, Right(expected))\n+    assertEquals(res, expected.success)\n   }\n \n   test(\"parse input object type definition\") {\n@@ -201,9 +204,9 @@ final class SDLSuite extends CatsEffectSuite {\n         )\n       )\n \n-    val res = GraphQLParser.Document.parseAll(schema)\n+    val res = parser.parseText(schema)\n \n-    assertEquals(res, Right(expected))\n+    assertEquals(res, expected.success)\n   }\n \n   test(\"parse directive definition\") {\n@@ -215,7 +218,7 @@ final class SDLSuite extends CatsEffectSuite {\n          |directive @delegateField(name: String!) repeatable on OBJECT|INTERFACE|FIELD|FIELD_DEFINITION|ENUM|ENUM_VALUE\n          |\"\"\".stripMargin\n \n-    val res = SchemaParser.parseText(schema)\n+    val res = schemaParser.parseText(schema)\n     val ser = res.map(_.toString)\n \n     assertEquals(ser, schema.success)\n@@ -240,7 +243,7 @@ final class SDLSuite extends CatsEffectSuite {\n        |  author(id: Int! = 23): Author\n        |}\"\"\".stripMargin\n \n-    val res = SchemaParser.parseText(schema)\n+    val res = schemaParser.parseText(schema)\n     val ser = res.map(_.toString)\n \n     assertEquals(ser, schema.success)\n@@ -284,7 +287,7 @@ final class SDLSuite extends CatsEffectSuite {\n        |  primaryFunction: String\n        |}\"\"\".stripMargin\n \n-    val res = SchemaParser.parseText(schema)\n+    val res = schemaParser.parseText(schema)\n     val ser = res.map(_.toString)\n \n     assertEquals(ser, schema.success)\n@@ -307,7 +310,7 @@ final class SDLSuite extends CatsEffectSuite {\n        |  y: Int\n        |}\"\"\".stripMargin\n \n-    val res = SchemaParser.parseText(schema)\n+    val res = schemaParser.parseText(schema)\n     val ser = res.map(_.toString)\n \n     assertEquals(ser, schema.success)\n@@ -369,7 +372,7 @@ final class SDLSuite extends CatsEffectSuite {\n          |directive @Inp on INPUT_OBJECT\n          |\"\"\".stripMargin\n \n-    val res = SchemaParser.parseText(schema)\n+    val res = schemaParser.parseText(schema)\n     val ser = res.map(_.toString)\n \n     assertEquals(ser, schema.success)\n@@ -414,7 +417,7 @@ final class SDLSuite extends CatsEffectSuite {\n          |directive @Inp on INPUT_OBJECT\n          |\"\"\".stripMargin\n \n-    val res = SchemaParser.parseText(schema)\n+    val res = schemaParser.parseText(schema)\n     val ser = res.map(_.toString)\n \n     assertEquals(ser, schema.success)"
        },
        {
            "filename": "modules/generic/src/test/scala/ScalarsSuite.scala",
            "diff": "@@ -373,6 +373,38 @@ final class ScalarsSuite extends CatsEffectSuite {\n     assertIO(res, expected)\n   }\n \n+  test(\"query with scalar argument without apostrophes\") {\n+    val query = \"\"\"\n+      query {\n+        moviesLongerThan(duration: PT3H) {\n+          title\n+          duration\n+        }\n+      }\n+    \"\"\"\n+\n+    val expected = json\"\"\"\n+      {\n+        \"data\" : {\n+          \"moviesLongerThan\" : [\n+            {\n+              \"title\" : \"Celine et Julie Vont en Bateau\",\n+              \"duration\" : \"PT3H25M\"\n+            },\n+            {\n+              \"title\" : \"L'Amour fou\",\n+              \"duration\" : \"PT4H12M\"\n+            }\n+          ]\n+        }\n+      }\n+    \"\"\"\n+\n+    val res = MovieMapping.compileAndRun(query)\n+\n+    assertIO(res, expected)\n+  }\n+\n   test(\"query with LocalTime argument\") {\n     val query = \"\"\"\n       query {"
        }
    ],
    "commitTime": "2023-12-18 21:58:16"
}