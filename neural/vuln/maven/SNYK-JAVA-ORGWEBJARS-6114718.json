{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "NONE",
        "availability": "NONE"
    },
    "credit": [
        "Varga Daniel"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 5.9,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "HIGH",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "NONE",
                "availability": "NONE"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 5.9,
    "disclosureTime": "2023-08-13 21:00:00",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.43148",
        "probability": "0.00108"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-JAVA-ORGWEBJARS-6114718",
    "identifiers": {
        "CVE": [
            "CVE-2023-26154"
        ],
        "CWE": [
            "CWE-331"
        ]
    },
    "language": "java",
    "malicious": false,
    "packageManager": "maven",
    "publicationTime": "2023-12-14 13:57:45",
    "remediation": "Upgrade org.webjars:pubnub to version 7.4.0 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Insufficient Entropy",
    "vulnDescription": {
        "Overview": "org.webjars:pubnub is a Publish & Subscribe Real-time Messaging with PubNub Affected versions of this package are vulnerable to Insufficient Entropy via the getKey function, due to inefficient implementation of the AES-256-CBC cryptographic algorithm. The provided encrypt function is less secure when hex encoding and trimming are applied, leaving half of the bits in the key always the same for every encoded message or file. Note: In order to exploit this vulnerability, the attacker needs to invest resources in preparing the attack and brute-force the encryption. "
    },
    "source_code": [
        {
            "filename": ".pubnub.yml",
            "diff": "@@ -1,5 +1,12 @@\n ---\n changelog:\n+  - date: 2023-10-16\n+    version: v7.4.0\n+    changes:\n+      - type: feature\n+        text: \"Add crypto module that allows configure SDK to encrypt and decrypt messages.\"\n+      - type: bug\n+        text: \"Improved security of crypto implementation by adding enhanced AES-CBC cryptor.\"\n   - date: 2023-09-11\n     version: v7.3.3\n     changes:\n@@ -895,7 +902,7 @@ supported-platforms:\n       - 'Ubuntu 14.04 and up'\n       - 'Windows 7 and up'\n     version: 'Pubnub Javascript for Node'\n-version: '7.3.3'\n+version: '7.4.0'\n sdks:\n   - full-name: PubNub Javascript SDK\n     short-name: Javascript\n@@ -911,7 +918,7 @@ sdks:\n           - distribution-type: source\n             distribution-repository: GitHub release\n             package-name: pubnub.js\n-            location: https://github.com/pubnub/javascript/archive/refs/tags/v7.3.3.zip\n+            location: https://github.com/pubnub/javascript/archive/refs/tags/v7.4.0.zip\n             requires:\n               - name: 'agentkeepalive'\n                 min-version: '3.5.2'\n@@ -1582,7 +1589,7 @@ sdks:\n           - distribution-type: library\n             distribution-repository: GitHub release\n             package-name: pubnub.js\n-            location: https://github.com/pubnub/javascript/releases/download/v7.3.3/pubnub.7.3.3.js\n+            location: https://github.com/pubnub/javascript/releases/download/v7.4.0/pubnub.7.4.0.js\n             requires:\n               - name: 'agentkeepalive'\n                 min-version: '3.5.2'"
        },
        {
            "filename": "CHANGELOG.md",
            "diff": "@@ -1,3 +1,12 @@\n+## v7.4.0\n+October 16 2023\n+\n+#### Added\n+- Add crypto module that allows configure SDK to encrypt and decrypt messages.\n+\n+#### Fixed\n+- Improved security of crypto implementation by adding enhanced AES-CBC cryptor.\n+\n ## v7.3.3\n September 11 2023\n "
        },
        {
            "filename": "LICENSE",
            "diff": "@@ -1,27 +1,29 @@\n-PubNub Real-time Cloud-Hosted Push API and Push Notification Client Frameworks\n-Copyright (c) 2013 PubNub Inc.\n-http://www.pubnub.com/\n-http://www.pubnub.com/terms\n+PubNub Software Development Kit License Agreement\n+Copyright \u00a9 2023 PubNub Inc. All rights reserved.\n \n-Permission is hereby granted, free of charge, to any person obtaining a copy\n-of this software and associated documentation files (the \"Software\"), to deal\n-in the Software without restriction, including without limitation the rights\n-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-copies of the Software, and to permit persons to whom the Software is\n-furnished to do so, subject to the following conditions:\n+Subject to the terms and conditions of the license, you are hereby granted\n+a non-exclusive, worldwide, royalty-free license to (a) copy and modify\n+the software in source code or binary form for use with the software services\n+and interfaces provided by PubNub, and (b) redistribute unmodified copies\n+of the software to third parties. The software may not be incorporated in\n+or used to provide any product or service competitive with the products\n+and services of PubNub.\n \n-The above copyright notice and this permission notice shall be included in\n-all copies or substantial portions of the Software.\n+The above copyright notice and this license shall be included\n+in or with all copies or substantial portions of the software.\n \n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-THE SOFTWARE.\n+This license does not grant you permission to use the trade names, trademarks,\n+service marks, or product names of PubNub, except as required for reasonable\n+and customary use in describing the origin of the software and reproducing\n+the content of this license.\n \n-PubNub Real-time Cloud-Hosted Push API and Push Notification Client Frameworks\n-Copyright (c) 2013 PubNub Inc.\n-http://www.pubnub.com/\n-http://www.pubnub.com/terms\n+THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO\n+EVENT SHALL PUBNUB OR THE AUTHORS OR COPYRIGHT HOLDERS OF THE SOFTWARE BE\n+LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\n+CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n+\n+https://www.pubnub.com/\n+https://www.pubnub.com/terms"
        },
        {
            "filename": "README.md",
            "diff": "@@ -28,8 +28,8 @@ Watch [Getting Started with PubNub JS SDK](https://app.dashcam.io/replay/64ee0d2\n      npm install pubnub\n      ```\n    * or download one of our builds from our CDN: \n-     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.3.3.js\n-     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.3.3.min.js\n+     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.js\n+     * https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.min.js\n \n 2. Configure your keys:\n "
        },
        {
            "filename": "dist/web/pubnub.js",
            "diff": "@@ -636,7 +636,7 @@\n             this.sdkFamily = setup.sdkFamily;\n             this.partnerId = setup.partnerId;\n             this.setAuthKey(setup.authKey);\n-            this.setCipherKey(setup.cipherKey);\n+            this.cryptoModule = setup.cryptoModule;\n             this.setFilterExpression(setup.filterExpression);\n             if (typeof setup.origin !== 'string' && !Array.isArray(setup.origin) && setup.origin !== undefined) {\n                 throw new Error('Origin must be either undefined, a string or a list of strings.');\n@@ -695,6 +695,7 @@\n                 }\n                 this.setUUID(setup.uuid);\n             }\n+            this.setCipherKey(setup.cipherKey, setup);\n         }\n         // exposed setters\n         default_1.prototype.getAuthKey = function () {\n@@ -704,8 +705,15 @@\n             this.authKey = val;\n             return this;\n         };\n-        default_1.prototype.setCipherKey = function (val) {\n+        default_1.prototype.setCipherKey = function (val, setup, modules) {\n+            var _a;\n             this.cipherKey = val;\n+            if (this.cipherKey) {\n+                this.cryptoModule =\n+                    (_a = setup.cryptoModule) !== null && _a !== void 0 ? _a : setup.initCryptoModule({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs });\n+                if (modules)\n+                    modules.cryptoModule = this.cryptoModule;\n+            }\n             return this;\n         };\n         default_1.prototype.getUUID = function () {\n@@ -783,7 +791,7 @@\n             return this;\n         };\n         default_1.prototype.getVersion = function () {\n-            return '7.3.3';\n+            return '7.4.0';\n         };\n         default_1.prototype._addPnsdkSuffix = function (name, suffix) {\n             this._PNSDKSuffix[name] = suffix;\n@@ -841,6 +849,45 @@\n         }\n         return data;\n     }\n+    function encode$1(input) {\n+        var base64 = '';\n+        var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n+        var bytes = new Uint8Array(input);\n+        var byteLength = bytes.byteLength;\n+        var byteRemainder = byteLength % 3;\n+        var mainLength = byteLength - byteRemainder;\n+        var a, b, c, d;\n+        var chunk;\n+        // Main loop deals with bytes in chunks of 3\n+        for (var i = 0; i < mainLength; i = i + 3) {\n+            // Combine the three bytes into a single integer\n+            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n+            // Use bitmasks to extract 6-bit segments from the triplet\n+            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n+            b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n+            c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n+            d = chunk & 63; // 63       = 2^6 - 1\n+            // Convert the raw binary segments to the appropriate ASCII encoding\n+            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n+        }\n+        // Deal with the remaining bytes and padding\n+        if (byteRemainder == 1) {\n+            chunk = bytes[mainLength];\n+            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n+            // Set the 4 least significant bits to zero\n+            b = (chunk & 3) << 4; // 3   = 2^2 - 1\n+            base64 += encodings[a] + encodings[b] + '==';\n+        }\n+        else if (byteRemainder == 2) {\n+            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n+            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n+            b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n+            // Set the 2 least significant bits to zero\n+            c = (chunk & 15) << 2; // 15    = 2^4 - 1\n+            base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n+        }\n+        return base64;\n+    }\n \n     /*eslint-disable */\n     /*\n@@ -1764,11 +1811,20 @@\n         });\n         return { promise: promise, reject: failureResolve, fulfill: successResolve };\n     }\n+    function stringToArrayBuffer(str) {\n+        var buf = new ArrayBuffer(str.length * 2);\n+        var bufView = new Uint16Array(buf);\n+        for (var i = 0, strLen = str.length; i < strLen; i++) {\n+            bufView[i] = str.charCodeAt(i);\n+        }\n+        return buf;\n+    }\n     var utils$5 = {\n         signPamFromParams: signPamFromParams,\n         endsWith: endsWith,\n         createPromise: createPromise,\n         encodeString: encodeString,\n+        stringToArrayBuffer: stringToArrayBuffer,\n     };\n \n     /*       */\n@@ -1795,7 +1851,7 @@\n \n     var default_1$7 = /** @class */ (function () {\n         function default_1(_a) {\n-            var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager;\n+            var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager, cryptoModule = _a.cryptoModule;\n             this._listenerManager = listenerManager;\n             this._config = config;\n             this._leaveEndpoint = leaveEndpoint;\n@@ -1804,6 +1860,7 @@\n             this._subscribeEndpoint = subscribeEndpoint;\n             this._getFileUrl = getFileUrl;\n             this._crypto = crypto;\n+            this._cryptoModule = cryptoModule;\n             this._channels = {};\n             this._presenceChannels = {};\n             this._heartbeatChannels = {};\n@@ -1819,6 +1876,8 @@\n             this._isOnline = true;\n             this._reconnectionManager = new default_1$9({ timeEndpoint: timeEndpoint });\n             this._dedupingManager = new default_1$8({ config: config });\n+            if (this._cryptoModule)\n+                this._decoder = new TextDecoder();\n         }\n         default_1.prototype.adaptStateChange = function (args, callback) {\n             var _this = this;\n@@ -2286,9 +2345,20 @@\n                     announce.timetoken = publishMetaData.publishTimetoken;\n                     announce.publisher = message.issuingClientId;\n                     var msgPayload = message.payload;\n-                    if (_this._config.cipherKey) {\n-                        var decryptedPayload = _this._crypto.decrypt(message.payload);\n-                        if (typeof decryptedPayload === 'object' && decryptedPayload !== null) {\n+                    if (_this._cryptoModule) {\n+                        var decryptedPayload = void 0;\n+                        try {\n+                            var decryptedData = _this._cryptoModule.decrypt(message.payload);\n+                            decryptedPayload =\n+                                decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;\n+                        }\n+                        catch (e) {\n+                            decryptedPayload = null;\n+                            if (console && console.log) {\n+                                console.log('decryption error', e.message);\n+                            }\n+                        }\n+                        if (decryptedPayload !== null) {\n                             msgPayload = decryptedPayload;\n                         }\n                     }\n@@ -2322,8 +2392,26 @@\n                     if (message.userMetadata) {\n                         announce.userMetadata = message.userMetadata;\n                     }\n-                    if (_this._config.cipherKey) {\n-                        announce.message = _this._crypto.decrypt(message.payload);\n+                    if (_this._cryptoModule) {\n+                        var decryptedPayload = void 0;\n+                        try {\n+                            var decryptedData = _this._cryptoModule.decrypt(message.payload);\n+                            decryptedPayload =\n+                                decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;\n+                        }\n+                        catch (e) {\n+                            decryptedPayload = null;\n+                            // eslint-disable-next-line\n+                            if (console && console.log) {\n+                                console.log('decryption error', e.message); //eslint-disable-line\n+                            }\n+                        }\n+                        if (decryptedPayload != null) {\n+                            announce.message = decryptedPayload;\n+                        }\n+                        else {\n+                            announce.message = message.payload;\n+                        }\n                     }\n                     else {\n                         announce.message = message.payload;\n@@ -4622,11 +4710,11 @@\n     };\n \n     /**       */\n-    var preparePayload = function (_a, payload) {\n-        var crypto = _a.crypto, config = _a.config;\n+    var preparePayload = function (modules, payload) {\n         var stringifiedPayload = JSON.stringify(payload);\n-        if (config.cipherKey) {\n-            stringifiedPayload = crypto.encrypt(stringifiedPayload);\n+        if (modules.cryptoModule) {\n+            var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);\n+            stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode$1(encrypted);\n             stringifiedPayload = JSON.stringify(stringifiedPayload);\n         }\n         return stringifiedPayload || '';\n@@ -4681,13 +4769,13 @@\n \n     var sendFile = function (_a) {\n         var _this = this;\n-        var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, networking = _b.networking;\n+        var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, cryptoModule = _b.cryptoModule, networking = _b.networking;\n         return function (_a) {\n             var channel = _a.channel, input = _a.file, message = _a.message, cipherKey = _a.cipherKey, meta = _a.meta, ttl = _a.ttl, storeInHistory = _a.storeInHistory;\n             return __awaiter(_this, void 0, void 0, function () {\n-                var file, _b, _c, url, formFields, _d, id, name, formFieldsWithMimeType, result, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, e_1, errorBody, reason, retries, wasSuccessful, publishResult;\n-                return __generator(this, function (_s) {\n-                    switch (_s.label) {\n+                var file, _b, _c, url, formFields, _d, id, name, _e, formFieldsWithMimeType, result, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, e_1, errorBody, reason, retries, wasSuccessful, publishResult;\n+                return __generator(this, function (_t) {\n+                    switch (_t.label) {\n                         case 0:\n                             if (!channel) {\n                                 throw new PubNubError('Validation failed, check status for details', createValidationError(\"channel can't be empty\"));\n@@ -4698,13 +4786,21 @@\n                             file = PubNubFile.create(input);\n                             return [4 /*yield*/, generateUploadUrl({ channel: channel, name: file.name })];\n                         case 1:\n-                            _b = _s.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;\n-                            if (!(PubNubFile.supportsEncryptFile && (cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey))) return [3 /*break*/, 3];\n-                            return [4 /*yield*/, cryptography.encryptFile(cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey, file, PubNubFile)];\n+                            _b = _t.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;\n+                            if (!(PubNubFile.supportsEncryptFile && (cipherKey || cryptoModule))) return [3 /*break*/, 6];\n+                            if (!(cipherKey == null)) return [3 /*break*/, 3];\n+                            return [4 /*yield*/, cryptoModule.encryptFile(file, PubNubFile)];\n                         case 2:\n-                            file = _s.sent();\n-                            _s.label = 3;\n-                        case 3:\n+                            _e = _t.sent();\n+                            return [3 /*break*/, 5];\n+                        case 3: return [4 /*yield*/, cryptography.encryptFile(cipherKey, file, PubNubFile)];\n+                        case 4:\n+                            _e = _t.sent();\n+                            _t.label = 5;\n+                        case 5:\n+                            file = _e;\n+                            _t.label = 6;\n+                        case 6:\n                             formFieldsWithMimeType = formFields;\n                             if (file.mimeType) {\n                                 formFieldsWithMimeType = formFields.map(function (entry) {\n@@ -4713,48 +4809,48 @@\n                                     return entry;\n                                 });\n                             }\n-                            _s.label = 4;\n-                        case 4:\n-                            _s.trys.push([4, 18, , 19]);\n-                            if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 7];\n-                            _f = (_e = networking).POSTFILE;\n-                            _g = [url, formFieldsWithMimeType];\n-                            return [4 /*yield*/, file.toFileUri()];\n-                        case 5: return [4 /*yield*/, _f.apply(_e, _g.concat([_s.sent()]))];\n-                        case 6:\n-                            result = _s.sent();\n-                            return [3 /*break*/, 17];\n+                            _t.label = 7;\n                         case 7:\n-                            if (!PubNubFile.supportsFile) return [3 /*break*/, 10];\n-                            _j = (_h = networking).POSTFILE;\n-                            _k = [url, formFieldsWithMimeType];\n-                            return [4 /*yield*/, file.toFile()];\n-                        case 8: return [4 /*yield*/, _j.apply(_h, _k.concat([_s.sent()]))];\n+                            _t.trys.push([7, 21, , 22]);\n+                            if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 10];\n+                            _g = (_f = networking).POSTFILE;\n+                            _h = [url, formFieldsWithMimeType];\n+                            return [4 /*yield*/, file.toFileUri()];\n+                        case 8: return [4 /*yield*/, _g.apply(_f, _h.concat([_t.sent()]))];\n                         case 9:\n-                            result = _s.sent();\n-                            return [3 /*break*/, 17];\n+                            result = _t.sent();\n+                            return [3 /*break*/, 20];\n                         case 10:\n-                            if (!PubNubFile.supportsBuffer) return [3 /*break*/, 13];\n-                            _m = (_l = networking).POSTFILE;\n-                            _o = [url, formFieldsWithMimeType];\n-                            return [4 /*yield*/, file.toBuffer()];\n-                        case 11: return [4 /*yield*/, _m.apply(_l, _o.concat([_s.sent()]))];\n+                            if (!PubNubFile.supportsFile) return [3 /*break*/, 13];\n+                            _k = (_j = networking).POSTFILE;\n+                            _l = [url, formFieldsWithMimeType];\n+                            return [4 /*yield*/, file.toFile()];\n+                        case 11: return [4 /*yield*/, _k.apply(_j, _l.concat([_t.sent()]))];\n                         case 12:\n-                            result = _s.sent();\n-                            return [3 /*break*/, 17];\n+                            result = _t.sent();\n+                            return [3 /*break*/, 20];\n                         case 13:\n-                            if (!PubNubFile.supportsBlob) return [3 /*break*/, 16];\n-                            _q = (_p = networking).POSTFILE;\n-                            _r = [url, formFieldsWithMimeType];\n-                            return [4 /*yield*/, file.toBlob()];\n-                        case 14: return [4 /*yield*/, _q.apply(_p, _r.concat([_s.sent()]))];\n+                            if (!PubNubFile.supportsBuffer) return [3 /*break*/, 16];\n+                            _o = (_m = networking).POSTFILE;\n+                            _p = [url, formFieldsWithMimeType];\n+                            return [4 /*yield*/, file.toBuffer()];\n+                        case 14: return [4 /*yield*/, _o.apply(_m, _p.concat([_t.sent()]))];\n                         case 15:\n-                            result = _s.sent();\n-                            return [3 /*break*/, 17];\n-                        case 16: throw new Error('Unsupported environment');\n-                        case 17: return [3 /*break*/, 19];\n+                            result = _t.sent();\n+                            return [3 /*break*/, 20];\n+                        case 16:\n+                            if (!PubNubFile.supportsBlob) return [3 /*break*/, 19];\n+                            _r = (_q = networking).POSTFILE;\n+                            _s = [url, formFieldsWithMimeType];\n+                            return [4 /*yield*/, file.toBlob()];\n+                        case 17: return [4 /*yield*/, _r.apply(_q, _s.concat([_t.sent()]))];\n                         case 18:\n-                            e_1 = _s.sent();\n+                            result = _t.sent();\n+                            return [3 /*break*/, 20];\n+                        case 19: throw new Error('Unsupported environment');\n+                        case 20: return [3 /*break*/, 22];\n+                        case 21:\n+                            e_1 = _t.sent();\n                             if (e_1.response && typeof e_1.response.text === 'string') {\n                                 errorBody = e_1.response.text;\n                                 reason = /<Message>(.*)<\\/Message>/gi.exec(errorBody);\n@@ -4763,16 +4859,16 @@\n                             else {\n                                 throw new PubNubError('Upload to bucket failed.', e_1);\n                             }\n-                        case 19:\n+                        case 22:\n                             if (result.status !== 204) {\n                                 throw new PubNubError('Upload to bucket was unsuccessful', result);\n                             }\n                             retries = config.fileUploadPublishRetryLimit;\n                             wasSuccessful = false;\n                             publishResult = { timetoken: '0' };\n-                            _s.label = 20;\n-                        case 20:\n-                            _s.trys.push([20, 22, , 23]);\n+                            _t.label = 23;\n+                        case 23:\n+                            _t.trys.push([23, 25, , 26]);\n                             return [4 /*yield*/, publishFile({\n                                     channel: channel,\n                                     message: message,\n@@ -4782,19 +4878,19 @@\n                                     storeInHistory: storeInHistory,\n                                     ttl: ttl,\n                                 })];\n-                        case 21:\n+                        case 24:\n                             /* eslint-disable-next-line no-await-in-loop */\n-                            publishResult = _s.sent();\n+                            publishResult = _t.sent();\n                             wasSuccessful = true;\n-                            return [3 /*break*/, 23];\n-                        case 22:\n-                            _s.sent();\n+                            return [3 /*break*/, 26];\n+                        case 25:\n+                            _t.sent();\n                             retries -= 1;\n-                            return [3 /*break*/, 23];\n-                        case 23:\n-                            if (!wasSuccessful && retries > 0) return [3 /*break*/, 20];\n-                            _s.label = 24;\n-                        case 24:\n+                            return [3 /*break*/, 26];\n+                        case 26:\n+                            if (!wasSuccessful && retries > 0) return [3 /*break*/, 23];\n+                            _t.label = 27;\n+                        case 27:\n                             if (!wasSuccessful) {\n                                 throw new PubNubError('Publish failed. You may want to execute that operation manually using pubnub.publishFile', {\n                                     channel: channel,\n@@ -4861,7 +4957,7 @@\n         return \"\".concat(networking.getStandardOrigin()).concat(url);\n     });\n \n-    /**       */\n+    // Download_file.js\n     var endpoint$g = {\n         getOperation: function () { return OPERATIONS.PNDownloadFileOperation; },\n         validateParams: function (_, params) {\n@@ -4889,20 +4985,28 @@\n         forceBuffered: function () { return true; },\n         prepareParams: function () { return ({}); },\n         handleResponse: function (_a, res, params) {\n-            var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography;\n+            var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography, cryptoModule = _a.cryptoModule;\n             return __awaiter(void 0, void 0, void 0, function () {\n-                var body;\n-                var _b, _c, _d;\n+                var body, _b;\n+                var _c, _d;\n                 return __generator(this, function (_e) {\n                     switch (_e.label) {\n                         case 0:\n                             body = res.response.body;\n-                            if (!(PubNubFile.supportsEncryptFile && ((_b = params.cipherKey) !== null && _b !== void 0 ? _b : config.cipherKey))) return [3 /*break*/, 2];\n-                            return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];\n+                            if (!(PubNubFile.supportsEncryptFile && (params.cipherKey || cryptoModule))) return [3 /*break*/, 5];\n+                            if (!(params.cipherKey == null)) return [3 /*break*/, 2];\n+                            return [4 /*yield*/, cryptoModule.decryptFile(PubNubFile.create({ data: body, name: params.name }), PubNubFile)];\n                         case 1:\n-                            body = _e.sent();\n-                            _e.label = 2;\n-                        case 2: return [2 /*return*/, PubNubFile.create({\n+                            _b = (_e.sent()).data;\n+                            return [3 /*break*/, 4];\n+                        case 2: return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];\n+                        case 3:\n+                            _b = _e.sent();\n+                            _e.label = 4;\n+                        case 4:\n+                            body = _b;\n+                            _e.label = 5;\n+                        case 5: return [2 /*return*/, PubNubFile.create({\n                                 data: body,\n                                 name: (_d = res.response.name) !== null && _d !== void 0 ? _d : params.name,\n                                 mimeType: res.response.type,\n@@ -5996,13 +6100,13 @@\n \n     /*       */\n     function prepareMessagePayload$1(modules, messagePayload) {\n-        var crypto = modules.crypto, config = modules.config;\n         var stringifiedPayload = JSON.stringify(messagePayload);\n-        if (config.cipherKey) {\n-            stringifiedPayload = crypto.encrypt(stringifiedPayload);\n+        if (modules.cryptoModule) {\n+            var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);\n+            stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode$1(encrypted);\n             stringifiedPayload = JSON.stringify(stringifiedPayload);\n         }\n-        return stringifiedPayload;\n+        return stringifiedPayload || '';\n     }\n     function getOperation$7() {\n         return OPERATIONS.PNPublishOperation;\n@@ -6135,13 +6239,16 @@\n \n     /*       */\n     function __processMessage$1(modules, message) {\n-        var config = modules.config, crypto = modules.crypto;\n-        if (!config.cipherKey)\n+        if (!modules.cryptoModule)\n             return message;\n         try {\n-            return crypto.decrypt(message);\n+            var decryptedData = modules.cryptoModule.decrypt(message);\n+            var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;\n+            return decryptedPayload;\n         }\n         catch (e) {\n+            if (console && console.log)\n+                console.log('decryption error', e.message);\n             return message;\n         }\n     }\n@@ -6331,13 +6438,16 @@\n \n     /*       */\n     function __processMessage(modules, message) {\n-        var config = modules.config, crypto = modules.crypto;\n-        if (!config.cipherKey)\n+        if (!modules.cryptoModule)\n             return message;\n         try {\n-            return crypto.decrypt(message);\n+            var decryptedData = modules.cryptoModule.decrypt(message);\n+            var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;\n+            return decryptedPayload;\n         }\n         catch (e) {\n+            if (console && console.log)\n+                console.log('decryption error', e.message);\n             return message;\n         }\n     }\n@@ -7375,6 +7485,7 @@\n                 maximumSamplesCount: 60000,\n             });\n             this._telemetryManager = telemetryManager;\n+            var cryptoModule = this._config.cryptoModule;\n             var modules = {\n                 config: config,\n                 networking: networking,\n@@ -7383,10 +7494,23 @@\n                 tokenManager: tokenManager,\n                 telemetryManager: telemetryManager,\n                 PubNubFile: setup.PubNubFile,\n+                cryptoModule: cryptoModule,\n             };\n             this.File = setup.PubNubFile;\n-            this.encryptFile = function (key, file) { return cryptography.encryptFile(key, file, _this.File); };\n-            this.decryptFile = function (key, file) { return cryptography.decryptFile(key, file, _this.File); };\n+            this.encryptFile = function (key, file) {\n+                if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {\n+                    file = key;\n+                    return modules.cryptoModule.encryptFile(file, this.File);\n+                }\n+                return cryptography.encryptFile(key, file, this.File);\n+            };\n+            this.decryptFile = function (key, file) {\n+                if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {\n+                    file = key;\n+                    return modules.cryptoModule.decryptFile(file, this.File);\n+                }\n+                return cryptography.decryptFile(key, file, this.File);\n+            };\n             var timeEndpoint = endpointCreator.bind(this, modules, timeEndpointConfig);\n             var leaveEndpoint = endpointCreator.bind(this, modules, presenceLeaveEndpointConfig);\n             var heartbeatEndpoint = endpointCreator.bind(this, modules, presenceHeartbeatEndpointConfig);\n@@ -7417,6 +7541,7 @@\n                     config: modules.config,\n                     listenerManager: listenerManager,\n                     getFileUrl: function (params) { return getFileUrlFunction(modules, params); },\n+                    cryptoModule: modules.cryptoModule,\n                 });\n                 this.subscribe = subscriptionManager_1.adaptSubscribeChange.bind(subscriptionManager_1);\n                 this.unsubscribe = subscriptionManager_1.adaptUnsubscribeChange.bind(subscriptionManager_1);\n@@ -7706,18 +7831,35 @@\n             this.stop = this.destroy; // --------\n             // --- deprecated  ------------------\n             // mount crypto\n-            this.encrypt = crypto.encrypt.bind(crypto);\n-            this.decrypt = crypto.decrypt.bind(crypto);\n+            this.encrypt = function (data, key) {\n+                if (typeof key === 'undefined' && modules.cryptoModule) {\n+                    var encrypted = modules.cryptoModule.encrypt(data);\n+                    return typeof encrypted === 'string' ? encrypted : encode$1(encrypted);\n+                }\n+                else {\n+                    return crypto.encrypt(data, key);\n+                }\n+            };\n+            this.decrypt = function (data, key) {\n+                if (typeof key === 'undefined' && cryptoModule) {\n+                    var decrypted = modules.cryptoModule.decrypt(data);\n+                    return decrypted instanceof ArrayBuffer ? encode$1(decrypted) : decrypted;\n+                }\n+                else {\n+                    return crypto.decrypt(data, key);\n+                }\n+            };\n             /* config */\n             this.getAuthKey = modules.config.getAuthKey.bind(modules.config);\n             this.setAuthKey = modules.config.setAuthKey.bind(modules.config);\n-            this.setCipherKey = modules.config.setCipherKey.bind(modules.config);\n             this.getUUID = modules.config.getUUID.bind(modules.config);\n             this.setUUID = modules.config.setUUID.bind(modules.config);\n             this.getUserId = modules.config.getUserId.bind(modules.config);\n             this.setUserId = modules.config.setUserId.bind(modules.config);\n             this.getFilterExpression = modules.config.getFilterExpression.bind(modules.config);\n             this.setFilterExpression = modules.config.setFilterExpression.bind(modules.config);\n+            // this.setCipherKey = modules.config.setCipherKey.bind(modules.config);\n+            this.setCipherKey = function (key) { return modules.config.setCipherKey(key, setup, modules); };\n             this.setHeartbeatInterval = modules.config.setHeartbeatInterval.bind(modules.config);\n             if (networking.hasModule('proxy')) {\n                 this.setProxy = function (proxy) {\n@@ -12534,10 +12676,13 @@\n                 var bKey, abPlaindata, abCipherdata;\n                 return __generator(this, function (_a) {\n                     switch (_a.label) {\n-                        case 0: return [4 /*yield*/, this.getKey(key)];\n+                        case 0:\n+                            if (file.data.byteLength <= 0)\n+                                throw new Error('encryption error. empty content');\n+                            return [4 /*yield*/, this.getKey(key)];\n                         case 1:\n                             bKey = _a.sent();\n-                            return [4 /*yield*/, file.toArrayBuffer()];\n+                            return [4 /*yield*/, file.data.arrayBuffer()];\n                         case 2:\n                             abPlaindata = _a.sent();\n                             return [4 /*yield*/, this.encryptArrayBuffer(bKey, abPlaindata)];\n@@ -12560,7 +12705,7 @@\n                         case 0: return [4 /*yield*/, this.getKey(key)];\n                         case 1:\n                             bKey = _a.sent();\n-                            return [4 /*yield*/, file.toArrayBuffer()];\n+                            return [4 /*yield*/, file.data.arrayBuffer()];\n                         case 2:\n                             abCipherdata = _a.sent();\n                             return [4 /*yield*/, this.decryptArrayBuffer(bKey, abCipherdata)];\n@@ -12576,15 +12721,16 @@\n         };\n         WebCryptography.prototype.getKey = function (key) {\n             return __awaiter(this, void 0, void 0, function () {\n-                var bKey, abHash, abKey;\n+                var digest, hashHex, abKey;\n                 return __generator(this, function (_a) {\n                     switch (_a.label) {\n-                        case 0:\n-                            bKey = Buffer.from(key);\n-                            return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];\n+                        case 0: return [4 /*yield*/, crypto.subtle.digest('SHA-256', WebCryptography.encoder.encode(key))];\n                         case 1:\n-                            abHash = _a.sent();\n-                            abKey = Buffer.from(Buffer.from(abHash).toString('hex').slice(0, 32), 'utf8').buffer;\n+                            digest = _a.sent();\n+                            hashHex = Array.from(new Uint8Array(digest))\n+                                .map(function (b) { return b.toString(16).padStart(2, '0'); })\n+                                .join('');\n+                            abKey = WebCryptography.encoder.encode(hashHex.slice(0, 32)).buffer;\n                             return [2 /*return*/, crypto.subtle.importKey('raw', abKey, 'AES-CBC', true, ['encrypt', 'decrypt'])];\n                     }\n                 });\n@@ -12607,10 +12753,18 @@\n         };\n         WebCryptography.prototype.decryptArrayBuffer = function (key, ciphertext) {\n             return __awaiter(this, void 0, void 0, function () {\n-                var abIv;\n+                var abIv, data;\n                 return __generator(this, function (_a) {\n-                    abIv = ciphertext.slice(0, 16);\n-                    return [2 /*return*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(16))];\n+                    switch (_a.label) {\n+                        case 0:\n+                            abIv = ciphertext.slice(0, 16);\n+                            if (ciphertext.slice(WebCryptography.IV_LENGTH).byteLength <= 0)\n+                                throw new Error('decryption error: empty content');\n+                            return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(WebCryptography.IV_LENGTH))];\n+                        case 1:\n+                            data = _a.sent();\n+                            return [2 /*return*/, data];\n+                    }\n                 });\n             });\n         };\n@@ -12621,12 +12775,12 @@\n                     switch (_a.label) {\n                         case 0:\n                             abIv = crypto.getRandomValues(new Uint8Array(16));\n-                            abPlaintext = Buffer.from(plaintext).buffer;\n+                            abPlaintext = WebCryptography.encoder.encode(plaintext).buffer;\n                             return [4 /*yield*/, crypto.subtle.encrypt({ name: 'AES-CBC', iv: abIv }, key, abPlaintext)];\n                         case 1:\n                             abPayload = _a.sent();\n                             ciphertext = concatArrayBuffer(abIv.buffer, abPayload);\n-                            return [2 /*return*/, Buffer.from(ciphertext).toString('utf8')];\n+                            return [2 /*return*/, WebCryptography.decoder.decode(ciphertext)];\n                     }\n                 });\n             });\n@@ -12637,18 +12791,20 @@\n                 return __generator(this, function (_a) {\n                     switch (_a.label) {\n                         case 0:\n-                            abCiphertext = Buffer.from(ciphertext);\n+                            abCiphertext = WebCryptography.encoder.encode(ciphertext).buffer;\n                             abIv = abCiphertext.slice(0, 16);\n                             abPayload = abCiphertext.slice(16);\n                             return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, abPayload)];\n                         case 1:\n                             abPlaintext = _a.sent();\n-                            return [2 /*return*/, Buffer.from(abPlaintext).toString('utf8')];\n+                            return [2 /*return*/, WebCryptography.decoder.decode(abPlaintext)];\n                     }\n                 });\n             });\n         };\n         WebCryptography.IV_LENGTH = 16;\n+        WebCryptography.encoder = new TextEncoder();\n+        WebCryptography.decoder = new TextDecoder();\n         return WebCryptography;\n     }());\n \n@@ -12764,6 +12920,443 @@\n         _a.supportsFileUri = false,\n         _a);\n \n+    var LegacyCryptor = /** @class */ (function () {\n+        function LegacyCryptor(config) {\n+            this.config = config;\n+            this.cryptor = new default_1$a({ config: config });\n+            this.fileCryptor = new WebCryptography();\n+        }\n+        Object.defineProperty(LegacyCryptor.prototype, \"identifier\", {\n+            get: function () {\n+                return '';\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        LegacyCryptor.prototype.encrypt = function (data) {\n+            var stringData = typeof data === 'string' ? data : new TextDecoder().decode(data);\n+            return {\n+                data: this.cryptor.encrypt(stringData),\n+                metadata: null,\n+            };\n+        };\n+        LegacyCryptor.prototype.decrypt = function (encryptedData) {\n+            var data = typeof encryptedData.data === 'string' ? encryptedData.data : encode$1(encryptedData.data);\n+            return this.cryptor.decrypt(data);\n+        };\n+        LegacyCryptor.prototype.encryptFile = function (file, File) {\n+            var _a;\n+            return __awaiter(this, void 0, void 0, function () {\n+                return __generator(this, function (_b) {\n+                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+                    //@ts-ignore: can not detect cipherKey from old Config\n+                    return [2 /*return*/, this.fileCryptor.encryptFile((_a = this.config) === null || _a === void 0 ? void 0 : _a.cipherKey, file, File)];\n+                });\n+            });\n+        };\n+        LegacyCryptor.prototype.decryptFile = function (file, File) {\n+            return __awaiter(this, void 0, void 0, function () {\n+                return __generator(this, function (_a) {\n+                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+                    //@ts-ignore: can not detect cipherKey from old Config\n+                    return [2 /*return*/, this.fileCryptor.decryptFile(this.config.cipherKey, file, File)];\n+                });\n+            });\n+        };\n+        return LegacyCryptor;\n+    }());\n+\n+    var AesCbcCryptor = /** @class */ (function () {\n+        function AesCbcCryptor(configuration) {\n+            this.cipherKey = configuration.cipherKey;\n+            this.CryptoJS = hmacSha256;\n+            this.encryptedKey = this.CryptoJS.SHA256(this.cipherKey);\n+        }\n+        Object.defineProperty(AesCbcCryptor.prototype, \"algo\", {\n+            get: function () {\n+                return 'AES-CBC';\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        Object.defineProperty(AesCbcCryptor.prototype, \"identifier\", {\n+            get: function () {\n+                return 'ACRH';\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        AesCbcCryptor.prototype.getIv = function () {\n+            return crypto.getRandomValues(new Uint8Array(AesCbcCryptor.BLOCK_SIZE));\n+        };\n+        AesCbcCryptor.prototype.getKey = function () {\n+            return __awaiter(this, void 0, void 0, function () {\n+                var bKey, abHash;\n+                return __generator(this, function (_a) {\n+                    switch (_a.label) {\n+                        case 0:\n+                            bKey = AesCbcCryptor.encoder.encode(this.cipherKey);\n+                            return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];\n+                        case 1:\n+                            abHash = _a.sent();\n+                            return [2 /*return*/, crypto.subtle.importKey('raw', abHash, this.algo, true, ['encrypt', 'decrypt'])];\n+                    }\n+                });\n+            });\n+        };\n+        AesCbcCryptor.prototype.encrypt = function (data) {\n+            var stringData = typeof data === 'string' ? data : AesCbcCryptor.decoder.decode(data);\n+            if (stringData.length === 0)\n+                throw new Error('encryption error. empty content');\n+            var abIv = this.getIv();\n+            return {\n+                metadata: abIv,\n+                data: decode$1(this.CryptoJS.AES.encrypt(data, this.encryptedKey, {\n+                    iv: this.bufferToWordArray(abIv),\n+                    mode: this.CryptoJS.mode.CBC,\n+                }).ciphertext.toString(this.CryptoJS.enc.Base64)),\n+            };\n+        };\n+        AesCbcCryptor.prototype.decrypt = function (encryptedData) {\n+            var iv = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.metadata));\n+            var data = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.data));\n+            return AesCbcCryptor.encoder.encode(this.CryptoJS.AES.decrypt({ ciphertext: data }, this.encryptedKey, {\n+                iv: iv,\n+                mode: this.CryptoJS.mode.CBC,\n+            }).toString(this.CryptoJS.enc.Utf8)).buffer;\n+        };\n+        AesCbcCryptor.prototype.encryptFileData = function (data) {\n+            return __awaiter(this, void 0, void 0, function () {\n+                var key, iv;\n+                var _a;\n+                return __generator(this, function (_b) {\n+                    switch (_b.label) {\n+                        case 0: return [4 /*yield*/, this.getKey()];\n+                        case 1:\n+                            key = _b.sent();\n+                            iv = this.getIv();\n+                            _a = {};\n+                            return [4 /*yield*/, crypto.subtle.encrypt({ name: this.algo, iv: iv }, key, data)];\n+                        case 2: return [2 /*return*/, (_a.data = _b.sent(),\n+                                _a.metadata = iv,\n+                                _a)];\n+                    }\n+                });\n+            });\n+        };\n+        AesCbcCryptor.prototype.decryptFileData = function (encryptedData) {\n+            return __awaiter(this, void 0, void 0, function () {\n+                var key;\n+                return __generator(this, function (_a) {\n+                    switch (_a.label) {\n+                        case 0: return [4 /*yield*/, this.getKey()];\n+                        case 1:\n+                            key = _a.sent();\n+                            return [2 /*return*/, crypto.subtle.decrypt({ name: this.algo, iv: encryptedData.metadata }, key, encryptedData.data)];\n+                    }\n+                });\n+            });\n+        };\n+        AesCbcCryptor.prototype.bufferToWordArray = function (b) {\n+            var wa = [];\n+            var i;\n+            for (i = 0; i < b.length; i += 1) {\n+                wa[(i / 4) | 0] |= b[i] << (24 - 8 * i);\n+            }\n+            return this.CryptoJS.lib.WordArray.create(wa, b.length);\n+        };\n+        AesCbcCryptor.BLOCK_SIZE = 16;\n+        AesCbcCryptor.encoder = new TextEncoder();\n+        AesCbcCryptor.decoder = new TextDecoder();\n+        return AesCbcCryptor;\n+    }());\n+\n+    var CryptoModule = /** @class */ (function () {\n+        function CryptoModule(cryptoModuleConfiguration) {\n+            var _a;\n+            this.defaultCryptor = cryptoModuleConfiguration.default;\n+            this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];\n+        }\n+        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+        //@ts-ignore: type detection issue with old Config type assignment\n+        CryptoModule.legacyCryptoModule = function (config) {\n+            var _a;\n+            return new this({\n+                default: new LegacyCryptor({\n+                    cipherKey: config.cipherKey,\n+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+                }),\n+                cryptors: [new AesCbcCryptor({ cipherKey: config.cipherKey })],\n+            });\n+        };\n+        CryptoModule.aesCbcCryptoModule = function (config) {\n+            var _a;\n+            return new this({\n+                default: new AesCbcCryptor({ cipherKey: config.cipherKey }),\n+                cryptors: [\n+                    new LegacyCryptor({\n+                        cipherKey: config.cipherKey,\n+                        useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+                    }),\n+                ],\n+            });\n+        };\n+        CryptoModule.withDefaultCryptor = function (defaultCryptor) {\n+            return new this({ default: defaultCryptor });\n+        };\n+        CryptoModule.prototype.getAllCryptors = function () {\n+            return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);\n+        };\n+        CryptoModule.prototype.encrypt = function (data) {\n+            var encrypted = this.defaultCryptor.encrypt(data);\n+            if (!encrypted.metadata)\n+                return encrypted.data;\n+            var headerData = this.getHeaderData(encrypted);\n+            return this.concatArrayBuffer(headerData, encrypted.data);\n+        };\n+        CryptoModule.prototype.decrypt = function (data) {\n+            var encryptedData = typeof data === 'string' ? decode$1(data) : data;\n+            var header = CryptorHeader.tryParse(encryptedData);\n+            var cryptor = this.getCryptor(header);\n+            var metadata = header.length > 0\n+                ? encryptedData.slice(header.length - header.metadataLength, header.length)\n+                : null;\n+            if (encryptedData.slice(header.length).byteLength <= 0)\n+                throw new Error('decryption error. empty content');\n+            return cryptor.decrypt({\n+                data: encryptedData.slice(header.length),\n+                metadata: metadata,\n+            });\n+        };\n+        CryptoModule.prototype.encryptFile = function (file, File) {\n+            return __awaiter(this, void 0, void 0, function () {\n+                var fileData, encrypted;\n+                return __generator(this, function (_a) {\n+                    switch (_a.label) {\n+                        case 0:\n+                            if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)\n+                                return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];\n+                            fileData = this.getFileData(file.data);\n+                            return [4 /*yield*/, this.defaultCryptor.encryptFileData(fileData)];\n+                        case 1:\n+                            encrypted = _a.sent();\n+                            return [2 /*return*/, File.create({\n+                                    name: file.name,\n+                                    mimeType: 'application/octet-stream',\n+                                    data: this.concatArrayBuffer(this.getHeaderData(encrypted), encrypted.data),\n+                                })];\n+                    }\n+                });\n+            });\n+        };\n+        CryptoModule.prototype.decryptFile = function (file, File) {\n+            return __awaiter(this, void 0, void 0, function () {\n+                var data, header, cryptor, fileData, metadata, _a, _b;\n+                var _c;\n+                return __generator(this, function (_d) {\n+                    switch (_d.label) {\n+                        case 0: return [4 /*yield*/, file.data.arrayBuffer()];\n+                        case 1:\n+                            data = _d.sent();\n+                            header = CryptorHeader.tryParse(data);\n+                            cryptor = this.getCryptor(header);\n+                            if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER) {\n+                                return [2 /*return*/, cryptor.decryptFile(file, File)];\n+                            }\n+                            fileData = this.getFileData(data);\n+                            metadata = fileData.slice(header.length - header.metadataLength, header.length);\n+                            _b = (_a = File).create;\n+                            _c = {\n+                                name: file.name\n+                            };\n+                            return [4 /*yield*/, this.defaultCryptor.decryptFileData({\n+                                    data: data.slice(header.length),\n+                                    metadata: metadata,\n+                                })];\n+                        case 2: return [2 /*return*/, _b.apply(_a, [(_c.data = _d.sent(),\n+                                    _c)])];\n+                    }\n+                });\n+            });\n+        };\n+        CryptoModule.prototype.getCryptor = function (header) {\n+            if (header === '') {\n+                var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });\n+                if (cryptor)\n+                    return cryptor;\n+                throw new Error('unknown cryptor error');\n+            }\n+            else if (header instanceof CryptorHeaderV1) {\n+                return this.getCryptorFromId(header.identifier);\n+            }\n+        };\n+        CryptoModule.prototype.getCryptorFromId = function (id) {\n+            var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });\n+            if (cryptor) {\n+                return cryptor;\n+            }\n+            throw Error('unknown cryptor error');\n+        };\n+        CryptoModule.prototype.concatArrayBuffer = function (ab1, ab2) {\n+            var tmp = new Uint8Array(ab1.byteLength + ab2.byteLength);\n+            tmp.set(new Uint8Array(ab1), 0);\n+            tmp.set(new Uint8Array(ab2), ab1.byteLength);\n+            return tmp.buffer;\n+        };\n+        CryptoModule.prototype.getHeaderData = function (encrypted) {\n+            if (!encrypted.metadata)\n+                return;\n+            var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);\n+            var headerData = new Uint8Array(header.length);\n+            var pos = 0;\n+            headerData.set(header.data, pos);\n+            pos += header.length - encrypted.metadata.byteLength;\n+            headerData.set(new Uint8Array(encrypted.metadata), pos);\n+            return headerData.buffer;\n+        };\n+        CryptoModule.prototype.getFileData = function (input) {\n+            if (input instanceof ArrayBuffer) {\n+                return input;\n+            }\n+            if (typeof input === 'string') {\n+                return CryptoModule.encoder.encode(input);\n+            }\n+            throw new Error('Cannot decrypt/encrypt file. In browsers file decryption supports only string or ArrayBuffer');\n+        };\n+        CryptoModule.LEGACY_IDENTIFIER = '';\n+        CryptoModule.encoder = new TextEncoder();\n+        CryptoModule.decoder = new TextDecoder();\n+        return CryptoModule;\n+    }());\n+    // CryptorHeader Utility\n+    var CryptorHeader = /** @class */ (function () {\n+        function CryptorHeader() {\n+        }\n+        CryptorHeader.from = function (id, metadata) {\n+            if (id === CryptorHeader.LEGACY_IDENTIFIER)\n+                return;\n+            return new CryptorHeaderV1(id, metadata.byteLength);\n+        };\n+        CryptorHeader.tryParse = function (data) {\n+            var encryptedData = new Uint8Array(data);\n+            var sentinel = '';\n+            var version = null;\n+            if (encryptedData.byteLength >= 4) {\n+                sentinel = encryptedData.slice(0, 4);\n+                if (this.decoder.decode(sentinel) !== CryptorHeader.SENTINEL)\n+                    return '';\n+            }\n+            if (encryptedData.byteLength >= 5) {\n+                version = encryptedData[4];\n+            }\n+            else {\n+                throw new Error('decryption error. invalid header version');\n+            }\n+            if (version > CryptorHeader.MAX_VERSION)\n+                throw new Error('unknown cryptor error');\n+            var identifier = '';\n+            var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;\n+            if (encryptedData.byteLength >= pos) {\n+                identifier = encryptedData.slice(5, pos);\n+            }\n+            else {\n+                throw new Error('decryption error. invalid crypto identifier');\n+            }\n+            var metadataLength = null;\n+            if (encryptedData.byteLength >= pos + 1) {\n+                metadataLength = encryptedData[pos];\n+            }\n+            else {\n+                throw new Error('decryption error. invalid metadata length');\n+            }\n+            pos += 1;\n+            if (metadataLength === 255 && encryptedData.byteLength >= pos + 2) {\n+                metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);\n+                pos += 2;\n+            }\n+            return new CryptorHeaderV1(this.decoder.decode(identifier), metadataLength);\n+        };\n+        CryptorHeader.SENTINEL = 'PNED';\n+        CryptorHeader.LEGACY_IDENTIFIER = '';\n+        CryptorHeader.IDENTIFIER_LENGTH = 4;\n+        CryptorHeader.VERSION = 1;\n+        CryptorHeader.MAX_VERSION = 1;\n+        CryptorHeader.decoder = new TextDecoder();\n+        return CryptorHeader;\n+    }());\n+    // v1 CryptorHeader\n+    var CryptorHeaderV1 = /** @class */ (function () {\n+        function CryptorHeaderV1(id, metadataLength) {\n+            this._identifier = id;\n+            this._metadataLength = metadataLength;\n+        }\n+        Object.defineProperty(CryptorHeaderV1.prototype, \"identifier\", {\n+            get: function () {\n+                return this._identifier;\n+            },\n+            set: function (value) {\n+                this._identifier = value;\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        Object.defineProperty(CryptorHeaderV1.prototype, \"metadataLength\", {\n+            get: function () {\n+                return this._metadataLength;\n+            },\n+            set: function (value) {\n+                this._metadataLength = value;\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        Object.defineProperty(CryptorHeaderV1.prototype, \"version\", {\n+            get: function () {\n+                return CryptorHeader.VERSION;\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        Object.defineProperty(CryptorHeaderV1.prototype, \"length\", {\n+            get: function () {\n+                return (CryptorHeader.SENTINEL.length +\n+                    1 +\n+                    CryptorHeader.IDENTIFIER_LENGTH +\n+                    (this.metadataLength < 255 ? 1 : 3) +\n+                    this.metadataLength);\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        Object.defineProperty(CryptorHeaderV1.prototype, \"data\", {\n+            get: function () {\n+                var pos = 0;\n+                var header = new Uint8Array(this.length);\n+                var encoder = new TextEncoder();\n+                header.set(encoder.encode(CryptorHeader.SENTINEL));\n+                pos += CryptorHeader.SENTINEL.length;\n+                header[pos] = this.version;\n+                pos++;\n+                if (this.identifier)\n+                    header.set(encoder.encode(this.identifier), pos);\n+                pos += CryptorHeader.IDENTIFIER_LENGTH;\n+                var metadataLength = this.metadataLength;\n+                if (metadataLength < 255) {\n+                    header[pos] = metadataLength;\n+                }\n+                else {\n+                    header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);\n+                }\n+                return header;\n+            },\n+            enumerable: false,\n+            configurable: true\n+        });\n+        CryptorHeaderV1.IDENTIFIER_LENGTH = 4;\n+        CryptorHeaderV1.SENTINEL = 'PNED';\n+        return CryptorHeaderV1;\n+    }());\n+\n     /* eslint no-bitwise: [\"error\", { \"allow\": [\"~\", \"&\", \">>\"] }] */\n     function sendBeacon(url) {\n         if (navigator && navigator.sendBeacon) {\n@@ -12792,6 +13385,15 @@\n             setup.cbor = new default_1$1(function (arrayBuffer) { return stringifyBufferKeys(CborReader.decode(arrayBuffer)); }, decode$1);\n             setup.PubNubFile = PubNubFile;\n             setup.cryptography = new WebCryptography();\n+            setup.initCryptoModule = function (cryptoConfiguration) {\n+                return new CryptoModule({\n+                    default: new LegacyCryptor({\n+                        cipherKey: cryptoConfiguration.cipherKey,\n+                        useRandomIVs: cryptoConfiguration.useRandomIVs,\n+                    }),\n+                    cryptors: [new AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],\n+                });\n+            };\n             _this = _super.call(this, setup) || this;\n             if (listenToBrowserNetworkEvents) {\n                 // mount network events.\n@@ -12804,6 +13406,7 @@\n             }\n             return _this;\n         }\n+        default_1.CryptoModule = CryptoModule;\n         return default_1;\n     }(default_1$3));\n "
        },
        {
            "filename": "lib/core/components/base64_codec.js",
            "diff": "@@ -1,6 +1,6 @@\n \"use strict\";\n Object.defineProperty(exports, \"__esModule\", { value: true });\n-exports.decode = void 0;\n+exports.encode = exports.decode = void 0;\n var BASE64_CHARMAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n /**\n  * Decode a Base64 encoded string.\n@@ -48,3 +48,43 @@ function decode(paddedInput) {\n     return data;\n }\n exports.decode = decode;\n+function encode(input) {\n+    var base64 = '';\n+    var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n+    var bytes = new Uint8Array(input);\n+    var byteLength = bytes.byteLength;\n+    var byteRemainder = byteLength % 3;\n+    var mainLength = byteLength - byteRemainder;\n+    var a, b, c, d;\n+    var chunk;\n+    // Main loop deals with bytes in chunks of 3\n+    for (var i = 0; i < mainLength; i = i + 3) {\n+        // Combine the three bytes into a single integer\n+        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n+        // Use bitmasks to extract 6-bit segments from the triplet\n+        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n+        b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n+        c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n+        d = chunk & 63; // 63       = 2^6 - 1\n+        // Convert the raw binary segments to the appropriate ASCII encoding\n+        base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n+    }\n+    // Deal with the remaining bytes and padding\n+    if (byteRemainder == 1) {\n+        chunk = bytes[mainLength];\n+        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n+        // Set the 4 least significant bits to zero\n+        b = (chunk & 3) << 4; // 3   = 2^2 - 1\n+        base64 += encodings[a] + encodings[b] + '==';\n+    }\n+    else if (byteRemainder == 2) {\n+        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n+        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n+        b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n+        // Set the 2 least significant bits to zero\n+        c = (chunk & 15) << 2; // 15    = 2^4 - 1\n+        base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n+    }\n+    return base64;\n+}\n+exports.encode = encode;"
        },
        {
            "filename": "lib/core/components/config.js",
            "diff": "@@ -22,7 +22,7 @@ var default_1 = /** @class */ (function () {\n         this.sdkFamily = setup.sdkFamily;\n         this.partnerId = setup.partnerId;\n         this.setAuthKey(setup.authKey);\n-        this.setCipherKey(setup.cipherKey);\n+        this.cryptoModule = setup.cryptoModule;\n         this.setFilterExpression(setup.filterExpression);\n         if (typeof setup.origin !== 'string' && !Array.isArray(setup.origin) && setup.origin !== undefined) {\n             throw new Error('Origin must be either undefined, a string or a list of strings.');\n@@ -81,6 +81,7 @@ var default_1 = /** @class */ (function () {\n             }\n             this.setUUID(setup.uuid);\n         }\n+        this.setCipherKey(setup.cipherKey, setup);\n     }\n     // exposed setters\n     default_1.prototype.getAuthKey = function () {\n@@ -90,8 +91,15 @@ var default_1 = /** @class */ (function () {\n         this.authKey = val;\n         return this;\n     };\n-    default_1.prototype.setCipherKey = function (val) {\n+    default_1.prototype.setCipherKey = function (val, setup, modules) {\n+        var _a;\n         this.cipherKey = val;\n+        if (this.cipherKey) {\n+            this.cryptoModule =\n+                (_a = setup.cryptoModule) !== null && _a !== void 0 ? _a : setup.initCryptoModule({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs });\n+            if (modules)\n+                modules.cryptoModule = this.cryptoModule;\n+        }\n         return this;\n     };\n     default_1.prototype.getUUID = function () {\n@@ -169,7 +177,7 @@ var default_1 = /** @class */ (function () {\n         return this;\n     };\n     default_1.prototype.getVersion = function () {\n-        return '7.3.3';\n+        return '7.4.0';\n     };\n     default_1.prototype._addPnsdkSuffix = function (name, suffix) {\n         this._PNSDKSuffix[name] = suffix;"
        },
        {
            "filename": "lib/core/components/subscription_manager.js",
            "diff": "@@ -31,7 +31,7 @@ var utils_1 = __importDefault(require(\"../utils\"));\n var categories_1 = __importDefault(require(\"../constants/categories\"));\n var default_1 = /** @class */ (function () {\n     function default_1(_a) {\n-        var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager;\n+        var subscribeEndpoint = _a.subscribeEndpoint, leaveEndpoint = _a.leaveEndpoint, heartbeatEndpoint = _a.heartbeatEndpoint, setStateEndpoint = _a.setStateEndpoint, timeEndpoint = _a.timeEndpoint, getFileUrl = _a.getFileUrl, config = _a.config, crypto = _a.crypto, listenerManager = _a.listenerManager, cryptoModule = _a.cryptoModule;\n         this._listenerManager = listenerManager;\n         this._config = config;\n         this._leaveEndpoint = leaveEndpoint;\n@@ -40,6 +40,7 @@ var default_1 = /** @class */ (function () {\n         this._subscribeEndpoint = subscribeEndpoint;\n         this._getFileUrl = getFileUrl;\n         this._crypto = crypto;\n+        this._cryptoModule = cryptoModule;\n         this._channels = {};\n         this._presenceChannels = {};\n         this._heartbeatChannels = {};\n@@ -55,6 +56,8 @@ var default_1 = /** @class */ (function () {\n         this._isOnline = true;\n         this._reconnectionManager = new reconnection_manager_1.default({ timeEndpoint: timeEndpoint });\n         this._dedupingManager = new deduping_manager_1.default({ config: config });\n+        if (this._cryptoModule)\n+            this._decoder = new TextDecoder();\n     }\n     default_1.prototype.adaptStateChange = function (args, callback) {\n         var _this = this;\n@@ -522,9 +525,20 @@ var default_1 = /** @class */ (function () {\n                 announce.timetoken = publishMetaData.publishTimetoken;\n                 announce.publisher = message.issuingClientId;\n                 var msgPayload = message.payload;\n-                if (_this._config.cipherKey) {\n-                    var decryptedPayload = _this._crypto.decrypt(message.payload);\n-                    if (typeof decryptedPayload === 'object' && decryptedPayload !== null) {\n+                if (_this._cryptoModule) {\n+                    var decryptedPayload = void 0;\n+                    try {\n+                        var decryptedData = _this._cryptoModule.decrypt(message.payload);\n+                        decryptedPayload =\n+                            decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;\n+                    }\n+                    catch (e) {\n+                        decryptedPayload = null;\n+                        if (console && console.log) {\n+                            console.log('decryption error', e.message);\n+                        }\n+                    }\n+                    if (decryptedPayload !== null) {\n                         msgPayload = decryptedPayload;\n                     }\n                 }\n@@ -558,8 +572,26 @@ var default_1 = /** @class */ (function () {\n                 if (message.userMetadata) {\n                     announce.userMetadata = message.userMetadata;\n                 }\n-                if (_this._config.cipherKey) {\n-                    announce.message = _this._crypto.decrypt(message.payload);\n+                if (_this._cryptoModule) {\n+                    var decryptedPayload = void 0;\n+                    try {\n+                        var decryptedData = _this._cryptoModule.decrypt(message.payload);\n+                        decryptedPayload =\n+                            decryptedData instanceof ArrayBuffer ? JSON.parse(_this._decoder.decode(decryptedData)) : decryptedData;\n+                    }\n+                    catch (e) {\n+                        decryptedPayload = null;\n+                        // eslint-disable-next-line\n+                        if (console && console.log) {\n+                            console.log('decryption error', e.message); //eslint-disable-line\n+                        }\n+                    }\n+                    if (decryptedPayload != null) {\n+                        announce.message = decryptedPayload;\n+                    }\n+                    else {\n+                        announce.message = message.payload;\n+                    }\n                 }\n                 else {\n                     announce.message = message.payload;"
        },
        {
            "filename": "lib/core/endpoints/fetch_messages.js",
            "diff": "@@ -8,13 +8,16 @@ exports.handleResponse = exports.prepareParams = exports.isAuthSupported = expor\n var operations_1 = __importDefault(require(\"../constants/operations\"));\n var utils_1 = __importDefault(require(\"../utils\"));\n function __processMessage(modules, message) {\n-    var config = modules.config, crypto = modules.crypto;\n-    if (!config.cipherKey)\n+    if (!modules.cryptoModule)\n         return message;\n     try {\n-        return crypto.decrypt(message);\n+        var decryptedData = modules.cryptoModule.decrypt(message);\n+        var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;\n+        return decryptedPayload;\n     }\n     catch (e) {\n+        if (console && console.log)\n+            console.log('decryption error', e.message);\n         return message;\n     }\n }"
        },
        {
            "filename": "lib/core/endpoints/file_upload/download_file.js",
            "diff": "@@ -1,5 +1,5 @@\n \"use strict\";\n-/**       */\n+// Download_file.js\n var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n     function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n     return new (P || (P = Promise))(function (resolve, reject) {\n@@ -40,6 +40,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {\n     return (mod && mod.__esModule) ? mod : { \"default\": mod };\n };\n Object.defineProperty(exports, \"__esModule\", { value: true });\n+/**       */\n var operations_1 = __importDefault(require(\"../../constants/operations\"));\n var utils_1 = __importDefault(require(\"../../utils\"));\n var endpoint = {\n@@ -69,20 +70,28 @@ var endpoint = {\n     forceBuffered: function () { return true; },\n     prepareParams: function () { return ({}); },\n     handleResponse: function (_a, res, params) {\n-        var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography;\n+        var PubNubFile = _a.PubNubFile, config = _a.config, cryptography = _a.cryptography, cryptoModule = _a.cryptoModule;\n         return __awaiter(void 0, void 0, void 0, function () {\n-            var body;\n-            var _b, _c, _d;\n+            var body, _b;\n+            var _c, _d;\n             return __generator(this, function (_e) {\n                 switch (_e.label) {\n                     case 0:\n                         body = res.response.body;\n-                        if (!(PubNubFile.supportsEncryptFile && ((_b = params.cipherKey) !== null && _b !== void 0 ? _b : config.cipherKey))) return [3 /*break*/, 2];\n-                        return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];\n+                        if (!(PubNubFile.supportsEncryptFile && (params.cipherKey || cryptoModule))) return [3 /*break*/, 5];\n+                        if (!(params.cipherKey == null)) return [3 /*break*/, 2];\n+                        return [4 /*yield*/, cryptoModule.decryptFile(PubNubFile.create({ data: body, name: params.name }), PubNubFile)];\n                     case 1:\n-                        body = _e.sent();\n-                        _e.label = 2;\n-                    case 2: return [2 /*return*/, PubNubFile.create({\n+                        _b = (_e.sent()).data;\n+                        return [3 /*break*/, 4];\n+                    case 2: return [4 /*yield*/, cryptography.decrypt((_c = params.cipherKey) !== null && _c !== void 0 ? _c : config.cipherKey, body)];\n+                    case 3:\n+                        _b = _e.sent();\n+                        _e.label = 4;\n+                    case 4:\n+                        body = _b;\n+                        _e.label = 5;\n+                    case 5: return [2 /*return*/, PubNubFile.create({\n                             data: body,\n                             name: (_d = res.response.name) !== null && _d !== void 0 ? _d : params.name,\n                             mimeType: res.response.type,"
        },
        {
            "filename": "lib/core/endpoints/file_upload/publish_file.js",
            "diff": "@@ -6,11 +6,12 @@ var __importDefault = (this && this.__importDefault) || function (mod) {\n Object.defineProperty(exports, \"__esModule\", { value: true });\n var operations_1 = __importDefault(require(\"../../constants/operations\"));\n var utils_1 = __importDefault(require(\"../../utils\"));\n-var preparePayload = function (_a, payload) {\n-    var crypto = _a.crypto, config = _a.config;\n+var base64_codec_1 = require(\"../../components/base64_codec\");\n+var preparePayload = function (modules, payload) {\n     var stringifiedPayload = JSON.stringify(payload);\n-    if (config.cipherKey) {\n-        stringifiedPayload = crypto.encrypt(stringifiedPayload);\n+    if (modules.cryptoModule) {\n+        var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);\n+        stringifiedPayload = typeof encrypted === 'string' ? encrypted : (0, base64_codec_1.encode)(encrypted);\n         stringifiedPayload = JSON.stringify(stringifiedPayload);\n     }\n     return stringifiedPayload || '';"
        },
        {
            "filename": "lib/core/endpoints/file_upload/send_file.js",
            "diff": "@@ -39,13 +39,13 @@ Object.defineProperty(exports, \"__esModule\", { value: true });\n var endpoint_1 = require(\"../../components/endpoint\");\n var sendFile = function (_a) {\n     var _this = this;\n-    var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, networking = _b.networking;\n+    var generateUploadUrl = _a.generateUploadUrl, publishFile = _a.publishFile, _b = _a.modules, PubNubFile = _b.PubNubFile, config = _b.config, cryptography = _b.cryptography, cryptoModule = _b.cryptoModule, networking = _b.networking;\n     return function (_a) {\n         var channel = _a.channel, input = _a.file, message = _a.message, cipherKey = _a.cipherKey, meta = _a.meta, ttl = _a.ttl, storeInHistory = _a.storeInHistory;\n         return __awaiter(_this, void 0, void 0, function () {\n-            var file, _b, _c, url, formFields, _d, id, name, formFieldsWithMimeType, result, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, e_1, errorBody, reason, retries, wasSuccessful, publishResult, e_2;\n-            return __generator(this, function (_s) {\n-                switch (_s.label) {\n+            var file, _b, _c, url, formFields, _d, id, name, _e, formFieldsWithMimeType, result, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, e_1, errorBody, reason, retries, wasSuccessful, publishResult, e_2;\n+            return __generator(this, function (_t) {\n+                switch (_t.label) {\n                     case 0:\n                         if (!channel) {\n                             throw new endpoint_1.PubNubError('Validation failed, check status for details', (0, endpoint_1.createValidationError)(\"channel can't be empty\"));\n@@ -56,13 +56,21 @@ var sendFile = function (_a) {\n                         file = PubNubFile.create(input);\n                         return [4 /*yield*/, generateUploadUrl({ channel: channel, name: file.name })];\n                     case 1:\n-                        _b = _s.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;\n-                        if (!(PubNubFile.supportsEncryptFile && (cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey))) return [3 /*break*/, 3];\n-                        return [4 /*yield*/, cryptography.encryptFile(cipherKey !== null && cipherKey !== void 0 ? cipherKey : config.cipherKey, file, PubNubFile)];\n+                        _b = _t.sent(), _c = _b.file_upload_request, url = _c.url, formFields = _c.form_fields, _d = _b.data, id = _d.id, name = _d.name;\n+                        if (!(PubNubFile.supportsEncryptFile && (cipherKey || cryptoModule))) return [3 /*break*/, 6];\n+                        if (!(cipherKey == null)) return [3 /*break*/, 3];\n+                        return [4 /*yield*/, cryptoModule.encryptFile(file, PubNubFile)];\n                     case 2:\n-                        file = _s.sent();\n-                        _s.label = 3;\n-                    case 3:\n+                        _e = _t.sent();\n+                        return [3 /*break*/, 5];\n+                    case 3: return [4 /*yield*/, cryptography.encryptFile(cipherKey, file, PubNubFile)];\n+                    case 4:\n+                        _e = _t.sent();\n+                        _t.label = 5;\n+                    case 5:\n+                        file = _e;\n+                        _t.label = 6;\n+                    case 6:\n                         formFieldsWithMimeType = formFields;\n                         if (file.mimeType) {\n                             formFieldsWithMimeType = formFields.map(function (entry) {\n@@ -71,48 +79,48 @@ var sendFile = function (_a) {\n                                 return entry;\n                             });\n                         }\n-                        _s.label = 4;\n-                    case 4:\n-                        _s.trys.push([4, 18, , 19]);\n-                        if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 7];\n-                        _f = (_e = networking).POSTFILE;\n-                        _g = [url, formFieldsWithMimeType];\n-                        return [4 /*yield*/, file.toFileUri()];\n-                    case 5: return [4 /*yield*/, _f.apply(_e, _g.concat([_s.sent()]))];\n-                    case 6:\n-                        result = _s.sent();\n-                        return [3 /*break*/, 17];\n+                        _t.label = 7;\n                     case 7:\n-                        if (!PubNubFile.supportsFile) return [3 /*break*/, 10];\n-                        _j = (_h = networking).POSTFILE;\n-                        _k = [url, formFieldsWithMimeType];\n-                        return [4 /*yield*/, file.toFile()];\n-                    case 8: return [4 /*yield*/, _j.apply(_h, _k.concat([_s.sent()]))];\n+                        _t.trys.push([7, 21, , 22]);\n+                        if (!(PubNubFile.supportsFileUri && input.uri)) return [3 /*break*/, 10];\n+                        _g = (_f = networking).POSTFILE;\n+                        _h = [url, formFieldsWithMimeType];\n+                        return [4 /*yield*/, file.toFileUri()];\n+                    case 8: return [4 /*yield*/, _g.apply(_f, _h.concat([_t.sent()]))];\n                     case 9:\n-                        result = _s.sent();\n-                        return [3 /*break*/, 17];\n+                        result = _t.sent();\n+                        return [3 /*break*/, 20];\n                     case 10:\n-                        if (!PubNubFile.supportsBuffer) return [3 /*break*/, 13];\n-                        _m = (_l = networking).POSTFILE;\n-                        _o = [url, formFieldsWithMimeType];\n-                        return [4 /*yield*/, file.toBuffer()];\n-                    case 11: return [4 /*yield*/, _m.apply(_l, _o.concat([_s.sent()]))];\n+                        if (!PubNubFile.supportsFile) return [3 /*break*/, 13];\n+                        _k = (_j = networking).POSTFILE;\n+                        _l = [url, formFieldsWithMimeType];\n+                        return [4 /*yield*/, file.toFile()];\n+                    case 11: return [4 /*yield*/, _k.apply(_j, _l.concat([_t.sent()]))];\n                     case 12:\n-                        result = _s.sent();\n-                        return [3 /*break*/, 17];\n+                        result = _t.sent();\n+                        return [3 /*break*/, 20];\n                     case 13:\n-                        if (!PubNubFile.supportsBlob) return [3 /*break*/, 16];\n-                        _q = (_p = networking).POSTFILE;\n-                        _r = [url, formFieldsWithMimeType];\n-                        return [4 /*yield*/, file.toBlob()];\n-                    case 14: return [4 /*yield*/, _q.apply(_p, _r.concat([_s.sent()]))];\n+                        if (!PubNubFile.supportsBuffer) return [3 /*break*/, 16];\n+                        _o = (_m = networking).POSTFILE;\n+                        _p = [url, formFieldsWithMimeType];\n+                        return [4 /*yield*/, file.toBuffer()];\n+                    case 14: return [4 /*yield*/, _o.apply(_m, _p.concat([_t.sent()]))];\n                     case 15:\n-                        result = _s.sent();\n-                        return [3 /*break*/, 17];\n-                    case 16: throw new Error('Unsupported environment');\n-                    case 17: return [3 /*break*/, 19];\n+                        result = _t.sent();\n+                        return [3 /*break*/, 20];\n+                    case 16:\n+                        if (!PubNubFile.supportsBlob) return [3 /*break*/, 19];\n+                        _r = (_q = networking).POSTFILE;\n+                        _s = [url, formFieldsWithMimeType];\n+                        return [4 /*yield*/, file.toBlob()];\n+                    case 17: return [4 /*yield*/, _r.apply(_q, _s.concat([_t.sent()]))];\n                     case 18:\n-                        e_1 = _s.sent();\n+                        result = _t.sent();\n+                        return [3 /*break*/, 20];\n+                    case 19: throw new Error('Unsupported environment');\n+                    case 20: return [3 /*break*/, 22];\n+                    case 21:\n+                        e_1 = _t.sent();\n                         if (e_1.response && typeof e_1.response.text === 'string') {\n                             errorBody = e_1.response.text;\n                             reason = /<Message>(.*)<\\/Message>/gi.exec(errorBody);\n@@ -121,17 +129,17 @@ var sendFile = function (_a) {\n                         else {\n                             throw new endpoint_1.PubNubError('Upload to bucket failed.', e_1);\n                         }\n-                        return [3 /*break*/, 19];\n-                    case 19:\n+                        return [3 /*break*/, 22];\n+                    case 22:\n                         if (result.status !== 204) {\n                             throw new endpoint_1.PubNubError('Upload to bucket was unsuccessful', result);\n                         }\n                         retries = config.fileUploadPublishRetryLimit;\n                         wasSuccessful = false;\n                         publishResult = { timetoken: '0' };\n-                        _s.label = 20;\n-                    case 20:\n-                        _s.trys.push([20, 22, , 23]);\n+                        _t.label = 23;\n+                    case 23:\n+                        _t.trys.push([23, 25, , 26]);\n                         return [4 /*yield*/, publishFile({\n                                 channel: channel,\n                                 message: message,\n@@ -141,19 +149,19 @@ var sendFile = function (_a) {\n                                 storeInHistory: storeInHistory,\n                                 ttl: ttl,\n                             })];\n-                    case 21:\n+                    case 24:\n                         /* eslint-disable-next-line no-await-in-loop */\n-                        publishResult = _s.sent();\n+                        publishResult = _t.sent();\n                         wasSuccessful = true;\n-                        return [3 /*break*/, 23];\n-                    case 22:\n-                        e_2 = _s.sent();\n+                        return [3 /*break*/, 26];\n+                    case 25:\n+                        e_2 = _t.sent();\n                         retries -= 1;\n-                        return [3 /*break*/, 23];\n-                    case 23:\n-                        if (!wasSuccessful && retries > 0) return [3 /*break*/, 20];\n-                        _s.label = 24;\n-                    case 24:\n+                        return [3 /*break*/, 26];\n+                    case 26:\n+                        if (!wasSuccessful && retries > 0) return [3 /*break*/, 23];\n+                        _t.label = 27;\n+                    case 27:\n                         if (!wasSuccessful) {\n                             throw new endpoint_1.PubNubError('Publish failed. You may want to execute that operation manually using pubnub.publishFile', {\n                                 channel: channel,"
        },
        {
            "filename": "lib/core/endpoints/history/get_history.js",
            "diff": "@@ -8,13 +8,16 @@ exports.handleResponse = exports.prepareParams = exports.isAuthSupported = expor\n var operations_1 = __importDefault(require(\"../../constants/operations\"));\n var utils_1 = __importDefault(require(\"../../utils\"));\n function __processMessage(modules, message) {\n-    var config = modules.config, crypto = modules.crypto;\n-    if (!config.cipherKey)\n+    if (!modules.cryptoModule)\n         return message;\n     try {\n-        return crypto.decrypt(message);\n+        var decryptedData = modules.cryptoModule.decrypt(message);\n+        var decryptedPayload = decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;\n+        return decryptedPayload;\n     }\n     catch (e) {\n+        if (console && console.log)\n+            console.log('decryption error', e.message);\n         return message;\n     }\n }"
        },
        {
            "filename": "lib/core/endpoints/publish.js",
            "diff": "@@ -7,14 +7,15 @@ Object.defineProperty(exports, \"__esModule\", { value: true });\n exports.handleResponse = exports.prepareParams = exports.postPayload = exports.isAuthSupported = exports.getRequestTimeout = exports.postURL = exports.getURL = exports.usePost = exports.validateParams = exports.getOperation = void 0;\n var operations_1 = __importDefault(require(\"../constants/operations\"));\n var utils_1 = __importDefault(require(\"../utils\"));\n+var base64_codec_1 = require(\"../components/base64_codec\");\n function prepareMessagePayload(modules, messagePayload) {\n-    var crypto = modules.crypto, config = modules.config;\n     var stringifiedPayload = JSON.stringify(messagePayload);\n-    if (config.cipherKey) {\n-        stringifiedPayload = crypto.encrypt(stringifiedPayload);\n+    if (modules.cryptoModule) {\n+        var encrypted = modules.cryptoModule.encrypt(stringifiedPayload);\n+        stringifiedPayload = typeof encrypted === 'string' ? encrypted : (0, base64_codec_1.encode)(encrypted);\n         stringifiedPayload = JSON.stringify(stringifiedPayload);\n     }\n-    return stringifiedPayload;\n+    return stringifiedPayload || '';\n }\n function getOperation() {\n     return operations_1.default.PNPublishOperation;"
        },
        {
            "filename": "lib/core/pubnub-common.js",
            "diff": "@@ -60,6 +60,7 @@ var __importDefault = (this && this.__importDefault) || function (mod) {\n Object.defineProperty(exports, \"__esModule\", { value: true });\n var config_1 = __importDefault(require(\"./components/config\"));\n var index_1 = __importDefault(require(\"./components/cryptography/index\"));\n+var base64_codec_1 = require(\"./components/base64_codec\");\n var subscription_manager_1 = __importDefault(require(\"./components/subscription_manager\"));\n var telemetry_manager_1 = __importDefault(require(\"./components/telemetry_manager\"));\n var push_payload_1 = __importDefault(require(\"./components/push_payload\"));\n@@ -141,6 +142,7 @@ var default_1 = /** @class */ (function () {\n             maximumSamplesCount: 60000,\n         });\n         this._telemetryManager = telemetryManager;\n+        var cryptoModule = this._config.cryptoModule;\n         var modules = {\n             config: config,\n             networking: networking,\n@@ -149,10 +151,23 @@ var default_1 = /** @class */ (function () {\n             tokenManager: tokenManager,\n             telemetryManager: telemetryManager,\n             PubNubFile: setup.PubNubFile,\n+            cryptoModule: cryptoModule,\n         };\n         this.File = setup.PubNubFile;\n-        this.encryptFile = function (key, file) { return cryptography.encryptFile(key, file, _this.File); };\n-        this.decryptFile = function (key, file) { return cryptography.decryptFile(key, file, _this.File); };\n+        this.encryptFile = function (key, file) {\n+            if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {\n+                file = key;\n+                return modules.cryptoModule.encryptFile(file, this.File);\n+            }\n+            return cryptography.encryptFile(key, file, this.File);\n+        };\n+        this.decryptFile = function (key, file) {\n+            if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {\n+                file = key;\n+                return modules.cryptoModule.decryptFile(file, this.File);\n+            }\n+            return cryptography.decryptFile(key, file, this.File);\n+        };\n         var timeEndpoint = endpoint_1.default.bind(this, modules, timeEndpointConfig);\n         var leaveEndpoint = endpoint_1.default.bind(this, modules, presenceLeaveEndpointConfig);\n         var heartbeatEndpoint = endpoint_1.default.bind(this, modules, presenceHeartbeatEndpointConfig);\n@@ -183,6 +198,7 @@ var default_1 = /** @class */ (function () {\n                 config: modules.config,\n                 listenerManager: listenerManager,\n                 getFileUrl: function (params) { return (0, get_file_url_1.default)(modules, params); },\n+                cryptoModule: modules.cryptoModule,\n             });\n             this.subscribe = subscriptionManager_1.adaptSubscribeChange.bind(subscriptionManager_1);\n             this.unsubscribe = subscriptionManager_1.adaptUnsubscribeChange.bind(subscriptionManager_1);\n@@ -472,18 +488,35 @@ var default_1 = /** @class */ (function () {\n         this.stop = this.destroy; // --------\n         // --- deprecated  ------------------\n         // mount crypto\n-        this.encrypt = crypto.encrypt.bind(crypto);\n-        this.decrypt = crypto.decrypt.bind(crypto);\n+        this.encrypt = function (data, key) {\n+            if (typeof key === 'undefined' && modules.cryptoModule) {\n+                var encrypted = modules.cryptoModule.encrypt(data);\n+                return typeof encrypted === 'string' ? encrypted : (0, base64_codec_1.encode)(encrypted);\n+            }\n+            else {\n+                return crypto.encrypt(data, key);\n+            }\n+        };\n+        this.decrypt = function (data, key) {\n+            if (typeof key === 'undefined' && cryptoModule) {\n+                var decrypted = modules.cryptoModule.decrypt(data);\n+                return decrypted instanceof ArrayBuffer ? (0, base64_codec_1.encode)(decrypted) : decrypted;\n+            }\n+            else {\n+                return crypto.decrypt(data, key);\n+            }\n+        };\n         /* config */\n         this.getAuthKey = modules.config.getAuthKey.bind(modules.config);\n         this.setAuthKey = modules.config.setAuthKey.bind(modules.config);\n-        this.setCipherKey = modules.config.setCipherKey.bind(modules.config);\n         this.getUUID = modules.config.getUUID.bind(modules.config);\n         this.setUUID = modules.config.setUUID.bind(modules.config);\n         this.getUserId = modules.config.getUserId.bind(modules.config);\n         this.setUserId = modules.config.setUserId.bind(modules.config);\n         this.getFilterExpression = modules.config.getFilterExpression.bind(modules.config);\n         this.setFilterExpression = modules.config.setFilterExpression.bind(modules.config);\n+        // this.setCipherKey = modules.config.setCipherKey.bind(modules.config);\n+        this.setCipherKey = function (key) { return modules.config.setCipherKey(key, setup, modules); };\n         this.setHeartbeatInterval = modules.config.setHeartbeatInterval.bind(modules.config);\n         if (networking.hasModule('proxy')) {\n             this.setProxy = function (proxy) {"
        },
        {
            "filename": "lib/core/utils.js",
            "diff": "@@ -26,9 +26,18 @@ function createPromise() {\n     });\n     return { promise: promise, reject: failureResolve, fulfill: successResolve };\n }\n+function stringToArrayBuffer(str) {\n+    var buf = new ArrayBuffer(str.length * 2);\n+    var bufView = new Uint16Array(buf);\n+    for (var i = 0, strLen = str.length; i < strLen; i++) {\n+        bufView[i] = str.charCodeAt(i);\n+    }\n+    return buf;\n+}\n module.exports = {\n     signPamFromParams: signPamFromParams,\n     endsWith: endsWith,\n     createPromise: createPromise,\n     encodeString: encodeString,\n+    stringToArrayBuffer: stringToArrayBuffer,\n };"
        },
        {
            "filename": "lib/crypto/modules/NodeCryptoModule/ICryptor.js",
            "diff": "@@ -0,0 +1,2 @@\n+\"use strict\";\n+Object.defineProperty(exports, \"__esModule\", { value: true });"
        },
        {
            "filename": "lib/crypto/modules/NodeCryptoModule/ILegacyCryptor.js",
            "diff": "@@ -0,0 +1,2 @@\n+\"use strict\";\n+Object.defineProperty(exports, \"__esModule\", { value: true });"
        },
        {
            "filename": "lib/crypto/modules/NodeCryptoModule/NodeCryptoModule.js",
            "diff": "@@ -0,0 +1,446 @@\n+\"use strict\";\n+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n+    return new (P || (P = Promise))(function (resolve, reject) {\n+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n+        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n+        step((generator = generator.apply(thisArg, _arguments || [])).next());\n+    });\n+};\n+var __generator = (this && this.__generator) || function (thisArg, body) {\n+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n+    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n+    function verb(n) { return function (v) { return step([n, v]); }; }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while (_) try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [op[0] & 2, t.value];\n+            switch (op[0]) {\n+                case 0: case 1: t = op; break;\n+                case 4: _.label++; return { value: op[1], done: false };\n+                case 5: _.label++; y = op[1]; op = [0]; continue;\n+                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop(); continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n+    }\n+};\n+var __read = (this && this.__read) || function (o, n) {\n+    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n+    if (!m) return o;\n+    var i = m.call(o), r, ar = [], e;\n+    try {\n+        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n+    }\n+    catch (error) { e = { error: error }; }\n+    finally {\n+        try {\n+            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n+        }\n+        finally { if (e) throw e.error; }\n+    }\n+    return ar;\n+};\n+var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n+    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n+        if (ar || !(i in from)) {\n+            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n+            ar[i] = from[i];\n+        }\n+    }\n+    return to.concat(ar || Array.prototype.slice.call(from));\n+};\n+var __importDefault = (this && this.__importDefault) || function (mod) {\n+    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n+};\n+Object.defineProperty(exports, \"__esModule\", { value: true });\n+exports.CryptoModule = exports.AesCbcCryptor = exports.LegacyCryptor = void 0;\n+var stream_1 = require(\"stream\");\n+var base64_codec_1 = require(\"../../../core/components/base64_codec\");\n+var legacyCryptor_1 = __importDefault(require(\"./legacyCryptor\"));\n+exports.LegacyCryptor = legacyCryptor_1.default;\n+var aesCbcCryptor_1 = __importDefault(require(\"./aesCbcCryptor\"));\n+exports.AesCbcCryptor = aesCbcCryptor_1.default;\n+var CryptoModule = /** @class */ (function () {\n+    function CryptoModule(cryptoModuleConfiguration) {\n+        var _a;\n+        this.defaultCryptor = cryptoModuleConfiguration.default;\n+        this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];\n+    }\n+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+    // @ts-ignore: type detection issue with old Config type assignment\n+    CryptoModule.legacyCryptoModule = function (config) {\n+        var _a;\n+        return new this({\n+            default: new legacyCryptor_1.default({\n+                cipherKey: config.cipherKey,\n+                useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+            }),\n+            cryptors: [new aesCbcCryptor_1.default({ cipherKey: config.cipherKey })],\n+        });\n+    };\n+    CryptoModule.aesCbcCryptoModule = function (config) {\n+        var _a;\n+        return new this({\n+            default: new aesCbcCryptor_1.default({ cipherKey: config.cipherKey }),\n+            cryptors: [\n+                new legacyCryptor_1.default({\n+                    cipherKey: config.cipherKey,\n+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+                }),\n+            ],\n+        });\n+    };\n+    CryptoModule.withDefaultCryptor = function (defaultCryptor) {\n+        return new this({ default: defaultCryptor });\n+    };\n+    CryptoModule.prototype.getAllCryptors = function () {\n+        return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);\n+    };\n+    CryptoModule.prototype.getLegacyCryptor = function () {\n+        return this.getAllCryptors().find(function (c) { return c.identifier === ''; });\n+    };\n+    CryptoModule.prototype.encrypt = function (data) {\n+        var encrypted = this.defaultCryptor.encrypt(data);\n+        if (!encrypted.metadata)\n+            return encrypted.data;\n+        var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);\n+        var headerData = new Uint8Array(header.length);\n+        var pos = 0;\n+        headerData.set(header.data, pos);\n+        pos = header.length - encrypted.metadata.length;\n+        headerData.set(encrypted.metadata, pos);\n+        return Buffer.concat([headerData, Buffer.from(encrypted.data)]);\n+    };\n+    CryptoModule.prototype.decrypt = function (data) {\n+        var encryptedData = Buffer.from(typeof data === 'string' ? (0, base64_codec_1.decode)(data) : data);\n+        var header = CryptorHeader.tryParse(encryptedData);\n+        var cryptor = this.getCryptor(header);\n+        var metadata = header.length > 0\n+            ? encryptedData.slice(header.length - header.metadataLength, header.length)\n+            : null;\n+        if (encryptedData.slice(header.length).byteLength <= 0)\n+            throw new Error('decryption error. empty content');\n+        return cryptor.decrypt({\n+            data: encryptedData.slice(header.length),\n+            metadata: metadata,\n+        });\n+    };\n+    CryptoModule.prototype.encryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var encryptedStream, header, payload, pos, output;\n+            return __generator(this, function (_a) {\n+                switch (_a.label) {\n+                    case 0:\n+                        /**\n+                         * Files handled differently in case of Legacy cryptor.\n+                         * (as long as we support legacy need to check on intsance type)\n+                         */\n+                        if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)\n+                            return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];\n+                        if (file.data instanceof Buffer) {\n+                            return [2 /*return*/, File.create({\n+                                    name: file.name,\n+                                    mimeType: 'application/octet-stream',\n+                                    data: Buffer.from(this.encrypt(file.data)),\n+                                })];\n+                        }\n+                        if (!(file.data instanceof stream_1.Readable)) return [3 /*break*/, 2];\n+                        if (file.contentLength === 0)\n+                            throw new Error('encryption error. empty content');\n+                        return [4 /*yield*/, this.defaultCryptor.encryptStream(file.data)];\n+                    case 1:\n+                        encryptedStream = _a.sent();\n+                        header = CryptorHeader.from(this.defaultCryptor.identifier, encryptedStream.metadata);\n+                        payload = new Uint8Array(header.length);\n+                        pos = 0;\n+                        payload.set(header.data, pos);\n+                        pos += header.length;\n+                        if (encryptedStream.metadata) {\n+                            pos -= encryptedStream.metadata.length;\n+                            payload.set(encryptedStream.metadata, pos);\n+                        }\n+                        output = new stream_1.PassThrough();\n+                        output.write(payload);\n+                        encryptedStream.stream.pipe(output);\n+                        return [2 /*return*/, File.create({\n+                                name: file.name,\n+                                mimeType: 'application/octet-stream',\n+                                stream: output,\n+                            })];\n+                    case 2: return [2 /*return*/];\n+                }\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.decryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var header, cryptor, stream_2;\n+            var _this = this;\n+            return __generator(this, function (_a) {\n+                if ((file === null || file === void 0 ? void 0 : file.data) instanceof Buffer) {\n+                    header = CryptorHeader.tryParse(file.data);\n+                    cryptor = this.getCryptor(header);\n+                    /**\n+                     * If It's legacyone then redirect it.\n+                     * (as long as we support legacy need to check on instance type)\n+                     */\n+                    if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER)\n+                        return [2 /*return*/, cryptor.decryptFile(file, File)];\n+                    return [2 /*return*/, File.create({\n+                            name: file.name,\n+                            data: Buffer.from(this.decrypt(file === null || file === void 0 ? void 0 : file.data)),\n+                        })];\n+                }\n+                if (file.data instanceof stream_1.Readable) {\n+                    stream_2 = file.data;\n+                    return [2 /*return*/, new Promise(function (resolve) {\n+                            stream_2.on('readable', function () { return resolve(_this.onStreamReadable(stream_2, file, File)); });\n+                        })];\n+                }\n+                return [2 /*return*/];\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.onStreamReadable = function (stream, file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var magicBytes, versionByte, identifier, cryptor, headerSize, _a, _b;\n+            var _c;\n+            return __generator(this, function (_d) {\n+                switch (_d.label) {\n+                    case 0:\n+                        stream.removeAllListeners('readable');\n+                        magicBytes = stream.read(4);\n+                        if (!CryptorHeader.isSentinel(magicBytes)) {\n+                            if (magicBytes === null)\n+                                throw new Error('decryption error. empty content');\n+                            stream.unshift(magicBytes);\n+                            return [2 /*return*/, this.decryptLegacyFileStream(stream, file, File)];\n+                        }\n+                        versionByte = stream.read(1);\n+                        CryptorHeader.validateVersion(versionByte[0]);\n+                        identifier = stream.read(4);\n+                        cryptor = this.getCryptorFromId(CryptorHeader.tryGetIdentifier(identifier));\n+                        headerSize = CryptorHeader.tryGetMetadataSizeFromStream(stream);\n+                        if (file.contentLength <= CryptorHeader.MIN_HEADER_LEGTH + headerSize)\n+                            throw new Error('decryption error. empty content');\n+                        _b = (_a = File).create;\n+                        _c = {\n+                            name: file.name,\n+                            mimeType: 'application/octet-stream'\n+                        };\n+                        return [4 /*yield*/, cryptor.decryptStream({ stream: stream, metadataLength: headerSize })];\n+                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.stream = _d.sent(),\n+                                _c)])];\n+                }\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.decryptLegacyFileStream = function (stream, file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var cryptor;\n+            return __generator(this, function (_a) {\n+                if (file.contentLength <= 16)\n+                    throw new Error('decryption error: empty content');\n+                cryptor = this.getLegacyCryptor();\n+                if (cryptor) {\n+                    return [2 /*return*/, cryptor.decryptFile(File.create({\n+                            name: file.name,\n+                            stream: stream,\n+                        }), File)];\n+                }\n+                else {\n+                    throw new Error('unknown cryptor error');\n+                }\n+                return [2 /*return*/];\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.getCryptor = function (header) {\n+        if (header === '') {\n+            var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });\n+            if (cryptor)\n+                return cryptor;\n+            throw new Error('unknown cryptor error');\n+        }\n+        else if (header instanceof CryptorHeaderV1) {\n+            return this.getCryptorFromId(header.identifier);\n+        }\n+    };\n+    CryptoModule.prototype.getCryptorFromId = function (id) {\n+        var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });\n+        if (cryptor) {\n+            return cryptor;\n+        }\n+        throw new Error('unknown cryptor error');\n+    };\n+    CryptoModule.LEGACY_IDENTIFIER = '';\n+    return CryptoModule;\n+}());\n+exports.CryptoModule = CryptoModule;\n+// CryptorHeader Utility\n+var CryptorHeader = /** @class */ (function () {\n+    function CryptorHeader() {\n+    }\n+    CryptorHeader.from = function (id, metadata) {\n+        if (id === CryptorHeader.LEGACY_IDENTIFIER)\n+            return;\n+        return new CryptorHeaderV1(id, metadata.length);\n+    };\n+    CryptorHeader.isSentinel = function (bytes) {\n+        if (bytes && bytes.byteLength >= 4) {\n+            if (bytes.toString('utf8') == CryptorHeader.SENTINEL)\n+                return true;\n+        }\n+    };\n+    CryptorHeader.validateVersion = function (data) {\n+        if (data && data > CryptorHeader.MAX_VERSION)\n+            throw new Error('decryption error. invalid header version');\n+        return data;\n+    };\n+    CryptorHeader.tryGetIdentifier = function (data) {\n+        if (data.byteLength < 4) {\n+            throw new Error('unknown cryptor error. decryption failed');\n+        }\n+        else {\n+            return data.toString('utf8');\n+        }\n+    };\n+    CryptorHeader.tryGetMetadataSizeFromStream = function (stream) {\n+        var sizeBuf = stream.read(1);\n+        if (sizeBuf && sizeBuf[0] < 255) {\n+            return sizeBuf[0];\n+        }\n+        if (sizeBuf[0] === 255) {\n+            var nextBuf = stream.read(2);\n+            if (nextBuf.length >= 2) {\n+                return new Uint16Array([nextBuf[0], nextBuf[1]]).reduce(function (acc, val) { return (acc << 8) + val; }, 0);\n+            }\n+        }\n+        throw new Error('decryption error. Invalid metadata size');\n+    };\n+    CryptorHeader.tryParse = function (encryptedData) {\n+        var sentinel = '';\n+        var version = null;\n+        if (encryptedData.length >= 4) {\n+            sentinel = encryptedData.slice(0, 4);\n+            if (sentinel.toString('utf8') !== CryptorHeader.SENTINEL)\n+                return '';\n+        }\n+        if (encryptedData.length >= 5) {\n+            version = encryptedData[4];\n+        }\n+        else {\n+            throw new Error('decryption error. invalid header version');\n+        }\n+        if (version > CryptorHeader.MAX_VERSION)\n+            throw new Error('unknown cryptor error');\n+        var identifier;\n+        var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;\n+        if (encryptedData.length >= pos) {\n+            identifier = encryptedData.slice(5, pos);\n+        }\n+        else {\n+            throw new Error('decryption error. invalid crypto identifier');\n+        }\n+        var metadataLength = null;\n+        if (encryptedData.length >= pos + 1) {\n+            metadataLength = encryptedData[pos];\n+        }\n+        else {\n+            throw new Error('decryption error. invalid metadata length');\n+        }\n+        pos += 1;\n+        if (metadataLength === 255 && encryptedData.length >= pos + 2) {\n+            metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);\n+            pos += 2;\n+        }\n+        return new CryptorHeaderV1(identifier.toString('utf8'), metadataLength);\n+    };\n+    CryptorHeader.SENTINEL = 'PNED';\n+    CryptorHeader.LEGACY_IDENTIFIER = '';\n+    CryptorHeader.IDENTIFIER_LENGTH = 4;\n+    CryptorHeader.VERSION = 1;\n+    CryptorHeader.MAX_VERSION = 1;\n+    CryptorHeader.MIN_HEADER_LEGTH = 10;\n+    return CryptorHeader;\n+}());\n+// v1 CryptorHeader\n+var CryptorHeaderV1 = /** @class */ (function () {\n+    function CryptorHeaderV1(id, metadataLength) {\n+        this._identifier = id;\n+        this._metadataLength = metadataLength;\n+    }\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"identifier\", {\n+        get: function () {\n+            return this._identifier;\n+        },\n+        set: function (value) {\n+            this._identifier = value;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"metadataLength\", {\n+        get: function () {\n+            return this._metadataLength;\n+        },\n+        set: function (value) {\n+            this._metadataLength = value;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"version\", {\n+        get: function () {\n+            return CryptorHeader.VERSION;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"length\", {\n+        get: function () {\n+            return (CryptorHeader.SENTINEL.length +\n+                1 +\n+                CryptorHeader.IDENTIFIER_LENGTH +\n+                (this.metadataLength < 255 ? 1 : 3) +\n+                this.metadataLength);\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"data\", {\n+        get: function () {\n+            var pos = 0;\n+            var header = new Uint8Array(this.length);\n+            header.set(Buffer.from(CryptorHeader.SENTINEL));\n+            pos += CryptorHeader.SENTINEL.length;\n+            header[pos] = this.version;\n+            pos++;\n+            if (this.identifier)\n+                header.set(Buffer.from(this.identifier), pos);\n+            pos += CryptorHeader.IDENTIFIER_LENGTH;\n+            var metadataLength = this.metadataLength;\n+            if (metadataLength < 255) {\n+                header[pos] = metadataLength;\n+            }\n+            else {\n+                header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);\n+            }\n+            return header;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    return CryptorHeaderV1;\n+}());"
        },
        {
            "filename": "lib/crypto/modules/NodeCryptoModule/aesCbcCryptor.js",
            "diff": "@@ -0,0 +1,146 @@\n+\"use strict\";\n+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n+    return new (P || (P = Promise))(function (resolve, reject) {\n+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n+        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n+        step((generator = generator.apply(thisArg, _arguments || [])).next());\n+    });\n+};\n+var __generator = (this && this.__generator) || function (thisArg, body) {\n+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n+    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n+    function verb(n) { return function (v) { return step([n, v]); }; }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while (_) try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [op[0] & 2, t.value];\n+            switch (op[0]) {\n+                case 0: case 1: t = op; break;\n+                case 4: _.label++; return { value: op[1], done: false };\n+                case 5: _.label++; y = op[1]; op = [0]; continue;\n+                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop(); continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n+    }\n+};\n+Object.defineProperty(exports, \"__esModule\", { value: true });\n+var stream_1 = require(\"stream\");\n+var crypto_1 = require(\"crypto\");\n+var AesCbcCryptor = /** @class */ (function () {\n+    function AesCbcCryptor(configuration) {\n+        this.cipherKey = configuration.cipherKey;\n+    }\n+    Object.defineProperty(AesCbcCryptor.prototype, \"algo\", {\n+        get: function () {\n+            return 'aes-256-cbc';\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(AesCbcCryptor.prototype, \"identifier\", {\n+        get: function () {\n+            return 'ACRH';\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    AesCbcCryptor.prototype.getIv = function () {\n+        return (0, crypto_1.randomBytes)(AesCbcCryptor.BLOCK_SIZE);\n+    };\n+    AesCbcCryptor.prototype.getKey = function () {\n+        var sha = (0, crypto_1.createHash)('sha256');\n+        sha.update(Buffer.from(this.cipherKey, 'utf8'));\n+        return Buffer.from(sha.digest());\n+    };\n+    AesCbcCryptor.prototype.encrypt = function (data) {\n+        var iv = this.getIv();\n+        var key = this.getKey();\n+        var plainData = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n+        var bPlain = Buffer.from(plainData);\n+        if (bPlain.byteLength === 0)\n+            throw new Error('encryption error. empty content');\n+        var aes = (0, crypto_1.createCipheriv)(this.algo, key, iv);\n+        return {\n+            metadata: iv,\n+            data: Buffer.concat([aes.update(bPlain), aes.final()]),\n+        };\n+    };\n+    AesCbcCryptor.prototype.decrypt = function (encryptedData) {\n+        var data = typeof encryptedData.data === 'string' ? new TextEncoder().encode(encryptedData.data) : encryptedData.data;\n+        if (data.byteLength <= 0)\n+            throw new Error('decryption error: empty content');\n+        var aes = (0, crypto_1.createDecipheriv)(this.algo, this.getKey(), encryptedData.metadata);\n+        return Uint8Array.from(Buffer.concat([aes.update(data), aes.final()])).buffer;\n+    };\n+    AesCbcCryptor.prototype.encryptStream = function (stream) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var output, bIv, aes;\n+            return __generator(this, function (_a) {\n+                output = new stream_1.PassThrough();\n+                bIv = this.getIv();\n+                if (stream.readable === false)\n+                    throw new Error('encryption error. empty stream');\n+                aes = (0, crypto_1.createCipheriv)(this.algo, this.getKey(), bIv);\n+                stream.pipe(aes).pipe(output);\n+                return [2 /*return*/, {\n+                        stream: output,\n+                        metadata: bIv,\n+                        metadataLength: AesCbcCryptor.BLOCK_SIZE,\n+                    }];\n+            });\n+        });\n+    };\n+    AesCbcCryptor.prototype.decryptStream = function (encryptedStream) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var decryptedStream, bIv, aes, onReadable;\n+            var _this = this;\n+            return __generator(this, function (_a) {\n+                decryptedStream = new stream_1.PassThrough();\n+                bIv = Buffer.alloc(0);\n+                aes = null;\n+                onReadable = function () {\n+                    var data = encryptedStream.stream.read();\n+                    while (data !== null) {\n+                        if (data) {\n+                            var bChunk = Buffer.from(data);\n+                            var sliceLen = encryptedStream.metadataLength - bIv.byteLength;\n+                            if (bChunk.byteLength < sliceLen) {\n+                                bIv = Buffer.concat([bIv, bChunk]);\n+                            }\n+                            else {\n+                                bIv = Buffer.concat([bIv, bChunk.slice(0, sliceLen)]);\n+                                aes = (0, crypto_1.createDecipheriv)(_this.algo, _this.getKey(), bIv);\n+                                aes.pipe(decryptedStream);\n+                                aes.write(bChunk.slice(sliceLen));\n+                            }\n+                        }\n+                        data = encryptedStream.stream.read();\n+                    }\n+                };\n+                encryptedStream.stream.on('readable', onReadable);\n+                encryptedStream.stream.on('end', function () {\n+                    if (aes) {\n+                        aes.end();\n+                    }\n+                    decryptedStream.end();\n+                });\n+                return [2 /*return*/, decryptedStream];\n+            });\n+        });\n+    };\n+    AesCbcCryptor.BLOCK_SIZE = 16;\n+    return AesCbcCryptor;\n+}());\n+exports.default = AesCbcCryptor;"
        },
        {
            "filename": "lib/crypto/modules/NodeCryptoModule/legacyCryptor.js",
            "diff": "@@ -0,0 +1,86 @@\n+\"use strict\";\n+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n+    return new (P || (P = Promise))(function (resolve, reject) {\n+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n+        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n+        step((generator = generator.apply(thisArg, _arguments || [])).next());\n+    });\n+};\n+var __generator = (this && this.__generator) || function (thisArg, body) {\n+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n+    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n+    function verb(n) { return function (v) { return step([n, v]); }; }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while (_) try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [op[0] & 2, t.value];\n+            switch (op[0]) {\n+                case 0: case 1: t = op; break;\n+                case 4: _.label++; return { value: op[1], done: false };\n+                case 5: _.label++; y = op[1]; op = [0]; continue;\n+                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop(); continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n+    }\n+};\n+var __importDefault = (this && this.__importDefault) || function (mod) {\n+    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n+};\n+Object.defineProperty(exports, \"__esModule\", { value: true });\n+var index_1 = __importDefault(require(\"../../../core/components/cryptography/index\"));\n+var base64_codec_1 = require(\"../../../core/components/base64_codec\");\n+var node_1 = __importDefault(require(\"../node\"));\n+var LegacyCryptor = /** @class */ (function () {\n+    function LegacyCryptor(config) {\n+        this.config = config;\n+        this.cryptor = new index_1.default({ config: config });\n+        this.fileCryptor = new node_1.default();\n+    }\n+    Object.defineProperty(LegacyCryptor.prototype, \"identifier\", {\n+        get: function () {\n+            return '';\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    LegacyCryptor.prototype.encrypt = function (data) {\n+        if (data.length === 0)\n+            throw new Error('encryption error. empty content');\n+        return {\n+            data: this.cryptor.encrypt(data),\n+            metadata: null,\n+        };\n+    };\n+    LegacyCryptor.prototype.decrypt = function (encryptedData) {\n+        var data = typeof encryptedData.data === 'string' ? encryptedData.data : (0, base64_codec_1.encode)(encryptedData.data);\n+        return this.cryptor.decrypt(data);\n+    };\n+    LegacyCryptor.prototype.encryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            return __generator(this, function (_a) {\n+                return [2 /*return*/, this.fileCryptor.encryptFile(this.config.cipherKey, file, File)];\n+            });\n+        });\n+    };\n+    LegacyCryptor.prototype.decryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            return __generator(this, function (_a) {\n+                return [2 /*return*/, this.fileCryptor.decryptFile(this.config.cipherKey, file, File)];\n+            });\n+        });\n+    };\n+    return LegacyCryptor;\n+}());\n+exports.default = LegacyCryptor;"
        },
        {
            "filename": "lib/crypto/modules/NodeCryptoModule/nodeCryptoModule.js",
            "diff": "@@ -0,0 +1,446 @@\n+\"use strict\";\n+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n+    return new (P || (P = Promise))(function (resolve, reject) {\n+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n+        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n+        step((generator = generator.apply(thisArg, _arguments || [])).next());\n+    });\n+};\n+var __generator = (this && this.__generator) || function (thisArg, body) {\n+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n+    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n+    function verb(n) { return function (v) { return step([n, v]); }; }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while (_) try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [op[0] & 2, t.value];\n+            switch (op[0]) {\n+                case 0: case 1: t = op; break;\n+                case 4: _.label++; return { value: op[1], done: false };\n+                case 5: _.label++; y = op[1]; op = [0]; continue;\n+                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop(); continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n+    }\n+};\n+var __read = (this && this.__read) || function (o, n) {\n+    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n+    if (!m) return o;\n+    var i = m.call(o), r, ar = [], e;\n+    try {\n+        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n+    }\n+    catch (error) { e = { error: error }; }\n+    finally {\n+        try {\n+            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n+        }\n+        finally { if (e) throw e.error; }\n+    }\n+    return ar;\n+};\n+var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n+    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n+        if (ar || !(i in from)) {\n+            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n+            ar[i] = from[i];\n+        }\n+    }\n+    return to.concat(ar || Array.prototype.slice.call(from));\n+};\n+var __importDefault = (this && this.__importDefault) || function (mod) {\n+    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n+};\n+Object.defineProperty(exports, \"__esModule\", { value: true });\n+exports.CryptoModule = exports.AesCbcCryptor = exports.LegacyCryptor = void 0;\n+var stream_1 = require(\"stream\");\n+var base64_codec_1 = require(\"../../../core/components/base64_codec\");\n+var legacyCryptor_1 = __importDefault(require(\"./legacyCryptor\"));\n+exports.LegacyCryptor = legacyCryptor_1.default;\n+var aesCbcCryptor_1 = __importDefault(require(\"./aesCbcCryptor\"));\n+exports.AesCbcCryptor = aesCbcCryptor_1.default;\n+var CryptoModule = /** @class */ (function () {\n+    function CryptoModule(cryptoModuleConfiguration) {\n+        var _a;\n+        this.defaultCryptor = cryptoModuleConfiguration.default;\n+        this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];\n+    }\n+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+    // @ts-ignore: type detection issue with old Config type assignment\n+    CryptoModule.legacyCryptoModule = function (config) {\n+        var _a;\n+        return new this({\n+            default: new legacyCryptor_1.default({\n+                cipherKey: config.cipherKey,\n+                useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+            }),\n+            cryptors: [new aesCbcCryptor_1.default({ cipherKey: config.cipherKey })],\n+        });\n+    };\n+    CryptoModule.aesCbcCryptoModule = function (config) {\n+        var _a;\n+        return new this({\n+            default: new aesCbcCryptor_1.default({ cipherKey: config.cipherKey }),\n+            cryptors: [\n+                new legacyCryptor_1.default({\n+                    cipherKey: config.cipherKey,\n+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+                }),\n+            ],\n+        });\n+    };\n+    CryptoModule.withDefaultCryptor = function (defaultCryptor) {\n+        return new this({ default: defaultCryptor });\n+    };\n+    CryptoModule.prototype.getAllCryptors = function () {\n+        return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);\n+    };\n+    CryptoModule.prototype.getLegacyCryptor = function () {\n+        return this.getAllCryptors().find(function (c) { return c.identifier === ''; });\n+    };\n+    CryptoModule.prototype.encrypt = function (data) {\n+        var encrypted = this.defaultCryptor.encrypt(data);\n+        if (!encrypted.metadata)\n+            return encrypted.data;\n+        var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);\n+        var headerData = new Uint8Array(header.length);\n+        var pos = 0;\n+        headerData.set(header.data, pos);\n+        pos = header.length - encrypted.metadata.length;\n+        headerData.set(encrypted.metadata, pos);\n+        return Buffer.concat([headerData, Buffer.from(encrypted.data)]);\n+    };\n+    CryptoModule.prototype.decrypt = function (data) {\n+        var encryptedData = Buffer.from(typeof data === 'string' ? (0, base64_codec_1.decode)(data) : data);\n+        var header = CryptorHeader.tryParse(encryptedData);\n+        var cryptor = this.getCryptor(header);\n+        var metadata = header.length > 0\n+            ? encryptedData.slice(header.length - header.metadataLength, header.length)\n+            : null;\n+        if (encryptedData.slice(header.length).byteLength <= 0)\n+            throw new Error('decryption error. empty content');\n+        return cryptor.decrypt({\n+            data: encryptedData.slice(header.length),\n+            metadata: metadata,\n+        });\n+    };\n+    CryptoModule.prototype.encryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var encryptedStream, header, payload, pos, output;\n+            return __generator(this, function (_a) {\n+                switch (_a.label) {\n+                    case 0:\n+                        /**\n+                         * Files handled differently in case of Legacy cryptor.\n+                         * (as long as we support legacy need to check on intsance type)\n+                         */\n+                        if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)\n+                            return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];\n+                        if (file.data instanceof Buffer) {\n+                            return [2 /*return*/, File.create({\n+                                    name: file.name,\n+                                    mimeType: 'application/octet-stream',\n+                                    data: Buffer.from(this.encrypt(file.data)),\n+                                })];\n+                        }\n+                        if (!(file.data instanceof stream_1.Readable)) return [3 /*break*/, 2];\n+                        if (file.contentLength === 0)\n+                            throw new Error('encryption error. empty content');\n+                        return [4 /*yield*/, this.defaultCryptor.encryptStream(file.data)];\n+                    case 1:\n+                        encryptedStream = _a.sent();\n+                        header = CryptorHeader.from(this.defaultCryptor.identifier, encryptedStream.metadata);\n+                        payload = new Uint8Array(header.length);\n+                        pos = 0;\n+                        payload.set(header.data, pos);\n+                        pos += header.length;\n+                        if (encryptedStream.metadata) {\n+                            pos -= encryptedStream.metadata.length;\n+                            payload.set(encryptedStream.metadata, pos);\n+                        }\n+                        output = new stream_1.PassThrough();\n+                        output.write(payload);\n+                        encryptedStream.stream.pipe(output);\n+                        return [2 /*return*/, File.create({\n+                                name: file.name,\n+                                mimeType: 'application/octet-stream',\n+                                stream: output,\n+                            })];\n+                    case 2: return [2 /*return*/];\n+                }\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.decryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var header, cryptor, stream_2;\n+            var _this = this;\n+            return __generator(this, function (_a) {\n+                if ((file === null || file === void 0 ? void 0 : file.data) instanceof Buffer) {\n+                    header = CryptorHeader.tryParse(file.data);\n+                    cryptor = this.getCryptor(header);\n+                    /**\n+                     * If It's legacyone then redirect it.\n+                     * (as long as we support legacy need to check on instance type)\n+                     */\n+                    if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER)\n+                        return [2 /*return*/, cryptor.decryptFile(file, File)];\n+                    return [2 /*return*/, File.create({\n+                            name: file.name,\n+                            data: Buffer.from(this.decrypt(file === null || file === void 0 ? void 0 : file.data)),\n+                        })];\n+                }\n+                if (file.data instanceof stream_1.Readable) {\n+                    stream_2 = file.data;\n+                    return [2 /*return*/, new Promise(function (resolve) {\n+                            stream_2.on('readable', function () { return resolve(_this.onStreamReadable(stream_2, file, File)); });\n+                        })];\n+                }\n+                return [2 /*return*/];\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.onStreamReadable = function (stream, file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var magicBytes, versionByte, identifier, cryptor, headerSize, _a, _b;\n+            var _c;\n+            return __generator(this, function (_d) {\n+                switch (_d.label) {\n+                    case 0:\n+                        stream.removeAllListeners('readable');\n+                        magicBytes = stream.read(4);\n+                        if (!CryptorHeader.isSentinel(magicBytes)) {\n+                            if (magicBytes === null)\n+                                throw new Error('decryption error. empty content');\n+                            stream.unshift(magicBytes);\n+                            return [2 /*return*/, this.decryptLegacyFileStream(stream, file, File)];\n+                        }\n+                        versionByte = stream.read(1);\n+                        CryptorHeader.validateVersion(versionByte[0]);\n+                        identifier = stream.read(4);\n+                        cryptor = this.getCryptorFromId(CryptorHeader.tryGetIdentifier(identifier));\n+                        headerSize = CryptorHeader.tryGetMetadataSizeFromStream(stream);\n+                        if (file.contentLength <= CryptorHeader.MIN_HEADER_LEGTH + headerSize)\n+                            throw new Error('decryption error. empty content');\n+                        _b = (_a = File).create;\n+                        _c = {\n+                            name: file.name,\n+                            mimeType: 'application/octet-stream'\n+                        };\n+                        return [4 /*yield*/, cryptor.decryptStream({ stream: stream, metadataLength: headerSize })];\n+                    case 1: return [2 /*return*/, _b.apply(_a, [(_c.stream = _d.sent(),\n+                                _c)])];\n+                }\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.decryptLegacyFileStream = function (stream, file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var cryptor;\n+            return __generator(this, function (_a) {\n+                if (file.contentLength <= 16)\n+                    throw new Error('decryption error: empty content');\n+                cryptor = this.getLegacyCryptor();\n+                if (cryptor) {\n+                    return [2 /*return*/, cryptor.decryptFile(File.create({\n+                            name: file.name,\n+                            stream: stream,\n+                        }), File)];\n+                }\n+                else {\n+                    throw new Error('unknown cryptor error');\n+                }\n+                return [2 /*return*/];\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.getCryptor = function (header) {\n+        if (header === '') {\n+            var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });\n+            if (cryptor)\n+                return cryptor;\n+            throw new Error('unknown cryptor error');\n+        }\n+        else if (header instanceof CryptorHeaderV1) {\n+            return this.getCryptorFromId(header.identifier);\n+        }\n+    };\n+    CryptoModule.prototype.getCryptorFromId = function (id) {\n+        var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });\n+        if (cryptor) {\n+            return cryptor;\n+        }\n+        throw new Error('unknown cryptor error');\n+    };\n+    CryptoModule.LEGACY_IDENTIFIER = '';\n+    return CryptoModule;\n+}());\n+exports.CryptoModule = CryptoModule;\n+// CryptorHeader Utility\n+var CryptorHeader = /** @class */ (function () {\n+    function CryptorHeader() {\n+    }\n+    CryptorHeader.from = function (id, metadata) {\n+        if (id === CryptorHeader.LEGACY_IDENTIFIER)\n+            return;\n+        return new CryptorHeaderV1(id, metadata.length);\n+    };\n+    CryptorHeader.isSentinel = function (bytes) {\n+        if (bytes && bytes.byteLength >= 4) {\n+            if (bytes.toString('utf8') == CryptorHeader.SENTINEL)\n+                return true;\n+        }\n+    };\n+    CryptorHeader.validateVersion = function (data) {\n+        if (data && data > CryptorHeader.MAX_VERSION)\n+            throw new Error('decryption error. invalid header version');\n+        return data;\n+    };\n+    CryptorHeader.tryGetIdentifier = function (data) {\n+        if (data.byteLength < 4) {\n+            throw new Error('unknown cryptor error. decryption failed');\n+        }\n+        else {\n+            return data.toString('utf8');\n+        }\n+    };\n+    CryptorHeader.tryGetMetadataSizeFromStream = function (stream) {\n+        var sizeBuf = stream.read(1);\n+        if (sizeBuf && sizeBuf[0] < 255) {\n+            return sizeBuf[0];\n+        }\n+        if (sizeBuf[0] === 255) {\n+            var nextBuf = stream.read(2);\n+            if (nextBuf.length >= 2) {\n+                return new Uint16Array([nextBuf[0], nextBuf[1]]).reduce(function (acc, val) { return (acc << 8) + val; }, 0);\n+            }\n+        }\n+        throw new Error('decryption error. Invalid metadata size');\n+    };\n+    CryptorHeader.tryParse = function (encryptedData) {\n+        var sentinel = '';\n+        var version = null;\n+        if (encryptedData.length >= 4) {\n+            sentinel = encryptedData.slice(0, 4);\n+            if (sentinel.toString('utf8') !== CryptorHeader.SENTINEL)\n+                return '';\n+        }\n+        if (encryptedData.length >= 5) {\n+            version = encryptedData[4];\n+        }\n+        else {\n+            throw new Error('decryption error. invalid header version');\n+        }\n+        if (version > CryptorHeader.MAX_VERSION)\n+            throw new Error('unknown cryptor error');\n+        var identifier;\n+        var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;\n+        if (encryptedData.length >= pos) {\n+            identifier = encryptedData.slice(5, pos);\n+        }\n+        else {\n+            throw new Error('decryption error. invalid crypto identifier');\n+        }\n+        var metadataLength = null;\n+        if (encryptedData.length >= pos + 1) {\n+            metadataLength = encryptedData[pos];\n+        }\n+        else {\n+            throw new Error('decryption error. invalid metadata length');\n+        }\n+        pos += 1;\n+        if (metadataLength === 255 && encryptedData.length >= pos + 2) {\n+            metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);\n+            pos += 2;\n+        }\n+        return new CryptorHeaderV1(identifier.toString('utf8'), metadataLength);\n+    };\n+    CryptorHeader.SENTINEL = 'PNED';\n+    CryptorHeader.LEGACY_IDENTIFIER = '';\n+    CryptorHeader.IDENTIFIER_LENGTH = 4;\n+    CryptorHeader.VERSION = 1;\n+    CryptorHeader.MAX_VERSION = 1;\n+    CryptorHeader.MIN_HEADER_LEGTH = 10;\n+    return CryptorHeader;\n+}());\n+// v1 CryptorHeader\n+var CryptorHeaderV1 = /** @class */ (function () {\n+    function CryptorHeaderV1(id, metadataLength) {\n+        this._identifier = id;\n+        this._metadataLength = metadataLength;\n+    }\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"identifier\", {\n+        get: function () {\n+            return this._identifier;\n+        },\n+        set: function (value) {\n+            this._identifier = value;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"metadataLength\", {\n+        get: function () {\n+            return this._metadataLength;\n+        },\n+        set: function (value) {\n+            this._metadataLength = value;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"version\", {\n+        get: function () {\n+            return CryptorHeader.VERSION;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"length\", {\n+        get: function () {\n+            return (CryptorHeader.SENTINEL.length +\n+                1 +\n+                CryptorHeader.IDENTIFIER_LENGTH +\n+                (this.metadataLength < 255 ? 1 : 3) +\n+                this.metadataLength);\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"data\", {\n+        get: function () {\n+            var pos = 0;\n+            var header = new Uint8Array(this.length);\n+            header.set(Buffer.from(CryptorHeader.SENTINEL));\n+            pos += CryptorHeader.SENTINEL.length;\n+            header[pos] = this.version;\n+            pos++;\n+            if (this.identifier)\n+                header.set(Buffer.from(this.identifier), pos);\n+            pos += CryptorHeader.IDENTIFIER_LENGTH;\n+            var metadataLength = this.metadataLength;\n+            if (metadataLength < 255) {\n+                header[pos] = metadataLength;\n+            }\n+            else {\n+                header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);\n+            }\n+            return header;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    return CryptorHeaderV1;\n+}());"
        },
        {
            "filename": "lib/crypto/modules/WebCryptoModule/ICryptor.js",
            "diff": "@@ -0,0 +1,2 @@\n+\"use strict\";\n+Object.defineProperty(exports, \"__esModule\", { value: true });"
        },
        {
            "filename": "lib/crypto/modules/WebCryptoModule/ILegacyCryptor.js",
            "diff": "@@ -0,0 +1,2 @@\n+\"use strict\";\n+Object.defineProperty(exports, \"__esModule\", { value: true });"
        },
        {
            "filename": "lib/crypto/modules/WebCryptoModule/aesCbcCryptor.js",
            "diff": "@@ -0,0 +1,148 @@\n+\"use strict\";\n+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n+    return new (P || (P = Promise))(function (resolve, reject) {\n+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n+        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n+        step((generator = generator.apply(thisArg, _arguments || [])).next());\n+    });\n+};\n+var __generator = (this && this.__generator) || function (thisArg, body) {\n+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n+    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n+    function verb(n) { return function (v) { return step([n, v]); }; }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while (_) try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [op[0] & 2, t.value];\n+            switch (op[0]) {\n+                case 0: case 1: t = op; break;\n+                case 4: _.label++; return { value: op[1], done: false };\n+                case 5: _.label++; y = op[1]; op = [0]; continue;\n+                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop(); continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n+    }\n+};\n+var __importDefault = (this && this.__importDefault) || function (mod) {\n+    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n+};\n+Object.defineProperty(exports, \"__esModule\", { value: true });\n+var hmac_sha256_1 = __importDefault(require(\"../../../core/components/cryptography/hmac-sha256\"));\n+var base64_codec_1 = require(\"../../../core/components/base64_codec\");\n+var AesCbcCryptor = /** @class */ (function () {\n+    function AesCbcCryptor(configuration) {\n+        this.cipherKey = configuration.cipherKey;\n+        this.CryptoJS = hmac_sha256_1.default;\n+        this.encryptedKey = this.CryptoJS.SHA256(this.cipherKey);\n+    }\n+    Object.defineProperty(AesCbcCryptor.prototype, \"algo\", {\n+        get: function () {\n+            return 'AES-CBC';\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(AesCbcCryptor.prototype, \"identifier\", {\n+        get: function () {\n+            return 'ACRH';\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    AesCbcCryptor.prototype.getIv = function () {\n+        return crypto.getRandomValues(new Uint8Array(AesCbcCryptor.BLOCK_SIZE));\n+    };\n+    AesCbcCryptor.prototype.getKey = function () {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var bKey, abHash;\n+            return __generator(this, function (_a) {\n+                switch (_a.label) {\n+                    case 0:\n+                        bKey = AesCbcCryptor.encoder.encode(this.cipherKey);\n+                        return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];\n+                    case 1:\n+                        abHash = _a.sent();\n+                        return [2 /*return*/, crypto.subtle.importKey('raw', abHash, this.algo, true, ['encrypt', 'decrypt'])];\n+                }\n+            });\n+        });\n+    };\n+    AesCbcCryptor.prototype.encrypt = function (data) {\n+        var stringData = typeof data === 'string' ? data : AesCbcCryptor.decoder.decode(data);\n+        if (stringData.length === 0)\n+            throw new Error('encryption error. empty content');\n+        var abIv = this.getIv();\n+        return {\n+            metadata: abIv,\n+            data: (0, base64_codec_1.decode)(this.CryptoJS.AES.encrypt(data, this.encryptedKey, {\n+                iv: this.bufferToWordArray(abIv),\n+                mode: this.CryptoJS.mode.CBC,\n+            }).ciphertext.toString(this.CryptoJS.enc.Base64)),\n+        };\n+    };\n+    AesCbcCryptor.prototype.decrypt = function (encryptedData) {\n+        var iv = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.metadata));\n+        var data = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.data));\n+        return AesCbcCryptor.encoder.encode(this.CryptoJS.AES.decrypt({ ciphertext: data }, this.encryptedKey, {\n+            iv: iv,\n+            mode: this.CryptoJS.mode.CBC,\n+        }).toString(this.CryptoJS.enc.Utf8)).buffer;\n+    };\n+    AesCbcCryptor.prototype.encryptFileData = function (data) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var key, iv;\n+            var _a;\n+            return __generator(this, function (_b) {\n+                switch (_b.label) {\n+                    case 0: return [4 /*yield*/, this.getKey()];\n+                    case 1:\n+                        key = _b.sent();\n+                        iv = this.getIv();\n+                        _a = {};\n+                        return [4 /*yield*/, crypto.subtle.encrypt({ name: this.algo, iv: iv }, key, data)];\n+                    case 2: return [2 /*return*/, (_a.data = _b.sent(),\n+                            _a.metadata = iv,\n+                            _a)];\n+                }\n+            });\n+        });\n+    };\n+    AesCbcCryptor.prototype.decryptFileData = function (encryptedData) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var key;\n+            return __generator(this, function (_a) {\n+                switch (_a.label) {\n+                    case 0: return [4 /*yield*/, this.getKey()];\n+                    case 1:\n+                        key = _a.sent();\n+                        return [2 /*return*/, crypto.subtle.decrypt({ name: this.algo, iv: encryptedData.metadata }, key, encryptedData.data)];\n+                }\n+            });\n+        });\n+    };\n+    AesCbcCryptor.prototype.bufferToWordArray = function (b) {\n+        var wa = [];\n+        var i;\n+        for (i = 0; i < b.length; i += 1) {\n+            wa[(i / 4) | 0] |= b[i] << (24 - 8 * i);\n+        }\n+        return this.CryptoJS.lib.WordArray.create(wa, b.length);\n+    };\n+    AesCbcCryptor.BLOCK_SIZE = 16;\n+    AesCbcCryptor.encoder = new TextEncoder();\n+    AesCbcCryptor.decoder = new TextDecoder();\n+    return AesCbcCryptor;\n+}());\n+exports.default = AesCbcCryptor;"
        },
        {
            "filename": "lib/crypto/modules/WebCryptoModule/legacyCryptor.js",
            "diff": "@@ -0,0 +1,90 @@\n+\"use strict\";\n+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n+    return new (P || (P = Promise))(function (resolve, reject) {\n+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n+        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n+        step((generator = generator.apply(thisArg, _arguments || [])).next());\n+    });\n+};\n+var __generator = (this && this.__generator) || function (thisArg, body) {\n+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n+    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n+    function verb(n) { return function (v) { return step([n, v]); }; }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while (_) try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [op[0] & 2, t.value];\n+            switch (op[0]) {\n+                case 0: case 1: t = op; break;\n+                case 4: _.label++; return { value: op[1], done: false };\n+                case 5: _.label++; y = op[1]; op = [0]; continue;\n+                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop(); continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n+    }\n+};\n+var __importDefault = (this && this.__importDefault) || function (mod) {\n+    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n+};\n+Object.defineProperty(exports, \"__esModule\", { value: true });\n+var index_1 = __importDefault(require(\"../../../core/components/cryptography/index\"));\n+var web_1 = __importDefault(require(\"../web\"));\n+var base64_codec_1 = require(\"../../../core/components/base64_codec\");\n+var LegacyCryptor = /** @class */ (function () {\n+    function LegacyCryptor(config) {\n+        this.config = config;\n+        this.cryptor = new index_1.default({ config: config });\n+        this.fileCryptor = new web_1.default();\n+    }\n+    Object.defineProperty(LegacyCryptor.prototype, \"identifier\", {\n+        get: function () {\n+            return '';\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    LegacyCryptor.prototype.encrypt = function (data) {\n+        var stringData = typeof data === 'string' ? data : new TextDecoder().decode(data);\n+        return {\n+            data: this.cryptor.encrypt(stringData),\n+            metadata: null,\n+        };\n+    };\n+    LegacyCryptor.prototype.decrypt = function (encryptedData) {\n+        var data = typeof encryptedData.data === 'string' ? encryptedData.data : (0, base64_codec_1.encode)(encryptedData.data);\n+        return this.cryptor.decrypt(data);\n+    };\n+    LegacyCryptor.prototype.encryptFile = function (file, File) {\n+        var _a;\n+        return __awaiter(this, void 0, void 0, function () {\n+            return __generator(this, function (_b) {\n+                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+                //@ts-ignore: can not detect cipherKey from old Config\n+                return [2 /*return*/, this.fileCryptor.encryptFile((_a = this.config) === null || _a === void 0 ? void 0 : _a.cipherKey, file, File)];\n+            });\n+        });\n+    };\n+    LegacyCryptor.prototype.decryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            return __generator(this, function (_a) {\n+                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+                //@ts-ignore: can not detect cipherKey from old Config\n+                return [2 /*return*/, this.fileCryptor.decryptFile(this.config.cipherKey, file, File)];\n+            });\n+        });\n+    };\n+    return LegacyCryptor;\n+}());\n+exports.default = LegacyCryptor;"
        },
        {
            "filename": "lib/crypto/modules/WebCryptoModule/webCryptoModule.js",
            "diff": "@@ -0,0 +1,358 @@\n+\"use strict\";\n+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n+    return new (P || (P = Promise))(function (resolve, reject) {\n+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n+        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n+        step((generator = generator.apply(thisArg, _arguments || [])).next());\n+    });\n+};\n+var __generator = (this && this.__generator) || function (thisArg, body) {\n+    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n+    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n+    function verb(n) { return function (v) { return step([n, v]); }; }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while (_) try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [op[0] & 2, t.value];\n+            switch (op[0]) {\n+                case 0: case 1: t = op; break;\n+                case 4: _.label++; return { value: op[1], done: false };\n+                case 5: _.label++; y = op[1]; op = [0]; continue;\n+                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n+                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n+                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n+                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop(); continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n+        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n+    }\n+};\n+var __read = (this && this.__read) || function (o, n) {\n+    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n+    if (!m) return o;\n+    var i = m.call(o), r, ar = [], e;\n+    try {\n+        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n+    }\n+    catch (error) { e = { error: error }; }\n+    finally {\n+        try {\n+            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n+        }\n+        finally { if (e) throw e.error; }\n+    }\n+    return ar;\n+};\n+var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n+    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n+        if (ar || !(i in from)) {\n+            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n+            ar[i] = from[i];\n+        }\n+    }\n+    return to.concat(ar || Array.prototype.slice.call(from));\n+};\n+var __importDefault = (this && this.__importDefault) || function (mod) {\n+    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n+};\n+Object.defineProperty(exports, \"__esModule\", { value: true });\n+exports.CryptoModule = exports.AesCbcCryptor = exports.LegacyCryptor = void 0;\n+var legacyCryptor_1 = __importDefault(require(\"./legacyCryptor\"));\n+exports.LegacyCryptor = legacyCryptor_1.default;\n+var aesCbcCryptor_1 = __importDefault(require(\"./aesCbcCryptor\"));\n+exports.AesCbcCryptor = aesCbcCryptor_1.default;\n+var base64_codec_1 = require(\"../../../core/components/base64_codec\");\n+var CryptoModule = /** @class */ (function () {\n+    function CryptoModule(cryptoModuleConfiguration) {\n+        var _a;\n+        this.defaultCryptor = cryptoModuleConfiguration.default;\n+        this.cryptors = (_a = cryptoModuleConfiguration.cryptors) !== null && _a !== void 0 ? _a : [];\n+    }\n+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+    //@ts-ignore: type detection issue with old Config type assignment\n+    CryptoModule.legacyCryptoModule = function (config) {\n+        var _a;\n+        return new this({\n+            default: new legacyCryptor_1.default({\n+                cipherKey: config.cipherKey,\n+                useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+            }),\n+            cryptors: [new aesCbcCryptor_1.default({ cipherKey: config.cipherKey })],\n+        });\n+    };\n+    CryptoModule.aesCbcCryptoModule = function (config) {\n+        var _a;\n+        return new this({\n+            default: new aesCbcCryptor_1.default({ cipherKey: config.cipherKey }),\n+            cryptors: [\n+                new legacyCryptor_1.default({\n+                    cipherKey: config.cipherKey,\n+                    useRandomIVs: (_a = config.useRandomIVs) !== null && _a !== void 0 ? _a : true,\n+                }),\n+            ],\n+        });\n+    };\n+    CryptoModule.withDefaultCryptor = function (defaultCryptor) {\n+        return new this({ default: defaultCryptor });\n+    };\n+    CryptoModule.prototype.getAllCryptors = function () {\n+        return __spreadArray([this.defaultCryptor], __read(this.cryptors), false);\n+    };\n+    CryptoModule.prototype.encrypt = function (data) {\n+        var encrypted = this.defaultCryptor.encrypt(data);\n+        if (!encrypted.metadata)\n+            return encrypted.data;\n+        var headerData = this.getHeaderData(encrypted);\n+        return this.concatArrayBuffer(headerData, encrypted.data);\n+    };\n+    CryptoModule.prototype.decrypt = function (data) {\n+        var encryptedData = typeof data === 'string' ? (0, base64_codec_1.decode)(data) : data;\n+        var header = CryptorHeader.tryParse(encryptedData);\n+        var cryptor = this.getCryptor(header);\n+        var metadata = header.length > 0\n+            ? encryptedData.slice(header.length - header.metadataLength, header.length)\n+            : null;\n+        if (encryptedData.slice(header.length).byteLength <= 0)\n+            throw new Error('decryption error. empty content');\n+        return cryptor.decrypt({\n+            data: encryptedData.slice(header.length),\n+            metadata: metadata,\n+        });\n+    };\n+    CryptoModule.prototype.encryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var fileData, encrypted;\n+            return __generator(this, function (_a) {\n+                switch (_a.label) {\n+                    case 0:\n+                        if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)\n+                            return [2 /*return*/, this.defaultCryptor.encryptFile(file, File)];\n+                        fileData = this.getFileData(file.data);\n+                        return [4 /*yield*/, this.defaultCryptor.encryptFileData(fileData)];\n+                    case 1:\n+                        encrypted = _a.sent();\n+                        return [2 /*return*/, File.create({\n+                                name: file.name,\n+                                mimeType: 'application/octet-stream',\n+                                data: this.concatArrayBuffer(this.getHeaderData(encrypted), encrypted.data),\n+                            })];\n+                }\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.decryptFile = function (file, File) {\n+        return __awaiter(this, void 0, void 0, function () {\n+            var data, header, cryptor, fileData, metadata, _a, _b;\n+            var _c;\n+            return __generator(this, function (_d) {\n+                switch (_d.label) {\n+                    case 0: return [4 /*yield*/, file.data.arrayBuffer()];\n+                    case 1:\n+                        data = _d.sent();\n+                        header = CryptorHeader.tryParse(data);\n+                        cryptor = this.getCryptor(header);\n+                        if ((cryptor === null || cryptor === void 0 ? void 0 : cryptor.identifier) === CryptoModule.LEGACY_IDENTIFIER) {\n+                            return [2 /*return*/, cryptor.decryptFile(file, File)];\n+                        }\n+                        fileData = this.getFileData(data);\n+                        metadata = fileData.slice(header.length - header.metadataLength, header.length);\n+                        _b = (_a = File).create;\n+                        _c = {\n+                            name: file.name\n+                        };\n+                        return [4 /*yield*/, this.defaultCryptor.decryptFileData({\n+                                data: data.slice(header.length),\n+                                metadata: metadata,\n+                            })];\n+                    case 2: return [2 /*return*/, _b.apply(_a, [(_c.data = _d.sent(),\n+                                _c)])];\n+                }\n+            });\n+        });\n+    };\n+    CryptoModule.prototype.getCryptor = function (header) {\n+        if (header === '') {\n+            var cryptor = this.getAllCryptors().find(function (c) { return c.identifier === ''; });\n+            if (cryptor)\n+                return cryptor;\n+            throw new Error('unknown cryptor error');\n+        }\n+        else if (header instanceof CryptorHeaderV1) {\n+            return this.getCryptorFromId(header.identifier);\n+        }\n+    };\n+    CryptoModule.prototype.getCryptorFromId = function (id) {\n+        var cryptor = this.getAllCryptors().find(function (c) { return id === c.identifier; });\n+        if (cryptor) {\n+            return cryptor;\n+        }\n+        throw Error('unknown cryptor error');\n+    };\n+    CryptoModule.prototype.concatArrayBuffer = function (ab1, ab2) {\n+        var tmp = new Uint8Array(ab1.byteLength + ab2.byteLength);\n+        tmp.set(new Uint8Array(ab1), 0);\n+        tmp.set(new Uint8Array(ab2), ab1.byteLength);\n+        return tmp.buffer;\n+    };\n+    CryptoModule.prototype.getHeaderData = function (encrypted) {\n+        if (!encrypted.metadata)\n+            return;\n+        var header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);\n+        var headerData = new Uint8Array(header.length);\n+        var pos = 0;\n+        headerData.set(header.data, pos);\n+        pos += header.length - encrypted.metadata.byteLength;\n+        headerData.set(new Uint8Array(encrypted.metadata), pos);\n+        return headerData.buffer;\n+    };\n+    CryptoModule.prototype.getFileData = function (input) {\n+        if (input instanceof ArrayBuffer) {\n+            return input;\n+        }\n+        if (typeof input === 'string') {\n+            return CryptoModule.encoder.encode(input);\n+        }\n+        throw new Error('Cannot decrypt/encrypt file. In browsers file decryption supports only string or ArrayBuffer');\n+    };\n+    CryptoModule.LEGACY_IDENTIFIER = '';\n+    CryptoModule.encoder = new TextEncoder();\n+    CryptoModule.decoder = new TextDecoder();\n+    return CryptoModule;\n+}());\n+exports.CryptoModule = CryptoModule;\n+// CryptorHeader Utility\n+var CryptorHeader = /** @class */ (function () {\n+    function CryptorHeader() {\n+    }\n+    CryptorHeader.from = function (id, metadata) {\n+        if (id === CryptorHeader.LEGACY_IDENTIFIER)\n+            return;\n+        return new CryptorHeaderV1(id, metadata.byteLength);\n+    };\n+    CryptorHeader.tryParse = function (data) {\n+        var encryptedData = new Uint8Array(data);\n+        var sentinel = '';\n+        var version = null;\n+        if (encryptedData.byteLength >= 4) {\n+            sentinel = encryptedData.slice(0, 4);\n+            if (this.decoder.decode(sentinel) !== CryptorHeader.SENTINEL)\n+                return '';\n+        }\n+        if (encryptedData.byteLength >= 5) {\n+            version = encryptedData[4];\n+        }\n+        else {\n+            throw new Error('decryption error. invalid header version');\n+        }\n+        if (version > CryptorHeader.MAX_VERSION)\n+            throw new Error('unknown cryptor error');\n+        var identifier = '';\n+        var pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;\n+        if (encryptedData.byteLength >= pos) {\n+            identifier = encryptedData.slice(5, pos);\n+        }\n+        else {\n+            throw new Error('decryption error. invalid crypto identifier');\n+        }\n+        var metadataLength = null;\n+        if (encryptedData.byteLength >= pos + 1) {\n+            metadataLength = encryptedData[pos];\n+        }\n+        else {\n+            throw new Error('decryption error. invalid metadata length');\n+        }\n+        pos += 1;\n+        if (metadataLength === 255 && encryptedData.byteLength >= pos + 2) {\n+            metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce(function (acc, val) { return (acc << 8) + val; }, 0);\n+            pos += 2;\n+        }\n+        return new CryptorHeaderV1(this.decoder.decode(identifier), metadataLength);\n+    };\n+    CryptorHeader.SENTINEL = 'PNED';\n+    CryptorHeader.LEGACY_IDENTIFIER = '';\n+    CryptorHeader.IDENTIFIER_LENGTH = 4;\n+    CryptorHeader.VERSION = 1;\n+    CryptorHeader.MAX_VERSION = 1;\n+    CryptorHeader.decoder = new TextDecoder();\n+    return CryptorHeader;\n+}());\n+// v1 CryptorHeader\n+var CryptorHeaderV1 = /** @class */ (function () {\n+    function CryptorHeaderV1(id, metadataLength) {\n+        this._identifier = id;\n+        this._metadataLength = metadataLength;\n+    }\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"identifier\", {\n+        get: function () {\n+            return this._identifier;\n+        },\n+        set: function (value) {\n+            this._identifier = value;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"metadataLength\", {\n+        get: function () {\n+            return this._metadataLength;\n+        },\n+        set: function (value) {\n+            this._metadataLength = value;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"version\", {\n+        get: function () {\n+            return CryptorHeader.VERSION;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"length\", {\n+        get: function () {\n+            return (CryptorHeader.SENTINEL.length +\n+                1 +\n+                CryptorHeader.IDENTIFIER_LENGTH +\n+                (this.metadataLength < 255 ? 1 : 3) +\n+                this.metadataLength);\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    Object.defineProperty(CryptorHeaderV1.prototype, \"data\", {\n+        get: function () {\n+            var pos = 0;\n+            var header = new Uint8Array(this.length);\n+            var encoder = new TextEncoder();\n+            header.set(encoder.encode(CryptorHeader.SENTINEL));\n+            pos += CryptorHeader.SENTINEL.length;\n+            header[pos] = this.version;\n+            pos++;\n+            if (this.identifier)\n+                header.set(encoder.encode(this.identifier), pos);\n+            pos += CryptorHeader.IDENTIFIER_LENGTH;\n+            var metadataLength = this.metadataLength;\n+            if (metadataLength < 255) {\n+                header[pos] = metadataLength;\n+            }\n+            else {\n+                header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);\n+            }\n+            return header;\n+        },\n+        enumerable: false,\n+        configurable: true\n+    });\n+    CryptorHeaderV1.IDENTIFIER_LENGTH = 4;\n+    CryptorHeaderV1.SENTINEL = 'PNED';\n+    return CryptorHeaderV1;\n+}());"
        },
        {
            "filename": "lib/crypto/modules/node.js",
            "diff": "@@ -94,6 +94,8 @@ var NodeCryptography = /** @class */ (function () {\n                     case 0:\n                         bKey = this.getKey(key);\n                         if (!(file.data instanceof Buffer)) return [3 /*break*/, 2];\n+                        if (file.data.byteLength <= 0)\n+                            throw new Error('encryption error. empty content');\n                         _b = (_a = File).create;\n                         _e = {\n                             name: file.name,\n@@ -104,6 +106,8 @@ var NodeCryptography = /** @class */ (function () {\n                                 _e)])];\n                     case 2:\n                         if (!(file.data instanceof stream_1.Readable)) return [3 /*break*/, 4];\n+                        if (file.contentLength === 0)\n+                            throw new Error('encryption error. empty content');\n                         _d = (_c = File).create;\n                         _f = {\n                             name: file.name,\n@@ -176,16 +180,32 @@ var NodeCryptography = /** @class */ (function () {\n     NodeCryptography.prototype.decryptBuffer = function (key, ciphertext) {\n         var bIv = ciphertext.slice(0, NodeCryptography.IV_LENGTH);\n         var bCiphertext = ciphertext.slice(NodeCryptography.IV_LENGTH);\n+        if (bCiphertext.byteLength <= 0)\n+            throw new Error('decryption error: empty content');\n         var aes = (0, crypto_1.createDecipheriv)(this.algo, key, bIv);\n         return Buffer.concat([aes.update(bCiphertext), aes.final()]);\n     };\n     NodeCryptography.prototype.encryptStream = function (key, stream) {\n-        var output = new stream_1.PassThrough();\n-        var bIv = this.getIv();\n-        var aes = (0, crypto_1.createCipheriv)(this.algo, key, bIv);\n-        output.write(bIv);\n-        stream.pipe(aes).pipe(output);\n-        return output;\n+        return __awaiter(this, void 0, void 0, function () {\n+            var bIv, aes, inited;\n+            return __generator(this, function (_a) {\n+                bIv = this.getIv();\n+                aes = (0, crypto_1.createCipheriv)('aes-256-cbc', key, bIv).setAutoPadding(true);\n+                inited = false;\n+                return [2 /*return*/, stream.pipe(aes).pipe(new stream_1.Transform({\n+                        transform: function (chunk, _, cb) {\n+                            if (!inited) {\n+                                inited = true;\n+                                this.push(Buffer.concat([bIv, chunk]));\n+                            }\n+                            else {\n+                                this.push(chunk);\n+                            }\n+                            cb();\n+                        },\n+                    }))];\n+            });\n+        });\n     };\n     NodeCryptography.prototype.decryptStream = function (key, stream) {\n         var _this = this;"
        },
        {
            "filename": "lib/crypto/modules/web.js",
            "diff": "@@ -96,10 +96,13 @@ var WebCryptography = /** @class */ (function () {\n             var bKey, abPlaindata, abCipherdata;\n             return __generator(this, function (_a) {\n                 switch (_a.label) {\n-                    case 0: return [4 /*yield*/, this.getKey(key)];\n+                    case 0:\n+                        if (file.data.byteLength <= 0)\n+                            throw new Error('encryption error. empty content');\n+                        return [4 /*yield*/, this.getKey(key)];\n                     case 1:\n                         bKey = _a.sent();\n-                        return [4 /*yield*/, file.toArrayBuffer()];\n+                        return [4 /*yield*/, file.data.arrayBuffer()];\n                     case 2:\n                         abPlaindata = _a.sent();\n                         return [4 /*yield*/, this.encryptArrayBuffer(bKey, abPlaindata)];\n@@ -122,7 +125,7 @@ var WebCryptography = /** @class */ (function () {\n                     case 0: return [4 /*yield*/, this.getKey(key)];\n                     case 1:\n                         bKey = _a.sent();\n-                        return [4 /*yield*/, file.toArrayBuffer()];\n+                        return [4 /*yield*/, file.data.arrayBuffer()];\n                     case 2:\n                         abCipherdata = _a.sent();\n                         return [4 /*yield*/, this.decryptArrayBuffer(bKey, abCipherdata)];\n@@ -138,15 +141,16 @@ var WebCryptography = /** @class */ (function () {\n     };\n     WebCryptography.prototype.getKey = function (key) {\n         return __awaiter(this, void 0, void 0, function () {\n-            var bKey, abHash, abKey;\n+            var digest, hashHex, abKey;\n             return __generator(this, function (_a) {\n                 switch (_a.label) {\n-                    case 0:\n-                        bKey = Buffer.from(key);\n-                        return [4 /*yield*/, crypto.subtle.digest('SHA-256', bKey.buffer)];\n+                    case 0: return [4 /*yield*/, crypto.subtle.digest('SHA-256', WebCryptography.encoder.encode(key))];\n                     case 1:\n-                        abHash = _a.sent();\n-                        abKey = Buffer.from(Buffer.from(abHash).toString('hex').slice(0, 32), 'utf8').buffer;\n+                        digest = _a.sent();\n+                        hashHex = Array.from(new Uint8Array(digest))\n+                            .map(function (b) { return b.toString(16).padStart(2, '0'); })\n+                            .join('');\n+                        abKey = WebCryptography.encoder.encode(hashHex.slice(0, 32)).buffer;\n                         return [2 /*return*/, crypto.subtle.importKey('raw', abKey, 'AES-CBC', true, ['encrypt', 'decrypt'])];\n                 }\n             });\n@@ -169,10 +173,18 @@ var WebCryptography = /** @class */ (function () {\n     };\n     WebCryptography.prototype.decryptArrayBuffer = function (key, ciphertext) {\n         return __awaiter(this, void 0, void 0, function () {\n-            var abIv;\n+            var abIv, data;\n             return __generator(this, function (_a) {\n-                abIv = ciphertext.slice(0, 16);\n-                return [2 /*return*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(16))];\n+                switch (_a.label) {\n+                    case 0:\n+                        abIv = ciphertext.slice(0, 16);\n+                        if (ciphertext.slice(WebCryptography.IV_LENGTH).byteLength <= 0)\n+                            throw new Error('decryption error: empty content');\n+                        return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(WebCryptography.IV_LENGTH))];\n+                    case 1:\n+                        data = _a.sent();\n+                        return [2 /*return*/, data];\n+                }\n             });\n         });\n     };\n@@ -183,12 +195,12 @@ var WebCryptography = /** @class */ (function () {\n                 switch (_a.label) {\n                     case 0:\n                         abIv = crypto.getRandomValues(new Uint8Array(16));\n-                        abPlaintext = Buffer.from(plaintext).buffer;\n+                        abPlaintext = WebCryptography.encoder.encode(plaintext).buffer;\n                         return [4 /*yield*/, crypto.subtle.encrypt({ name: 'AES-CBC', iv: abIv }, key, abPlaintext)];\n                     case 1:\n                         abPayload = _a.sent();\n                         ciphertext = concatArrayBuffer(abIv.buffer, abPayload);\n-                        return [2 /*return*/, Buffer.from(ciphertext).toString('utf8')];\n+                        return [2 /*return*/, WebCryptography.decoder.decode(ciphertext)];\n                 }\n             });\n         });\n@@ -199,18 +211,20 @@ var WebCryptography = /** @class */ (function () {\n             return __generator(this, function (_a) {\n                 switch (_a.label) {\n                     case 0:\n-                        abCiphertext = Buffer.from(ciphertext);\n+                        abCiphertext = WebCryptography.encoder.encode(ciphertext).buffer;\n                         abIv = abCiphertext.slice(0, 16);\n                         abPayload = abCiphertext.slice(16);\n                         return [4 /*yield*/, crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, abPayload)];\n                     case 1:\n                         abPlaintext = _a.sent();\n-                        return [2 /*return*/, Buffer.from(abPlaintext).toString('utf8')];\n+                        return [2 /*return*/, WebCryptography.decoder.decode(abPlaintext)];\n                 }\n             });\n         });\n     };\n     WebCryptography.IV_LENGTH = 16;\n+    WebCryptography.encoder = new TextEncoder();\n+    WebCryptography.decoder = new TextDecoder();\n     return WebCryptography;\n }());\n exports.default = WebCryptography;"
        },
        {
            "filename": "lib/file/modules/node.js",
            "diff": "@@ -1,5 +1,4 @@\n \"use strict\";\n-/**       */\n var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n     function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n     return new (P || (P = Promise))(function (resolve, reject) {\n@@ -36,19 +35,23 @@ var __generator = (this && this.__generator) || function (thisArg, body) {\n         if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n     }\n };\n+var __importDefault = (this && this.__importDefault) || function (mod) {\n+    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n+};\n var _a;\n Object.defineProperty(exports, \"__esModule\", { value: true });\n var stream_1 = require(\"stream\");\n-var fs_1 = require(\"fs\");\n+var fs_1 = __importDefault(require(\"fs\"));\n var path_1 = require(\"path\");\n var PubNubFile = (_a = /** @class */ (function () {\n         function PubNubFile(_a) {\n             var stream = _a.stream, data = _a.data, encoding = _a.encoding, name = _a.name, mimeType = _a.mimeType;\n             if (stream instanceof stream_1.Readable) {\n                 this.data = stream;\n-                if (stream instanceof fs_1.ReadStream) {\n+                if (stream instanceof fs_1.default.ReadStream) {\n                     // $FlowFixMe: incomplete flow node definitions\n                     this.name = (0, path_1.basename)(stream.path);\n+                    this.contentLength = fs_1.default.statSync(stream.path).size;\n                 }\n             }\n             else if (data instanceof Buffer) {"
        },
        {
            "filename": "lib/node/index.js",
            "diff": "@@ -17,6 +17,7 @@ var __extends = (this && this.__extends) || (function () {\n var __importDefault = (this && this.__importDefault) || function (mod) {\n     return (mod && mod.__esModule) ? mod : { \"default\": mod };\n };\n+var _a;\n var cbor_sync_1 = __importDefault(require(\"cbor-sync\"));\n var pubnub_common_1 = __importDefault(require(\"../core/pubnub-common\"));\n var networking_1 = __importDefault(require(\"../networking\"));\n@@ -26,29 +27,41 @@ var web_node_1 = require(\"../networking/modules/web-node\");\n var node_1 = require(\"../networking/modules/node\");\n var node_2 = __importDefault(require(\"../crypto/modules/node\"));\n var node_3 = __importDefault(require(\"../file/modules/node\"));\n-module.exports = /** @class */ (function (_super) {\n-    __extends(class_1, _super);\n-    function class_1(setup) {\n-        var _this = this;\n-        setup.cbor = new common_1.default(function (buffer) { return cbor_sync_1.default.decode(Buffer.from(buffer)); }, base64_codec_1.decode);\n-        setup.networking = new networking_1.default({\n-            keepAlive: node_1.keepAlive,\n-            del: web_node_1.del,\n-            get: web_node_1.get,\n-            post: web_node_1.post,\n-            patch: web_node_1.patch,\n-            proxy: node_1.proxy,\n-            getfile: web_node_1.getfile,\n-            postfile: web_node_1.postfile,\n-        });\n-        setup.sdkFamily = 'Nodejs';\n-        setup.PubNubFile = node_3.default;\n-        setup.cryptography = new node_2.default();\n-        if (!('ssl' in setup)) {\n-            setup.ssl = true;\n+var nodeCryptoModule_1 = require(\"../crypto/modules/NodeCryptoModule/nodeCryptoModule\");\n+module.exports = (_a = /** @class */ (function (_super) {\n+        __extends(class_1, _super);\n+        function class_1(setup) {\n+            var _this = this;\n+            setup.cbor = new common_1.default(function (buffer) { return cbor_sync_1.default.decode(Buffer.from(buffer)); }, base64_codec_1.decode);\n+            setup.networking = new networking_1.default({\n+                keepAlive: node_1.keepAlive,\n+                del: web_node_1.del,\n+                get: web_node_1.get,\n+                post: web_node_1.post,\n+                patch: web_node_1.patch,\n+                proxy: node_1.proxy,\n+                getfile: web_node_1.getfile,\n+                postfile: web_node_1.postfile,\n+            });\n+            setup.sdkFamily = 'Nodejs';\n+            setup.PubNubFile = node_3.default;\n+            setup.cryptography = new node_2.default();\n+            setup.initCryptoModule = function (cryptoConfiguration) {\n+                return new nodeCryptoModule_1.CryptoModule({\n+                    default: new nodeCryptoModule_1.LegacyCryptor({\n+                        cipherKey: cryptoConfiguration.cipherKey,\n+                        useRandomIVs: cryptoConfiguration.useRandomIVs,\n+                    }),\n+                    cryptors: [new nodeCryptoModule_1.AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],\n+                });\n+            };\n+            if (!('ssl' in setup)) {\n+                setup.ssl = true;\n+            }\n+            _this = _super.call(this, setup) || this;\n+            return _this;\n         }\n-        _this = _super.call(this, setup) || this;\n-        return _this;\n-    }\n-    return class_1;\n-}(pubnub_common_1.default));\n+        return class_1;\n+    }(pubnub_common_1.default)),\n+    _a.CryptoModule = nodeCryptoModule_1.CryptoModule,\n+    _a);"
        },
        {
            "filename": "lib/web/index.js",
            "diff": "@@ -29,6 +29,7 @@ var common_1 = __importDefault(require(\"../cbor/common\"));\n var web_node_1 = require(\"../networking/modules/web-node\");\n var web_1 = __importDefault(require(\"../crypto/modules/web\"));\n var web_2 = __importDefault(require(\"../file/modules/web\"));\n+var webCryptoModule_1 = require(\"../crypto/modules/WebCryptoModule/webCryptoModule\");\n function sendBeacon(url) {\n     if (navigator && navigator.sendBeacon) {\n         navigator.sendBeacon(url);\n@@ -56,6 +57,15 @@ var default_1 = /** @class */ (function (_super) {\n         setup.cbor = new common_1.default(function (arrayBuffer) { return (0, stringify_buffer_keys_1.stringifyBufferKeys)(cbor_js_1.default.decode(arrayBuffer)); }, base64_codec_1.decode);\n         setup.PubNubFile = web_2.default;\n         setup.cryptography = new web_1.default();\n+        setup.initCryptoModule = function (cryptoConfiguration) {\n+            return new webCryptoModule_1.CryptoModule({\n+                default: new webCryptoModule_1.LegacyCryptor({\n+                    cipherKey: cryptoConfiguration.cipherKey,\n+                    useRandomIVs: cryptoConfiguration.useRandomIVs,\n+                }),\n+                cryptors: [new webCryptoModule_1.AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],\n+            });\n+        };\n         _this = _super.call(this, setup) || this;\n         if (listenToBrowserNetworkEvents) {\n             // mount network events.\n@@ -68,6 +78,7 @@ var default_1 = /** @class */ (function (_super) {\n         }\n         return _this;\n     }\n+    default_1.CryptoModule = webCryptoModule_1.CryptoModule;\n     return default_1;\n }(pubnub_common_1.default));\n exports.default = default_1;"
        },
        {
            "filename": "package.json",
            "diff": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"pubnub\",\n-  \"version\": \"7.3.3\",\n+  \"version\": \"7.4.0\",\n   \"author\": \"PubNub <support@pubnub.com>\",\n   \"description\": \"Publish & Subscribe Real-time Messaging with PubNub\",\n   \"scripts\": {\n@@ -102,4 +102,4 @@\n   \"engine\": {\n     \"node\": \">=0.8\"\n   }\n-}\n+}\n\\ No newline at end of file"
        },
        {
            "filename": "src/core/components/base64_codec.ts",
            "diff": "@@ -53,3 +53,55 @@ export function decode(paddedInput: string): ArrayBuffer {\n \n   return data;\n }\n+\n+export function encode(input: ArrayBuffer): string {\n+  let base64 = '';\n+  const encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n+\n+  const bytes = new Uint8Array(input);\n+  const byteLength = bytes.byteLength;\n+  const byteRemainder = byteLength % 3;\n+  const mainLength = byteLength - byteRemainder;\n+\n+  let a, b, c, d;\n+  let chunk;\n+\n+  // Main loop deals with bytes in chunks of 3\n+  for (let i = 0; i < mainLength; i = i + 3) {\n+    // Combine the three bytes into a single integer\n+    chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n+\n+    // Use bitmasks to extract 6-bit segments from the triplet\n+    a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n+    b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n+    c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n+    d = chunk & 63; // 63       = 2^6 - 1\n+\n+    // Convert the raw binary segments to the appropriate ASCII encoding\n+    base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n+  }\n+\n+  // Deal with the remaining bytes and padding\n+  if (byteRemainder == 1) {\n+    chunk = bytes[mainLength];\n+\n+    a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n+\n+    // Set the 4 least significant bits to zero\n+    b = (chunk & 3) << 4; // 3   = 2^2 - 1\n+\n+    base64 += encodings[a] + encodings[b] + '==';\n+  } else if (byteRemainder == 2) {\n+    chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n+\n+    a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n+    b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n+\n+    // Set the 2 least significant bits to zero\n+    c = (chunk & 15) << 2; // 15    = 2^4 - 1\n+\n+    base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n+  }\n+\n+  return base64;\n+}"
        },
        {
            "filename": "src/core/components/config.js",
            "diff": "@@ -129,7 +129,7 @@ export default class {\n   maximumCacheSize;\n \n   /*\n-    support customp encryption and decryption functions.\n+    support custom encryption and decryption functions.\n   */\n   customEncrypt; // function to support custome encryption of messages\n \n@@ -142,6 +142,11 @@ export default class {\n   useRandomIVs;\n   enableSubscribeBeta;\n \n+  /*\n+    set cryptoModule to encrypt/decrypt messages and files.\n+  */\n+  cryptoModule;\n+\n   constructor({ setup }) {\n     this._PNSDKSuffix = {};\n \n@@ -153,7 +158,7 @@ export default class {\n     this.sdkFamily = setup.sdkFamily;\n     this.partnerId = setup.partnerId;\n     this.setAuthKey(setup.authKey);\n-    this.setCipherKey(setup.cipherKey);\n+    this.cryptoModule = setup.cryptoModule;\n \n     this.setFilterExpression(setup.filterExpression);\n \n@@ -227,6 +232,7 @@ export default class {\n \n       this.setUUID(setup.uuid);\n     }\n+    this.setCipherKey(setup.cipherKey, setup);\n   }\n \n   // exposed setters\n@@ -239,8 +245,13 @@ export default class {\n     return this;\n   }\n \n-  setCipherKey(val) {\n+  setCipherKey(val, setup, modules) {\n     this.cipherKey = val;\n+    if (this.cipherKey) {\n+      this.cryptoModule =\n+        setup.cryptoModule ?? setup.initCryptoModule({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs });\n+      if (modules) modules.cryptoModule = this.cryptoModule;\n+    }\n     return this;\n   }\n \n@@ -339,7 +350,7 @@ export default class {\n   }\n \n   getVersion() {\n-    return '7.3.3';\n+    return '7.4.0';\n   }\n \n   _addPnsdkSuffix(name, suffix) {"
        },
        {
            "filename": "src/core/components/cryptography/index.js",
            "diff": "@@ -26,7 +26,6 @@ export default class {\n \n   constructor({ config }) {\n     this._config = config;\n-\n     this._iv = '0123456789012345';\n \n     this._allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];"
        },
        {
            "filename": "src/core/components/subscription_manager.js",
            "diff": "@@ -58,6 +58,10 @@ export default class {\n   _pendingChannelGroupSubscriptions;\n   //\n \n+  _cryptoModule;\n+\n+  _decoder;\n+\n   _dedupingManager;\n \n   constructor({\n@@ -70,6 +74,7 @@ export default class {\n     config,\n     crypto,\n     listenerManager,\n+    cryptoModule,\n   }) {\n     this._listenerManager = listenerManager;\n     this._config = config;\n@@ -81,6 +86,7 @@ export default class {\n     this._getFileUrl = getFileUrl;\n \n     this._crypto = crypto;\n+    this._cryptoModule = cryptoModule;\n \n     this._channels = {};\n     this._presenceChannels = {};\n@@ -104,6 +110,8 @@ export default class {\n \n     this._reconnectionManager = new ReconnectionManager({ timeEndpoint });\n     this._dedupingManager = new DedupingManager({ config });\n+\n+    if (this._cryptoModule) this._decoder = new TextDecoder();\n   }\n \n   adaptStateChange(args, callback) {\n@@ -683,10 +691,19 @@ export default class {\n \n         let msgPayload = message.payload;\n \n-        if (this._config.cipherKey) {\n-          const decryptedPayload = this._crypto.decrypt(message.payload);\n-\n-          if (typeof decryptedPayload === 'object' && decryptedPayload !== null) {\n+        if (this._cryptoModule) {\n+          let decryptedPayload;\n+          try {\n+            const decryptedData = this._cryptoModule.decrypt(message.payload);\n+            decryptedPayload =\n+              decryptedData instanceof ArrayBuffer ? JSON.parse(this._decoder.decode(decryptedData)) : decryptedData;\n+          } catch (e) {\n+            decryptedPayload = null;\n+            if (console && console.log) {\n+              console.log('decryption error', e.message);\n+            }\n+          }\n+          if (decryptedPayload !== null) {\n             msgPayload = decryptedPayload;\n           }\n         }\n@@ -727,8 +744,24 @@ export default class {\n           announce.userMetadata = message.userMetadata;\n         }\n \n-        if (this._config.cipherKey) {\n-          announce.message = this._crypto.decrypt(message.payload);\n+        if (this._cryptoModule) {\n+          let decryptedPayload;\n+          try {\n+            const decryptedData = this._cryptoModule.decrypt(message.payload);\n+            decryptedPayload =\n+              decryptedData instanceof ArrayBuffer ? JSON.parse(this._decoder.decode(decryptedData)) : decryptedData;\n+          } catch (e) {\n+            decryptedPayload = null;\n+            // eslint-disable-next-line\n+            if (console && console.log) {\n+              console.log('decryption error', e.message); //eslint-disable-line\n+            }\n+          }\n+          if (decryptedPayload != null) {\n+            announce.message = decryptedPayload;\n+          } else {\n+            announce.message = message.payload;\n+          }\n         } else {\n           announce.message = message.payload;\n         }"
        },
        {
            "filename": "src/core/endpoints/fetch_messages.js",
            "diff": "@@ -11,12 +11,14 @@ import operationConstants from '../constants/operations';\n import utils from '../utils';\n \n function __processMessage(modules, message) {\n-  const { config, crypto } = modules;\n-  if (!config.cipherKey) return message;\n-\n+  if (!modules.cryptoModule) return message;\n   try {\n-    return crypto.decrypt(message);\n+    const decryptedData = modules.cryptoModule.decrypt(message);\n+    const decryptedPayload =\n+      decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;\n+    return decryptedPayload;\n   } catch (e) {\n+    if (console && console.log) console.log('decryption error', e.message);\n     return message;\n   }\n }"
        },
        {
            "filename": "src/core/endpoints/file_upload/download_file.js",
            "diff": "@@ -1,3 +1,5 @@\n+// Download_file.js\n+\n /**       */\n \n import operationConstants from '../../constants/operations';\n@@ -34,11 +36,13 @@ const endpoint = {\n \n   prepareParams: () => ({}),\n \n-  handleResponse: async ({ PubNubFile, config, cryptography }, res, params) => {\n+  handleResponse: async ({ PubNubFile, config, cryptography, cryptoModule }, res, params) => {\n     let { body } = res.response;\n-\n-    if (PubNubFile.supportsEncryptFile && (params.cipherKey ?? config.cipherKey)) {\n-      body = await cryptography.decrypt(params.cipherKey ?? config.cipherKey, body);\n+    if (PubNubFile.supportsEncryptFile && (params.cipherKey || cryptoModule)) {\n+      body =\n+        params.cipherKey == null\n+          ? (await cryptoModule.decryptFile(PubNubFile.create({ data: body, name: params.name }), PubNubFile)).data\n+          : await cryptography.decrypt(params.cipherKey ?? config.cipherKey, body);\n     }\n \n     return PubNubFile.create({"
        },
        {
            "filename": "src/core/endpoints/file_upload/publish_file.js",
            "diff": "@@ -1,17 +1,16 @@\n /**       */\n \n import operationConstants from '../../constants/operations';\n-\n import utils from '../../utils';\n+import { encode } from '../../components/base64_codec';\n \n-const preparePayload = ({ crypto, config }, payload) => {\n+const preparePayload = (modules, payload) => {\n   let stringifiedPayload = JSON.stringify(payload);\n-\n-  if (config.cipherKey) {\n-    stringifiedPayload = crypto.encrypt(stringifiedPayload);\n+  if (modules.cryptoModule) {\n+    const encrypted = modules.cryptoModule.encrypt(stringifiedPayload);\n+    stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode(encrypted);\n     stringifiedPayload = JSON.stringify(stringifiedPayload);\n   }\n-\n   return stringifiedPayload || '';\n };\n "
        },
        {
            "filename": "src/core/endpoints/file_upload/send_file.js",
            "diff": "@@ -3,7 +3,7 @@ import { PubNubError, createValidationError } from '../../components/endpoint';\n const sendFile = function ({\n   generateUploadUrl,\n   publishFile,\n-  modules: { PubNubFile, config, cryptography, networking },\n+  modules: { PubNubFile, config, cryptography, cryptoModule, networking },\n }) {\n   return async ({ channel, file: input, message, cipherKey, meta, ttl, storeInHistory }) => {\n     if (!channel) {\n@@ -27,8 +27,11 @@ const sendFile = function ({\n       data: { id, name },\n     } = await generateUploadUrl({ channel, name: file.name });\n \n-    if (PubNubFile.supportsEncryptFile && (cipherKey ?? config.cipherKey)) {\n-      file = await cryptography.encryptFile(cipherKey ?? config.cipherKey, file, PubNubFile);\n+    if (PubNubFile.supportsEncryptFile && (cipherKey || cryptoModule)) {\n+      file =\n+        cipherKey == null\n+          ? await cryptoModule.encryptFile(file, PubNubFile)\n+          : await cryptography.encryptFile(cipherKey, file, PubNubFile);\n     }\n \n     let formFieldsWithMimeType = formFields;"
        },
        {
            "filename": "src/core/endpoints/history/get_history.js",
            "diff": "@@ -5,12 +5,14 @@ import operationConstants from '../../constants/operations';\n import utils from '../../utils';\n \n function __processMessage(modules, message) {\n-  const { config, crypto } = modules;\n-  if (!config.cipherKey) return message;\n-\n+  if (!modules.cryptoModule) return message;\n   try {\n-    return crypto.decrypt(message);\n+    const decryptedData = modules.cryptoModule.decrypt(message);\n+    const decryptedPayload =\n+      decryptedData instanceof ArrayBuffer ? JSON.parse(new TextDecoder().decode(decryptedData)) : decryptedData;\n+    return decryptedPayload;\n   } catch (e) {\n+    if (console && console.log) console.log('decryption error', e.message);\n     return message;\n   }\n }"
        },
        {
            "filename": "src/core/endpoints/publish.js",
            "diff": "@@ -3,17 +3,17 @@\n import { PublishResponse, PublishArguments, ModulesInject } from '../flow_interfaces';\n import operationConstants from '../constants/operations';\n import utils from '../utils';\n+import { encode } from '../components/base64_codec';\n \n function prepareMessagePayload(modules, messagePayload) {\n-  const { crypto, config } = modules;\n   let stringifiedPayload = JSON.stringify(messagePayload);\n \n-  if (config.cipherKey) {\n-    stringifiedPayload = crypto.encrypt(stringifiedPayload);\n+  if (modules.cryptoModule) {\n+    const encrypted = modules.cryptoModule.encrypt(stringifiedPayload);\n+    stringifiedPayload = typeof encrypted === 'string' ? encrypted : encode(encrypted);\n     stringifiedPayload = JSON.stringify(stringifiedPayload);\n   }\n-\n-  return stringifiedPayload;\n+  return stringifiedPayload || '';\n }\n \n export function getOperation() {"
        },
        {
            "filename": "src/core/pubnub-common.js",
            "diff": "@@ -1,5 +1,6 @@\n import Config from './components/config';\n import Crypto from './components/cryptography/index';\n+import { encode } from './components/base64_codec';\n import SubscriptionManager from './components/subscription_manager';\n import TelemetryManager from './components/telemetry_manager';\n import NotificationsPayload from './components/push_payload';\n@@ -291,6 +292,7 @@ export default class {\n     });\n \n     this._telemetryManager = telemetryManager;\n+    const cryptoModule = this._config.cryptoModule;\n \n     const modules = {\n       config,\n@@ -300,12 +302,25 @@ export default class {\n       tokenManager,\n       telemetryManager,\n       PubNubFile: setup.PubNubFile,\n+      cryptoModule: cryptoModule,\n     };\n \n     this.File = setup.PubNubFile;\n \n-    this.encryptFile = (key, file) => cryptography.encryptFile(key, file, this.File);\n-    this.decryptFile = (key, file) => cryptography.decryptFile(key, file, this.File);\n+    this.encryptFile = function (key, file) {\n+      if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {\n+        file = key;\n+        return modules.cryptoModule.encryptFile(file, this.File);\n+      }\n+      return cryptography.encryptFile(key, file, this.File);\n+    };\n+    this.decryptFile = function (key, file) {\n+      if (arguments.length == 1 && typeof key != 'string' && modules.cryptoModule) {\n+        file = key;\n+        return modules.cryptoModule.decryptFile(file, this.File);\n+      }\n+      return cryptography.decryptFile(key, file, this.File);\n+    };\n \n     const timeEndpoint = endpointCreator.bind(this, modules, timeEndpointConfig);\n     const leaveEndpoint = endpointCreator.bind(this, modules, presenceLeaveEndpointConfig);\n@@ -341,6 +356,7 @@ export default class {\n         config: modules.config,\n         listenerManager,\n         getFileUrl: (params) => getFileUrlFunction(modules, params),\n+        cryptoModule: modules.cryptoModule,\n       });\n \n       this.subscribe = subscriptionManager.adaptSubscribeChange.bind(subscriptionManager);\n@@ -664,20 +680,34 @@ export default class {\n     // --- deprecated  ------------------\n \n     // mount crypto\n-    this.encrypt = crypto.encrypt.bind(crypto);\n-    this.decrypt = crypto.decrypt.bind(crypto);\n+    this.encrypt = function (data, key) {\n+      if (typeof key === 'undefined' && modules.cryptoModule) {\n+        const encrypted = modules.cryptoModule.encrypt(data);\n+        return typeof encrypted === 'string' ? encrypted : encode(encrypted);\n+      } else {\n+        return crypto.encrypt(data, key);\n+      }\n+    };\n+    this.decrypt = function (data, key) {\n+      if (typeof key === 'undefined' && cryptoModule) {\n+        const decrypted = modules.cryptoModule.decrypt(data);\n+        return decrypted instanceof ArrayBuffer ? encode(decrypted) : decrypted;\n+      } else {\n+        return crypto.decrypt(data, key);\n+      }\n+    };\n \n     /* config */\n     this.getAuthKey = modules.config.getAuthKey.bind(modules.config);\n     this.setAuthKey = modules.config.setAuthKey.bind(modules.config);\n-    this.setCipherKey = modules.config.setCipherKey.bind(modules.config);\n     this.getUUID = modules.config.getUUID.bind(modules.config);\n     this.setUUID = modules.config.setUUID.bind(modules.config);\n     this.getUserId = modules.config.getUserId.bind(modules.config);\n     this.setUserId = modules.config.setUserId.bind(modules.config);\n     this.getFilterExpression = modules.config.getFilterExpression.bind(modules.config);\n     this.setFilterExpression = modules.config.setFilterExpression.bind(modules.config);\n-\n+    // this.setCipherKey = modules.config.setCipherKey.bind(modules.config);\n+    this.setCipherKey = (key) => modules.config.setCipherKey(key, setup, modules);\n     this.setHeartbeatInterval = modules.config.setHeartbeatInterval.bind(modules.config);\n \n     if (networking.hasModule('proxy')) {"
        },
        {
            "filename": "src/core/utils.js",
            "diff": "@@ -32,9 +32,19 @@ function createPromise() {\n   return { promise, reject: failureResolve, fulfill: successResolve };\n }\n \n+function stringToArrayBuffer(str) {\n+  var buf = new ArrayBuffer(str.length * 2);\n+  var bufView = new Uint16Array(buf);\n+  for (var i = 0, strLen = str.length; i < strLen; i++) {\n+    bufView[i] = str.charCodeAt(i);\n+  }\n+  return buf;\n+}\n+\n module.exports = {\n   signPamFromParams,\n   endsWith,\n   createPromise,\n   encodeString,\n+  stringToArrayBuffer,\n };"
        },
        {
            "filename": "src/crypto/modules/NodeCryptoModule/ICryptor.ts",
            "diff": "@@ -0,0 +1,19 @@\n+export type EncryptedDataType = {\n+  data: Buffer | string;\n+  metadata: Buffer | null;\n+};\n+\n+export type EncryptedStream = {\n+  stream: NodeJS.ReadableStream;\n+  metadataLength: number;\n+  metadata?: Buffer | undefined;\n+};\n+\n+export interface ICryptor {\n+  get identifier(): string;\n+  encrypt(data: BufferSource | string): EncryptedDataType;\n+  decrypt(data: EncryptedDataType): ArrayBuffer;\n+\n+  encryptStream(stream: NodeJS.ReadableStream): Promise<EncryptedStream>;\n+  decryptStream(encryptedStream: EncryptedStream): Promise<NodeJS.ReadableStream>;\n+}"
        },
        {
            "filename": "src/crypto/modules/NodeCryptoModule/ILegacyCryptor.ts",
            "diff": "@@ -0,0 +1,26 @@\n+import { EncryptedDataType } from './ICryptor';\n+\n+export type PubNubFileType = {\n+  stream: NodeJS.ReadStream;\n+  data: NodeJS.ReadStream | Buffer;\n+  name: string;\n+  mimeType: string;\n+  contentLength: number;\n+\n+  create(config: any): PubNubFileType;\n+\n+  toBuffer(): Buffer;\n+  toArrayBuffer(): ArrayBuffer;\n+  toString(): string;\n+  toStream(): NodeJS.ReadStream;\n+};\n+\n+export interface ILegacyCryptor<T extends PubNubFileType> {\n+  get identifier(): string;\n+\n+  encrypt(data: string | ArrayBuffer): EncryptedDataType;\n+  decrypt(data: EncryptedDataType): BufferSource | string;\n+\n+  encryptFile(file: T, File: T): Promise<T>;\n+  decryptFile(file: T, File: T): Promise<T>;\n+}"
        },
        {
            "filename": "src/crypto/modules/NodeCryptoModule/aesCbcCryptor.ts",
            "diff": "@@ -0,0 +1,97 @@\n+import { PassThrough } from 'stream';\n+import { createCipheriv, createDecipheriv, createHash, randomBytes } from 'crypto';\n+import { ICryptor, EncryptedDataType, EncryptedStream } from './ICryptor';\n+\n+export default class AesCbcCryptor implements ICryptor {\n+  static BLOCK_SIZE = 16;\n+\n+  cipherKey: string;\n+  constructor(configuration: { cipherKey: string }) {\n+    this.cipherKey = configuration.cipherKey;\n+  }\n+\n+  get algo() {\n+    return 'aes-256-cbc';\n+  }\n+\n+  get identifier() {\n+    return 'ACRH';\n+  }\n+\n+  getIv() {\n+    return randomBytes(AesCbcCryptor.BLOCK_SIZE);\n+  }\n+\n+  getKey() {\n+    const sha = createHash('sha256');\n+    sha.update(Buffer.from(this.cipherKey, 'utf8'));\n+    return Buffer.from(sha.digest());\n+  }\n+\n+  encrypt(data: ArrayBuffer | string) {\n+    const iv = this.getIv();\n+    const key = this.getKey();\n+    const plainData = typeof data === 'string' ? new TextEncoder().encode(data) : data;\n+    const bPlain = Buffer.from(plainData);\n+    if (bPlain.byteLength === 0) throw new Error('encryption error. empty content');\n+    const aes = createCipheriv(this.algo, key, iv);\n+\n+    return {\n+      metadata: iv,\n+      data: Buffer.concat([aes.update(bPlain), aes.final()]),\n+    };\n+  }\n+\n+  decrypt(encryptedData: EncryptedDataType) {\n+    const data =\n+      typeof encryptedData.data === 'string' ? new TextEncoder().encode(encryptedData.data) : encryptedData.data;\n+    if (data.byteLength <= 0) throw new Error('decryption error: empty content');\n+    const aes = createDecipheriv(this.algo, this.getKey(), encryptedData.metadata);\n+    return Uint8Array.from(Buffer.concat([aes.update(data), aes.final()])).buffer;\n+  }\n+\n+  async encryptStream(stream: NodeJS.ReadableStream) {\n+    const output = new PassThrough();\n+    const bIv = this.getIv();\n+    if (stream.readable === false) throw new Error('encryption error. empty stream');\n+    const aes = createCipheriv(this.algo, this.getKey(), bIv);\n+    stream.pipe(aes).pipe(output);\n+    return {\n+      stream: output,\n+      metadata: bIv,\n+      metadataLength: AesCbcCryptor.BLOCK_SIZE,\n+    };\n+  }\n+\n+  async decryptStream(encryptedStream: EncryptedStream) {\n+    const decryptedStream = new PassThrough();\n+    let bIv = Buffer.alloc(0);\n+    let aes: any = null;\n+    const onReadable = () => {\n+      let data = encryptedStream.stream.read();\n+      while (data !== null) {\n+        if (data) {\n+          const bChunk = Buffer.from(data);\n+          const sliceLen = encryptedStream.metadataLength - bIv.byteLength;\n+          if (bChunk.byteLength < sliceLen) {\n+            bIv = Buffer.concat([bIv, bChunk]);\n+          } else {\n+            bIv = Buffer.concat([bIv, bChunk.slice(0, sliceLen)]);\n+            aes = createDecipheriv(this.algo, this.getKey(), bIv);\n+            aes.pipe(decryptedStream);\n+            aes.write(bChunk.slice(sliceLen));\n+          }\n+        }\n+        data = encryptedStream.stream.read();\n+      }\n+    };\n+    encryptedStream.stream.on('readable', onReadable);\n+    encryptedStream.stream.on('end', () => {\n+      if (aes) {\n+        aes.end();\n+      }\n+      decryptedStream.end();\n+    });\n+    return decryptedStream;\n+  }\n+}"
        },
        {
            "filename": "src/crypto/modules/NodeCryptoModule/legacyCryptor.ts",
            "diff": "@@ -0,0 +1,41 @@\n+import Crypto from '../../../core/components/cryptography/index';\n+import { encode } from '../../../core/components/base64_codec';\n+import FileCryptor from '../node';\n+import { EncryptedDataType } from './ICryptor';\n+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';\n+\n+export default class LegacyCryptor implements ILegacyCryptor<PubNubFileType> {\n+  config;\n+\n+  cryptor;\n+  fileCryptor;\n+\n+  constructor(config: any) {\n+    this.config = config;\n+    this.cryptor = new Crypto({ config });\n+    this.fileCryptor = new FileCryptor();\n+  }\n+  get identifier() {\n+    return '';\n+  }\n+  encrypt(data: string) {\n+    if (data.length === 0) throw new Error('encryption error. empty content');\n+    return {\n+      data: this.cryptor.encrypt(data),\n+      metadata: null,\n+    };\n+  }\n+\n+  decrypt(encryptedData: EncryptedDataType) {\n+    const data = typeof encryptedData.data === 'string' ? encryptedData.data : encode(encryptedData.data);\n+    return this.cryptor.decrypt(data);\n+  }\n+\n+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    return this.fileCryptor.encryptFile(this.config.cipherKey, file, File);\n+  }\n+\n+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    return this.fileCryptor.decryptFile(this.config.cipherKey, file, File);\n+  }\n+}"
        },
        {
            "filename": "src/crypto/modules/NodeCryptoModule/nodeCryptoModule.ts",
            "diff": "@@ -0,0 +1,350 @@\n+import { Readable, PassThrough } from 'stream';\n+import { decode } from '../../../core/components/base64_codec';\n+import LegacyCryptor from './legacyCryptor';\n+import AesCbcCryptor from './aesCbcCryptor';\n+import { ICryptor } from './ICryptor';\n+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';\n+\n+export { LegacyCryptor, AesCbcCryptor };\n+\n+type CryptorType = ICryptor | ILegacyCryptor<PubNubFileType>;\n+\n+type CryptoModuleConfiguration = {\n+  default: CryptorType;\n+  cryptors?: Array<CryptorType>;\n+};\n+\n+export class CryptoModule {\n+  static LEGACY_IDENTIFIER = '';\n+\n+  defaultCryptor: CryptorType;\n+  cryptors: Array<CryptorType>;\n+\n+  constructor(cryptoModuleConfiguration: CryptoModuleConfiguration) {\n+    this.defaultCryptor = cryptoModuleConfiguration.default;\n+    this.cryptors = cryptoModuleConfiguration.cryptors ?? [];\n+  }\n+\n+  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+  // @ts-ignore: type detection issue with old Config type assignment\n+  static legacyCryptoModule(config) {\n+    return new this({\n+      default: new LegacyCryptor({\n+        cipherKey: config.cipherKey,\n+        useRandomIVs: config.useRandomIVs ?? true,\n+      }),\n+      cryptors: [new AesCbcCryptor({ cipherKey: config.cipherKey })],\n+    });\n+  }\n+\n+  static aesCbcCryptoModule(config: any) {\n+    return new this({\n+      default: new AesCbcCryptor({ cipherKey: config.cipherKey }),\n+      cryptors: [\n+        new LegacyCryptor({\n+          cipherKey: config.cipherKey,\n+          useRandomIVs: config.useRandomIVs ?? true,\n+        }),\n+      ],\n+    });\n+  }\n+  static withDefaultCryptor(defaultCryptor: CryptorType) {\n+    return new this({ default: defaultCryptor });\n+  }\n+\n+  private getAllCryptors() {\n+    return [this.defaultCryptor, ...this.cryptors];\n+  }\n+\n+  private getLegacyCryptor() {\n+    return this.getAllCryptors().find((c) => c.identifier === '');\n+  }\n+\n+  encrypt(data: ArrayBuffer | string) {\n+    const encrypted = this.defaultCryptor.encrypt(data);\n+    if (!encrypted.metadata) return encrypted.data;\n+\n+    const header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);\n+\n+    const headerData = new Uint8Array(header!.length);\n+    let pos = 0;\n+    headerData.set(header!.data, pos);\n+    pos = header!.length - encrypted.metadata.length;\n+    headerData.set(encrypted.metadata, pos);\n+    return Buffer.concat([headerData, Buffer.from(encrypted.data)]);\n+  }\n+\n+  decrypt(data: ArrayBuffer | string) {\n+    const encryptedData = Buffer.from(typeof data === 'string' ? decode(data) : data);\n+    const header = CryptorHeader.tryParse(encryptedData);\n+    const cryptor = this.getCryptor(header);\n+    const metadata =\n+      header.length > 0\n+        ? encryptedData.slice(header.length - (header as CryptorHeaderV1).metadataLength, header.length)\n+        : null;\n+    if (encryptedData.slice(header.length).byteLength <= 0) throw new Error('decryption error. empty content');\n+    return cryptor!.decrypt({\n+      data: encryptedData.slice(header.length),\n+      metadata: metadata,\n+    });\n+  }\n+\n+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    /**\n+     * Files handled differently in case of Legacy cryptor.\n+     * (as long as we support legacy need to check on intsance type)\n+     */\n+    if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)\n+      return (this.defaultCryptor as ILegacyCryptor<PubNubFileType>).encryptFile(file, File);\n+    if (file.data instanceof Buffer) {\n+      return File.create({\n+        name: file.name,\n+        mimeType: 'application/octet-stream',\n+        data: Buffer.from(this.encrypt(file.data!) as Buffer),\n+      });\n+    }\n+    if (file.data instanceof Readable) {\n+      if (file.contentLength === 0) throw new Error('encryption error. empty content');\n+      const encryptedStream = await (this.defaultCryptor as ICryptor).encryptStream(file.data);\n+      const header = CryptorHeader.from(this.defaultCryptor.identifier, encryptedStream.metadata!);\n+      const payload = new Uint8Array(header!.length);\n+      let pos = 0;\n+      payload.set(header!.data, pos);\n+      pos += header!.length;\n+      if (encryptedStream.metadata) {\n+        pos -= encryptedStream.metadata.length;\n+        payload.set(encryptedStream.metadata, pos);\n+      }\n+      const output = new PassThrough();\n+      output.write(payload);\n+      encryptedStream.stream.pipe(output);\n+      return File.create({\n+        name: file.name,\n+        mimeType: 'application/octet-stream',\n+        stream: output,\n+      });\n+    }\n+  }\n+\n+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    if (file?.data instanceof Buffer) {\n+      const header = CryptorHeader.tryParse(file.data);\n+      const cryptor = this.getCryptor(header);\n+      /**\n+       * If It's legacyone then redirect it.\n+       * (as long as we support legacy need to check on instance type)\n+       */\n+      if (cryptor?.identifier === CryptoModule.LEGACY_IDENTIFIER)\n+        return (cryptor as ILegacyCryptor<PubNubFileType>).decryptFile(file, File);\n+      return File.create({\n+        name: file.name,\n+        data: Buffer.from(this.decrypt(file?.data) as ArrayBuffer),\n+      });\n+    }\n+\n+    if (file.data instanceof Readable) {\n+      const stream = file.data;\n+      return new Promise((resolve) => {\n+        stream.on('readable', () => resolve(this.onStreamReadable(stream, file, File)));\n+      });\n+    }\n+  }\n+\n+  private async onStreamReadable(stream: NodeJS.ReadableStream, file: PubNubFileType, File: PubNubFileType) {\n+    stream.removeAllListeners('readable');\n+    const magicBytes = stream.read(4);\n+    if (!CryptorHeader.isSentinel(magicBytes as Buffer)) {\n+      if (magicBytes === null) throw new Error('decryption error. empty content');\n+      stream.unshift(magicBytes);\n+      return this.decryptLegacyFileStream(stream, file, File);\n+    }\n+    const versionByte = stream.read(1);\n+    CryptorHeader.validateVersion(versionByte[0] as number);\n+    const identifier = stream.read(4);\n+    const cryptor = this.getCryptorFromId(CryptorHeader.tryGetIdentifier(identifier as Buffer));\n+    const headerSize = CryptorHeader.tryGetMetadataSizeFromStream(stream);\n+    if (file.contentLength <= CryptorHeader.MIN_HEADER_LEGTH + headerSize)\n+      throw new Error('decryption error. empty content');\n+    return File.create({\n+      name: file.name,\n+      mimeType: 'application/octet-stream',\n+      stream: await (cryptor as ICryptor).decryptStream({ stream: stream, metadataLength: headerSize as number }),\n+    });\n+  }\n+\n+  private async decryptLegacyFileStream(stream: NodeJS.ReadableStream, file: PubNubFileType, File: PubNubFileType) {\n+    if (file.contentLength <= 16) throw new Error('decryption error: empty content');\n+    const cryptor = this.getLegacyCryptor();\n+    if (cryptor) {\n+      return (cryptor as ILegacyCryptor<PubNubFileType>).decryptFile(\n+        File.create({\n+          name: file.name,\n+          stream: stream,\n+        }),\n+        File,\n+      );\n+    } else {\n+      throw new Error('unknown cryptor error');\n+    }\n+  }\n+\n+  private getCryptor(header: CryptorHeader) {\n+    if (header === '') {\n+      const cryptor = this.getAllCryptors().find((c) => c.identifier === '');\n+      if (cryptor) return cryptor;\n+      throw new Error('unknown cryptor error');\n+    } else if (header instanceof CryptorHeaderV1) {\n+      return this.getCryptorFromId(header.identifier);\n+    }\n+  }\n+\n+  private getCryptorFromId(id: string) {\n+    const cryptor = this.getAllCryptors().find((c) => id === c.identifier);\n+    if (cryptor) {\n+      return cryptor;\n+    }\n+    throw new Error('unknown cryptor error');\n+  }\n+}\n+\n+// CryptorHeader Utility\n+class CryptorHeader {\n+  static SENTINEL = 'PNED';\n+  static LEGACY_IDENTIFIER = '';\n+  static IDENTIFIER_LENGTH = 4;\n+  static VERSION = 1;\n+  static MAX_VERSION = 1;\n+  static MIN_HEADER_LEGTH = 10;\n+\n+  static from(id: string, metadata: Buffer) {\n+    if (id === CryptorHeader.LEGACY_IDENTIFIER) return;\n+    return new CryptorHeaderV1(id, metadata.length);\n+  }\n+\n+  static isSentinel(bytes: Buffer) {\n+    if (bytes && bytes.byteLength >= 4) {\n+      if (bytes.toString('utf8') == CryptorHeader.SENTINEL) return true;\n+    }\n+  }\n+\n+  static validateVersion(data: number) {\n+    if (data && data > CryptorHeader.MAX_VERSION) throw new Error('decryption error. invalid header version');\n+    return data;\n+  }\n+\n+  static tryGetIdentifier(data: Buffer) {\n+    if (data.byteLength < 4) {\n+      throw new Error('unknown cryptor error. decryption failed');\n+    } else {\n+      return data.toString('utf8');\n+    }\n+  }\n+\n+  static tryGetMetadataSizeFromStream(stream: NodeJS.ReadableStream) {\n+    const sizeBuf = stream.read(1);\n+    if (sizeBuf && (sizeBuf[0] as number) < 255) {\n+      return sizeBuf[0] as number;\n+    }\n+    if ((sizeBuf[0] as number) === 255) {\n+      const nextBuf = stream.read(2);\n+      if (nextBuf.length >= 2) {\n+        return new Uint16Array([nextBuf[0] as number, nextBuf[1] as number]).reduce((acc, val) => (acc << 8) + val, 0);\n+      }\n+    }\n+    throw new Error('decryption error. Invalid metadata size');\n+  }\n+  static tryParse(encryptedData: Buffer) {\n+    let sentinel: any = '';\n+    let version = null;\n+    if (encryptedData.length >= 4) {\n+      sentinel = encryptedData.slice(0, 4);\n+      if (sentinel.toString('utf8') !== CryptorHeader.SENTINEL) return '';\n+    }\n+\n+    if (encryptedData.length >= 5) {\n+      version = encryptedData[4];\n+    } else {\n+      throw new Error('decryption error. invalid header version');\n+    }\n+    if (version > CryptorHeader.MAX_VERSION) throw new Error('unknown cryptor error');\n+\n+    let identifier: Buffer;\n+    let pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;\n+    if (encryptedData.length >= pos) {\n+      identifier = encryptedData.slice(5, pos);\n+    } else {\n+      throw new Error('decryption error. invalid crypto identifier');\n+    }\n+    let metadataLength = null;\n+    if (encryptedData.length >= pos + 1) {\n+      metadataLength = encryptedData[pos];\n+    } else {\n+      throw new Error('decryption error. invalid metadata length');\n+    }\n+    pos += 1;\n+    if (metadataLength === 255 && encryptedData.length >= pos + 2) {\n+      metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce((acc, val) => (acc << 8) + val, 0);\n+      pos += 2;\n+    }\n+    return new CryptorHeaderV1(identifier.toString('utf8'), metadataLength);\n+  }\n+}\n+\n+// v1 CryptorHeader\n+class CryptorHeaderV1 {\n+  _identifier;\n+  _metadataLength;\n+\n+  constructor(id: string, metadataLength: number) {\n+    this._identifier = id;\n+    this._metadataLength = metadataLength;\n+  }\n+\n+  get identifier() {\n+    return this._identifier;\n+  }\n+\n+  set identifier(value) {\n+    this._identifier = value;\n+  }\n+\n+  get metadataLength() {\n+    return this._metadataLength;\n+  }\n+\n+  set metadataLength(value) {\n+    this._metadataLength = value;\n+  }\n+\n+  get version() {\n+    return CryptorHeader.VERSION;\n+  }\n+\n+  get length() {\n+    return (\n+      CryptorHeader.SENTINEL.length +\n+      1 +\n+      CryptorHeader.IDENTIFIER_LENGTH +\n+      (this.metadataLength < 255 ? 1 : 3) +\n+      this.metadataLength\n+    );\n+  }\n+\n+  get data() {\n+    let pos = 0;\n+    const header = new Uint8Array(this.length);\n+    header.set(Buffer.from(CryptorHeader.SENTINEL));\n+    pos += CryptorHeader.SENTINEL.length;\n+    header[pos] = this.version;\n+    pos++;\n+    if (this.identifier) header.set(Buffer.from(this.identifier), pos);\n+    pos += CryptorHeader.IDENTIFIER_LENGTH;\n+    const metadataLength = this.metadataLength;\n+    if (metadataLength < 255) {\n+      header[pos] = metadataLength;\n+    } else {\n+      header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);\n+    }\n+    return header;\n+  }\n+}"
        },
        {
            "filename": "src/crypto/modules/WebCryptoModule/ICryptor.ts",
            "diff": "@@ -0,0 +1,13 @@\n+export type EncryptedDataType = {\n+  data: ArrayBuffer;\n+  metadata: ArrayBuffer | null;\n+};\n+\n+export interface ICryptor {\n+  get identifier(): string;\n+  encrypt(data: ArrayBuffer | string): EncryptedDataType;\n+  decrypt(data: EncryptedDataType): ArrayBuffer;\n+\n+  encryptFileData(data: ArrayBuffer): Promise<EncryptedDataType>;\n+  decryptFileData(data: EncryptedDataType): Promise<ArrayBuffer>;\n+}"
        },
        {
            "filename": "src/crypto/modules/WebCryptoModule/ILegacyCryptor.ts",
            "diff": "@@ -0,0 +1,24 @@\n+import { EncryptedDataType } from './ICryptor';\n+\n+export type PubNubFileType = {\n+  data: File | Blob;\n+  name: string;\n+  mimeType: string;\n+\n+  create(config: any): PubNubFileType;\n+\n+  toArrayBuffer(): ArrayBuffer;\n+  toBlob(): Blob;\n+  toString(): string;\n+  toFile(): File;\n+};\n+\n+export interface ILegacyCryptor<T extends PubNubFileType> {\n+  get identifier(): string;\n+\n+  encrypt(data: ArrayBuffer | string): EncryptedDataType;\n+  decrypt(data: EncryptedDataType): ArrayBuffer | string;\n+\n+  encryptFile(file: T, File: T): Promise<T>;\n+  decryptFile(file: T, File: T): Promise<T>;\n+}"
        },
        {
            "filename": "src/crypto/modules/WebCryptoModule/aesCbcCryptor.ts",
            "diff": "@@ -0,0 +1,86 @@\n+import { ICryptor, EncryptedDataType } from './ICryptor';\n+import cryptoJS from '../../../core/components/cryptography/hmac-sha256';\n+import { decode } from '../../../core/components/base64_codec';\n+\n+export default class AesCbcCryptor implements ICryptor {\n+  static BLOCK_SIZE = 16;\n+  static encoder = new TextEncoder();\n+  static decoder = new TextDecoder();\n+\n+  cipherKey: string;\n+  encryptedKey: any;\n+  CryptoJS: any;\n+\n+  constructor(configuration: { cipherKey: string }) {\n+    this.cipherKey = configuration.cipherKey;\n+    this.CryptoJS = cryptoJS;\n+    this.encryptedKey = this.CryptoJS.SHA256(this.cipherKey);\n+  }\n+\n+  get algo() {\n+    return 'AES-CBC';\n+  }\n+\n+  get identifier() {\n+    return 'ACRH';\n+  }\n+\n+  private getIv() {\n+    return crypto.getRandomValues(new Uint8Array(AesCbcCryptor.BLOCK_SIZE));\n+  }\n+\n+  private async getKey() {\n+    const bKey = AesCbcCryptor.encoder.encode(this.cipherKey);\n+    const abHash = await crypto.subtle.digest('SHA-256', bKey.buffer);\n+    return crypto.subtle.importKey('raw', abHash, this.algo, true, ['encrypt', 'decrypt']);\n+  }\n+\n+  encrypt(data: ArrayBuffer | string) {\n+    const stringData = typeof data === 'string' ? data : AesCbcCryptor.decoder.decode(data);\n+    if (stringData.length === 0) throw new Error('encryption error. empty content');\n+    const abIv = this.getIv();\n+    return {\n+      metadata: abIv,\n+      data: decode(\n+        this.CryptoJS.AES.encrypt(data, this.encryptedKey, {\n+          iv: this.bufferToWordArray(abIv),\n+          mode: this.CryptoJS.mode.CBC,\n+        }).ciphertext.toString(this.CryptoJS.enc.Base64),\n+      ),\n+    };\n+  }\n+\n+  decrypt(encryptedData: EncryptedDataType) {\n+    const iv = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.metadata!));\n+    const data = this.bufferToWordArray(new Uint8ClampedArray(encryptedData.data));\n+    return AesCbcCryptor.encoder.encode(\n+      this.CryptoJS.AES.decrypt({ ciphertext: data }, this.encryptedKey, {\n+        iv,\n+        mode: this.CryptoJS.mode.CBC,\n+      }).toString(this.CryptoJS.enc.Utf8),\n+    ).buffer;\n+  }\n+\n+  async encryptFileData(data: ArrayBuffer): Promise<EncryptedDataType> {\n+    const key = await this.getKey();\n+    const iv = this.getIv();\n+    return {\n+      data: await crypto.subtle.encrypt({ name: this.algo, iv: iv }, key, data),\n+      metadata: iv,\n+    };\n+  }\n+\n+  async decryptFileData(encryptedData: EncryptedDataType): Promise<ArrayBuffer> {\n+    const key = await this.getKey();\n+    return crypto.subtle.decrypt({ name: this.algo, iv: encryptedData.metadata! }, key, encryptedData.data);\n+  }\n+\n+  private bufferToWordArray(b: any) {\n+    const wa: any[] = [];\n+    let i;\n+    for (i = 0; i < b.length; i += 1) {\n+      wa[(i / 4) | 0] |= b[i] << (24 - 8 * i);\n+    }\n+    return this.CryptoJS.lib.WordArray.create(wa, b.length);\n+  }\n+}"
        },
        {
            "filename": "src/crypto/modules/WebCryptoModule/legacyCryptor.ts",
            "diff": "@@ -0,0 +1,46 @@\n+import Crypto from '../../../core/components/cryptography/index';\n+import FileCryptor from '../web';\n+import { EncryptedDataType } from './ICryptor';\n+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';\n+import { encode } from '../../../core/components/base64_codec';\n+\n+export default class LegacyCryptor implements ILegacyCryptor<PubNubFileType> {\n+  config;\n+\n+  cryptor;\n+  fileCryptor;\n+\n+  constructor(config: any) {\n+    this.config = config;\n+    this.cryptor = new Crypto({ config });\n+    this.fileCryptor = new FileCryptor();\n+  }\n+\n+  get identifier() {\n+    return '';\n+  }\n+  encrypt(data: ArrayBuffer | string) {\n+    const stringData = typeof data === 'string' ? data : new TextDecoder().decode(data);\n+    return {\n+      data: this.cryptor.encrypt(stringData),\n+      metadata: null,\n+    };\n+  }\n+\n+  decrypt(encryptedData: EncryptedDataType) {\n+    const data = typeof encryptedData.data === 'string' ? encryptedData.data : encode(encryptedData.data);\n+    return this.cryptor.decrypt(data);\n+  }\n+\n+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+    //@ts-ignore: can not detect cipherKey from old Config\n+    return this.fileCryptor.encryptFile(this.config?.cipherKey, file, File);\n+  }\n+\n+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+    //@ts-ignore: can not detect cipherKey from old Config\n+    return this.fileCryptor.decryptFile(this.config.cipherKey, file, File);\n+  }\n+}"
        },
        {
            "filename": "src/crypto/modules/WebCryptoModule/webCryptoModule.ts",
            "diff": "@@ -0,0 +1,273 @@\n+import LegacyCryptor from './legacyCryptor';\n+import AesCbcCryptor from './aesCbcCryptor';\n+import { EncryptedDataType, ICryptor } from './ICryptor';\n+import { ILegacyCryptor, PubNubFileType } from './ILegacyCryptor';\n+import { decode } from '../../../core/components/base64_codec';\n+\n+export { LegacyCryptor, AesCbcCryptor };\n+\n+type CryptorType = ICryptor | ILegacyCryptor<PubNubFileType>;\n+\n+type CryptoModuleConfiguration = {\n+  default: CryptorType;\n+  cryptors?: Array<CryptorType>;\n+};\n+\n+export class CryptoModule {\n+  static LEGACY_IDENTIFIER = '';\n+  static encoder = new TextEncoder();\n+  static decoder = new TextDecoder();\n+  defaultCryptor: CryptorType;\n+  cryptors: Array<CryptorType>;\n+\n+  constructor(cryptoModuleConfiguration: CryptoModuleConfiguration) {\n+    this.defaultCryptor = cryptoModuleConfiguration.default;\n+    this.cryptors = cryptoModuleConfiguration.cryptors ?? [];\n+  }\n+\n+  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n+  //@ts-ignore: type detection issue with old Config type assignment\n+  static legacyCryptoModule(config) {\n+    return new this({\n+      default: new LegacyCryptor({\n+        cipherKey: config.cipherKey,\n+        useRandomIVs: config.useRandomIVs ?? true,\n+      }),\n+      cryptors: [new AesCbcCryptor({ cipherKey: config.cipherKey })],\n+    });\n+  }\n+\n+  static aesCbcCryptoModule(config: any) {\n+    return new this({\n+      default: new AesCbcCryptor({ cipherKey: config.cipherKey }),\n+      cryptors: [\n+        new LegacyCryptor({\n+          cipherKey: config.cipherKey,\n+          useRandomIVs: config.useRandomIVs ?? true,\n+        }),\n+      ],\n+    });\n+  }\n+\n+  static withDefaultCryptor(defaultCryptor: CryptorType) {\n+    return new this({ default: defaultCryptor });\n+  }\n+\n+  private getAllCryptors() {\n+    return [this.defaultCryptor, ...this.cryptors];\n+  }\n+\n+  encrypt(data: ArrayBuffer | string) {\n+    const encrypted = (this.defaultCryptor as ICryptor).encrypt(data);\n+    if (!encrypted.metadata) return encrypted.data;\n+    const headerData = this.getHeaderData(encrypted);\n+    return this.concatArrayBuffer(headerData!, encrypted.data);\n+  }\n+\n+  decrypt(data: ArrayBuffer | string) {\n+    const encryptedData = typeof data === 'string' ? decode(data) : data;\n+    const header = CryptorHeader.tryParse(encryptedData);\n+    const cryptor = this.getCryptor(header);\n+    const metadata =\n+      header.length > 0\n+        ? encryptedData.slice(header.length - (header as CryptorHeaderV1).metadataLength, header.length)\n+        : null;\n+    if (encryptedData.slice(header.length).byteLength <= 0) throw new Error('decryption error. empty content');\n+    return cryptor!.decrypt({\n+      data: encryptedData.slice(header.length),\n+      metadata: metadata,\n+    });\n+  }\n+\n+  async encryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    if (this.defaultCryptor.identifier === CryptorHeader.LEGACY_IDENTIFIER)\n+      return (this.defaultCryptor as ILegacyCryptor<PubNubFileType>).encryptFile(file, File);\n+    const fileData = this.getFileData(file.data);\n+    const encrypted = await (this.defaultCryptor as ICryptor).encryptFileData(fileData);\n+    return File.create({\n+      name: file.name,\n+      mimeType: 'application/octet-stream',\n+      data: this.concatArrayBuffer(this.getHeaderData(encrypted)!, encrypted.data),\n+    });\n+  }\n+\n+  async decryptFile(file: PubNubFileType, File: PubNubFileType) {\n+    const data = await file.data.arrayBuffer();\n+    const header = CryptorHeader.tryParse(data);\n+    const cryptor = this.getCryptor(header);\n+    if (cryptor?.identifier === CryptoModule.LEGACY_IDENTIFIER) {\n+      return (cryptor as ILegacyCryptor<PubNubFileType>).decryptFile(file, File);\n+    }\n+    const fileData = this.getFileData(data);\n+    const metadata = fileData.slice(header.length - (header as CryptorHeaderV1).metadataLength, header.length);\n+    return File.create({\n+      name: file.name,\n+      data: await (this.defaultCryptor as ICryptor).decryptFileData({\n+        data: data.slice(header.length),\n+        metadata: metadata,\n+      }),\n+    });\n+  }\n+\n+  private getCryptor(header: string | CryptorHeaderV1) {\n+    if (header === '') {\n+      const cryptor = this.getAllCryptors().find((c) => c.identifier === '');\n+      if (cryptor) return cryptor;\n+      throw new Error('unknown cryptor error');\n+    } else if (header instanceof CryptorHeaderV1) {\n+      return this.getCryptorFromId(header.identifier);\n+    }\n+  }\n+\n+  private getCryptorFromId(id: string) {\n+    const cryptor = this.getAllCryptors().find((c) => id === c.identifier);\n+    if (cryptor) {\n+      return cryptor;\n+    }\n+    throw Error('unknown cryptor error');\n+  }\n+\n+  private concatArrayBuffer(ab1: ArrayBuffer, ab2: ArrayBuffer) {\n+    const tmp = new Uint8Array(ab1.byteLength + ab2.byteLength);\n+\n+    tmp.set(new Uint8Array(ab1), 0);\n+    tmp.set(new Uint8Array(ab2), ab1.byteLength);\n+\n+    return tmp.buffer;\n+  }\n+\n+  private getHeaderData(encrypted: EncryptedDataType) {\n+    if (!encrypted.metadata) return;\n+    const header = CryptorHeader.from(this.defaultCryptor.identifier, encrypted.metadata);\n+    const headerData = new Uint8Array(header!.length);\n+    let pos = 0;\n+    headerData.set(header!.data, pos);\n+    pos += header!.length - encrypted.metadata.byteLength;\n+    headerData.set(new Uint8Array(encrypted.metadata), pos);\n+    return headerData.buffer;\n+  }\n+\n+  private getFileData(input: any) {\n+    if (input instanceof ArrayBuffer) {\n+      return input;\n+    }\n+    if (typeof input === 'string') {\n+      return CryptoModule.encoder.encode(input);\n+    }\n+    throw new Error('Cannot decrypt/encrypt file. In browsers file decryption supports only string or ArrayBuffer');\n+  }\n+}\n+\n+// CryptorHeader Utility\n+class CryptorHeader {\n+  static SENTINEL = 'PNED';\n+  static LEGACY_IDENTIFIER = '';\n+  static IDENTIFIER_LENGTH = 4;\n+  static VERSION = 1;\n+  static MAX_VERSION = 1;\n+  static decoder = new TextDecoder();\n+\n+  static from(id: string, metadata: ArrayBuffer) {\n+    if (id === CryptorHeader.LEGACY_IDENTIFIER) return;\n+    return new CryptorHeaderV1(id, metadata.byteLength);\n+  }\n+\n+  static tryParse(data: ArrayBuffer) {\n+    const encryptedData = new Uint8Array(data);\n+    let sentinel: any = '';\n+    let version = null;\n+    if (encryptedData.byteLength >= 4) {\n+      sentinel = encryptedData.slice(0, 4);\n+      if (this.decoder.decode(sentinel) !== CryptorHeader.SENTINEL) return '';\n+    }\n+    if (encryptedData.byteLength >= 5) {\n+      version = (encryptedData as Uint8Array)[4] as number;\n+    } else {\n+      throw new Error('decryption error. invalid header version');\n+    }\n+    if (version > CryptorHeader.MAX_VERSION) throw new Error('unknown cryptor error');\n+\n+    let identifier: any = '';\n+    let pos = 5 + CryptorHeader.IDENTIFIER_LENGTH;\n+    if (encryptedData.byteLength >= pos) {\n+      identifier = encryptedData.slice(5, pos);\n+    } else {\n+      throw new Error('decryption error. invalid crypto identifier');\n+    }\n+    let metadataLength = null;\n+    if (encryptedData.byteLength >= pos + 1) {\n+      metadataLength = (encryptedData as Uint8Array)[pos];\n+    } else {\n+      throw new Error('decryption error. invalid metadata length');\n+    }\n+    pos += 1;\n+    if (metadataLength === 255 && encryptedData.byteLength >= pos + 2) {\n+      metadataLength = new Uint16Array(encryptedData.slice(pos, pos + 2)).reduce((acc, val) => (acc << 8) + val, 0);\n+      pos += 2;\n+    }\n+    return new CryptorHeaderV1(this.decoder.decode(identifier), metadataLength);\n+  }\n+}\n+\n+// v1 CryptorHeader\n+class CryptorHeaderV1 {\n+  static IDENTIFIER_LENGTH = 4;\n+  static SENTINEL = 'PNED';\n+\n+  _identifier;\n+  _metadataLength;\n+\n+  constructor(id: string, metadataLength: number) {\n+    this._identifier = id;\n+    this._metadataLength = metadataLength;\n+  }\n+\n+  get identifier() {\n+    return this._identifier;\n+  }\n+\n+  set identifier(value) {\n+    this._identifier = value;\n+  }\n+\n+  get metadataLength() {\n+    return this._metadataLength;\n+  }\n+\n+  set metadataLength(value) {\n+    this._metadataLength = value;\n+  }\n+\n+  get version() {\n+    return CryptorHeader.VERSION;\n+  }\n+\n+  get length() {\n+    return (\n+      CryptorHeader.SENTINEL.length +\n+      1 +\n+      CryptorHeader.IDENTIFIER_LENGTH +\n+      (this.metadataLength < 255 ? 1 : 3) +\n+      this.metadataLength\n+    );\n+  }\n+\n+  get data() {\n+    let pos = 0;\n+    const header = new Uint8Array(this.length);\n+    const encoder = new TextEncoder();\n+    header.set(encoder.encode(CryptorHeader.SENTINEL));\n+    pos += CryptorHeader.SENTINEL.length;\n+    header[pos] = this.version;\n+    pos++;\n+    if (this.identifier) header.set(encoder.encode(this.identifier), pos);\n+    pos += CryptorHeader.IDENTIFIER_LENGTH;\n+    const metadataLength = this.metadataLength;\n+    if (metadataLength < 255) {\n+      header[pos] = metadataLength;\n+    } else {\n+      header.set([255, metadataLength >> 8, metadataLength & 0xff], pos);\n+    }\n+    return header;\n+  }\n+}"
        },
        {
            "filename": "src/crypto/modules/node.js",
            "diff": "@@ -1,5 +1,5 @@\n /**       */\n-import { Readable, PassThrough } from 'stream';\n+import { Readable, PassThrough, Transform } from 'stream';\n import { createCipheriv, createDecipheriv, createHash, randomBytes } from 'crypto';\n \n export default class NodeCryptography {\n@@ -41,13 +41,15 @@ export default class NodeCryptography {\n     const bKey = this.getKey(key);\n \n     if (file.data instanceof Buffer) {\n+      if (file.data.byteLength <= 0) throw new Error('encryption error. empty content');\n       return File.create({\n         name: file.name,\n         mimeType: 'application/octet-stream',\n         data: await this.encryptBuffer(bKey, file.data),\n       });\n     }\n     if (file.data instanceof Readable) {\n+      if (file.contentLength === 0) throw new Error('encryption error. empty content');\n       return File.create({\n         name: file.name,\n         mimeType: 'application/octet-stream',\n@@ -118,22 +120,29 @@ export default class NodeCryptography {\n   decryptBuffer(key, ciphertext) {\n     const bIv = ciphertext.slice(0, NodeCryptography.IV_LENGTH);\n     const bCiphertext = ciphertext.slice(NodeCryptography.IV_LENGTH);\n-\n+    if (bCiphertext.byteLength <= 0) throw new Error('decryption error: empty content');\n     const aes = createDecipheriv(this.algo, key, bIv);\n \n     return Buffer.concat([aes.update(bCiphertext), aes.final()]);\n   }\n \n-  encryptStream(key, stream) {\n-    const output = new PassThrough();\n+  async encryptStream(key, stream) {\n     const bIv = this.getIv();\n-\n-    const aes = createCipheriv(this.algo, key, bIv);\n-\n-    output.write(bIv);\n-    stream.pipe(aes).pipe(output);\n-\n-    return output;\n+    const aes = createCipheriv('aes-256-cbc', key, bIv).setAutoPadding(true);\n+    let inited = false;\n+    return stream.pipe(aes).pipe(\n+      new Transform({\n+        transform(chunk, _, cb) {\n+          if (!inited) {\n+            inited = true;\n+            this.push(Buffer.concat([bIv, chunk]));\n+          } else {\n+            this.push(chunk);\n+          }\n+          cb();\n+        },\n+      }),\n+    );\n   }\n \n   decryptStream(key, stream) {"
        },
        {
            "filename": "src/crypto/modules/web.js",
            "diff": "@@ -11,6 +11,8 @@ function concatArrayBuffer(ab1, ab2) {\n \n export default class WebCryptography {\n   static IV_LENGTH = 16;\n+  static encoder = new TextEncoder();\n+  static decoder = new TextDecoder();\n \n   get algo() {\n     return 'aes-256-cbc';\n@@ -30,7 +32,6 @@ export default class WebCryptography {\n \n   async decrypt(key, input) {\n     const cKey = await this.getKey(key);\n-\n     if (input instanceof ArrayBuffer) {\n       return this.decryptArrayBuffer(cKey, input);\n     }\n@@ -41,9 +42,10 @@ export default class WebCryptography {\n   }\n \n   async encryptFile(key, file, File) {\n+    if (file.data.byteLength <= 0) throw new Error('encryption error. empty content');\n     const bKey = await this.getKey(key);\n \n-    const abPlaindata = await file.toArrayBuffer();\n+    const abPlaindata = await file.data.arrayBuffer();\n \n     const abCipherdata = await this.encryptArrayBuffer(bKey, abPlaindata);\n \n@@ -57,8 +59,7 @@ export default class WebCryptography {\n   async decryptFile(key, file, File) {\n     const bKey = await this.getKey(key);\n \n-    const abCipherdata = await file.toArrayBuffer();\n-\n+    const abCipherdata = await file.data.arrayBuffer();\n     const abPlaindata = await this.decryptArrayBuffer(bKey, abCipherdata);\n \n     return File.create({\n@@ -68,11 +69,11 @@ export default class WebCryptography {\n   }\n \n   async getKey(key) {\n-    const bKey = Buffer.from(key);\n-    const abHash = await crypto.subtle.digest('SHA-256', bKey.buffer);\n-\n-    const abKey = Buffer.from(Buffer.from(abHash).toString('hex').slice(0, 32), 'utf8').buffer;\n-\n+    const digest = await crypto.subtle.digest('SHA-256', WebCryptography.encoder.encode(key));\n+    const hashHex = Array.from(new Uint8Array(digest))\n+      .map((b) => b.toString(16).padStart(2, '0'))\n+      .join('');\n+    const abKey = WebCryptography.encoder.encode(hashHex.slice(0, 32)).buffer;\n     return crypto.subtle.importKey('raw', abKey, 'AES-CBC', true, ['encrypt', 'decrypt']);\n   }\n \n@@ -84,28 +85,33 @@ export default class WebCryptography {\n \n   async decryptArrayBuffer(key, ciphertext) {\n     const abIv = ciphertext.slice(0, 16);\n-\n-    return crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, ciphertext.slice(16));\n+    if (ciphertext.slice(WebCryptography.IV_LENGTH).byteLength <= 0) throw new Error('decryption error: empty content');\n+    const data = await crypto.subtle.decrypt(\n+      { name: 'AES-CBC', iv: abIv },\n+      key,\n+      ciphertext.slice(WebCryptography.IV_LENGTH),\n+    );\n+    return data;\n   }\n \n   async encryptString(key, plaintext) {\n     const abIv = crypto.getRandomValues(new Uint8Array(16));\n \n-    const abPlaintext = Buffer.from(plaintext).buffer;\n+    const abPlaintext = WebCryptography.encoder.encode(plaintext).buffer;\n     const abPayload = await crypto.subtle.encrypt({ name: 'AES-CBC', iv: abIv }, key, abPlaintext);\n \n     const ciphertext = concatArrayBuffer(abIv.buffer, abPayload);\n \n-    return Buffer.from(ciphertext).toString('utf8');\n+    return WebCryptography.decoder.decode(ciphertext);\n   }\n \n   async decryptString(key, ciphertext) {\n-    const abCiphertext = Buffer.from(ciphertext);\n+    const abCiphertext = WebCryptography.encoder.encode(ciphertext).buffer;\n     const abIv = abCiphertext.slice(0, 16);\n     const abPayload = abCiphertext.slice(16);\n \n     const abPlaintext = await crypto.subtle.decrypt({ name: 'AES-CBC', iv: abIv }, key, abPayload);\n \n-    return Buffer.from(abPlaintext).toString('utf8');\n+    return WebCryptography.decoder.decode(abPlaintext);\n   }\n }"
        },
        {
            "filename": "src/file/modules/node.js",
            "diff": "@@ -1,11 +1,7 @@\n-/**       */\n-\n import { Readable, PassThrough } from 'stream';\n-import { ReadStream } from 'fs';\n+import fs from 'fs';\n import { basename } from 'path';\n \n-import { IFile, FileClass } from '..';\n-\n const PubNubFile = class PubNubFile {\n   static supportsBlob = false;\n \n@@ -29,6 +25,8 @@ const PubNubFile = class PubNubFile {\n \n   mimeType;\n \n+  contentLength;\n+\n   static create(config) {\n     return new this(config);\n   }\n@@ -37,9 +35,10 @@ const PubNubFile = class PubNubFile {\n     if (stream instanceof Readable) {\n       this.data = stream;\n \n-      if (stream instanceof ReadStream) {\n+      if (stream instanceof fs.ReadStream) {\n         // $FlowFixMe: incomplete flow node definitions\n         this.name = basename(stream.path);\n+        this.contentLength = fs.statSync(stream.path).size;\n       }\n     } else if (data instanceof Buffer) {\n       this.data = Buffer.from(data);"
        },
        {
            "filename": "src/node/index.ts",
            "diff": "@@ -8,8 +8,10 @@ import { keepAlive, proxy } from '../networking/modules/node';\n \n import NodeCryptography from '../crypto/modules/node';\n import PubNubFile from '../file/modules/node';\n+import { CryptoModule, LegacyCryptor, AesCbcCryptor } from '../crypto/modules/NodeCryptoModule/nodeCryptoModule';\n \n export = class extends PubNubCore {\n+  static CryptoModule = CryptoModule;\n   constructor(setup: any) {\n     setup.cbor = new Cbor((buffer: ArrayBuffer) => CborReader.decode(Buffer.from(buffer)), decode);\n     setup.networking = new Networking({\n@@ -27,6 +29,16 @@ export = class extends PubNubCore {\n     setup.PubNubFile = PubNubFile;\n     setup.cryptography = new NodeCryptography();\n \n+    setup.initCryptoModule = (cryptoConfiguration: any) => {\n+      return new CryptoModule({\n+        default: new LegacyCryptor({\n+          cipherKey: cryptoConfiguration.cipherKey,\n+          useRandomIVs: cryptoConfiguration.useRandomIVs,\n+        }),\n+        cryptors: [new AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],\n+      });\n+    };\n+\n     if (!('ssl' in setup)) {\n       setup.ssl = true;\n     }"
        },
        {
            "filename": "src/web/index.js",
            "diff": "@@ -11,6 +11,7 @@ import { del, get, post, patch, getfile, postfile } from '../networking/modules/\n \n import WebCryptography from '../crypto/modules/web';\n import PubNubFile from '../file/modules/web';\n+import { CryptoModule, LegacyCryptor, AesCbcCryptor } from '../crypto/modules/WebCryptoModule/webCryptoModule';\n \n function sendBeacon(url) {\n   if (navigator && navigator.sendBeacon) {\n@@ -21,10 +22,10 @@ function sendBeacon(url) {\n }\n \n export default class extends PubNubCore {\n+  static CryptoModule = CryptoModule;\n   constructor(setup) {\n     // extract config.\n     const { listenToBrowserNetworkEvents = true } = setup;\n-\n     setup.sdkFamily = 'Web';\n     setup.networking = new Networking({\n       del,\n@@ -40,6 +41,16 @@ export default class extends PubNubCore {\n     setup.PubNubFile = PubNubFile;\n     setup.cryptography = new WebCryptography();\n \n+    setup.initCryptoModule = (cryptoConfiguration) => {\n+      return new CryptoModule({\n+        default: new LegacyCryptor({\n+          cipherKey: cryptoConfiguration.cipherKey,\n+          useRandomIVs: cryptoConfiguration.useRandomIVs,\n+        }),\n+        cryptors: [new AesCbcCryptor({ cipherKey: cryptoConfiguration.cipherKey })],\n+      });\n+    };\n+\n     super(setup);\n \n     if (listenToBrowserNetworkEvents) {"
        },
        {
            "filename": "test/contract/steps/cryptoModule/cryptoModule.ts",
            "diff": "@@ -0,0 +1,178 @@\n+import { Given, When, Then, Before } from '@cucumber/cucumber';\n+import { expect } from 'chai';\n+import fs from 'fs';\n+\n+import {\n+  CryptoModule,\n+  AesCbcCryptor,\n+  LegacyCryptor,\n+} from '../../../../lib/crypto/modules/NodeCryptoModule/nodeCryptoModule.js';\n+\n+Before(function () {\n+  this.useRandomIVs = true;\n+});\n+\n+Given('Crypto module with {string} cryptor', function (cryptorIdentifier: string) {\n+  this.cryptorIdentifier = cryptorIdentifier;\n+});\n+\n+Given(\n+  'Crypto module with default {string} and additional {string} cryptors',\n+  function (defaultCryptorId: string, additionalCryptorId: string) {\n+    this.defaultCryptorId = defaultCryptorId;\n+    this.additionalCryptorId = additionalCryptorId;\n+  },\n+);\n+\n+Given('with {string} cipher key', function (cipherKey: string) {\n+  this.cipherKey = cipherKey;\n+});\n+\n+Given('with {string} vector', function (vector: string) {\n+  if (vector === 'constant') this.useRandomIVs = false;\n+  this._initCryptor = (id: string) => {\n+    return id === 'legacy'\n+      ? new LegacyCryptor({ cipherKey: this.cipherKey, useRandomIVs: this.useRandomIVs })\n+      : new AesCbcCryptor({ cipherKey: this.cipherKey });\n+  };\n+});\n+\n+When('I decrypt {string} file', async function (fileName: string) {\n+  if (this.cryptorIdentifier === 'acrh') {\n+    const cryptor = new AesCbcCryptor({ cipherKey: this.cipherKey });\n+    this.cryptoModule = CryptoModule.withDefaultCryptor(cryptor);\n+  }\n+  const pubnub = await this.getPubnub({ subscribeKey: 'key' });\n+  const fileData = fs.readFileSync(this.getFilePath(fileName));\n+  const file = pubnub.File.create({\n+    name: fileName,\n+    mimeType: 'text/plain',\n+    data: fileData,\n+  });\n+  try {\n+    const result = await this.cryptoModule.decryptFile(file, pubnub.File);\n+  } catch (e: any) {\n+    this.errorMessage = e?.message;\n+  }\n+});\n+\n+When('I decrypt {string} file as {string}', async function (fileName: string, format: string) {\n+  if (this.defaultCryptorId && this.additionalCryptorId) {\n+    this.cryptoModule = new CryptoModule({\n+      default: this._initCryptor(this.defaultCryptorId),\n+      cryptors: [this._initCryptor(this.additionalCryptorId)],\n+    });\n+  } else {\n+    this.cryptoModule = CryptoModule.withDefaultCryptor(this._initCryptor(this.cryptorIdentifier));\n+  }\n+\n+  const pubnub = await this.getPubnub({ subscribeKey: 'key' });\n+\n+  if (format === 'binary') {\n+    this.isBinary = true;\n+    if (!this.useRandomIVs) return;\n+    let encrypteFile = pubnub.File.create({\n+      name: fileName,\n+      data: fs.readFileSync(this.getFilePath(fileName)),\n+    });\n+    try {\n+      this.binaryFileResult = await this.cryptoModule.decryptFile(encrypteFile, pubnub.File);\n+    } catch (e: any) {\n+      this.errorMessage = e?.message;\n+    }\n+  } else if (format === 'stream') {\n+    this.isStream = true;\n+    const filestream = fs.createReadStream(this.getFilePath(fileName));\n+    this.file = pubnub.File.create({\n+      name: fileName,\n+      stream: filestream,\n+    });\n+    try {\n+      this.streamFileResult = await this.cryptoModule.decryptFile(this.file, pubnub.File);\n+    } catch (e: any) {\n+      this.errorMessage = e?.message;\n+    }\n+  }\n+});\n+\n+Then('Decrypted file content equal to the {string} file content', async function (sourceFile: string) {\n+  if (this.isBinary && !this.useRandomIVs) return;\n+  if (this.isStream) {\n+    const fileStream = await this.streamFileResult.toStream();\n+    const tempFilePath = `${__dirname}/${this.file.name}`;\n+    const outputStream = fs.createWriteStream(tempFilePath);\n+    const expected = fs.readFileSync(this.getFilePath(sourceFile));\n+    fileStream.pipe(outputStream);\n+    return new Promise((resolve) => {\n+      outputStream.on('finish', () => {\n+        try {\n+          const actual = fs.readFileSync(tempFilePath);\n+          expect(Buffer.compare(actual, expected.slice(0, actual.length)) === 0).to.be.true;\n+        } finally {\n+          fs.unlink(tempFilePath, () => {});\n+        }\n+        resolve(0);\n+      });\n+    });\n+  }\n+  expect(this.binaryFileResult.data.equals(fs.readFileSync(this.getFilePath(sourceFile)))).to.be.true;\n+});\n+\n+Then('I receive {string}', async function (result: string) {\n+  if ((this.isBinaryFile || this.isBinary) && !this.useRandomIVs) return;\n+  if (result === 'success') {\n+    expect(this.errorMessage).to.be.undefined;\n+  } else {\n+    expect(this.errorMessage).to.have.string(result);\n+  }\n+});\n+\n+Given('Legacy code with {string} cipher key and {string} vector', function (cipherKey: string, vector: string) {\n+  const cryptor = new LegacyCryptor({ cipherKey: cipherKey, useRandomIVs: vector === 'random' ? true : false });\n+  this.cryptoModule = CryptoModule.withDefaultCryptor(cryptor);\n+});\n+\n+When('I encrypt {string} file as {string}', async function (fileName: string, format: string) {\n+  this.pubnub = await this.getPubnub({ subscribeKey: 'key' });\n+  this.fileDataBuffer = fs.readFileSync(this.getFilePath(fileName));\n+  if (format === 'stream') {\n+    this.file = this.pubnub.File.create({\n+      name: fileName,\n+      mimeType: 'application/octet-stream',\n+      stream: fs.createReadStream(this.getFilePath(fileName)),\n+    });\n+    this.isStream = true;\n+  } else {\n+    this.file = this.pubnub.File.create({\n+      name: fileName,\n+      mimeType: 'application/octet-stream',\n+      data: this.fileDataBuffer,\n+    });\n+    this.isBinaryFile = true;\n+  }\n+  if (!this.cryptoModule) {\n+    this.cryptoModule = CryptoModule.withDefaultCryptor(this._initCryptor(this.cryptorIdentifier));\n+  }\n+  try {\n+    this.encryptedFile = await this.cryptoModule.encryptFile(this.file, this.pubnub.File);\n+  } catch (e: any) {\n+    this.errorMessage = e?.message;\n+  }\n+});\n+\n+Then('Successfully decrypt an encrypted file with legacy code', async function () {\n+  const decryptedFile = await this.cryptoModule.decryptFile(this.encryptedFile, this.pubnub.File);\n+  if (this.isStream) {\n+    const fileStream = await decryptedFile.toStream();\n+    const tempFilePath = `${__dirname}/${this.file.name}`;\n+    const outputStream = fs.createWriteStream(tempFilePath);\n+    fileStream.pipe(outputStream);\n+    outputStream.on('end', () => {\n+      const actualFileBuffer = fs.readFileSync(tempFilePath);\n+      expect(actualFileBuffer).to.equalBytes(this.fileDataBuffer);\n+      fs.unlink(tempFilePath, () => {});\n+    });\n+  } else {\n+    expect(decryptedFile.data.toString('utf8')).to.equal(this.fileDataBuffer.toString('utf8'));\n+  }\n+});"
        },
        {
            "filename": "test/contract/utils.ts",
            "diff": "@@ -7,3 +7,7 @@ export function loadFixtureFile(persona) {\n   );\n   return JSON.parse(fileData);\n }\n+\n+export function getFilePath(filename) {\n+  return `${process.cwd()}/dist/contract/contract/features/encryption/assets/${filename}`;\n+}"
        },
        {
            "filename": "test/contract/world.ts",
            "diff": "@@ -4,7 +4,7 @@ import {\n   World\n } from '@cucumber/cucumber';\n import PubNub from '../../lib/node/index.js';\n-import { loadFixtureFile } from './utils';\n+import { loadFixtureFile, getFilePath } from './utils';\n import * as http from 'http';\n \n interface State {\n@@ -134,6 +134,9 @@ class PubnubWorld extends World{\n     }\n     return this.fileFixtures[name];\n   }\n+  getFilePath(filename) {\n+    return getFilePath(filename);\n+  }\n }\n \n setWorldConstructor(PubnubWorld);"
        },
        {
            "filename": "tsconfig.json",
            "diff": "@@ -1,18 +1,20 @@\n {\n   \"$schema\": \"https://json.schemastore.org/tsconfig\",\n-\n   \"compilerOptions\": {\n     \"target\": \"ES5\",\n     \"module\": \"CommonJS\",\n     \"moduleResolution\": \"Node\",\n     \"esModuleInterop\": true,\n-\n     \"allowJs\": true,\n     \"noEmitOnError\": true,\n     \"strict\": true,\n     \"outDir\": \"./lib\",\n     \"downlevelIteration\": true\n   },\n-  \"include\": [\"src/**/*\"],\n-  \"exclude\": [\"node_modules\"]\n-}\n+  \"include\": [\n+    \"src/**/*\"\n+  ],\n+  \"exclude\": [\n+    \"node_modules\"\n+  ]\n+}\n\\ No newline at end of file"
        }
    ],
    "commitTime": "2023-10-16 11:14:10"
}