{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "LOW",
        "availability": "LOW"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 8.6,
    "disclosureTime": "2024-01-02 22:45:25",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-RUBY-OMNIAUTHMICROSOFTGRAPH-6142750",
    "identifiers": {
        "CVE": [
            "CVE-2024-21632"
        ],
        "CWE": [
            "CWE-287"
        ]
    },
    "language": "ruby",
    "malicious": false,
    "packageManager": "rubygems",
    "publicationTime": "2024-01-03 14:41:11",
    "remediation": "Upgrade omniauth-microsoft_graph to version 2.0.0 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Improper Authentication",
    "vulnDescription": {
        "Overview": "omniauth-microsoft_graph is an omniauth provider for new Microsoft Graph API. Affected versions of this package are vulnerable to Improper Authentication due to missing validation of the email attribute. An attacker can take over accounts by exploiting the trust placed in the email as a user identifier. "
    },
    "source_code": [
        {
            "filename": "README.md",
            "diff": "@@ -32,10 +32,43 @@ end\n ```\n \n #### Login Hint\n-Just add {login_hint: \"email@example.com\"} to your url generation to form:\n+Just add `{login_hint: \"email@example.com\"}` to your url generation to form:\n ```ruby\n /auth/microsoft_graph?login_hint=email@example.com\n ```\n+\n+#### Domain Verification\n+Because Microsoft allows users to set vanity emails on their accounts, the value of the user's \"email\" doesn't establish membership in that domain. Put another way, user malicious@hacker.biz can edit their email in Active Directory to ceo@yourcompany.com, and (depending on your auth implementation) may be able to log in automatically as that user.\n+\n+To establish membership in the claimed email domain, we use two strategies:\n+\n+* `email` domain matches `userPrincipalName` domain (which by definition is a verified domain)\n+* The user's `id_token` includes the `xms_edov` (\"Email Domain Ownership Verified\") claim, with a truthy value\n+\n+The `xms_edov` claim is [optional](https://github.com/MicrosoftDocs/azure-docs/issues/111425), and must be configured in the Azure console before it's available in the token. Refer to [Clerk's guide](https://clerk.com/docs/authentication/social-connections/microsoft#stay-secure-against-the-n-o-auth-vulnerability) for instructions on configuring the claim.\n+\n+If you're not able or don't need to support domain verification, you can bypass for an individual domain:\n+```ruby\n+Rails.application.config.middleware.use OmniAuth::Builder do\n+  provider :microsoft_graph,\n+           ENV['AZURE_APPLICATION_CLIENT_ID'],\n+           ENV['AZURE_APPLICATION_CLIENT_SECRET'],\n+           skip_domain_verification: %w[contoso.com]\n+end\n+```\n+\n+Or, you can disable domain verification entirely. We *strongly recommend* that you do *not* disable domain verification if at all possible.\n+```ruby\n+Rails.application.config.middleware.use OmniAuth::Builder do\n+  provider :microsoft_graph,\n+           ENV['AZURE_APPLICATION_CLIENT_ID'],\n+           ENV['AZURE_APPLICATION_CLIENT_SECRET'],\n+           skip_domain_verification: true\n+end\n+```\n+\n+[nOAuth: How Microsoft OAuth Misconfiguration Can Lead to Full Account Takeover](https://www.descope.com/blog/post/noauth) from [Descope](https://www.descope.com/)\n+\n ### Upgrading to 1.0.0\n This version requires OmniAuth v2. If you are using Rails, you will need to include or upgrade `omniauth-rails_csrf_protection`. If you upgrade and get an error in your logs complaining about \"authenticity error\" or similiar, make sure to do `bundle update omniauth-rails_csrf_protection`\n "
        },
        {
            "filename": "lib/omniauth/microsoft_graph.rb",
            "diff": "@@ -1,2 +1,3 @@\n+require \"omniauth/microsoft_graph/domain_verifier\"\n require \"omniauth/microsoft_graph/version\"\n require \"omniauth/strategies/microsoft_graph\""
        },
        {
            "filename": "lib/omniauth/microsoft_graph/domain_verifier.rb",
            "diff": "@@ -0,0 +1,86 @@\n+# frozen_string_literal: true\n+require 'jwt' # for token signature validation\n+require 'omniauth' # to inherit from OmniAuth::Error\n+require 'oauth2' # to rescue OAuth2::Error\n+\n+module OmniAuth\n+  module MicrosoftGraph\n+    # Verify user email domains to mitigate the nOAuth vulnerability\n+    # https://www.descope.com/blog/post/noauth\n+    # https://clerk.com/docs/authentication/social-connections/microsoft#stay-secure-against-the-n-o-auth-vulnerability\n+    OIDC_CONFIG_URL = 'https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration'\n+\n+    class DomainVerificationError < OmniAuth::Error; end\n+\n+    class DomainVerifier\n+      def self.verify!(auth_hash, access_token, options)\n+        new(auth_hash, access_token, options).verify!\n+      end\n+\n+      def initialize(auth_hash, access_token, options)\n+        @email_domain = auth_hash['info']['email']&.split('@')&.last\n+        @upn_domain = auth_hash['extra']['raw_info']['userPrincipalName']&.split('@')&.last\n+        @access_token = access_token\n+        @id_token = access_token.params['id_token']\n+        @skip_verification = options[:skip_domain_verification]\n+      end\n+\n+      def verify!\n+        # The userPrincipalName property is mutable, but must always contain a\n+        # verified domain:\n+        #\n+        #  \"The general format is alias@domain, where domain must be present in\n+        #  the tenant's collection of verified domains.\"\n+        #  https://learn.microsoft.com/en-us/graph/api/resources/user?view=graph-rest-1.0\n+        #\n+        # This means while it's not suitable for consistently identifying a user\n+        # (the domain might change), it is suitable for verifying membership in\n+        # a given domain.\n+        return true if email_domain == upn_domain ||\n+          skip_verification == true ||\n+          (skip_verification.is_a?(Array) && skip_verification.include?(email_domain)) ||\n+          domain_verified_jwt_claim\n+        raise DomainVerificationError, verification_error_message\n+      end\n+\n+      private\n+\n+      attr_reader :access_token,\n+                  :email_domain,\n+                  :id_token,\n+                  :permitted_domains,\n+                  :skip_verification,\n+                  :upn_domain\n+\n+      # https://learn.microsoft.com/en-us/entra/identity-platform/optional-claims-reference\n+      # Microsoft offers an optional claim `xms_edov` that will indicate whether the\n+      # user's email domain is part of the organization's verified domains. This has to be\n+      # explicitly configured in the app registration.\n+      #\n+      # To get to it, we need to decode the ID token with the key material from Microsoft's\n+      # OIDC configuration endpoint, and inspect it for the claim in question.\n+      def domain_verified_jwt_claim\n+        oidc_config = access_token.get(OIDC_CONFIG_URL).parsed\n+        algorithms = oidc_config['id_token_signing_alg_values_supported']\n+        keys = JWT::JWK::Set.new(access_token.get(oidc_config['jwks_uri']).parsed)\n+        decoded_token = JWT.decode(id_token, nil, true, algorithms: algorithms, jwks: keys)\n+        # https://github.com/MicrosoftDocs/azure-docs/issues/111425#issuecomment-1761043378\n+        # Comments seemed to indicate the value is not consistent\n+        ['1', 1, 'true', true].include?(decoded_token.first['xms_edov'])\n+      rescue JWT::VerificationError, ::OAuth2::Error\n+        false\n+      end\n+\n+      def verification_error_message\n+        <<~MSG\n+          The email domain '#{email_domain}' is not a verified domain for this Azure AD account.\n+          You can either:\n+            * Update the user's email to match the principal domain '#{upn_domain}'\n+            * Skip verification on the '#{email_domain}' domain (not recommended)\n+            * Disable verification with `skip_domain_verification: true` (NOT RECOMMENDED!)\n+          Refer to the README for more details.\n+        MSG\n+      end\n+    end\n+  end\n+end"
        },
        {
            "filename": "lib/omniauth/strategies/microsoft_graph.rb",
            "diff": "@@ -22,6 +22,7 @@ class MicrosoftGraph < OmniAuth::Strategies::OAuth2\n \n       option :scope, DEFAULT_SCOPE\n       option :authorized_client_ids, []\n+      option :skip_domain_verification, false\n \n       uid { raw_info[\"id\"] }\n \n@@ -43,6 +44,12 @@ class MicrosoftGraph < OmniAuth::Strategies::OAuth2\n         }\n       end\n \n+      def auth_hash\n+        super.tap do |ah|\n+          verify_email(ah, access_token)\n+        end\n+      end\n+\n       def authorize_params\n         super.tap do |params|\n           options[:authorize_options].each do |k|\n@@ -54,15 +61,15 @@ def authorize_params\n \n           session['omniauth.state'] = params[:state] if params[:state]\n         end\n-      end     \n+      end\n \n       def raw_info\n         @raw_info ||= access_token.get('https://graph.microsoft.com/v1.0/me').parsed\n       end\n \n       def callback_url\n         options[:callback_url] || full_host + script_name + callback_path\n-      end  \n+      end\n \n       def custom_build_access_token\n         access_token = get_access_token(request)\n@@ -119,7 +126,11 @@ def verify_token(access_token)\n         raw_response = client.request(:get, 'https://graph.microsoft.com/v1.0/me',\n                                       params: { access_token: access_token }).parsed\n         (raw_response['aud'] == options.client_id) || options.authorized_client_ids.include?(raw_response['aud'])\n-      end              \n+      end\n+\n+      def verify_email(auth_hash, access_token)\n+        OmniAuth::MicrosoftGraph::DomainVerifier.verify!(auth_hash, access_token, options)\n+      end\n     end\n   end\n end"
        },
        {
            "filename": "omniauth-microsoft_graph.gemspec",
            "diff": "@@ -18,6 +18,7 @@ Gem::Specification.new do |spec|\n   spec.test_files    = spec.files.grep(%r{^(test|spec|features)/})\n   spec.require_paths = [\"lib\"]\n \n+  spec.add_runtime_dependency 'jwt', '>= 2.0'\n   spec.add_runtime_dependency 'omniauth', '~> 2.0'\n   spec.add_runtime_dependency 'omniauth-oauth2', '~> 1.8.0'\n   spec.add_development_dependency \"sinatra\", '~> 0'"
        },
        {
            "filename": "spec/omniauth/microsoft_graph/domain_verifier_spec.rb",
            "diff": "@@ -0,0 +1,82 @@\n+# frozen_string_literal: true\n+\n+require 'spec_helper'\n+require 'omniauth/microsoft_graph/domain_verifier'\n+\n+RSpec.describe OmniAuth::MicrosoftGraph::DomainVerifier do\n+  subject(:verifier) { described_class.new(auth_hash, access_token, options) }\n+\n+  let(:auth_hash) do\n+    {\n+      'info' => { 'email' => email },\n+      'extra' => { 'raw_info' => { 'userPrincipalName' => upn } }\n+    }\n+  end\n+  let(:email) { 'foo@example.com' }\n+  let(:upn) { 'bar@hackerman.biz' }\n+  let(:options) { { skip_domain_verification: false } }\n+  let(:access_token) { double('OAuth2::AccessToken', params: { 'id_token' => id_token }) }\n+  let(:id_token) { nil }\n+\n+  describe '#verify!' do\n+    subject(:result) { verifier.verify! }\n+\n+    context 'when email domain and userPrincipalName domain match' do\n+      let(:email) { 'foo@example.com' }\n+      let(:upn) { 'bar@example.com' }\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when domain validation is disabled' do\n+      let(:options) { super().merge(skip_domain_verification: true) }\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when the email domain is explicitly permitted' do\n+      let(:options) { super().merge(skip_domain_verification: ['example.com']) }\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when the ID token indicates domain verification' do\n+      # Sign a fake ID token with our own local key\n+      let(:mock_key) do\n+        optional_parameters = { kid: 'mock-kid', use: 'sig', alg: 'RS256' }\n+        JWT::JWK.new(OpenSSL::PKey::RSA.new(2048), optional_parameters)\n+      end\n+      let(:id_token) do\n+        payload = { email: email, xms_edov: true }\n+        JWT.encode(payload, mock_key.signing_key, mock_key[:alg], kid: mock_key[:kid])\n+      end\n+\n+      # Mock the API responses to return the local key\n+      before do\n+        allow(access_token).to receive(:get)\n+          .with(OmniAuth::MicrosoftGraph::OIDC_CONFIG_URL)\n+          .and_return(\n+            double('OAuth2::Response', parsed: {\n+              'id_token_signing_alg_values_supported' => ['RS256'],\n+              'jwks_uri' => 'https://example.com/jwks-keys'\n+            })\n+          )\n+        allow(access_token).to receive(:get)\n+          .with('https://example.com/jwks-keys')\n+          .and_return(\n+            double('OAuth2::Response', parsed: JWT::JWK::Set.new(mock_key).export)\n+          )\n+      end\n+\n+      it { is_expected.to be_truthy }\n+    end\n+\n+    context 'when all verification strategies fail' do\n+      before { allow(access_token).to receive(:get).and_raise(::OAuth2::Error.new('whoops')) }\n+\n+      it 'raises a DomainVerificationError' do\n+        expect { result }.to raise_error OmniAuth::MicrosoftGraph::DomainVerificationError\n+      end\n+    end\n+  end\n+end"
        },
        {
            "filename": "spec/omniauth/strategies/microsoft_graph_oauth2_spec.rb",
            "diff": "@@ -280,6 +280,18 @@\n       end\n     end\n \n+    context 'when email verification fails' do\n+      let(:response_hash) { { mail: 'something@domain.invalid' } }\n+      let(:error) { OmniAuth::MicrosoftGraph::DomainVerificationError.new }\n+\n+      before do\n+        allow(OmniAuth::MicrosoftGraph::DomainVerifier).to receive(:verify!).and_raise(error)\n+      end\n+\n+      it 'raises an error' do\n+        expect { subject.auth_hash }.to raise_error error\n+      end\n+    end\n   end\n \n   describe '#extra' do\n@@ -445,5 +457,4 @@\n       end.to raise_error(OAuth2::Error)\n     end\n   end\n-\n end"
        }
    ],
    "commitTime": "2023-12-20 04:52:58"
}