{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "LOW",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "HIGH"
    },
    "credit": [
        "LucyEgan"
    ],
    "cvssDetails": [],
    "cvssScore": 8.8,
    "disclosureTime": "2023-12-15 03:46:36",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-RUST-SURREALDB-6129066",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-276"
        ]
    },
    "language": "rust",
    "malicious": false,
    "packageManager": "cargo",
    "publicationTime": "2023-12-15 14:37:20",
    "remediation": "Upgrade surrealdb to version 1.0.1 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Incorrect Default Permissions",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Incorrect Default Permissions due to the default configuration of table permissions. Any authorized client can create, read, update, and delete data in tables that were defined without explicit permissions and are within their authorization scope. This is particularly critical for instances allowing guest access with publicly exposed interfaces, as a remote unauthenticated user may gain full access to tables without explicit permissions. ",
        "Workaround": "This vulnerability can be mitigated by explicitly defining table permissions using the PERMISSIONS clause in the table definition. "
    },
    "source_code": [
        {
            "filename": "lib/src/sql/permission.rs",
            "diff": "@@ -142,10 +142,10 @@ impl PermissionKind {\n \t}\n }\n \n-pub fn permissions(i: &str) -> IResult<&str, Permissions> {\n+pub fn permissions(i: &str, default: Permission) -> IResult<&str, Permissions> {\n \tlet (i, _) = tag_no_case(\"PERMISSIONS\")(i)?;\n \tlet (i, _) = shouldbespace(i)?;\n-\tcut(alt((none, full, specific)))(i)\n+\tcut(alt((none, full, specific(default))))(i)\n }\n \n fn none(i: &str) -> IResult<&str, Permissions> {\n@@ -158,49 +158,51 @@ fn full(i: &str) -> IResult<&str, Permissions> {\n \tOk((i, Permissions::full()))\n }\n \n-fn specific(i: &str) -> IResult<&str, Permissions> {\n-\tlet (i, perms) = separated_list1(commasorspace, rule)(i)?;\n-\tOk((\n-\t\ti,\n-\t\tPermissions {\n-\t\t\tselect: perms\n-\t\t\t\t.iter()\n-\t\t\t\t.find_map(|x| {\n-\t\t\t\t\tx.iter().find_map(|y| match y {\n-\t\t\t\t\t\t(PermissionKind::Select, ref v) => Some(v.to_owned()),\n-\t\t\t\t\t\t_ => None,\n+fn specific(default: Permission) -> impl Fn(&str) -> IResult<&str, Permissions> {\n+\tmove |i: &str| -> IResult<&str, Permissions> {\n+\t\tlet (i, perms) = separated_list1(commasorspace, rule)(i)?;\n+\t\tOk((\n+\t\t\ti,\n+\t\t\tPermissions {\n+\t\t\t\tselect: perms\n+\t\t\t\t\t.iter()\n+\t\t\t\t\t.find_map(|x| {\n+\t\t\t\t\t\tx.iter().find_map(|y| match y {\n+\t\t\t\t\t\t\t(PermissionKind::Select, ref v) => Some(v.to_owned()),\n+\t\t\t\t\t\t\t_ => None,\n+\t\t\t\t\t\t})\n \t\t\t\t\t})\n-\t\t\t\t})\n-\t\t\t\t.unwrap_or_default(),\n-\t\t\tcreate: perms\n-\t\t\t\t.iter()\n-\t\t\t\t.find_map(|x| {\n-\t\t\t\t\tx.iter().find_map(|y| match y {\n-\t\t\t\t\t\t(PermissionKind::Create, ref v) => Some(v.to_owned()),\n-\t\t\t\t\t\t_ => None,\n+\t\t\t\t\t.unwrap_or(default.to_owned()),\n+\t\t\t\tcreate: perms\n+\t\t\t\t\t.iter()\n+\t\t\t\t\t.find_map(|x| {\n+\t\t\t\t\t\tx.iter().find_map(|y| match y {\n+\t\t\t\t\t\t\t(PermissionKind::Create, ref v) => Some(v.to_owned()),\n+\t\t\t\t\t\t\t_ => None,\n+\t\t\t\t\t\t})\n \t\t\t\t\t})\n-\t\t\t\t})\n-\t\t\t\t.unwrap_or_default(),\n-\t\t\tupdate: perms\n-\t\t\t\t.iter()\n-\t\t\t\t.find_map(|x| {\n-\t\t\t\t\tx.iter().find_map(|y| match y {\n-\t\t\t\t\t\t(PermissionKind::Update, ref v) => Some(v.to_owned()),\n-\t\t\t\t\t\t_ => None,\n+\t\t\t\t\t.unwrap_or(default.to_owned()),\n+\t\t\t\tupdate: perms\n+\t\t\t\t\t.iter()\n+\t\t\t\t\t.find_map(|x| {\n+\t\t\t\t\t\tx.iter().find_map(|y| match y {\n+\t\t\t\t\t\t\t(PermissionKind::Update, ref v) => Some(v.to_owned()),\n+\t\t\t\t\t\t\t_ => None,\n+\t\t\t\t\t\t})\n \t\t\t\t\t})\n-\t\t\t\t})\n-\t\t\t\t.unwrap_or_default(),\n-\t\t\tdelete: perms\n-\t\t\t\t.iter()\n-\t\t\t\t.find_map(|x| {\n-\t\t\t\t\tx.iter().find_map(|y| match y {\n-\t\t\t\t\t\t(PermissionKind::Delete, ref v) => Some(v.to_owned()),\n-\t\t\t\t\t\t_ => None,\n+\t\t\t\t\t.unwrap_or(default.to_owned()),\n+\t\t\t\tdelete: perms\n+\t\t\t\t\t.iter()\n+\t\t\t\t\t.find_map(|x| {\n+\t\t\t\t\t\tx.iter().find_map(|y| match y {\n+\t\t\t\t\t\t\t(PermissionKind::Delete, ref v) => Some(v.to_owned()),\n+\t\t\t\t\t\t\t_ => None,\n+\t\t\t\t\t\t})\n \t\t\t\t\t})\n-\t\t\t\t})\n-\t\t\t\t.unwrap_or_default(),\n-\t\t},\n-\t))\n+\t\t\t\t\t.unwrap_or(default.to_owned()),\n+\t\t\t},\n+\t\t))\n+\t}\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Serialize, Deserialize, Hash)]\n@@ -285,7 +287,7 @@ mod tests {\n \t#[test]\n \tfn permissions_none() {\n \t\tlet sql = \"PERMISSIONS NONE\";\n-\t\tlet res = permissions(sql);\n+\t\tlet res = permissions(sql, Permission::Full);\n \t\tlet out = res.unwrap().1;\n \t\tassert_eq!(\"PERMISSIONS NONE\", format!(\"{}\", out));\n \t\tassert_eq!(out, Permissions::none());\n@@ -294,7 +296,7 @@ mod tests {\n \t#[test]\n \tfn permissions_full() {\n \t\tlet sql = \"PERMISSIONS FULL\";\n-\t\tlet res = permissions(sql);\n+\t\tlet res = permissions(sql, Permission::None);\n \t\tlet out = res.unwrap().1;\n \t\tassert_eq!(\"PERMISSIONS FULL\", format!(\"{}\", out));\n \t\tassert_eq!(out, Permissions::full());\n@@ -304,7 +306,7 @@ mod tests {\n \tfn permissions_specific() {\n \t\tlet sql =\n \t\t\t\"PERMISSIONS FOR select FULL, FOR create, update WHERE public = true, FOR delete NONE\";\n-\t\tlet res = permissions(sql);\n+\t\tlet res = permissions(sql, Permission::None);\n \t\tlet out = res.unwrap().1;\n \t\tassert_eq!(\n \t\t\t\"PERMISSIONS FOR select FULL, FOR create, update WHERE public = true, FOR delete NONE\","
        },
        {
            "filename": "lib/src/sql/statements/define/field.rs",
            "diff": "@@ -17,7 +17,7 @@ use crate::sql::ident::{ident, Ident};\n use crate::sql::idiom;\n use crate::sql::idiom::Idiom;\n use crate::sql::kind::{kind, Kind};\n-use crate::sql::permission::{permissions, Permissions};\n+use crate::sql::permission::{permissions, Permission, Permissions};\n use crate::sql::strand::{strand, Strand};\n use crate::sql::value::{value, Value};\n use derive::Store;\n@@ -96,15 +96,13 @@ impl Display for DefineFieldStatement {\n \t\tif let Some(ref v) = self.comment {\n \t\t\twrite!(f, \" COMMENT {v}\")?\n \t\t}\n-\t\tif !self.permissions.is_full() {\n-\t\t\tlet _indent = if is_pretty() {\n-\t\t\t\tSome(pretty_indent())\n-\t\t\t} else {\n-\t\t\t\tf.write_char(' ')?;\n-\t\t\t\tNone\n-\t\t\t};\n-\t\t\twrite!(f, \"{}\", self.permissions)?;\n-\t\t}\n+\t\tlet _indent = if is_pretty() {\n+\t\t\tSome(pretty_indent())\n+\t\t} else {\n+\t\t\tf.write_char(' ')?;\n+\t\t\tNone\n+\t\t};\n+\t\twrite!(f, \"{}\", self.permissions)?;\n \t\tOk(())\n \t}\n }\n@@ -232,6 +230,6 @@ fn field_comment(i: &str) -> IResult<&str, DefineFieldOption> {\n \n fn field_permissions(i: &str) -> IResult<&str, DefineFieldOption> {\n \tlet (i, _) = shouldbespace(i)?;\n-\tlet (i, v) = permissions(i)?;\n+\tlet (i, v) = permissions(i, Permission::Full)?;\n \tOk((i, DefineFieldOption::Permissions(v)))\n }"
        },
        {
            "filename": "lib/src/sql/statements/define/function.rs",
            "diff": "@@ -83,15 +83,13 @@ impl fmt::Display for DefineFunctionStatement {\n \t\tif let Some(ref v) = self.comment {\n \t\t\twrite!(f, \" COMMENT {v}\")?\n \t\t}\n-\t\tif !self.permissions.is_full() {\n-\t\t\tlet _indent = if is_pretty() {\n-\t\t\t\tSome(pretty_indent())\n-\t\t\t} else {\n-\t\t\t\tf.write_char(' ')?;\n-\t\t\t\tNone\n-\t\t\t};\n-\t\t\twrite!(f, \"PERMISSIONS {}\", self.permissions)?;\n-\t\t}\n+\t\tlet _indent = if is_pretty() {\n+\t\t\tSome(pretty_indent())\n+\t\t} else {\n+\t\t\tf.write_char(' ')?;\n+\t\t\tNone\n+\t\t};\n+\t\twrite!(f, \"PERMISSIONS {}\", self.permissions)?;\n \t\tOk(())\n \t}\n }"
        },
        {
            "filename": "lib/src/sql/statements/define/param.rs",
            "diff": "@@ -66,15 +66,13 @@ impl Display for DefineParamStatement {\n \t\tif let Some(ref v) = self.comment {\n \t\t\twrite!(f, \" COMMENT {v}\")?\n \t\t}\n-\t\tif !self.permissions.is_full() {\n-\t\t\tlet _indent = if is_pretty() {\n-\t\t\t\tSome(pretty_indent())\n-\t\t\t} else {\n-\t\t\t\tf.write_char(' ')?;\n-\t\t\t\tNone\n-\t\t\t};\n-\t\t\twrite!(f, \"PERMISSIONS {}\", self.permissions)?;\n-\t\t}\n+\t\tlet _indent = if is_pretty() {\n+\t\t\tSome(pretty_indent())\n+\t\t} else {\n+\t\t\tf.write_char(' ')?;\n+\t\t\tNone\n+\t\t};\n+\t\twrite!(f, \"PERMISSIONS {}\", self.permissions)?;\n \t\tOk(())\n \t}\n }"
        },
        {
            "filename": "lib/src/sql/statements/define/table.rs",
            "diff": "@@ -14,7 +14,7 @@ use crate::sql::error::IResult;\n use crate::sql::fmt::is_pretty;\n use crate::sql::fmt::pretty_indent;\n use crate::sql::ident::{ident, Ident};\n-use crate::sql::permission::{permissions, Permissions};\n+use crate::sql::permission::{permissions, Permission, Permissions};\n use crate::sql::statements::UpdateStatement;\n use crate::sql::strand::{strand, Strand};\n use crate::sql::value::{Value, Values};\n@@ -129,15 +129,13 @@ impl Display for DefineTableStatement {\n \t\tif let Some(ref v) = self.changefeed {\n \t\t\twrite!(f, \" {v}\")?;\n \t\t}\n-\t\tif !self.permissions.is_full() {\n-\t\t\tlet _indent = if is_pretty() {\n-\t\t\t\tSome(pretty_indent())\n-\t\t\t} else {\n-\t\t\t\tf.write_char(' ')?;\n-\t\t\t\tNone\n-\t\t\t};\n-\t\t\twrite!(f, \"{}\", self.permissions)?;\n-\t\t}\n+\t\tlet _indent = if is_pretty() {\n+\t\t\tSome(pretty_indent())\n+\t\t} else {\n+\t\t\tf.write_char(' ')?;\n+\t\t\tNone\n+\t\t};\n+\t\twrite!(f, \"{}\", self.permissions)?;\n \t\tOk(())\n \t}\n }\n@@ -154,6 +152,7 @@ pub fn table(i: &str) -> IResult<&str, DefineTableStatement> {\n \t// Create the base statement\n \tlet mut res = DefineTableStatement {\n \t\tname,\n+\t\tpermissions: Permissions::none(),\n \t\t..Default::default()\n \t};\n \t// Assign any defined options\n@@ -248,7 +247,7 @@ fn table_comment(i: &str) -> IResult<&str, DefineTableOption> {\n \n fn table_permissions(i: &str) -> IResult<&str, DefineTableOption> {\n \tlet (i, _) = shouldbespace(i)?;\n-\tlet (i, v) = permissions(i)?;\n+\tlet (i, v) = permissions(i, Permission::None)?;\n \tOk((i, DefineTableOption::Permissions(v)))\n }\n \n@@ -259,7 +258,7 @@ mod tests {\n \n \t#[test]\n \tfn define_table_with_changefeed() {\n-\t\tlet sql = \"TABLE mytable SCHEMALESS CHANGEFEED 1h\";\n+\t\tlet sql = \"TABLE mytable SCHEMALESS CHANGEFEED 1h PERMISSIONS NONE\";\n \t\tlet res = table(sql);\n \t\tlet out = res.unwrap().1;\n \t\tassert_eq!(format!(\"DEFINE {sql}\"), format!(\"{}\", out));"
        },
        {
            "filename": "lib/tests/define.rs",
            "diff": "@@ -86,7 +86,7 @@ async fn define_statement_function() -> Result<(), Error> {\n \t\t\"{\n \t\t\tanalyzers: {},\n \t\t\ttokens: {},\n-\t\t\tfunctions: { test: 'DEFINE FUNCTION fn::test($first: string, $last: string) { RETURN $first + $last; }' },\n+\t\t\tfunctions: { test: 'DEFINE FUNCTION fn::test($first: string, $last: string) { RETURN $first + $last; } PERMISSIONS FULL' },\n \t\t\tparams: {},\n \t\t\tscopes: {},\n \t\t\tparams: {},\n@@ -122,7 +122,7 @@ async fn define_statement_table_drop() -> Result<(), Error> {\n \t\t\tfunctions: {},\n \t\t\tparams: {},\n \t\t\tscopes: {},\n-\t\t\ttables: { test: 'DEFINE TABLE test DROP SCHEMALESS' },\n+\t\t\ttables: { test: 'DEFINE TABLE test DROP SCHEMALESS PERMISSIONS NONE' },\n \t\t\tusers: {},\n \t\t}\",\n \t);\n@@ -153,7 +153,7 @@ async fn define_statement_table_schemaless() -> Result<(), Error> {\n \t\t\tfunctions: {},\n \t\t\tparams: {},\n \t\t\tscopes: {},\n-\t\t\ttables: { test: 'DEFINE TABLE test SCHEMALESS' },\n+\t\t\ttables: { test: 'DEFINE TABLE test SCHEMALESS PERMISSIONS NONE' },\n \t\t\tusers: {},\n \t\t}\",\n \t);\n@@ -188,7 +188,7 @@ async fn define_statement_table_schemafull() -> Result<(), Error> {\n \t\t\tfunctions: {},\n \t\t\tparams: {},\n \t\t\tscopes: {},\n-\t\t\ttables: { test: 'DEFINE TABLE test SCHEMAFULL' },\n+\t\t\ttables: { test: 'DEFINE TABLE test SCHEMAFULL PERMISSIONS NONE' },\n \t\t\tusers: {},\n \t\t}\",\n \t);\n@@ -219,7 +219,7 @@ async fn define_statement_table_schemaful() -> Result<(), Error> {\n \t\t\tfunctions: {},\n \t\t\tparams: {},\n \t\t\tscopes: {},\n-\t\t\ttables: { test: 'DEFINE TABLE test SCHEMAFULL' },\n+\t\t\ttables: { test: 'DEFINE TABLE test SCHEMAFULL PERMISSIONS NONE' },\n \t\t\tusers: {},\n \t\t}\",\n \t);\n@@ -259,8 +259,8 @@ async fn define_statement_table_foreigntable() -> Result<(), Error> {\n \t\t\tparams: {},\n \t\t\tscopes: {},\n \t\t\ttables: {\n-\t\t\t\ttest: 'DEFINE TABLE test SCHEMAFULL',\n-\t\t\t\tview: 'DEFINE TABLE view SCHEMALESS AS SELECT count() FROM test GROUP ALL',\n+\t\t\t\ttest: 'DEFINE TABLE test SCHEMAFULL PERMISSIONS NONE',\n+\t\t\t\tview: 'DEFINE TABLE view SCHEMALESS AS SELECT count() FROM test GROUP ALL PERMISSIONS NONE',\n \t\t\t},\n \t\t\tusers: {},\n \t\t}\",\n@@ -272,7 +272,7 @@ async fn define_statement_table_foreigntable() -> Result<(), Error> {\n \t\t\"{\n \t\t\tevents: {},\n \t\t\tfields: {},\n-\t\t\ttables: { view: 'DEFINE TABLE view SCHEMALESS AS SELECT count() FROM test GROUP ALL' },\n+\t\t\ttables: { view: 'DEFINE TABLE view SCHEMALESS AS SELECT count() FROM test GROUP ALL PERMISSIONS NONE' },\n \t\t\tindexes: {},\n \t\t\tlives: {},\n \t\t}\",\n@@ -291,7 +291,7 @@ async fn define_statement_table_foreigntable() -> Result<(), Error> {\n \t\t\tparams: {},\n \t\t\tscopes: {},\n \t\t\ttables: {\n-\t\t\t\ttest: 'DEFINE TABLE test SCHEMAFULL',\n+\t\t\t\ttest: 'DEFINE TABLE test SCHEMAFULL PERMISSIONS NONE',\n \t\t\t},\n \t\t\tusers: {},\n \t\t}\",\n@@ -509,7 +509,7 @@ async fn define_statement_field() -> Result<(), Error> {\n \tlet val = Value::parse(\n \t\t\"{\n \t\t\tevents: {},\n-\t\t\tfields: { test: 'DEFINE FIELD test ON user' },\n+\t\t\tfields: { test: 'DEFINE FIELD test ON user PERMISSIONS FULL' },\n \t\t\ttables: {},\n \t\t\tindexes: {},\n \t\t\tlives: {},\n@@ -542,7 +542,7 @@ async fn define_statement_field_type() -> Result<(), Error> {\n \tlet val = Value::parse(\n \t\t\"{\n \t\t\tevents: {},\n-\t\t\tfields: { test: 'DEFINE FIELD test ON user TYPE string' },\n+\t\t\tfields: { test: 'DEFINE FIELD test ON user TYPE string PERMISSIONS FULL' },\n \t\t\ttables: {},\n \t\t\tindexes: {},\n \t\t\tlives: {},\n@@ -575,7 +575,7 @@ async fn define_statement_field_value() -> Result<(), Error> {\n \tlet val = Value::parse(\n \t\tr#\"{\n \t\t\tevents: {},\n-\t\t\tfields: { test: \"DEFINE FIELD test ON user VALUE $value OR 'GBR'\" },\n+\t\t\tfields: { test: \"DEFINE FIELD test ON user VALUE $value OR 'GBR' PERMISSIONS FULL\" },\n \t\t\ttables: {},\n \t\t\tindexes: {},\n \t\t\tlives: {},\n@@ -608,7 +608,7 @@ async fn define_statement_field_assert() -> Result<(), Error> {\n \tlet val = Value::parse(\n \t\t\"{\n \t\t\tevents: {},\n-\t\t\tfields: { test: 'DEFINE FIELD test ON user ASSERT $value != NONE AND $value = /[A-Z]{3}/' },\n+\t\t\tfields: { test: 'DEFINE FIELD test ON user ASSERT $value != NONE AND $value = /[A-Z]{3}/ PERMISSIONS FULL' },\n \t\t\ttables: {},\n \t\t\tindexes: {},\n \t\t\tlives: {},\n@@ -641,7 +641,7 @@ async fn define_statement_field_type_value_assert() -> Result<(), Error> {\n \tlet val = Value::parse(\n \t\tr#\"{\n \t\t\tevents: {},\n-\t\t\tfields: { test: \"DEFINE FIELD test ON user TYPE string VALUE $value OR 'GBR' ASSERT $value != NONE AND $value = /[A-Z]{3}/\" },\n+\t\t\tfields: { test: \"DEFINE FIELD test ON user TYPE string VALUE $value OR 'GBR' ASSERT $value != NONE AND $value = /[A-Z]{3}/ PERMISSIONS FULL\" },\n \t\t\ttables: {},\n \t\t\tindexes: {},\n \t\t\tlives: {},\n@@ -1491,7 +1491,7 @@ async fn permissions_checks_define_function() {\n \n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n-        vec![\"{ analyzers: {  }, functions: { greet: \\\"DEFINE FUNCTION fn::greet() { RETURN 'Hello'; }\\\" }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n+        vec![\"{ analyzers: {  }, functions: { greet: \\\"DEFINE FUNCTION fn::greet() { RETURN 'Hello'; } PERMISSIONS FULL\\\" }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n \t\tvec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"]\n     ];\n \n@@ -1827,7 +1827,7 @@ async fn permissions_checks_define_param() {\n \n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n-        vec![\"{ analyzers: {  }, functions: {  }, params: { param: \\\"DEFINE PARAM $param VALUE 'foo'\\\" }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n+        vec![\"{ analyzers: {  }, functions: {  }, params: { param: \\\"DEFINE PARAM $param VALUE 'foo' PERMISSIONS FULL\\\" }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n \t\tvec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"]\n     ];\n \n@@ -1866,7 +1866,7 @@ async fn permissions_checks_define_table() {\n \n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n-        vec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: { TB: 'DEFINE TABLE TB SCHEMALESS' }, tokens: {  }, users: {  } }\"],\n+        vec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: { TB: 'DEFINE TABLE TB SCHEMALESS PERMISSIONS NONE' }, tokens: {  }, users: {  } }\"],\n \t\tvec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"]\n     ];\n \n@@ -1950,7 +1950,7 @@ async fn permissions_checks_define_field() {\n \n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n-        vec![\"{ events: {  }, fields: { field: 'DEFINE FIELD field ON TB' }, indexes: {  }, lives: {  }, tables: {  } }\"],\n+        vec![\"{ events: {  }, fields: { field: 'DEFINE FIELD field ON TB PERMISSIONS FULL' }, indexes: {  }, lives: {  }, tables: {  } }\"],\n \t\tvec![\"{ events: {  }, fields: {  }, indexes: {  }, lives: {  }, tables: {  } }\"]\n     ];\n \n@@ -2023,3 +2023,48 @@ async fn permissions_checks_define_index() {\n \tlet res = iam_check_cases(test_cases.iter(), &scenario, check_results).await;\n \tassert!(res.is_ok(), \"{}\", res.unwrap_err());\n }\n+\n+#[tokio::test]\n+async fn define_statement_table_permissions() -> Result<(), Error> {\n+\t// Permissions for tables, unlike other resources, are restrictive (NONE) by default.\n+\t// This test ensures that behaviour\n+\tlet sql = \"\n+\t\tDEFINE TABLE default;\n+\t\tDEFINE TABLE select_full PERMISSIONS FOR select FULL;\n+\t\tDEFINE TABLE full PERMISSIONS FULL;\n+\t\tINFO FOR DB;\n+\t\";\n+\tlet dbs = new_ds().await?;\n+\tlet ses = Session::owner().with_ns(\"test\").with_db(\"test\");\n+\tlet res = &mut dbs.execute(sql, &ses, None).await?;\n+\tassert_eq!(res.len(), 4);\n+\t//\n+\tlet tmp = res.remove(0).result;\n+\tassert!(tmp.is_ok());\n+\t//\n+\tlet tmp = res.remove(0).result;\n+\tassert!(tmp.is_ok());\n+\t//\n+\tlet tmp = res.remove(0).result;\n+\tassert!(tmp.is_ok());\n+\t//\n+\tlet tmp = res.remove(0).result?;\n+\tlet val = Value::parse(\n+\t\t\"{\n+\t\t\tanalyzers: {},\n+\t\t\tfunctions: {},\n+\t\t\tparams: {},\n+\t\t\tscopes: {},\n+\t\t\ttables: {\n+\t\t\t\t\tdefault: 'DEFINE TABLE default SCHEMALESS PERMISSIONS NONE',\n+\t\t\t\t\tfull: 'DEFINE TABLE full SCHEMALESS PERMISSIONS FULL',\n+\t\t\t\t\tselect_full: 'DEFINE TABLE select_full SCHEMALESS PERMISSIONS FOR select FULL, FOR create, update, delete NONE'\n+\t\t\t},\n+\t\t\ttokens: {},\n+\t\t\tusers: {}\n+\t\t}\",\n+\t);\n+\tassert_eq!(tmp, val);\n+\t//\n+\tOk(())\n+}"
        },
        {
            "filename": "lib/tests/param.rs",
            "diff": "@@ -29,7 +29,7 @@ async fn define_global_param() -> Result<(), Error> {\n \t\t\tanalyzers: {},\n \t\t\ttokens: {},\n \t\t\tfunctions: {},\n-\t\t\tparams: { test: 'DEFINE PARAM $test VALUE 12345' },\n+\t\t\tparams: { test: 'DEFINE PARAM $test VALUE 12345 PERMISSIONS FULL' },\n \t\t\tscopes: {},\n \t\t\ttables: {},\n \t\t\tusers: {},"
        },
        {
            "filename": "lib/tests/remove.rs",
            "diff": "@@ -222,7 +222,7 @@ async fn permissions_checks_remove_function() {\n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n \t\tvec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n-        vec![\"{ analyzers: {  }, functions: { greet: \\\"DEFINE FUNCTION fn::greet() { RETURN 'Hello'; }\\\" }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n+        vec![\"{ analyzers: {  }, functions: { greet: \\\"DEFINE FUNCTION fn::greet() { RETURN 'Hello'; } PERMISSIONS FULL\\\" }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n     ];\n \n \tlet test_cases = [\n@@ -558,7 +558,7 @@ async fn permissions_checks_remove_param() {\n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n \t\tvec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n-        vec![\"{ analyzers: {  }, functions: {  }, params: { param: \\\"DEFINE PARAM $param VALUE 'foo'\\\" }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n+        vec![\"{ analyzers: {  }, functions: {  }, params: { param: \\\"DEFINE PARAM $param VALUE 'foo' PERMISSIONS FULL\\\" }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n     ];\n \n \tlet test_cases = [\n@@ -600,7 +600,7 @@ async fn permissions_checks_remove_table() {\n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n \t\tvec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: {  }, tokens: {  }, users: {  } }\"],\n-        vec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: { TB: 'DEFINE TABLE TB SCHEMALESS' }, tokens: {  }, users: {  } }\"],\n+        vec![\"{ analyzers: {  }, functions: {  }, params: {  }, scopes: {  }, tables: { TB: 'DEFINE TABLE TB SCHEMALESS PERMISSIONS NONE' }, tokens: {  }, users: {  } }\"],\n     ];\n \n \tlet test_cases = [\n@@ -684,7 +684,7 @@ async fn permissions_checks_remove_field() {\n \t// Define the expected results for the check statement when the test statement succeeded and when it failed\n \tlet check_results = [\n \t\tvec![\"{ events: {  }, fields: {  }, indexes: {  }, lives: {  }, tables: {  } }\"],\n-        vec![\"{ events: {  }, fields: { field: 'DEFINE FIELD field ON TB' }, indexes: {  }, lives: {  }, tables: {  } }\"],\n+        vec![\"{ events: {  }, fields: { field: 'DEFINE FIELD field ON TB PERMISSIONS FULL' }, indexes: {  }, lives: {  }, tables: {  } }\"],\n     ];\n \n \tlet test_cases = ["
        },
        {
            "filename": "lib/tests/strict.rs",
            "diff": "@@ -267,7 +267,7 @@ async fn loose_mode_all_ok() -> Result<(), Error> {\n \tlet val = Value::parse(\n \t\t\"{\n \t\t\tevents: {},\n-\t\t\tfields: { extra: 'DEFINE FIELD extra ON test VALUE true' },\n+\t\t\tfields: { extra: 'DEFINE FIELD extra ON test VALUE true PERMISSIONS FULL' },\n \t\t\ttables: {},\n \t\t\tindexes: {},\n \t\t\tlives: {},"
        },
        {
            "filename": "lib/tests/table.rs",
            "diff": "@@ -43,7 +43,7 @@ async fn define_foreign_table() -> Result<(), Error> {\n \t\t\"{\n \t\t\tevents: {},\n \t\t\tfields: {},\n-\t\t\ttables: { person_by_age: 'DEFINE TABLE person_by_age SCHEMALESS AS SELECT count(), age, math::sum(age) AS total, math::mean(score) AS average FROM person GROUP BY age' },\n+\t\t\ttables: { person_by_age: 'DEFINE TABLE person_by_age SCHEMALESS AS SELECT count(), age, math::sum(age) AS total, math::mean(score) AS average FROM person GROUP BY age PERMISSIONS NONE' },\n \t\t\tindexes: {},\n \t\t\tlives: {},\n \t\t}\","
        }
    ],
    "commitTime": "2023-12-13 12:13:29"
}