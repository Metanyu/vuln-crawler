{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "LOW"
    },
    "credit": [
        "marten-seemann"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 5.3,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "UNCHANGED",
                "confidentiality": "NONE",
                "integrity": "NONE",
                "availability": "LOW"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 5.3,
    "disclosureTime": "2023-12-12 14:45:49",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.14632",
        "probability": "0.00048"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-RUST-QUICHE-6124765",
    "identifiers": {
        "CVE": [
            "CVE-2023-6193"
        ],
        "CWE": [
            "CWE-400"
        ]
    },
    "language": "rust",
    "malicious": false,
    "packageManager": "cargo",
    "publicationTime": "2023-12-13 16:29:28",
    "remediation": "Upgrade quiche to version 0.19.1 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Uncontrolled Resource Consumption ('Resource Exhaustion')",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Uncontrolled Resource Consumption ('Resource Exhaustion') via the PATH_CHALLENGE frame processing. An attacker can cause excessive resource consumption by sending PATH_CHALLENGE frames and manipulating the connection to slow down the rate at which PATH_RESPONSE frames are sent, resulting in an unbounded queue of path validation data. "
    },
    "source_code": [
        {
            "filename": "quiche/src/lib.rs",
            "diff": "@@ -457,6 +457,9 @@ const MAX_SEND_UDP_PAYLOAD_SIZE: usize = 1200;\n // The default length of DATAGRAM queues.\n const DEFAULT_MAX_DGRAM_QUEUE_LEN: usize = 0;\n \n+// The default length of PATH_CHALLENGE receive queue.\n+const DEFAULT_MAX_PATH_CHALLENGE_RX_QUEUE_LEN: usize = 3;\n+\n // The DATAGRAM standard recommends either none or 65536 as maximum DATAGRAM\n // frames size. We enforce the recommendation for forward compatibility.\n const MAX_DGRAM_FRAME_SIZE: u64 = 65536;\n@@ -718,6 +721,8 @@ pub struct Config {\n     dgram_recv_max_queue_len: usize,\n     dgram_send_max_queue_len: usize,\n \n+    path_challenge_recv_max_queue_len: usize,\n+\n     max_send_udp_payload_size: usize,\n \n     max_connection_window: u64,\n@@ -780,6 +785,9 @@ impl Config {\n             dgram_recv_max_queue_len: DEFAULT_MAX_DGRAM_QUEUE_LEN,\n             dgram_send_max_queue_len: DEFAULT_MAX_DGRAM_QUEUE_LEN,\n \n+            path_challenge_recv_max_queue_len:\n+                DEFAULT_MAX_PATH_CHALLENGE_RX_QUEUE_LEN,\n+\n             max_send_udp_payload_size: MAX_SEND_UDP_PAYLOAD_SIZE,\n \n             max_connection_window: MAX_CONNECTION_WINDOW,\n@@ -1194,6 +1202,16 @@ impl Config {\n         self.dgram_send_max_queue_len = send_queue_len;\n     }\n \n+    /// Configures the max number of queued received PATH_CHALLENGE frames.\n+    ///\n+    /// When an endpoint receives a PATH_CHALLENGE frame and the queue is full,\n+    /// the frame is discarded.\n+    ///\n+    /// The default is 3.\n+    pub fn set_path_challenge_recv_max_queue_len(&mut self, queue_len: usize) {\n+        self.path_challenge_recv_max_queue_len = queue_len;\n+    }\n+\n     /// Sets the maximum size of the connection window.\n     ///\n     /// The default value is MAX_CONNECTION_WINDOW (24MBytes).\n@@ -1268,6 +1286,12 @@ pub struct Connection {\n     /// The path manager.\n     paths: path::PathMap,\n \n+    /// PATH_CHALLENGE receive queue max length.\n+    path_challenge_recv_max_queue_len: usize,\n+\n+    /// Total number of received PATH_CHALLENGE frames.\n+    path_challenge_rx_count: u64,\n+\n     /// List of supported application protocols.\n     application_protos: Vec<Vec<u8>>,\n \n@@ -1720,7 +1744,13 @@ impl Connection {\n \n         let recovery_config = recovery::RecoveryConfig::from_config(config);\n \n-        let mut path = path::Path::new(local, peer, &recovery_config, true);\n+        let mut path = path::Path::new(\n+            local,\n+            peer,\n+            &recovery_config,\n+            config.path_challenge_recv_max_queue_len,\n+            true,\n+        );\n         // If we did stateless retry assume the peer's address is verified.\n         path.verified_peer_address = odcid.is_some();\n         // Assume clients validate the server's address implicitly.\n@@ -1766,6 +1796,9 @@ impl Connection {\n             recovery_config,\n \n             paths,\n+            path_challenge_recv_max_queue_len: config\n+                .path_challenge_recv_max_queue_len,\n+            path_challenge_rx_count: 0,\n \n             application_protos: config.application_protos.clone(),\n \n@@ -6284,6 +6317,7 @@ impl Connection {\n             stopped_stream_count_local: self.stopped_stream_local_count,\n             reset_stream_count_remote: self.reset_stream_remote_count,\n             stopped_stream_count_remote: self.stopped_stream_remote_count,\n+            path_challenge_rx_count: self.path_challenge_rx_count,\n         }\n     }\n \n@@ -7009,6 +7043,8 @@ impl Connection {\n             },\n \n             frame::Frame::PathChallenge { data } => {\n+                self.path_challenge_rx_count += 1;\n+\n                 self.paths\n                     .get_mut(recv_path_id)?\n                     .on_challenge_received(data);\n@@ -7301,8 +7337,13 @@ impl Connection {\n         }\n \n         // This is a new path using an unassigned CID; create it!\n-        let mut path =\n-            path::Path::new(info.to, info.from, &self.recovery_config, false);\n+        let mut path = path::Path::new(\n+            info.to,\n+            info.from,\n+            &self.recovery_config,\n+            self.path_challenge_recv_max_queue_len,\n+            false,\n+        );\n \n         path.max_send_bytes = buf_len * MAX_AMPLIFICATION_FACTOR;\n         path.active_scid_seq = Some(in_scid_seq);\n@@ -7424,8 +7465,13 @@ impl Connection {\n                 .ok_or(Error::OutOfIdentifiers)?\n         };\n \n-        let mut path =\n-            path::Path::new(local_addr, peer_addr, &self.recovery_config, false);\n+        let mut path = path::Path::new(\n+            local_addr,\n+            peer_addr,\n+            &self.recovery_config,\n+            self.path_challenge_recv_max_queue_len,\n+            false,\n+        );\n         path.active_dcid_seq = Some(dcid_seq);\n \n         let pid = self\n@@ -7532,6 +7578,9 @@ pub struct Stats {\n \n     /// The number of streams stopped by remote.\n     pub stopped_stream_count_remote: u64,\n+\n+    /// The total number of PATH_CHALLENGE frames that were received.\n+    pub path_challenge_rx_count: u64,\n }\n \n impl std::fmt::Debug for Stats {\n@@ -15300,6 +15349,9 @@ mod tests {\n         };\n         assert_eq!(pipe.server.recv(&mut buf[..sent], ri), Ok(sent));\n \n+        let stats = pipe.server.stats();\n+        assert_eq!(stats.path_challenge_rx_count, 1);\n+\n         // A non-existing 4-tuple raises an InvalidState.\n         let client_addr_3 = \"127.0.0.1:9012\".parse().unwrap();\n         let server_addr_2 = \"127.0.0.1:9876\".parse().unwrap();\n@@ -15341,6 +15393,9 @@ mod tests {\n         };\n         assert_eq!(pipe.server.recv(&mut buf[..sent], ri), Ok(sent));\n \n+        let stats = pipe.server.stats();\n+        assert_eq!(stats.path_challenge_rx_count, 2);\n+\n         // STREAM frame on active path.\n         let (sent, si) = pipe\n             .client\n@@ -15355,6 +15410,9 @@ mod tests {\n         };\n         assert_eq!(pipe.server.recv(&mut buf[..sent], ri), Ok(sent));\n \n+        let stats = pipe.server.stats();\n+        assert_eq!(stats.path_challenge_rx_count, 2);\n+\n         // PATH_CHALLENGE\n         let (sent, si) = pipe\n             .client\n@@ -15370,6 +15428,9 @@ mod tests {\n         };\n         assert_eq!(pipe.server.recv(&mut buf[..sent], ri), Ok(sent));\n \n+        let stats = pipe.server.stats();\n+        assert_eq!(stats.path_challenge_rx_count, 3);\n+\n         // STREAM frame on active path.\n         let (sent, si) = pipe\n             .client\n@@ -15419,6 +15480,9 @@ mod tests {\n         v2.sort();\n \n         assert_eq!(v1, v2);\n+\n+        let stats = pipe.server.stats();\n+        assert_eq!(stats.path_challenge_rx_count, 3);\n     }\n \n     #[test]"
        },
        {
            "filename": "quiche/src/path.rs",
            "diff": "@@ -151,6 +151,9 @@ pub struct Path {\n     /// Received challenge data.\n     received_challenges: VecDeque<[u8; 8]>,\n \n+    /// Max length of received challenges queue.\n+    received_challenges_max_len: usize,\n+\n     /// Number of packets sent on this path.\n     pub sent_count: usize,\n \n@@ -199,7 +202,8 @@ impl Path {\n     /// the fields being set to their default value.\n     pub fn new(\n         local_addr: SocketAddr, peer_addr: SocketAddr,\n-        recovery_config: &recovery::RecoveryConfig, is_initial: bool,\n+        recovery_config: &recovery::RecoveryConfig,\n+        path_challenge_recv_max_queue_len: usize, is_initial: bool,\n     ) -> Self {\n         let (state, active_scid_seq, active_dcid_seq) = if is_initial {\n             (PathState::Validated, Some(0), Some(0))\n@@ -219,7 +223,10 @@ impl Path {\n             max_challenge_size: 0,\n             probing_lost: 0,\n             last_probe_lost_time: None,\n-            received_challenges: VecDeque::new(),\n+            received_challenges: VecDeque::with_capacity(\n+                path_challenge_recv_max_queue_len,\n+            ),\n+            received_challenges_max_len: path_challenge_recv_max_queue_len,\n             sent_count: 0,\n             recv_count: 0,\n             retrans_count: 0,\n@@ -334,6 +341,13 @@ impl Path {\n     }\n \n     pub fn on_challenge_received(&mut self, data: [u8; 8]) {\n+        // Discard challenges that would cause us to queue more than we want.\n+        if self.received_challenges.len() ==\n+            self.received_challenges_max_len\n+        {\n+            return;\n+        }\n+\n         self.received_challenges.push_back(data);\n         self.peer_verified_local_address = true;\n     }\n@@ -906,11 +920,22 @@ mod tests {\n         let config = Config::new(crate::PROTOCOL_VERSION).unwrap();\n         let recovery_config = RecoveryConfig::from_config(&config);\n \n-        let path = Path::new(client_addr, server_addr, &recovery_config, true);\n+        let path = Path::new(\n+            client_addr,\n+            server_addr,\n+            &recovery_config,\n+            config.path_challenge_recv_max_queue_len,\n+            true,\n+        );\n         let mut path_mgr = PathMap::new(path, 2, false);\n \n-        let probed_path =\n-            Path::new(client_addr_2, server_addr, &recovery_config, false);\n+        let probed_path = Path::new(\n+            client_addr_2,\n+            server_addr,\n+            &recovery_config,\n+            config.path_challenge_recv_max_queue_len,\n+            false,\n+        );\n         path_mgr.insert_path(probed_path, false).unwrap();\n \n         let pid = path_mgr\n@@ -980,10 +1005,21 @@ mod tests {\n         let config = Config::new(crate::PROTOCOL_VERSION).unwrap();\n         let recovery_config = RecoveryConfig::from_config(&config);\n \n-        let path = Path::new(client_addr, server_addr, &recovery_config, true);\n+        let path = Path::new(\n+            client_addr,\n+            server_addr,\n+            &recovery_config,\n+            config.path_challenge_recv_max_queue_len,\n+            true,\n+        );\n         let mut client_path_mgr = PathMap::new(path, 2, false);\n-        let mut server_path =\n-            Path::new(server_addr, client_addr, &recovery_config, false);\n+        let mut server_path = Path::new(\n+            server_addr,\n+            client_addr,\n+            &recovery_config,\n+            config.path_challenge_recv_max_queue_len,\n+            false,\n+        );\n \n         let client_pid = client_path_mgr\n             .path_id_from_addrs(&(client_addr, server_addr))\n@@ -1049,4 +1085,152 @@ mod tests {\n             0\n         );\n     }\n+\n+    #[test]\n+    fn too_many_probes() {\n+        let client_addr = \"127.0.0.1:1234\".parse().unwrap();\n+        let server_addr = \"127.0.0.1:4321\".parse().unwrap();\n+\n+        // Default to DEFAULT_MAX_PATH_CHALLENGE_RX_QUEUE_LEN\n+        let config = Config::new(crate::PROTOCOL_VERSION).unwrap();\n+        let recovery_config = RecoveryConfig::from_config(&config);\n+\n+        let path = Path::new(\n+            client_addr,\n+            server_addr,\n+            &recovery_config,\n+            config.path_challenge_recv_max_queue_len,\n+            true,\n+        );\n+        let mut client_path_mgr = PathMap::new(path, 2, false);\n+        let mut server_path = Path::new(\n+            server_addr,\n+            client_addr,\n+            &recovery_config,\n+            config.path_challenge_recv_max_queue_len,\n+            false,\n+        );\n+\n+        let client_pid = client_path_mgr\n+            .path_id_from_addrs(&(client_addr, server_addr))\n+            .unwrap();\n+\n+        // First probe.\n+        let data = rand::rand_u64().to_be_bytes();\n+\n+        client_path_mgr\n+            .get_mut(client_pid)\n+            .unwrap()\n+            .add_challenge_sent(\n+                data,\n+                MIN_CLIENT_INITIAL_LEN,\n+                time::Instant::now(),\n+            );\n+\n+        // Second probe.\n+        let data_2 = rand::rand_u64().to_be_bytes();\n+\n+        client_path_mgr\n+            .get_mut(client_pid)\n+            .unwrap()\n+            .add_challenge_sent(\n+                data_2,\n+                MIN_CLIENT_INITIAL_LEN,\n+                time::Instant::now(),\n+            );\n+        assert_eq!(\n+            client_path_mgr\n+                .get(client_pid)\n+                .unwrap()\n+                .in_flight_challenges\n+                .len(),\n+            2\n+        );\n+\n+        // Third probe.\n+        let data_3 = rand::rand_u64().to_be_bytes();\n+\n+        client_path_mgr\n+            .get_mut(client_pid)\n+            .unwrap()\n+            .add_challenge_sent(\n+                data_3,\n+                MIN_CLIENT_INITIAL_LEN,\n+                time::Instant::now(),\n+            );\n+        assert_eq!(\n+            client_path_mgr\n+                .get(client_pid)\n+                .unwrap()\n+                .in_flight_challenges\n+                .len(),\n+            3\n+        );\n+\n+        // Fourth probe.\n+        let data_4 = rand::rand_u64().to_be_bytes();\n+\n+        client_path_mgr\n+            .get_mut(client_pid)\n+            .unwrap()\n+            .add_challenge_sent(\n+                data_4,\n+                MIN_CLIENT_INITIAL_LEN,\n+                time::Instant::now(),\n+            );\n+        assert_eq!(\n+            client_path_mgr\n+                .get(client_pid)\n+                .unwrap()\n+                .in_flight_challenges\n+                .len(),\n+            4\n+        );\n+\n+        // If we receive multiple challenges, we can store them up to our queue size\n+        server_path.on_challenge_received(data);\n+        assert_eq!(server_path.received_challenges.len(), 1);\n+        server_path.on_challenge_received(data_2);\n+        assert_eq!(server_path.received_challenges.len(), 2);\n+        server_path.on_challenge_received(data_3);\n+        assert_eq!(server_path.received_challenges.len(), 3);\n+        server_path.on_challenge_received(data_4);\n+        assert_eq!(server_path.received_challenges.len(), 3);\n+\n+        // Response for first probe.\n+        client_path_mgr.on_response_received(data).unwrap();\n+        assert_eq!(\n+            client_path_mgr\n+                .get(client_pid)\n+                .unwrap()\n+                .in_flight_challenges\n+                .len(),\n+            3\n+        );\n+\n+        // Response for second probe.\n+        client_path_mgr.on_response_received(data_2).unwrap();\n+        assert_eq!(\n+            client_path_mgr\n+                .get(client_pid)\n+                .unwrap()\n+                .in_flight_challenges\n+                .len(),\n+            2\n+        );\n+\n+        // Response for third probe.\n+        client_path_mgr.on_response_received(data_3).unwrap();\n+        assert_eq!(\n+            client_path_mgr\n+                .get(client_pid)\n+                .unwrap()\n+                .in_flight_challenges\n+                .len(),\n+            1\n+        );\n+\n+        // There will never be a response for fourth probe...\n+\n+    }\n }"
        }
    ],
    "commitTime": "2023-12-11 16:15:27"
}