{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "LOCAL",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "HIGH",
        "integrity": "HIGH",
        "availability": "HIGH"
    },
    "credit": [
        "yagehu"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 8.6,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "NONE",
                "scope": "CHANGED",
                "confidentiality": "HIGH",
                "integrity": "NONE",
                "availability": "NONE"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 8.4,
    "disclosureTime": "2023-12-13 13:32:38",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.12298",
        "probability": "0.00045"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-RUST-WASMERCLI-6125586",
    "identifiers": {
        "CVE": [
            "CVE-2023-51661"
        ],
        "CWE": [
            "CWE-668"
        ]
    },
    "language": "rust",
    "malicious": false,
    "packageManager": "cargo",
    "publicationTime": "2023-12-14 12:56:35",
    "remediation": "Upgrade wasmer-cli to version 4.2.4 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Exposure of Resource to Wrong Sphere",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Exposure of Resource to Wrong Sphere due to improper enforcement of filesystem sandboxing. An attacker can access and manipulate files on the host filesystem by running a Wasm program that bypasses the intended sandbox restrictions. "
    },
    "source_code": [
        {
            "filename": "lib/cli/src/commands/run/mod.rs",
            "diff": "@@ -30,7 +30,7 @@ use wasmer_compiler::ArtifactBuild;\n use wasmer_registry::{wasmer_env::WasmerEnv, Package};\n use wasmer_wasix::{\n     bin_factory::BinaryPackage,\n-    runners::{MappedDirectory, Runner},\n+    runners::{MappedCommand, MappedDirectory, Runner},\n     runtime::{\n         module_cache::{CacheError, ModuleHash},\n         package_loader::PackageLoader,\n@@ -215,17 +215,7 @@ impl Run {\n         uses: Vec<BinaryPackage>,\n         runtime: Arc<dyn Runtime + Send + Sync>,\n     ) -> Result<(), Error> {\n-        let mut runner = wasmer_wasix::runners::wasi::WasiRunner::new()\n-            .with_args(self.args.clone())\n-            .with_envs(self.wasi.env_vars.clone())\n-            .with_mapped_directories(self.wasi.mapped_dirs.clone())\n-            .with_injected_packages(uses);\n-        if self.wasi.forward_host_env {\n-            runner.set_forward_host_env();\n-        }\n-\n-        *runner.capabilities() = self.wasi.capabilities();\n-\n+        let mut runner = self.build_wasi_runner(&runtime)?;\n         runner.run_command(command_name, pkg, runtime)\n     }\n \n@@ -298,23 +288,41 @@ impl Run {\n         Ok(())\n     }\n \n+    fn build_wasi_runner(\n+        &self,\n+        runtime: &Arc<dyn Runtime + Send + Sync>,\n+    ) -> Result<WasiRunner, anyhow::Error> {\n+        let packages = self.load_injected_packages(runtime)?;\n+\n+        let runner = WasiRunner::new()\n+            .with_args(&self.args)\n+            .with_injected_packages(packages)\n+            .with_envs(self.wasi.env_vars.clone())\n+            .with_mapped_host_commands(self.wasi.build_mapped_commands()?)\n+            .with_mapped_directories(self.wasi.build_mapped_directories()?)\n+            .with_forward_host_env(self.wasi.forward_host_env)\n+            .with_capabilities(self.wasi.capabilities());\n+\n+        Ok(runner)\n+    }\n+\n     #[tracing::instrument(skip_all)]\n     fn execute_wasi_module(\n         &self,\n         wasm_path: &Path,\n         module: &Module,\n         runtime: Arc<dyn Runtime + Send + Sync>,\n-        store: Store,\n+        mut store: Store,\n     ) -> Result<(), Error> {\n         let program_name = wasm_path.display().to_string();\n \n-        let builder = self\n-            .wasi\n-            .prepare(module, program_name, self.args.clone(), runtime)?;\n-\n-        builder.run_with_store_async(module.clone(), store)?;\n-\n-        Ok(())\n+        let runner = self.build_wasi_runner(&runtime)?;\n+        runner.run_wasm(\n+            runtime,\n+            &program_name,\n+            module,\n+            self.wasi.enable_async_threads,\n+        )\n     }\n \n     #[tracing::instrument(skip_all)]"
        },
        {
            "filename": "lib/cli/src/commands/run/wasi.rs",
            "diff": "@@ -20,7 +20,7 @@ use wasmer_wasix::{\n     http::HttpClient,\n     os::{tty_sys::SysTty, TtyBridge},\n     rewind_ext,\n-    runners::MappedDirectory,\n+    runners::{MappedCommand, MappedDirectory},\n     runtime::{\n         module_cache::{FileSystemCache, ModuleCache},\n         package_loader::{BuiltinPackageLoader, PackageLoader},\n@@ -77,11 +77,11 @@ pub struct Wasi {\n     /// List of webc packages that are explicitly included for execution\n     /// Note: these packages will be used instead of those in the registry\n     #[clap(long = \"include-webc\", name = \"WEBC\")]\n-    include_webcs: Vec<PathBuf>,\n+    pub(super) include_webcs: Vec<PathBuf>,\n \n     /// List of injected atoms\n     #[clap(long = \"map-command\", name = \"MAPCMD\")]\n-    map_commands: Vec<String>,\n+    pub(super) map_commands: Vec<String>,\n \n     /// Enable experimental IO devices\n     #[cfg(feature = \"experimental-io-devices\")]\n@@ -125,6 +125,8 @@ pub struct RunProperties {\n \n #[allow(dead_code)]\n impl Wasi {\n+    const MAPPED_CURRENT_DIR_DEFAULT_PATH: &'static str = \"/mnt/host\";\n+\n     pub fn map_dir(&mut self, alias: &str, target_on_disk: PathBuf) {\n         self.mapped_dirs.push(MappedDirectory {\n             guest: alias.to_string(),\n@@ -190,12 +192,93 @@ impl Wasi {\n             .uses(uses)\n             .map_commands(map_commands);\n \n-        let mut builder = if wasmer_wasix::is_wasix_module(module) {\n+        let mut builder = {\n             // If we preopen anything from the host then shallow copy it over\n             let root_fs = RootFileSystemBuilder::new()\n                 .with_tty(Box::new(DeviceFile::new(__WASI_STDIN_FILENO)))\n                 .build();\n-            if !self.mapped_dirs.is_empty() {\n+\n+            let mut mapped_dirs = Vec::new();\n+\n+            // Process the --dirs flag and merge it with --mapdir.\n+            let mut have_current_dir = false;\n+            for dir in &self.pre_opened_directories {\n+                let mapping = if dir == Path::new(\".\") {\n+                    if have_current_dir {\n+                        bail!(\"Cannot pre-open the current directory twice: --dir=. must only be specified once\");\n+                    }\n+                    have_current_dir = true;\n+\n+                    let current_dir =\n+                        std::env::current_dir().context(\"could not determine current directory\")?;\n+\n+                    MappedDirectory {\n+                        host: current_dir,\n+                        guest: Self::MAPPED_CURRENT_DIR_DEFAULT_PATH.to_string(),\n+                    }\n+                } else {\n+                    let resolved = dir.canonicalize().with_context(|| {\n+                        format!(\n+                            \"could not canonicalize path for argument '--dir {}'\",\n+                            dir.display()\n+                        )\n+                    })?;\n+\n+                    if &resolved != dir {\n+                        bail!(\n+                            \"Invalid argument '--dir {}': path must either be absolute, or '.'\",\n+                            dir.display(),\n+                        );\n+                    }\n+\n+                    let guest = resolved\n+                        .to_str()\n+                        .with_context(|| {\n+                            format!(\n+                                \"invalid argument '--dir {}': path must be valid utf-8\",\n+                                dir.display(),\n+                            )\n+                        })?\n+                        .to_string();\n+\n+                    MappedDirectory {\n+                        host: resolved,\n+                        guest,\n+                    }\n+                };\n+\n+                mapped_dirs.push(mapping);\n+            }\n+\n+            for MappedDirectory { host, guest } in &self.mapped_dirs {\n+                let resolved_host = host.canonicalize().with_context(|| {\n+                    format!(\n+                        \"could not canonicalize path for argument '--mapdir {}:{}'\",\n+                        host.display(),\n+                        guest,\n+                    )\n+                })?;\n+\n+                let mapping = if guest == \".\" {\n+                    if have_current_dir {\n+                        bail!(\"Cannot pre-open the current directory twice: '--mapdir=?:.' / '--dir=.' must only be specified once\");\n+                    }\n+                    have_current_dir = true;\n+\n+                    MappedDirectory {\n+                        host: resolved_host,\n+                        guest: Self::MAPPED_CURRENT_DIR_DEFAULT_PATH.to_string(),\n+                    }\n+                } else {\n+                    MappedDirectory {\n+                        host: resolved_host,\n+                        guest: guest.clone(),\n+                    }\n+                };\n+                mapped_dirs.push(mapping);\n+            }\n+\n+            if !mapped_dirs.is_empty() {\n                 let fs_backing: Arc<dyn FileSystem + Send + Sync> =\n                     Arc::new(PassthruFileSystem::new(default_fs_backing()));\n                 for MappedDirectory { host, guest } in self.mapped_dirs.clone() {\n@@ -209,20 +292,16 @@ impl Wasi {\n             }\n \n             // Open the root of the new filesystem\n-            builder\n+            let b = builder\n                 .sandbox_fs(root_fs)\n                 .preopen_dir(Path::new(\"/\"))\n-                .unwrap()\n-                .map_dir(\".\", \"/\")?\n-        } else {\n-            builder\n-                .fs(default_fs_backing())\n-                .preopen_dirs(self.pre_opened_directories.clone())?\n-                .map_dirs(\n-                    self.mapped_dirs\n-                        .iter()\n-                        .map(|d| (d.guest.clone(), d.host.clone())),\n-                )?\n+                .unwrap();\n+\n+            if have_current_dir {\n+                b.map_dir(\".\", Self::MAPPED_CURRENT_DIR_DEFAULT_PATH)?\n+            } else {\n+                b.map_dir(\".\", \"/\")?\n+            }\n         };\n \n         *builder.capabilities_mut() = self.capabilities();\n@@ -238,6 +317,119 @@ impl Wasi {\n         Ok(builder)\n     }\n \n+    pub fn build_mapped_directories(&self) -> Result<Vec<MappedDirectory>, anyhow::Error> {\n+        let mut mapped_dirs = Vec::new();\n+\n+        // Process the --dirs flag and merge it with --mapdir.\n+        let mut have_current_dir = false;\n+        for dir in &self.pre_opened_directories {\n+            let mapping = if dir == Path::new(\".\") {\n+                if have_current_dir {\n+                    bail!(\"Cannot pre-open the current directory twice: --dir=. must only be specified once\");\n+                }\n+                have_current_dir = true;\n+\n+                let current_dir =\n+                    std::env::current_dir().context(\"could not determine current directory\")?;\n+\n+                MappedDirectory {\n+                    host: current_dir,\n+                    guest: Self::MAPPED_CURRENT_DIR_DEFAULT_PATH.to_string(),\n+                }\n+            } else {\n+                let resolved = dir.canonicalize().with_context(|| {\n+                    format!(\n+                        \"could not canonicalize path for argument '--dir {}'\",\n+                        dir.display()\n+                    )\n+                })?;\n+\n+                if &resolved != dir {\n+                    bail!(\n+                        \"Invalid argument '--dir {}': path must either be absolute, or '.'\",\n+                        dir.display(),\n+                    );\n+                }\n+\n+                let guest = resolved\n+                    .to_str()\n+                    .with_context(|| {\n+                        format!(\n+                            \"invalid argument '--dir {}': path must be valid utf-8\",\n+                            dir.display(),\n+                        )\n+                    })?\n+                    .to_string();\n+\n+                MappedDirectory {\n+                    host: resolved,\n+                    guest,\n+                }\n+            };\n+\n+            mapped_dirs.push(mapping);\n+        }\n+\n+        for MappedDirectory { host, guest } in &self.mapped_dirs {\n+            let resolved_host = host.canonicalize().with_context(|| {\n+                format!(\n+                    \"could not canonicalize path for argument '--mapdir {}:{}'\",\n+                    host.display(),\n+                    guest,\n+                )\n+            })?;\n+\n+            let mapping = if guest == \".\" {\n+                if have_current_dir {\n+                    bail!(\"Cannot pre-open the current directory twice: '--mapdir=?:.' / '--dir=.' must only be specified once\");\n+                }\n+                have_current_dir = true;\n+\n+                MappedDirectory {\n+                    host: resolved_host,\n+                    guest: Self::MAPPED_CURRENT_DIR_DEFAULT_PATH.to_string(),\n+                }\n+            } else {\n+                MappedDirectory {\n+                    host: resolved_host,\n+                    guest: guest.clone(),\n+                }\n+            };\n+            mapped_dirs.push(mapping);\n+        }\n+\n+        Ok(mapped_dirs)\n+    }\n+\n+    pub fn build_mapped_commands(&self) -> Result<Vec<MappedCommand>, anyhow::Error> {\n+        self.map_commands\n+            .iter()\n+            .map(|item| {\n+                let (a, b) = item.split_once('=').with_context(|| {\n+                    format!(\n+                        \"Invalid --map-command flag: expected <ALIAS>=<HOST_PATH>, got '{item}'\"\n+                    )\n+                })?;\n+\n+                let a = a.trim();\n+                let b = b.trim();\n+\n+                if a.is_empty() {\n+                    bail!(\"Invalid --map-command flag - alias cannot be empty: '{item}'\");\n+                }\n+                // TODO(theduke): check if host command exists, and canonicalize PathBuf.\n+                if b.is_empty() {\n+                    bail!(\"Invalid --map-command flag - host path cannot be empty: '{item}'\");\n+                }\n+\n+                Ok(MappedCommand {\n+                    alias: a.to_string(),\n+                    target: b.to_string(),\n+                })\n+            })\n+            .collect::<Result<Vec<_>, anyhow::Error>>()\n+    }\n+\n     pub fn capabilities(&self) -> Capabilities {\n         let mut caps = Capabilities::default();\n "
        },
        {
            "filename": "lib/wasix/src/os/console/mod.rs",
            "diff": "@@ -225,7 +225,13 @@ impl Console {\n             .with_stdin(Box::new(self.stdin.clone()))\n             .with_stdout(Box::new(self.stdout.clone()))\n             .with_stderr(Box::new(self.stderr.clone()))\n-            .prepare_webc_env(prog, &wasi_opts, &pkg, self.runtime.clone(), Some(root_fs))\n+            .prepare_webc_env(\n+                prog,\n+                &wasi_opts,\n+                Some(&pkg),\n+                self.runtime.clone(),\n+                Some(root_fs),\n+            )\n             // TODO: better error conversion\n             .map_err(|err| SpawnError::Other(err.into()))?;\n "
        },
        {
            "filename": "lib/wasix/src/runners/mod.rs",
            "diff": "@@ -7,7 +7,7 @@ mod wasi_common;\n #[cfg(feature = \"webc_runner_rt_wcgi\")]\n pub mod wcgi;\n \n-pub use self::runner::Runner;\n+pub use self::{runner::Runner, wasi_common::MappedCommand};\n \n /// A directory that should be mapped from the host filesystem into a WASI\n /// instance (the \"guest\")."
        },
        {
            "filename": "lib/wasix/src/runners/wasi.rs",
            "diff": "@@ -1,10 +1,11 @@\n //! WebC container support for running WASI modules\n \n-use std::sync::Arc;\n+use std::{path::PathBuf, sync::Arc};\n \n use anyhow::{Context, Error};\n use tracing::Instrument;\n use virtual_fs::{ArcBoxFile, TmpFileSystem, VirtualFile};\n+use wasmer::Module;\n use webc::metadata::{annotations::Wasi, Command};\n \n use crate::{\n@@ -15,6 +16,8 @@ use crate::{\n     Runtime, WasiEnvBuilder, WasiRuntimeError,\n };\n \n+use super::wasi_common::MappedCommand;\n+\n #[derive(Debug, Default, Clone)]\n pub struct WasiRunner {\n     wasi: CommonWasiOptions,\n@@ -85,13 +88,13 @@ impl WasiRunner {\n         }\n     }\n \n-    pub fn with_forward_host_env(mut self) -> Self {\n-        self.set_forward_host_env();\n+    pub fn with_forward_host_env(mut self, forward: bool) -> Self {\n+        self.set_forward_host_env(forward);\n         self\n     }\n \n-    pub fn set_forward_host_env(&mut self) {\n-        self.wasi.forward_host_env = true;\n+    pub fn set_forward_host_env(&mut self, forward: bool) {\n+        self.wasi.forward_host_env = forward;\n     }\n \n     pub fn with_mapped_directories<I, D>(mut self, dirs: I) -> Self\n@@ -105,6 +108,15 @@ impl WasiRunner {\n         self\n     }\n \n+    pub fn set_current_dir(&mut self, dir: impl Into<PathBuf>) {\n+        self.wasi.current_dir = Some(dir.into());\n+    }\n+\n+    pub fn with_current_dir(mut self, dir: impl Into<PathBuf>) -> Self {\n+        self.set_current_dir(dir);\n+        self\n+    }\n+\n     /// Add a package that should be available to the instance at runtime.\n     pub fn add_injected_package(&mut self, pkg: BinaryPackage) -> &mut Self {\n         self.wasi.injected_packages.push(pkg);\n@@ -135,7 +147,35 @@ impl WasiRunner {\n         self\n     }\n \n-    pub fn capabilities(&mut self) -> &mut Capabilities {\n+    pub fn add_mapped_host_command(&mut self, alias: impl Into<String>, target: impl Into<String>) {\n+        self.wasi.mapped_host_commands.push(MappedCommand {\n+            alias: alias.into(),\n+            target: target.into(),\n+        });\n+    }\n+\n+    pub fn with_mapped_host_command(\n+        mut self,\n+        alias: impl Into<String>,\n+        target: impl Into<String>,\n+    ) -> Self {\n+        self.add_mapped_host_command(alias, target);\n+        self\n+    }\n+\n+    pub fn add_mapped_host_commands(&mut self, commands: impl IntoIterator<Item = MappedCommand>) {\n+        self.wasi.mapped_host_commands.extend(commands);\n+    }\n+\n+    pub fn with_mapped_host_commands(\n+        mut self,\n+        commands: impl IntoIterator<Item = MappedCommand>,\n+    ) -> Self {\n+        self.add_mapped_host_commands(commands);\n+        self\n+    }\n+\n+    pub fn capabilities_mut(&mut self) -> &mut Capabilities {\n         &mut self.wasi.capabilities\n     }\n \n@@ -183,12 +223,19 @@ impl WasiRunner {\n         &self,\n         program_name: &str,\n         wasi: &Wasi,\n-        pkg: &BinaryPackage,\n+        pkg: Option<&BinaryPackage>,\n         runtime: Arc<dyn Runtime + Send + Sync>,\n         root_fs: Option<TmpFileSystem>,\n     ) -> Result<WasiEnvBuilder, anyhow::Error> {\n-        let mut builder = WasiEnvBuilder::new(program_name);\n-        let container_fs = Arc::clone(&pkg.webc_fs);\n+        let mut builder = WasiEnvBuilder::new(program_name).runtime(runtime);\n+\n+        let container_fs = if let Some(pkg) = pkg {\n+            builder.add_webc(pkg.clone());\n+            Some(Arc::clone(&pkg.webc_fs))\n+        } else {\n+            None\n+        };\n+\n         self.wasi\n             .prepare_webc_env(&mut builder, container_fs, wasi, root_fs)?;\n \n@@ -202,11 +249,28 @@ impl WasiRunner {\n             builder.set_stderr(Box::new(stderr.clone()));\n         }\n \n-        builder.add_webc(pkg.clone());\n-        builder.set_runtime(runtime);\n-\n         Ok(builder)\n     }\n+\n+    pub fn run_wasm(\n+        &self,\n+        runtime: Arc<dyn Runtime + Send + Sync>,\n+        program_name: &str,\n+        module: &Module,\n+        asyncify: bool,\n+    ) -> Result<(), Error> {\n+        let wasi = webc::metadata::annotations::Wasi::new(program_name);\n+        let mut store = runtime.new_store();\n+        let env = self.prepare_webc_env(program_name, &wasi, None, runtime, None)?;\n+\n+        if asyncify {\n+            env.run_with_store_async(module.clone(), store)?;\n+        } else {\n+            env.run_with_store(module.clone(), &mut store)?;\n+        }\n+\n+        Ok(())\n+    }\n }\n \n impl crate::runners::Runner for WasiRunner {\n@@ -231,13 +295,13 @@ impl crate::runners::Runner for WasiRunner {\n             .annotation(\"wasi\")?\n             .unwrap_or_else(|| Wasi::new(command_name));\n \n-        let store = runtime.new_store();\n-\n         let env = self\n-            .prepare_webc_env(command_name, &wasi, pkg, Arc::clone(&runtime), None)\n+            .prepare_webc_env(command_name, &wasi, Some(pkg), Arc::clone(&runtime), None)\n             .context(\"Unable to prepare the WASI environment\")?\n             .build()?;\n \n+        let store = runtime.new_store();\n+\n         let command_name = command_name.to_string();\n         let tasks = runtime.task_manager().clone();\n         let pkg = pkg.clone();"
        },
        {
            "filename": "lib/wasix/src/runners/wasi_common.rs",
            "diff": "@@ -14,21 +14,31 @@ use crate::{\n     WasiEnvBuilder,\n };\n \n+#[derive(Debug, Clone)]\n+pub struct MappedCommand {\n+    /// The new alias.\n+    pub alias: String,\n+    /// The original command.\n+    pub target: String,\n+}\n+\n #[derive(Debug, Default, Clone)]\n pub(crate) struct CommonWasiOptions {\n     pub(crate) args: Vec<String>,\n     pub(crate) env: HashMap<String, String>,\n     pub(crate) forward_host_env: bool,\n     pub(crate) mapped_dirs: Vec<MappedDirectory>,\n+    pub(crate) mapped_host_commands: Vec<MappedCommand>,\n     pub(crate) injected_packages: Vec<BinaryPackage>,\n     pub(crate) capabilities: Capabilities,\n+    pub(crate) current_dir: Option<PathBuf>,\n }\n \n impl CommonWasiOptions {\n     pub(crate) fn prepare_webc_env(\n         &self,\n         builder: &mut WasiEnvBuilder,\n-        container_fs: Arc<dyn FileSystem + Send + Sync>,\n+        container_fs: Option<Arc<dyn FileSystem + Send + Sync>>,\n         wasi: &WasiAnnotation,\n         root_fs: Option<TmpFileSystem>,\n     ) -> Result<(), anyhow::Error> {\n@@ -48,6 +58,12 @@ impl CommonWasiOptions {\n             builder.add_webc(pkg.clone());\n         }\n \n+        let mapped_cmds = self\n+            .mapped_host_commands\n+            .iter()\n+            .map(|c| (c.alias.as_str(), c.target.as_str()));\n+        builder.add_mapped_commands(mapped_cmds);\n+\n         self.populate_env(wasi, builder);\n         self.populate_args(wasi, builder);\n \n@@ -87,77 +103,85 @@ impl CommonWasiOptions {\n     }\n }\n \n-type ContainerFs =\n-    OverlayFileSystem<TmpFileSystem, [RelativeOrAbsolutePathHack<Arc<dyn FileSystem>>; 1]>;\n+// type ContainerFs =\n+//     OverlayFileSystem<TmpFileSystem, [RelativeOrAbsolutePathHack<Arc<dyn FileSystem>>; 1]>;\n \n-fn prepare_filesystem(\n-    root_fs: TmpFileSystem,\n-    mapped_dirs: &[MappedDirectory],\n-    container_fs: Arc<dyn FileSystem>,\n+fn build_directory_mappings(\n     builder: &mut WasiEnvBuilder,\n-) -> Result<ContainerFs, Error> {\n-    if !mapped_dirs.is_empty() {\n-        let host_fs: Arc<dyn FileSystem + Send + Sync> = Arc::new(crate::default_fs_backing());\n+    root_fs: &mut TmpFileSystem,\n+    host_fs: &Arc<dyn FileSystem + Send + Sync>,\n+    mapped_dirs: &[MappedDirectory],\n+) -> Result<(), anyhow::Error> {\n+    for dir in mapped_dirs {\n+        let MappedDirectory {\n+            host: host_path,\n+            guest: guest_path,\n+        } = dir;\n+        let mut guest_path = PathBuf::from(guest_path);\n+        tracing::debug!(\n+            guest=%guest_path.display(),\n+            host=%host_path.display(),\n+            \"Mounting host folder\",\n+        );\n \n-        for dir in mapped_dirs {\n-            let MappedDirectory {\n-                host: host_path,\n-                guest: guest_path,\n-            } = dir;\n-            let mut guest_path = PathBuf::from(guest_path);\n-            tracing::debug!(\n-                guest=%guest_path.display(),\n-                host=%host_path.display(),\n-                \"Mounting host folder\",\n-            );\n-\n-            if guest_path.is_relative() {\n-                guest_path = apply_relative_path_mounting_hack(&guest_path);\n-            }\n+        if guest_path.is_relative() {\n+            guest_path = apply_relative_path_mounting_hack(&guest_path);\n+        }\n \n-            let host_path = std::fs::canonicalize(host_path).with_context(|| {\n-                format!(\"Unable to canonicalize host path '{}'\", host_path.display())\n+        let host_path = std::fs::canonicalize(host_path).with_context(|| {\n+            format!(\"Unable to canonicalize host path '{}'\", host_path.display())\n+        })?;\n+\n+        let guest_path = root_fs\n+            .canonicalize_unchecked(&guest_path)\n+            .with_context(|| {\n+                format!(\n+                    \"Unable to canonicalize guest path '{}'\",\n+                    guest_path.display()\n+                )\n             })?;\n \n-            let guest_path = root_fs\n-                .canonicalize_unchecked(&guest_path)\n+        if guest_path == Path::new(\"/\") {\n+            root_fs\n+                .mount_directory_entries(&guest_path, host_fs, &host_path)\n+                .with_context(|| format!(\"Unable to mount \\\"{}\\\" to root\", host_path.display(),))?;\n+        } else {\n+            if let Some(parent) = guest_path.parent() {\n+                create_dir_all(root_fs, parent).with_context(|| {\n+                    format!(\"Unable to create the \\\"{}\\\" directory\", parent.display())\n+                })?;\n+            }\n+\n+            root_fs\n+                .mount(guest_path.clone(), host_fs, host_path.clone())\n                 .with_context(|| {\n                     format!(\n-                        \"Unable to canonicalize guest path '{}'\",\n+                        \"Unable to mount \\\"{}\\\" to \\\"{}\\\"\",\n+                        host_path.display(),\n                         guest_path.display()\n                     )\n                 })?;\n \n-            if guest_path == Path::new(\"/\") {\n-                root_fs\n-                    .mount_directory_entries(&guest_path, &host_fs, &host_path)\n-                    .with_context(|| {\n-                        format!(\"Unable to mount \\\"{}\\\" to root\", host_path.display(),)\n-                    })?;\n-            } else {\n-                if let Some(parent) = guest_path.parent() {\n-                    create_dir_all(&root_fs, parent).with_context(|| {\n-                        format!(\"Unable to create the \\\"{}\\\" directory\", parent.display())\n-                    })?;\n-                }\n-\n-                root_fs\n-                    .mount(guest_path.clone(), &host_fs, host_path.clone())\n-                    .with_context(|| {\n-                        format!(\n-                            \"Unable to mount \\\"{}\\\" to \\\"{}\\\"\",\n-                            host_path.display(),\n-                            guest_path.display()\n-                        )\n-                    })?;\n-\n-                builder\n-                    .add_preopen_dir(&guest_path)\n-                    .with_context(|| format!(\"Unable to preopen \\\"{}\\\"\", guest_path.display()))?;\n-            }\n+            builder\n+                .add_preopen_dir(&guest_path)\n+                .with_context(|| format!(\"Unable to preopen \\\"{}\\\"\", guest_path.display()))?;\n         }\n     }\n \n+    Ok(())\n+}\n+\n+fn prepare_filesystem(\n+    mut root_fs: TmpFileSystem,\n+    mapped_dirs: &[MappedDirectory],\n+    container_fs: Option<Arc<dyn FileSystem + Send + Sync>>,\n+    builder: &mut WasiEnvBuilder,\n+) -> Result<Box<dyn FileSystem + Send + Sync>, Error> {\n+    if !mapped_dirs.is_empty() {\n+        let host_fs: Arc<dyn FileSystem + Send + Sync> = Arc::new(crate::default_fs_backing());\n+        build_directory_mappings(builder, &mut root_fs, &host_fs, mapped_dirs)?;\n+    }\n+\n     // HACK(Michael-F-Bryan): The WebcVolumeFileSystem only accepts relative\n     // paths, but our Python executable will try to access its standard library\n     // with relative paths assuming that it is being run from the root\n@@ -166,8 +190,15 @@ fn prepare_filesystem(\n     // Until the FileSystem trait figures out whether relative paths should be\n     // supported or not, we'll add an adapter that automatically retries\n     // operations using an absolute path if it failed using a relative path.\n-    let container_fs = RelativeOrAbsolutePathHack(container_fs);\n-    let fs = OverlayFileSystem::new(root_fs, [container_fs]);\n+\n+    let fs = if let Some(container) = container_fs {\n+        let container = RelativeOrAbsolutePathHack(container);\n+        let fs = OverlayFileSystem::new(root_fs, [container]);\n+        Box::new(fs) as Box<dyn FileSystem + Send + Sync>\n+    } else {\n+        let fs = RelativeOrAbsolutePathHack(root_fs);\n+        Box::new(fs) as Box<dyn FileSystem + Send + Sync>\n+    };\n \n     Ok(fs)\n }\n@@ -309,7 +340,7 @@ mod tests {\n             \"args\".to_string(),\n         ]);\n \n-        args.prepare_webc_env(&mut builder, fs, &annotations, None)\n+        args.prepare_webc_env(&mut builder, Some(fs), &annotations, None)\n             .unwrap();\n \n         assert_eq!(\n@@ -341,7 +372,7 @@ mod tests {\n         let mut annotations = WasiAnnotation::new(\"python\");\n         annotations.env = Some(vec![\"HARD_CODED=env-vars\".to_string()]);\n \n-        args.prepare_webc_env(&mut builder, fs, &annotations, None)\n+        args.prepare_webc_env(&mut builder, Some(fs), &annotations, None)\n             .unwrap();\n \n         assert_eq!(\n@@ -368,7 +399,8 @@ mod tests {\n         let mut builder = WasiEnvBuilder::new(\"\");\n \n         let root_fs = RootFileSystemBuilder::default().build();\n-        let fs = prepare_filesystem(root_fs, &mapping, Arc::new(webc_fs), &mut builder).unwrap();\n+        let fs =\n+            prepare_filesystem(root_fs, &mapping, Some(Arc::new(webc_fs)), &mut builder).unwrap();\n \n         assert!(fs.metadata(\"/home/file.txt\".as_ref()).unwrap().is_file());\n         assert!(fs.metadata(\"lib\".as_ref()).unwrap().is_dir());"
        },
        {
            "filename": "lib/wasix/src/runners/wcgi/runner.rs",
            "diff": "@@ -67,7 +67,7 @@ impl WcgiRunner {\n         let wasi_common = self.config.wasi.clone();\n         let rt = Arc::clone(&runtime);\n         let setup_builder = move |builder: &mut WasiEnvBuilder| {\n-            wasi_common.prepare_webc_env(builder, Arc::clone(&container_fs), &wasi, None)?;\n+            wasi_common.prepare_webc_env(builder, Some(Arc::clone(&container_fs)), &wasi, None)?;\n             builder.set_runtime(Arc::clone(&rt));\n \n             Ok(())"
        },
        {
            "filename": "lib/wasix/src/state/builder.rs",
            "diff": "@@ -9,7 +9,7 @@ use std::{\n use bytes::Bytes;\n use rand::Rng;\n use thiserror::Error;\n-use virtual_fs::{ArcFile, FsError, TmpFileSystem, VirtualFile};\n+use virtual_fs::{ArcFile, FileSystem, FsError, TmpFileSystem, VirtualFile};\n use wasmer::{AsStoreMut, Instance, Module, RuntimeError, Store};\n use wasmer_wasix_types::wasi::{Errno, ExitCode};\n \n@@ -62,6 +62,7 @@ pub struct WasiEnvBuilder {\n     pub(super) stdin: Option<Box<dyn VirtualFile + Send + Sync + 'static>>,\n     pub(super) fs: Option<WasiFsRoot>,\n     pub(super) runtime: Option<Arc<dyn crate::Runtime + Send + Sync + 'static>>,\n+    pub(super) current_dir: Option<PathBuf>,\n \n     /// List of webc dependencies to be injected.\n     pub(super) uses: Vec<BinaryPackage>,\n@@ -306,14 +307,24 @@ impl WasiEnvBuilder {\n     /// Map an atom to a local binary\n     #[cfg(feature = \"sys\")]\n     pub fn map_command<Name, Target>(mut self, name: Name, target: Target) -> Self\n+    where\n+        Name: AsRef<str>,\n+        Target: AsRef<str>,\n+    {\n+        self.add_mapped_command(name, target);\n+        self\n+    }\n+\n+    /// Map an atom to a local binary\n+    #[cfg(feature = \"sys\")]\n+    pub fn add_mapped_command<Name, Target>(&mut self, name: Name, target: Target)\n     where\n         Name: AsRef<str>,\n         Target: AsRef<str>,\n     {\n         let path_buf = PathBuf::from(target.as_ref().to_string());\n         self.map_commands\n             .insert(name.as_ref().to_string(), path_buf);\n-        self\n     }\n \n     /// Maps a series of atoms to the local binaries\n@@ -324,14 +335,23 @@ impl WasiEnvBuilder {\n         Name: AsRef<str>,\n         Target: AsRef<str>,\n     {\n-        map_commands.into_iter().for_each(|(name, target)| {\n-            let path_buf = PathBuf::from(target.as_ref().to_string());\n-            self.map_commands\n-                .insert(name.as_ref().to_string(), path_buf);\n-        });\n+        self.add_mapped_commands(map_commands);\n         self\n     }\n \n+    /// Maps a series of atoms to local binaries.\n+    #[cfg(feature = \"sys\")]\n+    pub fn add_mapped_commands<I, Name, Target>(&mut self, map_commands: I)\n+    where\n+        I: IntoIterator<Item = (Name, Target)>,\n+        Name: AsRef<str>,\n+        Target: AsRef<str>,\n+    {\n+        for (alias, target) in map_commands {\n+            self.add_mapped_command(alias, target);\n+        }\n+    }\n+\n     /// Preopen a directory\n     ///\n     /// This opens the given directory at the virtual root, `/`, and allows\n@@ -480,6 +500,15 @@ impl WasiEnvBuilder {\n         Ok(self)\n     }\n \n+    pub fn set_current_dir(&mut self, dir: impl Into<PathBuf>) {\n+        self.current_dir = Some(dir.into());\n+    }\n+\n+    pub fn current_dir(mut self, dir: impl Into<PathBuf>) -> Self {\n+        self.set_current_dir(dir);\n+        self\n+    }\n+\n     /// Overwrite the default WASI `stdout`, if you want to hold on to the\n     /// original `stdout` use [`WasiFs::swap_file`] after building.\n     pub fn stdout(mut self, new_file: Box<dyn VirtualFile + Send + Sync + 'static>) -> Self {\n@@ -651,6 +680,28 @@ impl WasiEnvBuilder {\n             .take()\n             .unwrap_or_else(|| WasiFsRoot::Sandbox(Arc::new(TmpFileSystem::new())));\n \n+        if let Some(dir) = &self.current_dir {\n+            match fs_backing.read_dir(dir) {\n+                Ok(_) => {\n+                    // All good\n+                }\n+                Err(FsError::EntryNotFound) => {\n+                    fs_backing.create_dir(dir).map_err(|err| {\n+                        WasiStateCreationError::WasiFsSetupError(format!(\n+                            \"Could not create specified current directory at '{}': {err}\",\n+                            dir.display()\n+                        ))\n+                    })?;\n+                }\n+                Err(err) => {\n+                    return Err(WasiStateCreationError::WasiFsSetupError(format!(\n+                        \"Could check specified current directory at '{}': {err}\",\n+                        dir.display()\n+                    )));\n+                }\n+            }\n+        }\n+\n         // self.preopens are checked in [`PreopenDirBuilder::build`]\n         let inodes = crate::state::WasiInodes::new();\n         let wasi_fs = {\n@@ -682,6 +733,16 @@ impl WasiEnvBuilder {\n             wasi_fs\n         };\n \n+        if let Some(dir) = &self.current_dir {\n+            let s = dir.to_str().ok_or_else(|| {\n+                WasiStateCreationError::WasiFsSetupError(format!(\n+                    \"Specified current directory is not valid UTF-8: '{}'\",\n+                    dir.display()\n+                ))\n+            })?;\n+            wasi_fs.set_current_dir(s);\n+        }\n+\n         let envs = self\n             .envs\n             .into_iter()"
        }
    ],
    "commitTime": "2023-11-08 17:47:44"
}