{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 7.5,
    "disclosureTime": "2023-12-21 23:15:57",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-RUST-ROSENPASS-6137979",
    "identifiers": {
        "CVE": [],
        "CWE": [
            "CWE-20"
        ]
    },
    "language": "rust",
    "malicious": false,
    "packageManager": "cargo",
    "publicationTime": "2023-12-22 10:24:01",
    "remediation": "Upgrade rosenpass to version 0.2.1 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Improper Input Validation",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Improper Input Validation due to size of buffers not being properly checked when attempting to decode messages. An attacker can trigger a panic by sending a UDP datagram with a 1 byte payload over network. "
    },
    "source_code": [
        {
            "filename": "rosenpass/src/lib.rs",
            "diff": "@@ -19,7 +19,7 @@ pub enum RosenpassError {\n     Oqs,\n     #[error(\"error from external library while calling OQS\")]\n     OqsExternalLib,\n-    #[error(\"buffer size mismatch, required {required_size} but only found {actual_size}\")]\n+    #[error(\"buffer size mismatch, required {required_size} but found {actual_size}\")]\n     BufferSizeMismatch {\n         required_size: usize,\n         actual_size: usize,"
        },
        {
            "filename": "rosenpass/src/msgs.rs",
            "diff": "@@ -143,7 +143,7 @@ macro_rules! data_lense(\n             pub fn check_size(len: usize) -> Result<(), RosenpassError>{\n                 let required_size = $( $len + )+ 0;\n                 let actual_size = len;\n-                if required_size < actual_size {\n+                if required_size != actual_size {\n                     Err(RosenpassError::BufferSizeMismatch {\n                         required_size,\n                         actual_size,\n@@ -199,23 +199,53 @@ macro_rules! data_lense(\n             type __ContainerType;\n \n             /// Create a lense to the byte slice\n-            fn [< $type:snake >] $(< $($generic),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError>;\n+            fn [< $type:snake >] $(< $($generic : LenseView),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError>;\n+\n+            /// Create a lense to the byte slice, automatically truncating oversized buffers\n+            fn [< $type:snake _ truncating >] $(< $($generic : LenseView),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError>;\n         }\n \n         impl<'a> [< $type Ext >] for &'a [u8] {\n             type __ContainerType = &'a [u8];\n \n-            fn [< $type:snake >] $(< $($generic),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError> {\n+            fn [< $type:snake >] $(< $($generic : LenseView),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError> {\n+                $type::<Self::__ContainerType, $( $($generic),+ )? >::check_size(self.len())?;\n                 Ok($type ( self, $( $( ::core::marker::PhantomData::<$generic>  ),+ )? ))\n             }\n+\n+            fn [< $type:snake _ truncating >] $(< $($generic : LenseView),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError> {\n+                let required_size = $( $len + )+ 0;\n+                let actual_size = self.len();\n+                if actual_size < required_size {\n+                    return Err(RosenpassError::BufferSizeMismatch {\n+                        required_size,\n+                        actual_size,\n+                    });\n+                }\n+\n+                [< $type Ext >]::[< $type:snake >](&self[..required_size])\n+            }\n         }\n \n         impl<'a> [< $type Ext >] for &'a mut [u8] {\n             type __ContainerType = &'a mut [u8];\n-\n-            fn [< $type:snake >] $(< $($generic),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError> {\n+            fn [< $type:snake >] $(< $($generic : LenseView),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError> {\n+                $type::<Self::__ContainerType, $( $($generic),+ )? >::check_size(self.len())?;\n                 Ok($type ( self, $( $( ::core::marker::PhantomData::<$generic>  ),+ )? ))\n             }\n+\n+            fn [< $type:snake _ truncating >] $(< $($generic : LenseView),* >)? (self) -> Result< $type<Self::__ContainerType, $( $($generic),+ )? >, RosenpassError> {\n+                let required_size = $( $len + )+ 0;\n+                let actual_size = self.len();\n+                if actual_size < required_size {\n+                    return Err(RosenpassError::BufferSizeMismatch {\n+                        required_size,\n+                        actual_size,\n+                    });\n+                }\n+\n+                [< $type Ext >]::[< $type:snake >](&mut self[..required_size])\n+            }\n         }\n     });\n );"
        },
        {
            "filename": "rosenpass/src/protocol.rs",
            "diff": "@@ -736,7 +736,7 @@ impl CryptoServer {\n     // TODO remove unnecessary copying between global tx_buf and per-peer buf\n     // TODO move retransmission storage to io server\n     pub fn initiate_handshake(&mut self, peer: PeerPtr, tx_buf: &mut [u8]) -> Result<usize> {\n-        let mut msg = tx_buf.envelope::<InitHello<()>>()?; // Envelope::<InitHello>::default(); // TODO\n+        let mut msg = tx_buf.envelope_truncating::<InitHello<()>>()?; // Envelope::<InitHello>::default(); // TODO\n         self.handle_initiation(peer, msg.payload_mut().init_hello()?)?;\n         let len = self.seal_and_commit_msg(peer, MsgType::InitHello, msg)?;\n         peer.hs()\n@@ -793,7 +793,7 @@ impl CryptoServer {\n                 let msg_in = rx_buf.envelope::<InitHello<&[u8]>>()?;\n                 ensure!(msg_in.check_seal(self)?, seal_broken);\n \n-                let mut msg_out = tx_buf.envelope::<RespHello<&mut [u8]>>()?;\n+                let mut msg_out = tx_buf.envelope_truncating::<RespHello<&mut [u8]>>()?;\n                 let peer = self.handle_init_hello(\n                     msg_in.payload().init_hello()?,\n                     msg_out.payload_mut().resp_hello()?,\n@@ -805,7 +805,7 @@ impl CryptoServer {\n                 let msg_in = rx_buf.envelope::<RespHello<&[u8]>>()?;\n                 ensure!(msg_in.check_seal(self)?, seal_broken);\n \n-                let mut msg_out = tx_buf.envelope::<InitConf<&mut [u8]>>()?;\n+                let mut msg_out = tx_buf.envelope_truncating::<InitConf<&mut [u8]>>()?;\n                 let peer = self.handle_resp_hello(\n                     msg_in.payload().resp_hello()?,\n                     msg_out.payload_mut().init_conf()?,\n@@ -820,7 +820,7 @@ impl CryptoServer {\n                 let msg_in = rx_buf.envelope::<InitConf<&[u8]>>()?;\n                 ensure!(msg_in.check_seal(self)?, seal_broken);\n \n-                let mut msg_out = tx_buf.envelope::<EmptyData<&mut [u8]>>()?;\n+                let mut msg_out = tx_buf.envelope_truncating::<EmptyData<&mut [u8]>>()?;\n                 let peer = self.handle_init_conf(\n                     msg_in.payload().init_conf()?,\n                     msg_out.payload_mut().empty_data()?,\n@@ -1733,31 +1733,94 @@ impl CryptoServer {\n mod test {\n     use super::*;\n \n-    fn init_crypto_server() -> CryptoServer {\n-        // always init libsodium before anything\n+    #[test]\n+    /// Ensure that the protocol implementation can deal with truncated\n+    /// messages and with overlong messages.\n+    ///\n+    /// This test performs a complete handshake between two randomly generated\n+    /// servers; instead of delivering the message correctly at first messages\n+    /// of length zero through about 1.2 times the correct message size are delivered.\n+    ///\n+    /// Producing an error is expected on each of these messages.\n+    ///\n+    /// Finally the correct message is delivered and the same process\n+    /// starts again in the other direction.\n+    ///\n+    /// Through all this, the handshake should still successfully terminate;\n+    /// i.e. an exchanged key must be produced in both servers.\n+    fn handles_incorrect_size_messages() {\n         crate::sodium::sodium_init().unwrap();\n \n-        // initialize secret and public key for the crypto server\n-        let (mut sk, mut pk) = (SSk::zero(), SPk::zero());\n-\n-        // Guranteed to have 8MiB of stack size\n         stacker::grow(8 * 1024 * 1024, || {\n-            StaticKEM::keygen(sk.secret_mut(), pk.secret_mut()).expect(\"unable to generate keys\");\n+            const OVERSIZED_MESSAGE: usize = ((MAX_MESSAGE_LEN as f32) * 1.2) as usize;\n+            type MsgBufPlus = Public<OVERSIZED_MESSAGE>;\n+\n+            const PEER0: PeerPtr = PeerPtr(0);\n+\n+            let (mut me, mut they) = make_server_pair().unwrap();\n+            let (mut msgbuf, mut resbuf) = (MsgBufPlus::zero(), MsgBufPlus::zero());\n+\n+            // Process the entire handshake\n+            let mut msglen = Some(me.initiate_handshake(PEER0, &mut *resbuf).unwrap());\n+            loop {\n+                if let Some(l) = msglen {\n+                    std::mem::swap(&mut me, &mut they);\n+                    std::mem::swap(&mut msgbuf, &mut resbuf);\n+                    msglen = test_incorrect_sizes_for_msg(&mut me, &*msgbuf, l, &mut *resbuf);\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            assert_eq!(\n+                me.osk(PEER0).unwrap().secret(),\n+                they.osk(PEER0).unwrap().secret()\n+            );\n         });\n+    }\n \n-        CryptoServer::new(sk, pk)\n+    /// Used in handles_incorrect_size_messages() to first deliver many truncated\n+    /// and overlong messages, finally the correct message is delivered and the response\n+    /// returned.\n+    fn test_incorrect_sizes_for_msg(\n+        srv: &mut CryptoServer,\n+        msgbuf: &[u8],\n+        msglen: usize,\n+        resbuf: &mut [u8],\n+    ) -> Option<usize> {\n+        resbuf.fill(0);\n+\n+        for l in 0..(((msglen as f32) * 1.2) as usize) {\n+            if l == msglen {\n+                continue;\n+            }\n+\n+            let res = srv.handle_msg(&msgbuf[..l], resbuf);\n+            assert!(matches!(res, Err(_))); // handle_msg should raise an error\n+            assert!(!resbuf.iter().find(|x| **x != 0).is_some()); // resbuf should not have been changed\n+        }\n+\n+        // Apply the proper handle_msg operation\n+        srv.handle_msg(&msgbuf[..msglen], resbuf).unwrap().resp\n     }\n \n-    /// The determination of the message type relies on reading the first byte of the message. Only\n-    /// after that the length of the message is checked against the specified message type. This\n-    /// test ensures that nothing breaks in the case of an empty message.\n-    #[test]\n-    #[should_panic = \"called `Result::unwrap()` on an `Err` value: received empty message, ignoring it\"]\n-    fn handle_empty_message() {\n-        let mut crypt = init_crypto_server();\n-        let empty_rx_buf = [0u8; 0];\n-        let mut tx_buf = [0u8; 0];\n+    fn keygen() -> Result<(SSk, SPk)> {\n+        // TODO: Copied from the benchmark; deduplicate\n+        let (mut sk, mut pk) = (SSk::zero(), SPk::zero());\n+        StaticKEM::keygen(sk.secret_mut(), pk.secret_mut())?;\n+        Ok((sk, pk))\n+    }\n \n-        crypt.handle_msg(&empty_rx_buf, &mut tx_buf).unwrap();\n+    fn make_server_pair() -> Result<(CryptoServer, CryptoServer)> {\n+        // TODO: Copied from the benchmark; deduplicate\n+        let psk = SymKey::random();\n+        let ((ska, pka), (skb, pkb)) = (keygen()?, keygen()?);\n+        let (mut a, mut b) = (\n+            CryptoServer::new(ska, pka.clone()),\n+            CryptoServer::new(skb, pkb.clone()),\n+        );\n+        a.add_peer(Some(psk.clone()), pkb)?;\n+        b.add_peer(Some(psk), pka)?;\n+        Ok((a, b))\n     }\n }"
        }
    ],
    "commitTime": "2023-11-12 13:42:23"
}