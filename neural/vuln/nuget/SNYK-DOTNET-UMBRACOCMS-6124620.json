{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "LOW",
        "userInteraction": "REQUIRED",
        "scope": "UNCHANGED",
        "confidentiality": "LOW",
        "integrity": "LOW",
        "availability": "NONE"
    },
    "credit": [
        "S3ntago"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 5.4,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "LOW",
                "userInteraction": "REQUIRED",
                "scope": "CHANGED",
                "confidentiality": "LOW",
                "integrity": "LOW",
                "availability": "NONE"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 3.7,
    "disclosureTime": "2023-12-12 20:52:32",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.06909",
        "probability": "0.00043"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-DOTNET-UMBRACOCMS-6124620",
    "identifiers": {
        "CVE": [
            "CVE-2023-49279"
        ],
        "CWE": [
            "CWE-79"
        ]
    },
    "language": "dotnet",
    "malicious": false,
    "packageManager": "nuget",
    "publicationTime": "2023-12-13 14:43:42",
    "remediation": "Upgrade Umbraco.Cms to version 7.15.11, 8.18.9, 10.7.0, 11.5.0, 12.2.0 or higher. ",
    "severity": "low",
    "socialTrendAlert": false,
    "title": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
    "vulnDescription": {
        "Overview": "Affected versions of this package are vulnerable to Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'). An attacker with access to the backoffice can upload malicious SVG files containing scripts, which may be executed if another user is tricked into loading the media directly in a browser. ",
        "Workaround": "Users unable to upgrade to the fixed version can do one of the following: Implement the server-side file validation https://docs.umbraco.com/umbraco-cms/reference/security/serverside-file-validation Serve all media from a different host (e.g, cdn) than where Umbraco is hosted. "
    },
    "source_code": [
        {
            "filename": "src/Umbraco.Web.UI.Client/src/common/services/mediahelper.service.js",
            "diff": "@@ -1,9 +1,9 @@\n \ufeff/**\n-* @ngdoc service\n-* @name umbraco.services.mediaHelper\n-* @description A helper object used for dealing with media items\n-**/\n-function mediaHelper(umbRequestHelper, $log) {\n+ * @ngdoc service\n+ * @name umbraco.services.mediaHelper\n+ * @description A helper object used for dealing with media items\n+ **/\n+function mediaHelper(umbRequestHelper, $http, $log) {\n \n     //container of fileresolvers\n     var _mediaFileResolvers = {};\n@@ -304,11 +304,6 @@ function mediaHelper(umbRequestHelper, $log) {\n                 return imagePath;\n             }\n \n-            // Check if file is a svg\n-            if (this.getFileExtension(imagePath) === \"svg\") {\n-                return imagePath;\n-            }\n-\n             // If the path is not an image we cannot get a thumb\n             if (!this.detectIfImageByExtension(imagePath)) {\n                 return null;\n@@ -399,6 +394,61 @@ function mediaHelper(umbRequestHelper, $log) {\n             var lowered = filePath.toLowerCase();\n             var ext = lowered.substr(lowered.lastIndexOf(\".\") + 1);\n             return ext;\n+        },\n+\n+        /**\n+         * @ngdoc function\n+         * @name umbraco.services.mediaHelper#getProcessedImageUrl\n+         * @methodOf umbraco.services.mediaHelper\n+         * @function\n+         *\n+         * @description\n+         * Returns image URL with configured crop and other processing parameters.\n+         *\n+         * @param {string} imagePath Raw image path\n+         * @param {object} options Object describing image generation parameters:\n+         *  {\n+         *      width: <int>\n+         *      height: <int>\n+         *      focalPoint: {\n+         *          left: <int>\n+         *          top: <int>\n+         *      },\n+         *      mode: <string>\n+         *      cacheBusterValue: <string>\n+         *      crop: {\n+         *          x1: <int>\n+         *          x2: <int>\n+         *          y1: <int>\n+         *          y2: <int>\n+         *      },\n+         *  }\n+         */\n+        getProcessedImageUrl: function (imagePath, options) {\n+\n+            if (!options) {\n+                return imagePath;\n+            }\n+\n+            return umbRequestHelper.resourcePromise(\n+                $http.get(\n+                    umbRequestHelper.getApiUrl(\n+                        \"imagesApiBaseUrl\",\n+                        \"GetProcessedImageUrl\",\n+                        {\n+                            imagePath,\n+                            width: options.width,\n+                            height: options.height,\n+                            focalPointLeft: options.focalPoint ? options.focalPoint.left : null,\n+                            focalPointTop:  options.focalPoint ? options.focalPoint.top : null,\n+                            mode: options.mode,\n+                            cacheBusterValue: options.cacheBusterValue,\n+                            cropX1: options.crop ? options.crop.x1 : null,\n+                            cropX2: options.crop ? options.crop.x2 : null,\n+                            cropY1: options.crop ? options.crop.y1 : null,\n+                            cropY2: options.crop ? options.crop.y2 : null\n+                        })),\n+                \"Failed to retrieve processed image URL for image: \" + imagePath);\n         }\n \n     };"
        },
        {
            "filename": "src/Umbraco.Web.UI.Client/src/common/services/tinymce.service.js",
            "diff": "@@ -7,11 +7,11 @@\n  * A service containing all logic for all of the Umbraco TinyMCE plugins\n  */\n function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, stylesheetResource, macroResource, macroService,\n-                        $routeParams, umbRequestHelper, angularHelper, userService, editorService, entityResource, eventsService, localStorageService) {\n+                        $routeParams, umbRequestHelper, angularHelper, userService, editorService, entityResource, eventsService, localStorageService, mediaHelper) {\n \n     //These are absolutely required in order for the macros to render inline\n     //we put these as extended elements because they get merged on top of the normal allowed elements by tiny mce\n-    var extendedValidElements = \"@[id|class|style],-div[id|dir|class|align|style],ins[datetime|cite],-ul[class|style],-li[class|style],-h1[id|dir|class|align|style],-h2[id|dir|class|align|style],-h3[id|dir|class|align|style],-h4[id|dir|class|align|style],-h5[id|dir|class|align|style],-h6[id|style|dir|class|align],span[id|class|style|lang]\";\n+    var extendedValidElements = \"@[id|class|style],-div[id|dir|class|align|style],ins[datetime|cite],-ul[class|style],-li[class|style],-h1[id|dir|class|align|style],-h2[id|dir|class|align|style],-h3[id|dir|class|align|style],-h4[id|dir|class|align|style],-h5[id|dir|class|align|style],-h6[id|style|dir|class|align],span[id|class|style|lang],figure,figcaption\";\n     var fallbackStyles = [{ title: \"Page header\", block: \"h2\" }, { title: \"Section header\", block: \"h3\" }, { title: \"Paragraph header\", block: \"h4\" }, { title: \"Normal\", block: \"p\" }, { title: \"Quote\", block: \"blockquote\" }, { title: \"Code\", block: \"code\" }];\n     // these languages are available for localization\n     var availableLanguages = [\n@@ -222,9 +222,7 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n     }\n \n     function uploadImageHandler(blobInfo, success, failure, progress){\n-        let xhr, formData;\n-\n-        xhr = new XMLHttpRequest();\n+        const xhr = new XMLHttpRequest();\n         xhr.open('POST', Umbraco.Sys.ServerVariables.umbracoUrls.tinyMceApiBaseUrl + 'UploadImage');\n \n         xhr.onloadstart = function(e) {\n@@ -248,17 +246,29 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n         };\n \n         xhr.onload = function () {\n-            let json;\n-\n             if (xhr.status < 200 || xhr.status >= 300) {\n                 failure('HTTP Error: ' + xhr.status);\n                 return;\n             }\n \n-            json = JSON.parse(xhr.responseText);\n+            const data = xhr.responseText;\n+\n+            if (!data.length > 1) {\n+                failure('Unrecognized text string: ' + data);\n+                return;\n+            }\n+\n+            let json = {};\n+\n+            try {\n+                json = JSON.parse(data);\n+            } catch (e) {\n+                failure('Invalid JSON: ' + data + ' - ' + e.message);\n+                return;\n+            }\n \n             if (!json || typeof json.tmpLocation !== 'string') {\n-                failure('Invalid JSON: ' + xhr.responseText);\n+                failure('Invalid JSON: ' + data);\n                 return;\n             }\n \n@@ -271,7 +281,7 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n             success(blobInfo.blobUri());\n         };\n \n-        formData = new FormData();\n+        const formData = new FormData();\n         formData.append('file', blobInfo.blob(), blobInfo.blob().name);\n \n         xhr.send(formData);\n@@ -292,21 +302,25 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n     }\n \n     function sizeImageInEditor(editor, imageDomElement, imgUrl) {\n-\n         var size = editor.dom.getSize(imageDomElement);\n \n         if (editor.settings.maxImageSize && editor.settings.maxImageSize !== 0) {\n             var newSize = imageHelper.scaleToMaxSize(editor.settings.maxImageSize, size.w, size.h);\n \n-\n             editor.dom.setAttrib(imageDomElement, 'width', newSize.width);\n             editor.dom.setAttrib(imageDomElement, 'height', newSize.height);\n \n             // Images inserted via Media Picker will have a URL we can use for ImageResizer QueryStrings\n             // Images pasted/dragged in are not persisted to media until saved & thus will need to be added\n-            if(imgUrl){\n-                var src = imgUrl + \"?width=\" + newSize.width + \"&height=\" + newSize.height;\n-                editor.dom.setAttrib(imageDomElement, 'data-mce-src', src);\n+            if (imgUrl) {\n+                mediaHelper.getProcessedImageUrl(imgUrl,\n+                    {\n+                        width: newSize.width,\n+                        height: newSize.height\n+                    })\n+                    .then(function (resizedImgUrl) {\n+                        editor.dom.setAttrib(imageDomElement, 'data-mce-src', resizedImgUrl);\n+                    });\n             }\n \n             editor.execCommand(\"mceAutoResize\", false, null, null);\n@@ -431,7 +445,7 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n \n \n                 if (args.htmlId) {\n-                    config.selector = \"#\" + args.htmlId;\n+                    config.selector = `[id=\"${args.htmlId}\"]`;\n                 } else if (args.target) {\n                     config.target = args.target;\n                 }\n@@ -651,21 +665,19 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n                 stateSelector: 'img[data-udi]',\n                 onclick: function () {\n \n-\n                     var selectedElm = editor.selection.getNode(),\n-                        currentTarget,\n-                        imgDomElement;\n+                        currentTarget;\n \n                     if (selectedElm.nodeName === 'IMG') {\n                         var img = $(selectedElm);\n-                        imgDomElement = selectedElm;\n \n                         var hasUdi = img.attr(\"data-udi\") ? true : false;\n                         var hasDataTmpImg = img.attr(\"data-tmpimg\") ? true : false;\n \n                         currentTarget = {\n                             altText: img.attr(\"alt\"),\n-                            url: img.attr(\"src\")\n+                            url: img.attr(\"src\"),\n+                            caption: img.attr('data-caption')\n                         };\n \n                         if (hasUdi) {\n@@ -682,85 +694,80 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n                     userService.getCurrentUser().then(function (userData) {\n                         if (callback) {\n                             angularHelper.safeApply($rootScope, function() {\n-                                callback(currentTarget, userData, imgDomElement);\n+                                callback(currentTarget, userData);\n                             });\n                         }\n                     });\n                 }\n             });\n         },\n-\n-        insertMediaInEditor: function (editor, img, imgDomElement) {\n+        /**\n+         * @ngdoc method\n+         * @name umbraco.services.tinyMceService#insetMediaInEditor\n+         * @methodOf umbraco.services.tinyMceService\n+         *\n+         * @description\n+         * Inserts the image element in tinymce plugin\n+         *\n+         * @param {Object} editor the TinyMCE editor instance\n+         */\n+        insertMediaInEditor: function (editor, img) {\n             if (img) {\n-                // imgElement is only definied if updating an image\n-                // if null/undefinied then its a BRAND new image\n-                if(imgDomElement){\n-                    // Check if the img src has changed\n-                    // If it has we will need to do some resizing/recalc again\n-                    var hasImageSrcChanged = false;\n-\n-                    if(img.url !==  editor.dom.getAttrib(imgDomElement, \"src\")){\n-                        hasImageSrcChanged = true;\n-                    }\n+                // We need to create a NEW DOM <img> element to insert\n+                // setting an attribute of ID to __mcenew, so we can gather a reference to the node, to be able to update its size accordingly to the size of the image.\n+                var data = {\n+                    alt: img.altText || \"\",\n+                    src: (img.url) ? img.url : \"nothing.jpg\",\n+                    id: \"__mcenew\",\n+                    \"data-udi\": img.udi,\n+                    \"data-caption\": img.caption\n+                };\n+                var newImage = editor.dom.createHTML('img', data);\n+                var parentElement = editor.selection.getNode().parentElement;\n \n-                    // If null/undefinied it will remove the attribute\n-                    editor.dom.setAttrib(imgDomElement, \"alt\", img.altText);\n+                if (img.caption) {\n+                    var figCaption = editor.dom.createHTML('figcaption', {}, img.caption);\n+                    var combined = newImage + figCaption;\n \n-                    // It's possible to pick a NEW image - so need to ensure this gets updated\n-                    if(img.udi){\n-                        editor.dom.setAttrib(imgDomElement, \"data-udi\", img.udi);\n+                    if (parentElement.nodeName !== 'FIGURE') {\n+                        var fragment = editor.dom.createHTML('figure', {}, combined);\n+                        editor.selection.setContent(fragment);\n                     }\n-\n-                    // It's possible to pick a NEW image - so need to ensure this gets updated\n-                    if(img.url){\n-                        editor.dom.setAttrib(imgDomElement, \"src\", img.url);\n+                    else {\n+                        parentElement.innerHTML = combined;\n                     }\n-\n-                    // Remove width & height attributes (ONLY if imgSrc changed)\n-                    // So native image size is used as this needed to re-calc width & height\n-                    // For the function sizeImageInEditor() & apply the image resizing querystrings etc..\n-                    if(hasImageSrcChanged){\n-                        editor.dom.setAttrib(imgDomElement, \"width\", null);\n-                        editor.dom.setAttrib(imgDomElement, \"height\", null);\n-\n-                        //Re-calc the image dimensions\n-                        sizeImageInEditor(editor, imgDomElement, img.url);\n+                }\n+                else {\n+                    //if caption is removed, remove the figure element\n+                    if (parentElement.nodeName === 'FIGURE') {\n+                        parentElement.parentElement.innerHTML = newImage;\n                     }\n+                    else {\n+                        editor.selection.setContent(newImage);\n+                    }\n+                }\n \n-                } else{\n-                    // We need to create a NEW DOM <img> element to insert\n-                    // setting an attribute of ID to __mcenew, so we can gather a reference to the node, to be able to update its size accordingly to the size of the image.\n-                    var data = {\n-                        alt: img.altText || \"\",\n-                        src: (img.url) ? img.url : \"nothing.jpg\",\n-                        id: \"__mcenew\",\n-                        \"data-udi\": img.udi\n-                    };\n-\n-                    editor.selection.setContent(editor.dom.createHTML('img', data));\n-\n-                    // Using settimeout to wait for a DoM-render, so we can find the new element by ID.\n-                    $timeout(function () {\n+                // Using settimeout to wait for a DoM-render, so we can find the new element by ID.\n+                $timeout(function () {\n \n-                        var imgElm = editor.dom.get(\"__mcenew\");\n-                        editor.dom.setAttrib(imgElm, \"id\", null);\n+                    var imgElm = editor.dom.get(\"__mcenew\");\n+                    editor.dom.setAttrib(imgElm, \"id\", null);\n \n-                        // When image is loaded we are ready to call sizeImageInEditor.\n-                        var onImageLoaded = function() {\n-                            sizeImageInEditor(editor, imgElm, img.url);\n-                            editor.fire(\"Change\");\n-                        }\n+                    // When image is loaded we are ready to call sizeImageInEditor.\n+                    var onImageLoaded = function() {\n+                        sizeImageInEditor(editor, imgElm, img.url);\n+                        editor.fire(\"Change\");\n+                    }\n \n-                        // Check if image already is loaded.\n-                        if(imgElm.complete === true) {\n-                            onImageLoaded();\n-                        } else {\n-                            imgElm.onload = onImageLoaded;\n-                        }\n+                    // Check if image already is loaded.\n+                    if(imgElm.complete === true) {\n+                        onImageLoaded();\n+                    } else {\n+                        imgElm.onload = onImageLoaded;\n+                    }\n \n-                    });\n+                });\n \n-                }\n             }\n         },\n \n@@ -1243,7 +1250,7 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n \n             // the href might be an external url, so check the value for an anchor/qs\n             // href has the anchor re-appended later, hence the reset here to avoid duplicating the anchor\n-            if (!target.anchor) {\n+            if (!target.anchor && href) {\n                 var urlParts = href.split(/(#|\\?)/);\n                 if (urlParts.length === 3) {\n                     href = urlParts[0];\n@@ -1444,7 +1451,8 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n             // Then we need to add an event listener to the editor\n             // That will update native browser drag & drop events\n             // To update the icon to show you can NOT drop something into the editor\n-            var toolbarItems = args.editor.settings.toolbar.split(\" \");\n+\n+            var toolbarItems = args.editor.settings.toolbar === false ? [] : args.editor.settings.toolbar.split(\" \");\n             if(isMediaPickerEnabled(toolbarItems) === false){\n                 // Wire up the event listener\n                 args.editor.on('dragend dragover draggesture dragdrop drop drag', function (e) {\n@@ -1602,17 +1610,27 @@ function tinyMceService($rootScope, $q, imageHelper, $locale, $http, $timeout, s\n                 syncContent();\n             });\n \n+            // When the element is removed from the DOM, we need to terminate\n+            // any active watchers to ensure scopes are disposed and do not leak.\n+            // No need to sync content as that has already happened.\n+            args.editor.on('remove', () => stopWatch());\n+\n             args.editor.on('ObjectResized', function (e) {\n-                var qs = \"?width=\" + e.width + \"&height=\" + e.height + \"&mode=max\";\n                 var srcAttr = $(e.target).attr(\"src\");\n                 var path = srcAttr.split(\"?\")[0];\n-                $(e.target).attr(\"data-mce-src\", path + qs);\n+                mediaHelper.getProcessedImageUrl(path, {\n+                    width: e.width,\n+                    height: e.height,\n+                    mode: \"max\"\n+                }).then(function (resizedPath) {\n+                    $(e.target).attr(\"data-mce-src\", resizedPath);\n+                });\n \n                 syncContent();\n             });\n \n             args.editor.on('Dirty', function (e) {\n-            \tsyncContent(); // Set model.value to the RTE's content\n+                syncContent(); // Set model.value to the RTE's content\n             });\n \n             let self = this;"
        },
        {
            "filename": "src/Umbraco.Web/Editors/ImagesController.cs",
            "diff": "@@ -6,10 +6,8 @@\n using Umbraco.Core.Configuration.UmbracoSettings;\n using Umbraco.Core.IO;\n using Umbraco.Core.Models;\n-using Umbraco.Web.Media;\n using Umbraco.Web.Mvc;\n using Umbraco.Web.WebApi;\n-using Constants = Umbraco.Core.Constants;\n \n namespace Umbraco.Web.Editors\n {\n@@ -73,7 +71,7 @@ public HttpResponseMessage GetResized(string imagePath, int width)\n             try\n             {\n                 imageLastModified = _mediaFileSystem.GetLastModified(imagePath);\n-                \n+\n             }\n             catch (Exception)\n             {\n@@ -89,6 +87,59 @@ public HttpResponseMessage GetResized(string imagePath, int width)\n             response.Headers.Location = new Uri(imageUrl, UriKind.RelativeOrAbsolute);\n             return response;\n         }\n-        \n+\n+        /// <summary>\n+        ///     Gets a processed image for the image at the given path\n+        /// </summary>\n+        /// <param name=\"imagePath\"></param>\n+        /// <param name=\"width\"></param>\n+        /// <param name=\"height\"></param>\n+        /// <param name=\"focalPointLeft\"></param>\n+        /// <param name=\"focalPointTop\"></param>\n+        /// <param name=\"mode\"></param>\n+        /// <param name=\"cacheBusterValue\"></param>\n+        /// <param name=\"cropX1\"></param>\n+        /// <param name=\"cropX2\"></param>\n+        /// <param name=\"cropY1\"></param>\n+        /// <param name=\"cropY2\"></param>\n+        /// <returns></returns>\n+        /// <remarks>\n+        ///     If there is no media, image property or image file is found then this will return not found.\n+        /// </remarks>\n+        public string GetProcessedImageUrl(\n+            string imagePath,\n+            int? width = null,\n+            int? height = null,\n+            decimal? focalPointLeft = null,\n+            decimal? focalPointTop = null,\n+            string mode = \"max\",\n+            string cacheBusterValue = \"\",\n+            decimal? cropX1 = null,\n+            decimal? cropX2 = null,\n+            decimal? cropY1 = null,\n+            decimal? cropY2 = null)\n+        {\n+            var options = new ImageUrlGenerationOptions(imagePath)\n+            {\n+                Width = width,\n+                Height = height,\n+                ImageCropMode = mode,\n+                CacheBusterValue = cacheBusterValue\n+            };\n+\n+            if (focalPointLeft.HasValue && focalPointTop.HasValue)\n+            {\n+                options.FocalPoint =\n+                    new ImageUrlGenerationOptions.FocalPointPosition(focalPointLeft.Value, focalPointTop.Value);\n+            }\n+            else if (cropX1.HasValue && cropX2.HasValue && cropY1.HasValue && cropY2.HasValue)\n+            {\n+                options.Crop =\n+                    new ImageUrlGenerationOptions.CropCoordinates(cropX1.Value, cropY1.Value, cropX2.Value, cropY2.Value);\n+            }\n+\n+            return _imageUrlGenerator.GetImageUrl(options);\n+        }\n+\n     }\n }"
        },
        {
            "filename": "src/Umbraco.Web/Editors/TinyMceController.cs",
            "diff": "@@ -1,4 +1,5 @@\n \ufeffusing System;\n+using System.Collections.Generic;\n using System.IO;\n using System.Linq;\n using System.Net;\n@@ -28,6 +29,18 @@ public class TinyMceController : UmbracoAuthorizedApiController\n         private IMediaService _mediaService;\n         private IContentTypeBaseServiceProvider _contentTypeBaseServiceProvider;\n \n+        private readonly Dictionary<string, string> _fileContentTypeMappings = new()\n+        {\n+            { \"image/png\", \"png\" },\n+            { \"image/jpeg\", \"jpg\" },\n+            { \"image/gif\", \"gif\" },\n+            { \"image/bmp\", \"bmp\" },\n+            { \"image/x-icon\", \"ico\" },\n+            { \"image/svg+xml\", \"svg\" },\n+            { \"image/tiff\", \"tiff\" },\n+            { \"image/webp\", \"webp\" },\n+        };\n+\n \n         public TinyMceController(IMediaService mediaService, IContentTypeBaseServiceProvider contentTypeBaseServiceProvider)\n         {\n@@ -76,7 +89,20 @@ public async Task<HttpResponseMessage> UploadImage()\n             var file = result.FileData[0];\n             var fileName = file.Headers.ContentDisposition.FileName.Trim(Constants.CharArrays.DoubleQuote).TrimEnd();\n             var safeFileName = fileName.ToSafeFileName();\n-            var ext = safeFileName.Substring(safeFileName.LastIndexOf('.') + 1).ToLower();\n+            string ext;\n+            var fileExtensionIndex = safeFileName.LastIndexOf('.');\n+            if (fileExtensionIndex is not -1)\n+            {\n+                ext = safeFileName.Substring(fileExtensionIndex + 1).ToLowerInvariant();\n+            }\n+            else\n+            {\n+                _fileContentTypeMappings.TryGetValue(file.Headers.ContentType.MediaType, out var fileExtension);\n+                ext = fileExtension ?? string.Empty;\n+\n+                // safeFileName will not have a file extension, so we need to add it back\n+                safeFileName += $\".{ext}\";\n+            }\n \n             if (Current.Configs.Settings().Content.IsFileAllowedForUpload(ext) == false || Current.Configs.Settings().Content.ImageFileTypes.Contains(ext) == false)\n             {"
        }
    ],
    "commitTime": "2023-07-05 08:40:32"
}