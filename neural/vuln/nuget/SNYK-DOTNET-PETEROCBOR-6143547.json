{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "NONE",
        "availability": "HIGH"
    },
    "credit": [
        "Unknown"
    ],
    "cvssDetails": [],
    "cvssScore": 7.5,
    "disclosureTime": "2024-01-03 16:44:02",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-DOTNET-PETEROCBOR-6143547",
    "identifiers": {
        "CVE": [
            "CVE-2024-21909"
        ],
        "CWE": [
            "CWE-407"
        ]
    },
    "language": "dotnet",
    "malicious": false,
    "packageManager": "nuget",
    "publicationTime": "2024-01-04 09:39:54",
    "remediation": "Upgrade PeterO.Cbor to version 4.5.2 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Algorithmic Complexity",
    "vulnDescription": {
        "Details": "Denial of Service (DoS) describes a family of attacks, all aimed at making a system inaccessible to its intended and legitimate users. Unlike other vulnerabilities, DoS attacks usually do not aim at breaching security. Rather, they are focused on making websites and services unavailable to genuine users resulting in downtime. One popular Denial of Service vulnerability is DDoS (a Distributed Denial of Service), an attack that attempts to clog network pipes to the system by generating a large volume of traffic from many machines. When it comes to open source libraries, DoS vulnerabilities allow attackers to trigger such a crash or crippling of the service by using a flaw either in the application code or from the use of open source libraries. Two common types of DoS vulnerabilities: High CPU/Memory Consumption- An attacker sending crafted requests that could cause the system to take a disproportionate amount of time to process. For example, commons-fileupload:commons-fileupload . Crash - An attacker sending crafted requests that could cause the system to crash. For Example, npm ws package ",
        "Overview": "PeterO.Cbor is a C# implementation of Concise Binary Object Representation (CBOR). Affected versions of this package are vulnerable to Algorithmic Complexity due to use of an inefficient algorithm in the DecodeFromBytes or other decoding mechanisms. An attacker can cause a denial of service condition by providing crafted data. Note: The inputs affected by this issue are all CBOR maps or contain CBOR maps. ",
        "Workaround": "An input that decodes to a single CBOR object is not capable of containing a CBOR map if: It begins with a byte other than 0x80 through 0xDF It does not contain a byte in the range 0xa0 through 0xBF Such an input is not affected by this vulnerability and an application can choose to perform this check before passing it to a CBOR decoding mechanism. "
    },
    "source_code": [
        {
            "filename": "CBOR/PeterO/Cbor/CBORObject.cs",
            "diff": "@@ -7942,12 +7942,8 @@ public sealed partial class CBORObject : IComparable<CBORObject>,\n       if (listACount != listBCount) {\n         return listACount < listBCount ? -1 : 1;\n       }\n-      var sortedASet = new List<CBORObject>(mapA.Keys);\n-      var sortedBSet = new List<CBORObject>(mapB.Keys);\n-      // DebugUtility.Log(\"---sorting mapA's keys\");\n-      sortedASet.Sort();\n-      // DebugUtility.Log(\"---sorting mapB's keys\");\n-      sortedBSet.Sort();\n+      var sortedASet = new List<CBORObject>(PropertyMap.GetSortedKeys(mapA));\n+      var sortedBSet = new List<CBORObject>(PropertyMap.GetSortedKeys(mapB));\n       // DebugUtility.Log(\"---done sorting\");\n       listACount = sortedASet.Count;\n       listBCount = sortedBSet.Count;"
        },
        {
            "filename": "CBOR/PeterO/Cbor/PropertyMap.cs",
            "diff": "@@ -35,7 +35,7 @@ private sealed class OrderedDictionary<TKey, TValue> :\n       private readonly IDictionary<TKey, TValue> dict;\n       private readonly LinkedList<TKey> list;\n       public OrderedDictionary() {\n-        this.dict = new Dictionary<TKey, TValue>();\n+        this.dict = new SortedDictionary<TKey, TValue>();\n         this.list = new LinkedList<TKey>();\n       }\n       public void Add(KeyValuePair<TKey, TValue> kvp) {\n@@ -179,6 +179,12 @@ private sealed class OrderedDictionary<TKey, TValue> :\n         }\n       }\n \n+      public ICollection<TKey> SortedKeys {\n+        get {\n+           return this.dict.Keys;\n+        }\n+      }\n+\n       public ICollection<TValue> Values {\n         get {\n           return new ValueWrapper<TKey, TValue>(this.dict, this.list);\n@@ -895,6 +901,21 @@ private sealed class PropertyData {\n           Convert.ToInt32(value, CultureInfo.InvariantCulture));\n     }\n \n+    public static ICollection<TKey>\n+    GetSortedKeys<TKey, TValue>(\n+      IDictionary<TKey, TValue> dict) {\n+      var odict = dict as OrderedDictionary<TKey, TValue>;\n+      if (odict != null) {\n+        return odict.SortedKeys;\n+      }\n+      var sdict = dict as SortedDictionary<TKey, TValue>;\n+      if (sdict != null) {\n+        return sdict.Keys;\n+      }\n+      throw new InvalidOperationException(\"Internal error: Map doesn't\" +\n+\"\\u0020support sorted keys\");\n+    }\n+\n     public static ICollection<KeyValuePair<TKey, TValue>>\n     GetEntries<TKey, TValue>(\n       IDictionary<TKey, TValue> dict) {"
        },
        {
            "filename": "CBORTest/CBORGenerator.cs",
            "diff": "@@ -84,7 +84,13 @@ private sealed class ByteWriter {\n     private static int[]\n     valueMajorTypes = {\n       0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4,\n-      4, 5, 6, 6, 7, 7, 7, 7, 7, 7,\n+      4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7,\n+    };\n+\n+    private static int[]\n+    valueMajorTypesHighDepth = {\n+      0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+      5, 5, 5, 5, 5, 5, 6, 7,\n     };\n \n     private static int[] valueMajorTypesHighLength = {\n@@ -130,20 +136,50 @@ private sealed class ByteWriter {\n       }\n     }\n \n+    private void GenerateSmall(IRandomGenExtended r, int depth, ByteWriter bs) {\n+      int v = r.GetInt32(100);\n+      if (v < 25) {\n+        GenerateArgument(r, 0, r.GetInt32(100), bs);\n+      } else if (v < 35) {\n+        bs.Write(0x41);\n+      bs.Write(0x20);\n+      } else if (v < 45) {\n+        bs.Write(0x41);\n+      bs.Write(0x20);\n+      } else if (v < 50) {\n+        bs.Write(0x81);\n+      this.GenerateSmall(r, depth + 1, bs);\n+      } else if (v < 53) {\n+        bs.Write(0xa2);\n+      bs.Write(0xf7);\n+    bs.Write(0xf6);\n+  this.GenerateSmall(r, depth + 1, bs);\n+  bs.Write(0xf5);\n+      } else if (v < 80) {\n+        bs.Write(r.GetInt32(0x40));\n+      } else if (v < 100) {\n+        bs.Write(r.GetInt32(0x60));\n+      }\n+    }\n     private void Generate(IRandomGenExtended r, int depth, ByteWriter bs) {\n       int majorType = valueMajorTypes[r.GetInt32(valueMajorTypes.Length)];\n+      if (depth > 6) {\n+        majorType = valueMajorTypesHighDepth[r.GetInt32(\n+              valueMajorTypesHighDepth.Length)];\n+      }\n       if (bs.ByteLength > 2000000) {\n         majorType = valueMajorTypesHighLength[r.GetInt32(\n               valueMajorTypesHighLength.Length)];\n       }\n-      if (majorType == 3 || majorType == 2) {\n+      if (majorType == 3 || majorType == 2) { // Byte and text strings\n         int len = r.GetInt32(1000);\n         if (r.GetInt32(50) == 0 && depth < 2) {\n           var v = (long)r.GetInt32(100000) * r.GetInt32(100000);\n           len = (int)(v / 100000);\n-        }\n-        if (depth > 6) {\n+        } else if (depth > 6) {\n           len = r.GetInt32(100) == 0 ? 1 : 0;\n+        } else if (depth > 2) {\n+          len = r.GetInt32(16) + 1;\n         }\n         // TODO: Ensure key uniqueness\n         if (r.GetInt32(2) == 0) {\n@@ -174,11 +210,18 @@ private sealed class ByteWriter {\n           }\n         }\n         return;\n-      } else if (majorType == 4 || majorType == 5) {\n+      } else if (majorType == 4 || majorType == 5) { // Arrays and maps\n         int len = r.GetInt32(8);\n         if (r.GetInt32(50) == 0 && depth < 2) {\n           var v = (long)r.GetInt32(1000) * r.GetInt32(1000);\n           len = (int)(v / 1000);\n+        } else if (depth > 6) {\n+          len = r.GetInt32(100) == 0 ? 1 : 0;\n+        } else if (depth > 2) {\n+          len = r.GetInt32(3) + 1;\n+        }\n+        if (depth > 6) {\n+          len = r.GetInt32(100) < 50 ? 1 : (r.GetInt32(100) < 10 ? 2 : 0);\n         }\n         bool indefiniteLength = r.GetInt32(2) == 0;\n         if (indefiniteLength) {\n@@ -187,7 +230,11 @@ private sealed class ByteWriter {\n           GenerateArgument(r, majorType, len, bs);\n         }\n         for (int i = 0; i < len; ++i) {\n-          this.Generate(r, depth + 1, bs);\n+          if (depth > 6) {\n+            this.GenerateSmall(r, depth + 1, bs);\n+          } else {\n+            this.Generate(r, depth + 1, bs);\n+          }\n           if (majorType == 5) {\n             this.Generate(r, depth + 1, bs);\n           }\n@@ -229,7 +276,7 @@ private sealed class ByteWriter {\n           }\n           break;\n       }\n-      if (majorType == 6) {\n+      if (majorType == 6) { // Tags\n         this.Generate(r, depth + 1, bs);\n       }\n     }"
        },
        {
            "filename": "CBORTest/CBORObjectTest.cs",
            "diff": "@@ -9721,6 +9721,145 @@ public sealed class NestedPODClass {\n       Assert.IsTrue(cbor.AsDoubleValue() == Double.NegativeInfinity);\n     }\n \n+[Test]\n+public void TestRoundTripRegressions() {\n+{\n+var options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\n+var bytes = new byte[] {\n+  (byte)0xba, 0x00, 0x00, 0x00, 0x03,\n+  (byte)0xf9,\n+  (byte)0x83, 0x1d,\n+  (byte)0xda,\n+  (byte)0xb6,\n+  (byte)0xda, 0x50, 0x56, 0x1a, 0x50,\n+  (byte)0xe3, 0x2c, 0x7a, 0x16,\n+  (byte)0xfa, 0x50, 0x32, 0x73, 0x07,\n+  (byte)0xfa, (byte)0xb9, 0x2d, 0x73, (byte)0xce, 0x38, (byte)0xd0,\n+};\n+CBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n+}\n+{\n+var options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\n+var bytes = new byte[] {\n+  (byte)0xbf,\n+  (byte)0x9f,\n+  (byte)0xbf, 0x39, 0x20,\n+  (byte)0x8f, 0x4a, 0x1f, 0x46, 0x26, 0x0b, 0x3e, 0x72, 0x2c, 0x7f, 0x11,\n+  0x2e, 0x39,\n+  (byte)0x9d,\n+  (byte)0xba, 0x1a, 0x11,\n+  (byte)0x8d,\n+  (byte)0xc0,\n+  (byte)0xb4, 0x38,\n+  (byte)0xb6,\n+  (byte)0x9b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n+  (byte)0xd8, 0x3b,\n+  (byte)0x99, 0x00, 0x02, 0x3b, 0x05,\n+  (byte)0xbb,\n+  (byte)0xea,\n+  (byte)0x8e, 0x4b,\n+  (byte)0xd3, 0x5e, 0x22,\n+  (byte)0x9f, 0x59, 0x00, 0x00,\n+  (byte)0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x41, 0x20,\n+  (byte)0xbf, 0x1a, 0x00, 0x00, 0x00, 0x61,\n+  (byte)0xb9, 0x00, 0x01, 0x1a, 0x00, 0x00, 0x00, 0x0e,\n+  (byte)0xba, 0x00, 0x00, 0x00, 0x00,\n+  (byte)0xff,\n+  (byte)0xff,\n+  (byte)0xff,\n+  (byte)0xd8, 0x22,\n+  (byte)0xf8,\n+  (byte)0x93,\n+  (byte)0xd9,\n+  (byte)0xaf, 0x33, 0x19,\n+  (byte)0xf0,\n+  (byte)0xf0,\n+  (byte)0xf9,\n+  (byte)0x85,\n+  (byte)0x93,\n+  (byte)0x99, 0x00, 0x01, 0x3a,\n+  (byte)0xb5,\n+  (byte)0xfb, 0x4d, 0x43,\n+  (byte)0x98, 0x00,\n+  (byte)0xff, (byte)0xfa, (byte)0xb0, (byte)0xb4, (byte)0xdc, 0x6d,\n+  (byte)0xff,\n+};\n+CBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n+}\n+{\n+var options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\n+var bytes = new byte[] {\n+  (byte)0xdb, 0x0d,\n+  (byte)0xcb, 0x5d, 0x78,\n+  (byte)0x92,\n+  (byte)0xc2,\n+  (byte)0xc7, 0x2b,\n+  (byte)0xb9, 0x00, 0x02, 0x39,\n+  (byte)0xee,\n+  (byte)0xa0, (byte)0xa0, 0x1a, 0x0e, (byte)0xd9, (byte)0xec, (byte)0xca,\n+  (byte)0xf2,\n+};\n+CBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n+}\n+{\n+var options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\n+var bytes = new byte[] {\n+  (byte)0xbf,\n+  (byte)0xfb,\n+  (byte)0xb1, 0x21,\n+  (byte)0x93,\n+  (byte)0x8c,\n+  (byte)0xc6,\n+  (byte)0xf3,\n+  (byte)0xcf,\n+  (byte)0xb7, (byte)0xf8, 0x76, 0x18, (byte)0xda, 0x39, 0x60, (byte)0xf4,\n+  (byte)0xff,\n+};\n+CBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n+}\n+{\n+var options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\n+var bytes = new byte[] {\n+  (byte)0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+  0x00, 0x02, (byte)0xf0, 0x0d, 0x2a, 0x21,\n+};\n+CBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n+}\n+{\n+var options = new CBOREncodeOptions(\"allowduplicatekeys=1;keepkeyorder=1\");\n+var bytes = new byte[] {\n+  (byte)0xba, 0x00, 0x00, 0x00, 0x02,\n+  (byte)0xf9, 0x48, 0x37,\n+  (byte)0xda,\n+  (byte)0xb5, 0x72,\n+  (byte)0xcf,\n+  (byte)0xf8, 0x31, 0x3b, 0x06, 0x78,\n+  (byte)0xdb, 0x44, 0x7d, (byte)0xba, (byte)0xbd, 0x7d, 0x39, (byte)0x98,\n+  (byte)0xb9,\n+};\n+CBORTestCommon.AssertRoundTrip(CBORObject.DecodeFromBytes(bytes, options));\n+}\n+}\n+[Test]\n+public void TestMapCompareRegressions() {\n+  CBORObject m1, m2;\n+  m1 = CBORObject.NewMap().Add(3, 4).Add(1, 2);\n+  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n+  Assert.AreEqual(0, m1.CompareTo(m2));\n+  TestCommon.CompareTestEqualAndConsistent(m1, m2);\n+  m1 = CBORObject.NewMap().Add(3, 2).Add(1, 2);\n+  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n+  TestCommon.CompareTestLess(m1, m2);\n+  m1 = CBORObject.NewMap().Add(3, 7).Add(1, 2);\n+  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n+  TestCommon.CompareTestGreater(m1, m2);\n+  m1 = CBORObject.NewMap().Add(3, 4).Add(1, 0);\n+  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n+  TestCommon.CompareTestLess(m1, m2);\n+  m1 = CBORObject.NewMap().Add(3, 4).Add(1, 7);\n+  m2 = CBORObject.NewOrderedMap().Add(3, 4).Add(1, 2);\n+  TestCommon.CompareTestGreater(m1, m2);\n+}\n     [Test]\n     public void TestToObject_TypeMapper() {\n       var mapper = new CBORTypeMapper()"
        },
        {
            "filename": "CBORTest/CBORTest.csproj",
            "diff": "@@ -1,6 +1,6 @@\n <Project Sdk='Microsoft.NET.Sdk'>\n   <PropertyGroup>\n-    <TargetFramework>netcoreapp2.1</TargetFramework>\n+    <TargetFramework>netcoreapp5.0</TargetFramework>\n   </PropertyGroup>\n   <PropertyGroup Condition=' &apos;$(Configuration)&apos;==&apos;Debug&apos; '>\n     <DebugType>full</DebugType>"
        },
        {
            "filename": "CBORTest/CBORTestCommon.cs",
            "diff": "@@ -119,7 +119,8 @@ internal static class CBORTestCommon {\n     public static CBORObject RandomCBORMap(IRandomGenExtended rand, int depth) {\n       int x = rand.GetInt32(100);\n       int count = (x < 80) ? 2 : ((x < 93) ? 1 : ((x < 98) ? 0 : 10));\n-      CBORObject cborRet = CBORObject.NewMap();\n+      CBORObject cborRet = rand.GetInt32(100) < 30 ?\n+         CBORObject.NewOrderedMap() : CBORObject.NewMap();\n       for (var i = 0; i < count; ++i) {\n         CBORObject key = RandomCBORObject(rand, depth + 1);\n         CBORObject value = RandomCBORObject(rand, depth + 1);"
        },
        {
            "filename": "CBORTest/TestCommon.cs",
            "diff": "@@ -761,7 +761,7 @@ public static void CompareTestLessEqual<T>(T o1, T o2, string msg)\n       return true;\n     }\n \n-    private static bool ByteArraysEqual(byte[] arr1, byte[] arr2) {\n+    public static bool ByteArraysEqual(byte[] arr1, byte[] arr2) {\n       if (arr1 == null) {\n         return arr2 == null;\n       }"
        }
    ],
    "commitTime": "2022-01-18 10:14:03"
}