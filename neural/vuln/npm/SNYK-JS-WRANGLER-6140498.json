{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "ADJACENT_NETWORK",
        "attackComplexity": "HIGH",
        "privilegesRequired": "NONE",
        "userInteraction": "REQUIRED",
        "scope": "CHANGED",
        "confidentiality": "HIGH",
        "integrity": "LOW",
        "availability": "NONE"
    },
    "credit": [
        "Lekensteyn"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 5.7,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "ADJACENT_NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "REQUIRED",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "NONE",
                "availability": "NONE"
            },
            "severity": "medium"
        }
    ],
    "cvssScore": 6.4,
    "disclosureTime": "2023-12-29 12:55:05",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.12283",
        "probability": "0.00045"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-JS-WRANGLER-6140498",
    "identifiers": {
        "CVE": [
            "CVE-2023-7079"
        ],
        "CWE": [
            "CWE-22"
        ]
    },
    "language": "js",
    "malicious": false,
    "packageManager": "npm",
    "publicationTime": "2023-12-31 11:58:59",
    "remediation": "Upgrade wrangler to version 3.18.0 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Arbitrary File Read",
    "vulnDescription": {
        "Overview": "wrangler is a Command-line interface for all things Cloudflare Workers Affected versions of this package are vulnerable to Arbitrary File Read by specially crafted HTTP requests and inspector messages to the dev server. An attacker can access any file on the user's computer over the local network by convincing a user to open a malicious website. ",
        "Workaround": "This vulnerability can be mitigated by configuring Wrangler to listen on local interfaces instead with wrangler dev --ip 127.0.0.1 . This does not prevent the visiting of a malicious website. "
    },
    "source_code": [
        {
            "filename": ".changeset/serious-toys-repeat.md",
            "diff": "@@ -0,0 +1,12 @@\n+---\n+\"wrangler\": minor\n+---\n+\n+Reintroduces some internal refactorings of wrangler dev servers (including `wrangler dev`, `wrangler dev --remote`, and `unstable_dev()`).\n+\n+These changes were released in 3.13.0 and reverted in 3.13.1 -- we believe the changes are now more stable and ready for release again.\n+\n+There are no changes required for developers to opt-in. Improvements include:\n+\n+- fewer 'address in use' errors upon reloads\n+- upon config/source file changes, requests are buffered to guarantee the response is from the new version of the Worker"
        },
        {
            "filename": "fixtures/dev-env/.gitignore",
            "diff": "@@ -0,0 +1 @@\n+dist"
        },
        {
            "filename": "fixtures/dev-env/package.json",
            "diff": "@@ -0,0 +1,25 @@\n+{\n+\t\"name\": \"dev-env\",\n+\t\"version\": \"1.0.1\",\n+\t\"private\": true,\n+\t\"description\": \"\",\n+\t\"license\": \"ISC\",\n+\t\"author\": \"\",\n+\t\"main\": \"src/index.js\",\n+\t\"scripts\": {\n+\t\t\"test\": \"npx vitest run\",\n+\t\t\"test:ci\": \"npx vitest run\",\n+\t\t\"test:watch\": \"npx vitest\",\n+\t\t\"type:tests\": \"tsc -p ./tests/tsconfig.json\"\n+\t},\n+\t\"devDependencies\": {\n+\t\t\"@types/ws\": \"^8.5.7\",\n+\t\t\"@cloudflare/workers-tsconfig\": \"workspace:^\",\n+\t\t\"get-port\": \"^7.0.0\",\n+\t\t\"miniflare\": \"3.20231025.1\",\n+\t\t\"undici\": \"^5.23.0\",\n+\t\t\"wrangler\": \"workspace:*\",\n+\t\t\"ws\": \"^8.14.2\"\n+\t},\n+\t\"dependencies\": {}\n+}"
        },
        {
            "filename": "fixtures/dev-env/tests/index.test.ts",
            "diff": "@@ -0,0 +1,556 @@\n+import assert from \"node:assert\";\n+import getPort from \"get-port\";\n+import {\n+\tMiniflare,\n+\ttype Response as MiniflareResponse,\n+\ttype MiniflareOptions,\n+\tLog,\n+} from \"miniflare\";\n+import * as undici from \"undici\";\n+import { WebSocket } from \"ws\";\n+import { beforeEach, afterEach, describe, test, expect, vi } from \"vitest\";\n+import { unstable_DevEnv as DevEnv } from \"wrangler\";\n+import type { ProxyData } from \"wrangler/src/api\";\n+import type { StartDevWorkerOptions } from \"wrangler/src/api/startDevWorker/types\";\n+import type { EsbuildBundle } from \"wrangler/src/dev/use-esbuild\";\n+\n+const fakeBundle = {} as EsbuildBundle;\n+\n+let devEnv: DevEnv;\n+let mf: Miniflare | undefined;\n+let res: MiniflareResponse | undici.Response;\n+let ws: WebSocket | undefined;\n+let fireAndForgetPromises: Promise<any>[] = [];\n+\n+type OptionalKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n+\n+beforeEach(() => {\n+\tdevEnv = new DevEnv();\n+\tmf = undefined;\n+\tres = undefined as any;\n+\tws = undefined;\n+});\n+afterEach(async () => {\n+\tawait Promise.allSettled(fireAndForgetPromises);\n+\tawait devEnv?.teardown();\n+\tawait mf?.dispose();\n+\tawait ws?.close();\n+\n+\tvi.resetAllMocks();\n+});\n+\n+async function fakeStartUserWorker(options: {\n+\tscript: string;\n+\tname?: string;\n+\tmfOpts?: Partial<MiniflareOptions>;\n+\tconfig?: OptionalKeys<StartDevWorkerOptions, \"name\" | \"script\">;\n+}) {\n+\tconst config: StartDevWorkerOptions = {\n+\t\t...options.config,\n+\t\tname: options.name ?? \"test-worker\",\n+\t\tscript: { contents: options.script },\n+\t};\n+\tconst mfOpts: MiniflareOptions = Object.assign(\n+\t\t{\n+\t\t\tport: undefined,\n+\t\t\tinspectorPort: 0,\n+\t\t\tmodules: true,\n+\t\t\tcompatibilityDate: \"2023-08-01\",\n+\t\t\tname: config.name,\n+\t\t\tscript: options.script,\n+\t\t\tlog: Object.assign(new Log(), { error() {} }), // TODO: remove when this bug is fixed https://jira.cfdata.org/browse/DEVX-983\n+\t\t},\n+\t\toptions.mfOpts\n+\t);\n+\n+\tassert(\"script\" in mfOpts);\n+\n+\tfakeConfigUpdate(config);\n+\tfakeReloadStart(config);\n+\n+\tconst worker = devEnv.startWorker(config);\n+\tconst { proxyWorker } = await devEnv.proxy.ready.promise;\n+\tconst proxyWorkerUrl = await proxyWorker.ready;\n+\tconst inspectorProxyWorkerUrl = await proxyWorker.unsafeGetDirectURL(\n+\t\t\"InspectorProxyWorker\"\n+\t);\n+\n+\tmf = new Miniflare(mfOpts);\n+\n+\tconst userWorkerUrl = await mf.ready;\n+\tconst userWorkerInspectorUrl = await mf.getInspectorURL();\n+\tfakeReloadComplete(config, mfOpts, userWorkerUrl, userWorkerInspectorUrl);\n+\n+\treturn {\n+\t\tworker,\n+\t\tmf,\n+\t\tmfOpts,\n+\t\tconfig,\n+\t\tuserWorkerUrl,\n+\t\tuserWorkerInspectorUrl,\n+\t\tproxyWorkerUrl,\n+\t\tinspectorProxyWorkerUrl,\n+\t};\n+}\n+\n+async function fakeUserWorkerChanges({\n+\tscript,\n+\tmfOpts,\n+\tconfig,\n+}: {\n+\tscript?: string;\n+\tmfOpts: MiniflareOptions;\n+\tconfig: StartDevWorkerOptions;\n+}) {\n+\tassert(mf);\n+\tassert(\"script\" in mfOpts);\n+\n+\tconfig = {\n+\t\t...config,\n+\t\tscript: {\n+\t\t\t...config.script,\n+\t\t\t...(script ? { contents: script } : undefined),\n+\t\t},\n+\t};\n+\tmfOpts = {\n+\t\t...mfOpts,\n+\t\tscript: script ?? mfOpts.script,\n+\t};\n+\n+\tfakeReloadStart(config);\n+\n+\tawait mf.setOptions(mfOpts);\n+\n+\tconst userWorkerUrl = await mf.ready;\n+\tconst userWorkerInspectorUrl = await mf.getInspectorURL();\n+\tfakeReloadComplete(\n+\t\tconfig,\n+\t\tmfOpts,\n+\t\tuserWorkerUrl,\n+\t\tuserWorkerInspectorUrl,\n+\t\t1000\n+\t);\n+\n+\treturn { mfOpts, config, mf, userWorkerUrl, userWorkerInspectorUrl };\n+}\n+\n+function fireAndForgetFakeUserWorkerChanges(\n+\t...args: Parameters<typeof fakeUserWorkerChanges>\n+) {\n+\t// fire and forget the reload -- this let's us test request buffering\n+\tconst promise = fakeUserWorkerChanges(...args);\n+\tfireAndForgetPromises.push(promise);\n+}\n+\n+function fakeConfigUpdate(config: StartDevWorkerOptions) {\n+\tdevEnv.proxy.onConfigUpdate({\n+\t\ttype: \"configUpdate\",\n+\t\tconfig,\n+\t});\n+\n+\treturn config; // convenience to allow calling and defining new config inline but also store the new object\n+}\n+function fakeReloadStart(config: StartDevWorkerOptions) {\n+\tdevEnv.proxy.onReloadStart({\n+\t\ttype: \"reloadStart\",\n+\t\tconfig,\n+\t\tbundle: fakeBundle,\n+\t});\n+\n+\treturn config;\n+}\n+function fakeReloadComplete(\n+\tconfig: StartDevWorkerOptions,\n+\tmfOpts: MiniflareOptions,\n+\tuserWorkerUrl: URL,\n+\tuserWorkerInspectorUrl: URL,\n+\tdelay = 100\n+) {\n+\tconst proxyData: ProxyData = {\n+\t\tuserWorkerUrl: {\n+\t\t\tprotocol: userWorkerUrl.protocol,\n+\t\t\thostname: userWorkerUrl.hostname,\n+\t\t\tport: userWorkerUrl.port,\n+\t\t},\n+\t\tuserWorkerInspectorUrl: {\n+\t\t\tprotocol: userWorkerInspectorUrl.protocol,\n+\t\t\thostname: userWorkerInspectorUrl.hostname,\n+\t\t\tport: userWorkerInspectorUrl.port,\n+\t\t\tpathname: `/core:user:${config.name}`,\n+\t\t},\n+\t\tuserWorkerInnerUrlOverrides: {\n+\t\t\tprotocol: config?.dev?.urlOverrides?.secure ? \"https:\" : \"http:\",\n+\t\t\thostname: config?.dev?.urlOverrides?.hostname,\n+\t\t},\n+\t\theaders: {},\n+\t\tliveReload: config.dev?.liveReload,\n+\t};\n+\n+\tsetTimeout(() => {\n+\t\tdevEnv.proxy.onReloadComplete({\n+\t\t\ttype: \"reloadComplete\",\n+\t\t\tconfig,\n+\t\t\tbundle: fakeBundle,\n+\t\t\tproxyData,\n+\t\t});\n+\t}, delay);\n+\n+\treturn { config, mfOpts }; // convenience to allow calling and defining new config/mfOpts inline but also store the new objects\n+}\n+\n+describe(\"startDevWorker: ProxyController\", () => {\n+\ttest(\"ProxyWorker buffers requests while runtime reloads\", async () => {\n+\t\tconst run = await fakeStartUserWorker({\n+\t\t\tscript: `\n+\t\t\t\texport default {\n+\t\t\t\t\tfetch() {\n+\t\t\t\t\t\treturn new Response(\"body:1\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t`,\n+\t\t});\n+\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"body:1\");\n+\n+\t\tfireAndForgetFakeUserWorkerChanges({\n+\t\t\tmfOpts: run.mfOpts,\n+\t\t\tconfig: run.config,\n+\t\t\tscript: run.mfOpts.script.replace(\"1\", \"2\"),\n+\t\t});\n+\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"body:2\");\n+\t});\n+\n+\ttest(\"InspectorProxyWorker discovery endpoints + devtools websocket connection\", async () => {\n+\t\tconst run = await fakeStartUserWorker({\n+\t\t\tscript: `\n+\t\t\t\texport default {\n+\t\t\t\t\tfetch() {\n+\t\t\t\t\t\tconsole.log('Inside mock user worker');\n+\n+\t\t\t\t\t\treturn new Response(\"body:1\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t`,\n+\t\t});\n+\n+\t\tawait devEnv.proxy.ready;\n+\t\tres = await undici.fetch(`http://${run.inspectorProxyWorkerUrl.host}/json`);\n+\n+\t\tawait expect(res.json()).resolves.toBeInstanceOf(Array);\n+\n+\t\tws = new WebSocket(\n+\t\t\t`ws://${run.inspectorProxyWorkerUrl.host}/core:user:${run.config.name}`\n+\t\t);\n+\t\tconst openPromise = new Promise((resolve) => {\n+\t\t\tws?.addEventListener(\"open\", resolve);\n+\t\t});\n+\t\tconst consoleAPICalledPromise = new Promise((resolve) => {\n+\t\t\tws?.addEventListener(\"message\", (event) => {\n+\t\t\t\tassert(typeof event.data === \"string\");\n+\t\t\t\tif (event.data.includes(\"Runtime.consoleAPICalled\")) {\n+\t\t\t\t\tresolve(JSON.parse(event.data));\n+\t\t\t\t}\n+\t\t\t});\n+\t\t});\n+\t\tconst executionContextCreatedPromise = new Promise((resolve) => {\n+\t\t\tws?.addEventListener(\"message\", (event) => {\n+\t\t\t\tassert(typeof event.data === \"string\");\n+\t\t\t\tif (event.data.includes(\"Runtime.executionContextCreated\")) {\n+\t\t\t\t\tresolve(JSON.parse(event.data));\n+\t\t\t\t}\n+\t\t\t});\n+\t\t});\n+\n+\t\tawait openPromise;\n+\t\tawait run.worker.fetch(\"http://localhost\");\n+\n+\t\tawait expect(consoleAPICalledPromise).resolves.toMatchObject({\n+\t\t\tmethod: \"Runtime.consoleAPICalled\",\n+\t\t\tparams: {\n+\t\t\t\targs: expect.arrayContaining([\n+\t\t\t\t\t{ type: \"string\", value: \"Inside mock user worker\" },\n+\t\t\t\t]),\n+\t\t\t},\n+\t\t});\n+\t\tawait expect(executionContextCreatedPromise).resolves.toMatchObject({\n+\t\t\tmethod: \"Runtime.executionContextCreated\",\n+\t\t\tparams: {\n+\t\t\t\tcontext: { id: expect.any(Number) },\n+\t\t\t},\n+\t\t});\n+\t});\n+\n+\ttest(\"User worker exception\", async () => {\n+\t\tconst consoleErrorSpy = vi.spyOn(console, \"error\");\n+\n+\t\tconst run = await fakeStartUserWorker({\n+\t\t\tscript: `\n+\t\t\t\t\texport default {\n+\t\t\t\t\t\tfetch() {\n+\t\t\t\t\t\t\tthrow new Error('Boom!');\n+\n+\t\t\t\t\t\t\treturn new Response(\"body:1\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t`,\n+\t\t});\n+\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"Error: Boom!\");\n+\n+\t\tawait new Promise((r) => setTimeout(r, 100)); // allow some time for the error to be logged (TODO: replace with retry/waitUntil helper)\n+\t\texpect(consoleErrorSpy).toBeCalledWith(\n+\t\t\texpect.stringContaining(\"Error: Boom!\")\n+\t\t);\n+\n+\t\t// test changes causing a new error cause the new error to propogate\n+\t\tfireAndForgetFakeUserWorkerChanges({\n+\t\t\tscript: `\n+\t\t\t\t\texport default {\n+\t\t\t\t\t\tfetch() {\n+\t\t\t\t\t\t\tthrow new Error('Boom 2!');\n+\n+\t\t\t\t\t\t\treturn new Response(\"body:2\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t`,\n+\t\t\tmfOpts: run.mfOpts,\n+\t\t\tconfig: run.config,\n+\t\t});\n+\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"Error: Boom 2!\");\n+\n+\t\tawait new Promise((r) => setTimeout(r, 100)); // allow some time for the error to be logged (TODO: replace with retry/waitUntil helper)\n+\t\texpect(consoleErrorSpy).toBeCalledWith(\n+\t\t\texpect.stringContaining(\"Error: Boom 2!\")\n+\t\t);\n+\n+\t\t// test eyeball requests receive the pretty error page\n+\t\tfireAndForgetFakeUserWorkerChanges({\n+\t\t\tscript: `\n+\t\t\t\t\texport default {\n+\t\t\t\t\t\tfetch() {\n+\t\t\t\t\t\t\tconst e = new Error('Boom 3!');\n+\n+\t\t\t\t\t\t\t// this is how errors are serialised after they are caught by wrangler/miniflare3 middlewares\n+\t\t\t\t\t\t\tconst error = { name: e.name, message: e.message, stack: e.stack };\n+\t\t\t\t\t\t\treturn Response.json(error, {\n+\t\t\t\t\t\t\t\tstatus: 500,\n+\t\t\t\t\t\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t`,\n+\t\t\tmfOpts: run.mfOpts,\n+\t\t\tconfig: run.config,\n+\t\t});\n+\n+\t\tconst proxyWorkerUrl = await devEnv.proxy.proxyWorker?.ready;\n+\t\tassert(proxyWorkerUrl);\n+\t\tres = await undici.fetch(proxyWorkerUrl, {\n+\t\t\theaders: { Accept: \"text/html\" },\n+\t\t});\n+\t\tawait expect(res.text()).resolves.toEqual(\n+\t\t\texpect.stringContaining(`<h2 class=\"error-message\"> Boom 3! </h2>`) // pretty error page html snippet\n+\t\t);\n+\n+\t\t// test further changes that fix the code\n+\t\tfireAndForgetFakeUserWorkerChanges({\n+\t\t\tscript: `\n+\t\t\t\t\texport default {\n+\t\t\t\t\t\tfetch() {\n+\t\t\t\t\t\t\treturn new Response(\"body:3\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t`,\n+\t\t\tmfOpts: run.mfOpts,\n+\t\t\tconfig: run.config,\n+\t\t});\n+\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"body:3\");\n+\n+\t\tconsoleErrorSpy.mockReset();\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"body:3\");\n+\n+\t\tawait new Promise((r) => setTimeout(r, 100)); // allow some time for the error to be logged (TODO: replace with retry/waitUntil helper)\n+\t\texpect(consoleErrorSpy).not.toHaveBeenCalled();\n+\t});\n+\n+\ttest(\"config.dev.{server,inspector} changes, restart the server instance\", async () => {\n+\t\tconst run = await fakeStartUserWorker({\n+\t\t\tscript: `\n+\t\t\t\texport default {\n+\t\t\t\t\tfetch() {\n+\t\t\t\t\t\treturn new Response(\"body:1\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t`,\n+\t\t\tconfig: {\n+\t\t\t\tdev: {\n+\t\t\t\t\tserver: { port: await getPort() },\n+\t\t\t\t\tinspector: { port: await getPort() },\n+\t\t\t\t},\n+\t\t\t},\n+\t\t});\n+\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"body:1\");\n+\n+\t\tconst oldPort = run.config.dev?.server?.port;\n+\t\tres = await undici.fetch(`http://127.0.0.1:${oldPort}`);\n+\t\tawait expect(res.text()).resolves.toBe(\"body:1\");\n+\n+\t\tconst config2 = fakeConfigUpdate({\n+\t\t\t...run.config,\n+\t\t\tdev: {\n+\t\t\t\tserver: { port: await getPort() },\n+\t\t\t\tinspector: { port: await getPort() },\n+\t\t\t},\n+\t\t});\n+\t\tfakeReloadStart(config2);\n+\t\tfakeReloadComplete(\n+\t\t\tconfig2,\n+\t\t\trun.mfOpts,\n+\t\t\trun.userWorkerUrl,\n+\t\t\trun.userWorkerInspectorUrl\n+\t\t);\n+\n+\t\tconst newPort = config2.dev?.server?.port;\n+\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tawait expect(res.text()).resolves.toBe(\"body:1\");\n+\n+\t\tres = await undici.fetch(`http://127.0.0.1:${newPort}`);\n+\t\tawait expect(res.text()).resolves.toBe(\"body:1\");\n+\n+\t\tawait expect(\n+\t\t\tundici.fetch(`http://127.0.0.1:${oldPort}`).then((r) => r.text())\n+\t\t).rejects.toMatchInlineSnapshot(\"[TypeError: fetch failed]\");\n+\t});\n+\n+\ttest(\"liveReload\", async () => {\n+\t\tlet resText: string;\n+\t\tconst scriptRegex = /<script>([\\s\\S]*)<\\/script>/gm;\n+\n+\t\tconst run = await fakeStartUserWorker({\n+\t\t\tscript: `\n+\t\t\t\texport default {\n+\t\t\t\t\tfetch() {\n+\t\t\t\t\t\treturn new Response(\"body:1\", {\n+\t\t\t\t\t\t\theaders: { 'Content-Type': 'text/html' }\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t`,\n+\t\t\tconfig: {\n+\t\t\t\tdev: { liveReload: true },\n+\t\t\t},\n+\t\t});\n+\n+\t\t// test liveReload: true inserts live-reload <script> tag when the response Content-Type is html\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tresText = await res.text();\n+\t\texpect(resText).toEqual(expect.stringContaining(\"body:1\"));\n+\t\texpect(resText).toEqual(expect.stringMatching(scriptRegex));\n+\t\texpect(resText.replace(scriptRegex, \"\").trim()).toEqual(\"body:1\"); // test, without the <script> tag, the response is as authored\n+\n+\t\tfireAndForgetFakeUserWorkerChanges({\n+\t\t\tmfOpts: run.mfOpts,\n+\t\t\tscript: `\n+\t\t\t\texport default {\n+\t\t\t\t\tfetch() {\n+\t\t\t\t\t\treturn new Response(\"body:2\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t`,\n+\t\t\tconfig: {\n+\t\t\t\t...run.config,\n+\t\t\t\tdev: { liveReload: true },\n+\t\t\t},\n+\t\t});\n+\n+\t\t// test liveReload does nothing when the response Content-Type is not html\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tresText = await res.text();\n+\t\texpect(resText).toMatchInlineSnapshot('\"body:2\"');\n+\t\texpect(resText).toBe(\"body:2\");\n+\t\texpect(resText).not.toEqual(expect.stringMatching(scriptRegex));\n+\n+\t\tfireAndForgetFakeUserWorkerChanges({\n+\t\t\tmfOpts: run.mfOpts,\n+\t\t\tscript: `\n+\t\t\t\texport default {\n+\t\t\t\t\tfetch() {\n+\t\t\t\t\t\treturn new Response(\"body:3\", {\n+\t\t\t\t\t\t\theaders: { 'Content-Type': 'text/html' }\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t`,\n+\t\t\tconfig: {\n+\t\t\t\t...run.config,\n+\t\t\t\tdev: { liveReload: false },\n+\t\t\t},\n+\t\t});\n+\n+\t\t// test liveReload: false does nothing even when the response Content-Type is html\n+\t\tres = await run.worker.fetch(\"http://dummy\");\n+\t\tresText = await res.text();\n+\t\texpect(resText).toMatchInlineSnapshot('\"body:3\"');\n+\t\texpect(resText).toBe(\"body:3\");\n+\t\texpect(resText).not.toEqual(expect.stringMatching(scriptRegex));\n+\t});\n+\n+\ttest(\"urlOverrides take effect in the UserWorker\", async () => {\n+\t\tconst run = await fakeStartUserWorker({\n+\t\t\tscript: `\n+\t\t\t\texport default {\n+\t\t\t\t\tfetch(request) {\n+\t\t\t\t\t\treturn new Response(\"URL: \" + request.url);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t`,\n+\t\t\tconfig: {\n+\t\t\t\tdev: {\n+\t\t\t\t\turlOverrides: {\n+\t\t\t\t\t\thostname: \"www.google.com\",\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t});\n+\n+\t\tres = await run.worker.fetch(\"http://dummy/test/path/1\");\n+\t\tawait expect(res.text()).resolves.toBe(\n+\t\t\t`URL: http://www.google.com/test/path/1`\n+\t\t);\n+\n+\t\tconst config2 = fakeConfigUpdate({\n+\t\t\t...run.config,\n+\t\t\tdev: {\n+\t\t\t\t...run.config.dev,\n+\t\t\t\turlOverrides: {\n+\t\t\t\t\tsecure: true,\n+\t\t\t\t\thostname: \"mybank.co.uk\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t});\n+\t\tfakeReloadComplete(\n+\t\t\tconfig2,\n+\t\t\trun.mfOpts,\n+\t\t\trun.userWorkerUrl,\n+\t\t\trun.userWorkerInspectorUrl,\n+\t\t\t1000\n+\t\t);\n+\n+\t\tres = await run.worker.fetch(\"http://dummy/test/path/2\");\n+\t\tawait expect(res.text()).resolves.toBe(\n+\t\t\t\"URL: https://mybank.co.uk/test/path/2\"\n+\t\t);\n+\t});\n+});"
        },
        {
            "filename": "fixtures/dev-env/tests/tsconfig.json",
            "diff": "@@ -0,0 +1,12 @@\n+{\n+\t\"extends\": \"@cloudflare/workers-tsconfig/tsconfig.json\",\n+\t\"compilerOptions\": {\n+\t\t\"types\": [\"node\"],\n+\t\t\"jsx\": \"react\"\n+\t},\n+\t\"include\": [\n+\t\t\"**/*.ts\",\n+\t\t\"../../../node-types.d.ts\",\n+\t\t\"../../../packages/wrangler/src/*.d.ts\"\n+\t]\n+}"
        },
        {
            "filename": "packages/edge-preview-authenticated-proxy/tests/index.test.ts",
            "diff": "@@ -74,7 +74,6 @@ compatibility_date = \"2023-01-01\"\n \t\tremote = await unstable_dev(path.join(tmpDir, \"remote.js\"), {\n \t\t\tconfig: path.join(tmpDir, \"wrangler.toml\"),\n \t\t\texperimental: { disableExperimentalWarning: true },\n-\t\t\tport: 6756,\n \t\t});\n \t});\n \n@@ -92,7 +91,7 @@ compatibility_date = \"2023-01-01\"\n \tit(\"should obtain token from exchange_url\", async () => {\n \t\tconst resp = await worker.fetch(\n \t\t\t`https://preview.devprod.cloudflare.dev/exchange?exchange_url=${encodeURIComponent(\n-\t\t\t\t\"http://127.0.0.1:6756/exchange\"\n+\t\t\t\t`http://127.0.0.1:${remote.port}/exchange`\n \t\t\t)}`,\n \t\t\t{\n \t\t\t\tmethod: \"POST\",\n@@ -117,9 +116,9 @@ compatibility_date = \"2023-01-01\"\n \t\t\t`https://random-data.preview.devprod.cloudflare.dev/.update-preview-token?token=${encodeURIComponent(\n \t\t\t\ttoken\n \t\t\t)}&prewarm=${encodeURIComponent(\n-\t\t\t\t\"http://127.0.0.1:6756/prewarm\"\n+\t\t\t\t`http://127.0.0.1:${remote.port}/prewarm`\n \t\t\t)}&remote=${encodeURIComponent(\n-\t\t\t\t\"http://127.0.0.1:6756\"\n+\t\t\t\t`http://127.0.0.1:${remote.port}`\n \t\t\t)}&suffix=${encodeURIComponent(\"/hello?world\")}`,\n \t\t\t{\n \t\t\t\tmethod: \"GET\",\n@@ -151,17 +150,17 @@ compatibility_date = \"2023-01-01\"\n \t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any -- ignoring this test type error for sake of turborepo PR\n \t\tconst json = (await resp.json()) as any;\n \n-\t\texpect(\n-\t\t\tjson.headers.find(([h]: [string]) => h === \"cf-workers-preview-token\")[1]\n-\t\t).toBe(token);\n-\t\texpect(json.url).toMatchInlineSnapshot('\"http://127.0.0.1:6756/\"');\n+\t\texpect(json).toMatchObject({\n+\t\t\turl: `http://127.0.0.1:${remote.port}/`,\n+\t\t\theaders: expect.arrayContaining([[\"cf-workers-preview-token\", token]]),\n+\t\t});\n \t});\n \tit(\"should be redirected with cookie\", async () => {\n \t\tconst resp = await worker.fetch(\n \t\t\t`https://random-data.preview.devprod.cloudflare.dev/.update-preview-token?token=TEST_TOKEN&prewarm=${encodeURIComponent(\n-\t\t\t\t\"http://127.0.0.1:6756/prewarm\"\n+\t\t\t\t`http://127.0.0.1:${remote.port}/prewarm`\n \t\t\t)}&remote=${encodeURIComponent(\n-\t\t\t\t\"http://127.0.0.1:6756\"\n+\t\t\t\t`http://127.0.0.1:${remote.port}`\n \t\t\t)}&suffix=${encodeURIComponent(\"/hello?world\")}`,\n \t\t\t{\n \t\t\t\tmethod: \"GET\",\n@@ -193,10 +192,12 @@ compatibility_date = \"2023-01-01\"\n \t\t);\n \n \t\tconst json = (await resp.json()) as { headers: string[][]; url: string };\n-\t\texpect(Object.fromEntries([...json.headers])).toMatchObject({\n-\t\t\t\"cf-workers-preview-token\": \"TEST_TOKEN\",\n+\t\texpect(json).toMatchObject({\n+\t\t\turl: `http://127.0.0.1:${remote.port}/`,\n+\t\t\theaders: expect.arrayContaining([\n+\t\t\t\t[\"cf-workers-preview-token\", \"TEST_TOKEN\"],\n+\t\t\t]),\n \t\t});\n-\t\texpect(json.url).toMatchInlineSnapshot('\"http://127.0.0.1:6756/\"');\n \t});\n \tit(\"should not follow redirects\", async () => {\n \t\tconst resp = await worker.fetch("
        },
        {
            "filename": "packages/wrangler/.eslintrc.js",
            "diff": "@@ -10,6 +10,7 @@ module.exports = {\n \t],\n \toverrides: [\n \t\t{\n+\t\t\t// TODO: add linting for `startDevWorker` workers in `templates/startDevWorker`\n \t\t\tfiles: \"src/**/*.ts\",\n \t\t\texcludedFiles: \"*.test.ts\",\n \t\t\tparserOptions: {"
        },
        {
            "filename": "packages/wrangler/e2e/tsconfig.json",
            "diff": "@@ -3,6 +3,6 @@\n \t\"compilerOptions\": {\n \t\t\"types\": [\"node\"]\n \t},\n-\t\"include\": [\"**/*.ts\"],\n+\t\"include\": [\"**/*.ts\", \"../src/*.d.ts\"],\n \t\"exclude\": []\n }"
        },
        {
            "filename": "packages/wrangler/package.json",
            "diff": "@@ -64,7 +64,7 @@\n \t\t\"test:ci\": \"pnpm run test --coverage\",\n \t\t\"test:debug\": \"pnpm run test --silent=false --verbose=true\",\n \t\t\"test:e2e\": \"vitest --test-timeout 240000 --single-thread --dir ./e2e --retry 2 run\",\n-\t\t\"test:watch\": \"pnpm run test --runInBand --testTimeout=50000 --watch\",\n+\t\t\"test:watch\": \"pnpm run test --testTimeout=50000 --watch\",\n \t\t\"type:tests\": \"tsc -p ./src/__tests__/tsconfig.json && tsc -p ./e2e/tsconfig.json\"\n \t},\n \t\"jest\": {"
        },
        {
            "filename": "packages/wrangler/scripts/bundle.ts",
            "diff": "@@ -1,14 +1,17 @@\n import fs from \"node:fs/promises\";\n import path from \"node:path\";\n-import { build, context } from \"esbuild\";\n+import * as esbuild from \"esbuild\";\n import { EXTERNAL_DEPENDENCIES } from \"./deps\";\n-import type { BuildOptions } from \"esbuild\";\n+import type { BuildOptions, Plugin, BuildContext } from \"esbuild\";\n \n // the expectation is that this is being run from the project root\n type BuildFlags = {\n \twatch?: boolean;\n };\n \n+const WATCH = process.argv.includes(\"--watch\");\n+const TEMPLATES_DIR = path.join(__dirname, \"../templates\");\n+\n async function buildMain(flags: BuildFlags = {}) {\n \tconst outdir = path.resolve(\"./wrangler-dist\");\n \tconst wranglerPackageDir = path.resolve(\".\");\n@@ -52,13 +55,14 @@ async function buildMain(flags: BuildFlags = {}) {\n \t\t\t\t? { ALGOLIA_PUBLIC_KEY: `\"${process.env.ALGOLIA_PUBLIC_KEY}\"` }\n \t\t\t\t: {}),\n \t\t},\n+\t\tplugins: [embedWorkersPlugin],\n \t};\n \n \tif (flags.watch) {\n-\t\tconst ctx = await context(options);\n+\t\tconst ctx = await esbuild.context(options);\n \t\tawait ctx.watch();\n \t} else {\n-\t\tawait build(options);\n+\t\tawait esbuild.build(options);\n \t}\n \n \t// Copy `yoga-layout` `.wasm` file\n@@ -74,14 +78,63 @@ async function buildMain(flags: BuildFlags = {}) {\n \tawait fs.copyFile(wasmSrc, wasmDst);\n }\n \n+const workersContexts = new Map<string, BuildContext>();\n+const embedWorkersPlugin: Plugin = {\n+\tname: \"embed-workers\",\n+\tsetup(build) {\n+\t\tconst namespace = \"embed-worker\";\n+\t\tbuild.onResolve({ filter: /^worker:/ }, async (args) => {\n+\t\t\tconst name = args.path.substring(\"worker:\".length);\n+\t\t\t// Use `build.resolve()` API so Workers can be written as `m?[jt]s` files\n+\t\t\tconst result = await build.resolve(\"./\" + name, {\n+\t\t\t\tkind: \"import-statement\",\n+\t\t\t\tresolveDir: TEMPLATES_DIR,\n+\t\t\t});\n+\t\t\tif (result.errors.length > 0) return { errors: result.errors };\n+\t\t\treturn { path: result.path, namespace };\n+\t\t});\n+\t\tbuild.onLoad({ filter: /.*/, namespace }, async (args) => {\n+\t\t\tconst ctx =\n+\t\t\t\tworkersContexts.get(args.path) ??\n+\t\t\t\t(await esbuild.context({\n+\t\t\t\t\tplatform: \"node\", // Marks `node:*` imports as external\n+\t\t\t\t\tformat: \"esm\",\n+\t\t\t\t\ttarget: \"esnext\",\n+\t\t\t\t\tbundle: true,\n+\t\t\t\t\tsourcemap: true,\n+\t\t\t\t\tsourcesContent: false,\n+\t\t\t\t\tmetafile: true,\n+\t\t\t\t\tentryPoints: [args.path],\n+\t\t\t\t\toutdir: build.initialOptions.outdir,\n+\t\t\t\t}));\n+\t\t\tconst result = await ctx.rebuild();\n+\t\t\tworkersContexts.set(args.path, ctx);\n+\t\t\tconst watchFiles = Object.keys(result?.metafile?.inputs ?? {});\n+\t\t\tconst scriptPath = Object.keys(result?.metafile?.outputs ?? {}).find(\n+\t\t\t\t(filepath) => filepath.endsWith(\".js\")\n+\t\t\t);\n+\n+\t\t\tconst contents = `\n+\t\t\t\timport path from \"node:path\";\n+\t\t\t\tconst scriptPath = path.resolve(__dirname, \"..\", \"${scriptPath}\");\n+\t\t\t\texport default scriptPath;\n+            `;\n+\n+\t\t\treturn { contents, loader: \"js\", watchFiles };\n+\t\t});\n+\t},\n+};\n+\n async function run() {\n \t// main cli\n \tawait buildMain();\n \n \t// After built once completely, rerun them both in watch mode\n-\tif (process.argv.includes(\"--watch\")) {\n+\tif (WATCH) {\n \t\tconsole.log(\"Built. Watching for changes...\");\n \t\tawait buildMain({ watch: true });\n+\t} else {\n+\t\tfor (const ctx of workersContexts.values()) await ctx.dispose();\n \t}\n }\n "
        },
        {
            "filename": "packages/wrangler/src/__tests__/api-devregistry.test.ts",
            "diff": "@@ -13,6 +13,8 @@ describe(\"multi-worker testing\", () => {\n \tlet childWorker: any;\n \t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n \tlet parentWorker: any;\n+\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n+\tconst workers: any[] = [];\n \n \tbeforeAll(async () => {\n \t\tchildWorker = await unstable_dev(\n@@ -24,6 +26,8 @@ describe(\"multi-worker testing\", () => {\n \t\t\t\t},\n \t\t\t}\n \t\t);\n+\t\tworkers.push(childWorker);\n+\n \t\tparentWorker = await unstable_dev(\n \t\t\t\"src/__tests__/helpers/worker-scripts/parent-worker.js\",\n \t\t\t{\n@@ -33,11 +37,13 @@ describe(\"multi-worker testing\", () => {\n \t\t\t\t},\n \t\t\t}\n \t\t);\n+\t\tworkers.push(parentWorker);\n \t});\n \n \tafterAll(async () => {\n-\t\tawait childWorker.stop();\n-\t\tawait parentWorker.stop();\n+\t\tfor (const worker of workers) {\n+\t\t\tawait worker.stop();\n+\t\t}\n \t});\n \n \tit(\"parentWorker and childWorker should be added devRegistry\", async () => {\n@@ -81,13 +87,15 @@ describe(\"multi-worker testing\", () => {\n \t\t([\"debug\", \"info\", \"log\", \"warn\", \"error\"] as const).forEach((method) =>\n \t\t\tjest.spyOn(console, method).mockImplementation((...args: unknown[]) => {\n \t\t\t\tlogs += `\\n${args}`;\n+\t\t\t\tprocess.stdout.write(`\\n${args}`);\n \t\t\t\t// Regexp ignores colour codes\n-\t\t\t\tif (/\\[mf:inf].+GET.+\\/.+200.+OK/.test(String(args))) requestResolve();\n+\t\t\t\tif (/\\[wrangler.*:inf].+GET.+\\/.+200.+OK/.test(String(args)))\n+\t\t\t\t\trequestResolve();\n \t\t\t})\n \t\t);\n \n \t\tasync function startWorker() {\n-\t\t\treturn await unstable_dev(\n+\t\t\tconst worker = await unstable_dev(\n \t\t\t\t\"src/__tests__/helpers/worker-scripts/hello-world-worker.js\",\n \t\t\t\t{\n \t\t\t\t\t// We need the wrangler.toml config to specify a Worker name\n@@ -100,29 +108,27 @@ describe(\"multi-worker testing\", () => {\n \t\t\t\t\t},\n \t\t\t\t}\n \t\t\t);\n+\n+\t\t\tworkers.push(worker);\n+\n+\t\t\treturn worker;\n \t\t}\n \n-\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n-\t\tlet worker: any;\n-\t\ttry {\n-\t\t\tworker = await startWorker();\n+\t\tlet worker = await startWorker();\n \n-\t\t\t// Stop the worker and start it again\n-\t\t\tawait worker.stop();\n-\t\t\tawait new Promise((r) => setTimeout(r, 2000));\n+\t\t// Stop the worker and start it again\n+\t\tawait worker.stop();\n+\t\tawait new Promise((r) => setTimeout(r, 2000));\n \n-\t\t\tworker = await startWorker();\n+\t\tworker = await startWorker();\n \n-\t\t\tconst resp = await worker.fetch();\n-\t\t\texpect(resp).not.toBe(undefined);\n+\t\tconst resp = await worker.fetch();\n+\t\texpect(resp).not.toBe(undefined);\n \n-\t\t\texpect(logs).not.toMatch(\n-\t\t\t\t/Failed to register worker in local service registry/\n-\t\t\t);\n+\t\tawait requestPromise;\n \n-\t\t\tawait requestPromise;\n-\t\t} finally {\n-\t\t\tawait worker?.stop();\n-\t\t}\n+\t\texpect(logs).not.toMatch(\n+\t\t\t/Failed to register worker in local service registry/\n+\t\t);\n \t}, 10000);\n });"
        },
        {
            "filename": "packages/wrangler/src/__tests__/dev.test.tsx",
            "diff": "@@ -880,6 +880,7 @@ describe(\"wrangler dev\", () => {\n \n \tdescribe(\"inspector port\", () => {\n \t\tit(\"should use 9229 as the default port\", async () => {\n+\t\t\t(getPort as jest.Mock).mockImplementation((options) => options.port);\n \t\t\twriteWranglerToml({\n \t\t\t\tmain: \"index.js\",\n \t\t\t});\n@@ -898,6 +899,7 @@ describe(\"wrangler dev\", () => {\n \t\t});\n \n \t\tit(\"should read --inspector-port\", async () => {\n+\t\t\t(getPort as jest.Mock).mockImplementation((options) => options.port);\n \t\t\twriteWranglerToml({\n \t\t\t\tmain: \"index.js\",\n \t\t\t});"
        },
        {
            "filename": "packages/wrangler/src/__tests__/jest.setup.ts",
            "diff": "@@ -24,9 +24,10 @@ process.env.LC_ALL = \"en\";\n \n // Mock out getPort since we don't actually care about what ports are open in unit tests.\n jest.mock(\"get-port\", () => {\n+\tconst { default: getPort } = jest.requireActual(\"get-port\");\n \treturn {\n \t\t__esModule: true,\n-\t\tdefault: jest.fn().mockImplementation(async (options) => options.port),\n+\t\tdefault: jest.fn(getPort),\n \t};\n });\n \n@@ -101,6 +102,12 @@ fetchMock.dontMock();\n beforeAll(() => {\n \tmsw.listen({\n \t\tonUnhandledRequest: (request) => {\n+\t\t\tconst { hostname } = request.url;\n+\t\t\tconst localHostnames = [\"localhost\", \"127.0.0.1\"]; // TODO: add other local hostnames if you need them\n+\t\t\tif (localHostnames.includes(hostname)) {\n+\t\t\t\treturn request.passthrough();\n+\t\t\t}\n+\n \t\t\tthrow new Error(\n \t\t\t\t`No mock found for ${request.method} ${request.url.href}\n \t\t\t\t`\n@@ -228,3 +235,34 @@ afterEach(() => {\n \t// It is important that we clear mocks between tests to avoid leakage.\n \tjest.clearAllMocks();\n });\n+\n+// make jest understand virtual `worker:` imports\n+jest.mock(\n+\t\"worker:startDevWorker/ProxyWorker\",\n+\t() => {\n+\t\tconst path = jest.requireActual(\"path\");\n+\t\tconst { getBasePath } = jest.requireActual(\"../paths\");\n+\n+\t\treturn {\n+\t\t\t__esModule: true,\n+\t\t\tdefault: path.resolve(getBasePath(), `wrangler-dist/ProxyWorker.js`),\n+\t\t};\n+\t},\n+\t{ virtual: true }\n+);\n+jest.mock(\n+\t\"worker:startDevWorker/InspectorProxyWorker\",\n+\t() => {\n+\t\tconst path = jest.requireActual(\"path\");\n+\t\tconst { getBasePath } = jest.requireActual(\"../paths\");\n+\n+\t\treturn {\n+\t\t\t__esModule: true,\n+\t\t\tdefault: path.resolve(\n+\t\t\t\tgetBasePath(),\n+\t\t\t\t`wrangler-dist/InspectorProxyWorker.js`\n+\t\t\t),\n+\t\t};\n+\t},\n+\t{ virtual: true }\n+);"
        },
        {
            "filename": "packages/wrangler/src/api/dev.ts",
            "diff": "@@ -7,6 +7,7 @@ import type { Rule } from \"../config/environment\";\n import type { CfModule } from \"../deployment-bundle/worker\";\n import type { StartDevOptions } from \"../dev\";\n import type { EnablePagesAssetsServiceBindingOptions } from \"../miniflare-cli/types\";\n+import type { ProxyData } from \"./startDevWorker\";\n import type { Json } from \"miniflare\";\n import type { RequestInit, Response, RequestInfo } from \"undici\";\n \n@@ -75,6 +76,7 @@ export interface UnstableDevOptions {\n export interface UnstableDevWorker {\n \tport: number;\n \taddress: string;\n+\tproxyData: ProxyData;\n \tstop: () => Promise<void>;\n \tfetch: (input?: RequestInfo, init?: RequestInit) => Promise<Response>;\n \twaitUntilExit: () => Promise<void>;\n@@ -128,7 +130,11 @@ export async function unstable_dev(\n \t\t);\n \t}\n \n-\ttype ReadyInformation = { address: string; port: number };\n+\ttype ReadyInformation = {\n+\t\taddress: string;\n+\t\tport: number;\n+\t\tproxyData: ProxyData;\n+\t};\n \tlet readyResolve: (info: ReadyInformation) => void;\n \tconst readyPromise = new Promise<ReadyInformation>((resolve) => {\n \t\treadyResolve = resolve;\n@@ -152,8 +158,8 @@ export async function unstable_dev(\n \t\tforceLocal,\n \t\tliveReload,\n \t\tshowInteractiveDevSession,\n-\t\tonReady: (address, port) => {\n-\t\t\treadyResolve({ address, port });\n+\t\tonReady: (address, port, proxyData) => {\n+\t\t\treadyResolve({ address, port, proxyData });\n \t\t},\n \t\tconfig: options?.config,\n \t\tenv: options?.env,\n@@ -163,7 +169,7 @@ export async function unstable_dev(\n \t\tcompatibilityDate: options?.compatibilityDate,\n \t\tcompatibilityFlags: options?.compatibilityFlags,\n \t\tip: options?.ip,\n-\t\tinspectorPort: options?.inspectorPort,\n+\t\tinspectorPort: options?.inspectorPort ?? 0,\n \t\tv: undefined,\n \t\tlocalProtocol: options?.localProtocol,\n \t\tassets: options?.assets,\n@@ -203,10 +209,11 @@ export async function unstable_dev(\n \t\t// in testMode, we can run multiple wranglers in parallel, but rebuilds might not work out of the box\n \t\t// once the devServer is ready for requests, we resolve the ready promise\n \t\tconst devServer = await startApiDev(devOptions);\n-\t\tconst { port, address } = await readyPromise;\n+\t\tconst { port, address, proxyData } = await readyPromise;\n \t\treturn {\n \t\t\tport,\n \t\t\taddress,\n+\t\t\tproxyData,\n \t\t\tstop: devServer.stop,\n \t\t\tfetch: async (input?: RequestInfo, init?: RequestInit) => {\n \t\t\t\treturn await fetch(\n@@ -227,10 +234,11 @@ export async function unstable_dev(\n \t} else {\n \t\t//outside of test mode, rebuilds work fine, but only one instance of wrangler will work at a time\n \t\tconst devServer = await startDev(devOptions);\n-\t\tconst { port, address } = await readyPromise;\n+\t\tconst { port, address, proxyData } = await readyPromise;\n \t\treturn {\n \t\t\tport,\n \t\t\taddress,\n+\t\t\tproxyData,\n \t\t\tstop: devServer.stop,\n \t\t\tfetch: async (input?: RequestInfo, init?: RequestInit) => {\n \t\t\t\treturn await fetch("
        },
        {
            "filename": "packages/wrangler/src/api/index.ts",
            "diff": "@@ -9,3 +9,4 @@ export {\n \tgetMTlsCertificateByName,\n \tdeleteMTlsCertificate,\n } from \"./mtls-certificate\";\n+export * from \"./startDevWorker\";"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/BaseController.ts",
            "diff": "@@ -0,0 +1,40 @@\n+import { EventEmitter } from \"node:events\";\n+import type {\n+\tBundleCompleteEvent,\n+\tBundleStartEvent,\n+\tErrorEvent,\n+\tPreviewTokenExpiredEvent,\n+\tReloadCompleteEvent,\n+\tReloadStartEvent,\n+} from \"./events\";\n+\n+export abstract class Controller extends EventEmitter {}\n+\n+export abstract class RuntimeController extends Controller {\n+\t// ******************\n+\t//   Event Handlers\n+\t// ******************\n+\n+\tabstract onBundleStart(_: BundleStartEvent): void;\n+\tabstract onBundleComplete(_: BundleCompleteEvent): void;\n+\tabstract onPreviewTokenExpired(_: PreviewTokenExpiredEvent): void;\n+\tabstract teardown(): Promise<void>;\n+\n+\t// *********************\n+\t//   Event Dispatchers\n+\t// *********************\n+\n+\tabstract emitReloadStartEvent(data: ReloadStartEvent): void;\n+\tabstract emitReloadCompletetEvent(data: ReloadCompleteEvent): void;\n+\n+\t// *********************\n+\t//   Event Subscribers\n+\t// *********************\n+\n+\ton(event: \"reloadStart\", listener: (_: ReloadStartEvent) => void): this;\n+\ton(event: \"reloadComplete\", listener: (_: ReloadCompleteEvent) => void): this;\n+\t// @ts-expect-error Missing overload implementation (only need the signature types, base implementation is fine)\n+\ton(event: \"error\", listener: (_: ErrorEvent) => void): this;\n+\t// @ts-expect-error Missing initialisation (only need the signature types, base implementation is fine)\n+\tonce: typeof this.on;\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/BundlerController.ts",
            "diff": "@@ -0,0 +1,44 @@\n+import { Controller } from \"./BaseController\";\n+import { notImplemented } from \"./NotImplementedError\";\n+import type {\n+\tBundleCompleteEvent,\n+\tBundleStartEvent,\n+\tConfigUpdateEvent,\n+\tErrorEvent,\n+} from \"./events\";\n+\n+export class BundlerController extends Controller {\n+\t// ******************\n+\t//   Event Handlers\n+\t// ******************\n+\n+\tonConfigUpdate(_: ConfigUpdateEvent) {\n+\t\tnotImplemented(this.onConfigUpdate.name, this.constructor.name);\n+\t}\n+\n+\tasync teardown() {\n+\t\tnotImplemented(this.teardown.name, this.constructor.name);\n+\t}\n+\n+\t// *********************\n+\t//   Event Dispatchers\n+\t// *********************\n+\n+\temitBundleStartEvent(data: BundleStartEvent) {\n+\t\tthis.emit(\"bundleStart\", data);\n+\t}\n+\temitBundleCompletetEvent(data: BundleCompleteEvent) {\n+\t\tthis.emit(\"bundleComplete\", data);\n+\t}\n+\n+\t// *********************\n+\t//   Event Subscribers\n+\t// *********************\n+\n+\ton(event: \"bundleStart\", listener: (_: BundleStartEvent) => void): this;\n+\ton(event: \"bundleComplete\", listener: (_: BundleCompleteEvent) => void): this;\n+\t// @ts-expect-error Missing overload implementation (only need the signature types, base implementation is fine)\n+\ton(event: \"error\", listener: (_: ErrorEvent) => void): this;\n+\t// @ts-expect-error Missing initialisation (only need the signature types, base implementation is fine)\n+\tonce: typeof this.on;\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/ConfigController.ts",
            "diff": "@@ -0,0 +1,42 @@\n+import { EventEmitter } from \"node:events\";\n+// import { readFileSync } from \"../../parse\";\n+import { notImplemented } from \"./NotImplementedError\";\n+import type { ConfigUpdateEvent, ErrorEvent } from \"./events\";\n+import type { StartDevWorkerOptions } from \"./types\";\n+\n+export class ConfigController extends EventEmitter {\n+\tconfig?: StartDevWorkerOptions;\n+\n+\tsetOptions(_: StartDevWorkerOptions) {\n+\t\tnotImplemented(this.setOptions.name, this.constructor.name);\n+\t}\n+\tupdateOptions(_: Partial<StartDevWorkerOptions>) {\n+\t\tnotImplemented(this.updateOptions.name, this.constructor.name);\n+\t}\n+\n+\t// ******************\n+\t//   Event Handlers\n+\t// ******************\n+\n+\tasync teardown() {\n+\t\tnotImplemented(this.teardown.name, this.constructor.name);\n+\t}\n+\n+\t// *********************\n+\t//   Event Dispatchers\n+\t// *********************\n+\n+\temitConfigUpdateEvent(data: ConfigUpdateEvent) {\n+\t\tthis.emit(\"configUpdate\", data);\n+\t}\n+\n+\t// *********************\n+\t//   Event Subscribers\n+\t// *********************\n+\n+\ton(event: \"configUpdate\", listener: (_: ConfigUpdateEvent) => void): this;\n+\t// @ts-expect-error Missing overload implementation (only need the signature types, base implementation is fine)\n+\ton(event: \"error\", listener: (_: ErrorEvent) => void): this;\n+\t// @ts-expect-error Missing initialisation (only need the signature types, base implementation is fine)\n+\tonce: typeof this.on;\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/DevEnv.ts",
            "diff": "@@ -0,0 +1,185 @@\n+import assert from \"node:assert\";\n+import { EventEmitter } from \"node:events\";\n+import { logger } from \"../../logger\";\n+import { BundlerController } from \"./BundlerController\";\n+import { ConfigController } from \"./ConfigController\";\n+import { LocalRuntimeController } from \"./LocalRuntimeController\";\n+import { ProxyController } from \"./ProxyController\";\n+import { RemoteRuntimeController } from \"./RemoteRuntimeController\";\n+import type { RuntimeController } from \"./BaseController\";\n+import type { ErrorEvent } from \"./events\";\n+import type { StartDevWorkerOptions, DevWorker } from \"./types\";\n+\n+/**\n+ * @internal\n+ */\n+export class DevEnv extends EventEmitter {\n+\tconfig: ConfigController;\n+\tbundler: BundlerController;\n+\truntimes: RuntimeController[];\n+\tproxy: ProxyController;\n+\n+\tstartWorker(options: StartDevWorkerOptions): DevWorker {\n+\t\tconst worker = createWorkerObject(this);\n+\n+\t\tthis.config.setOptions(options);\n+\n+\t\treturn worker;\n+\t}\n+\n+\tconstructor({\n+\t\tconfig = new ConfigController(),\n+\t\tbundler = new BundlerController(),\n+\t\truntimes = [\n+\t\t\tnew LocalRuntimeController(),\n+\t\t\tnew RemoteRuntimeController(),\n+\t\t] as RuntimeController[],\n+\t\tproxy = new ProxyController(),\n+\t} = {}) {\n+\t\tsuper();\n+\n+\t\tthis.config = config;\n+\t\tthis.bundler = bundler;\n+\t\tthis.runtimes = runtimes;\n+\t\tthis.proxy = proxy;\n+\n+\t\t[config, bundler, ...runtimes, proxy].forEach((controller) =>\n+\t\t\tcontroller.on(\"error\", (event) => this.emitErrorEvent(event))\n+\t\t);\n+\n+\t\tthis.on(\"error\", (event: ErrorEvent) => {\n+\t\t\t// TODO: when we're are comfortable with StartDevWorker/DevEnv stability,\n+\t\t\t//       we can remove this handler and let the user handle the unknowable errors\n+\t\t\t//       or let the process crash. For now, log them to stderr\n+\t\t\t//       so we can identify knowable vs unknowable error candidates\n+\n+\t\t\tlogger.error(`Error in ${event.source}: ${event.reason}\\n`, event.cause);\n+\t\t\tlogger.debug(\"=> Error contextual data:\", event.data);\n+\t\t});\n+\n+\t\tconfig.on(\"configUpdate\", (event) => {\n+\t\t\tbundler.onConfigUpdate(event);\n+\t\t\tproxy.onConfigUpdate(event);\n+\t\t});\n+\n+\t\tbundler.on(\"bundleStart\", (event) => {\n+\t\t\tproxy.onBundleStart(event);\n+\t\t\truntimes.forEach((runtime) => {\n+\t\t\t\truntime.onBundleStart(event);\n+\t\t\t});\n+\t\t});\n+\t\tbundler.on(\"bundleComplete\", (event) => {\n+\t\t\truntimes.forEach((runtime) => {\n+\t\t\t\truntime.onBundleComplete(event);\n+\t\t\t});\n+\t\t});\n+\n+\t\truntimes.forEach((runtime) => {\n+\t\t\truntime.on(\"reloadStart\", (event) => {\n+\t\t\t\tproxy.onReloadStart(event);\n+\t\t\t});\n+\t\t\truntime.on(\"reloadComplete\", (event) => {\n+\t\t\t\tproxy.onReloadComplete(event);\n+\t\t\t});\n+\t\t});\n+\n+\t\tproxy.on(\"previewTokenExpired\", (event) => {\n+\t\t\truntimes.forEach((runtime) => {\n+\t\t\t\truntime.onPreviewTokenExpired(event);\n+\t\t\t});\n+\t\t});\n+\t}\n+\n+\t// *********************\n+\t//   Event Dispatchers\n+\t// *********************\n+\n+\tasync teardown() {\n+\t\tthis.emit(\"teardown\");\n+\n+\t\tawait Promise.all([\n+\t\t\tthis.config.teardown(),\n+\t\t\tthis.bundler.teardown(),\n+\t\t\tthis.runtimes.forEach((runtime) => runtime.teardown()),\n+\t\t\tthis.proxy.teardown(),\n+\t\t]);\n+\t}\n+\n+\temitErrorEvent(ev: ErrorEvent) {\n+\t\tif (\n+\t\t\tev.source === \"ProxyController\" &&\n+\t\t\tev.reason === \"Failed to start ProxyWorker or InspectorProxyWorker\"\n+\t\t) {\n+\t\t\tassert(ev.data.config); // we must already have a `config` if we've already tried (and failed) to instantiate the ProxyWorker(s)\n+\n+\t\t\tconst { config } = ev.data;\n+\t\t\tconst port = config.dev?.server?.port;\n+\t\t\tconst inspectorPort = config.dev?.inspector?.port;\n+\t\t\tconst randomPorts = [0, undefined];\n+\n+\t\t\t// console.log({ port, inspectorPort, ev });\n+\t\t\tif (!randomPorts.includes(port) || !randomPorts.includes(inspectorPort)) {\n+\t\t\t\t// emit the event here while the ConfigController is unimplemented\n+\t\t\t\t// this will cause the ProxyController to try reinstantiating the ProxyWorker(s)\n+\t\t\t\t// TODO: change this to `this.config.updateOptions({ dev: { server: { port: 0 }, inspector: { port: 0 } } });` when the ConfigController is implemented\n+\t\t\t\tthis.config.emitConfigUpdateEvent({\n+\t\t\t\t\ttype: \"configUpdate\",\n+\t\t\t\t\tconfig: {\n+\t\t\t\t\t\t...config,\n+\t\t\t\t\t\tdev: {\n+\t\t\t\t\t\t\t...config.dev,\n+\t\t\t\t\t\t\tserver: { ...config.dev?.server, port: 0 }, // override port\n+\t\t\t\t\t\t\tinspector: { ...config.dev?.inspector, port: 0 }, // override port\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t});\n+\t\t\t}\n+\t\t} else if (\n+\t\t\tev.source === \"ProxyController\" &&\n+\t\t\t(ev.reason.startsWith(\"Failed to send message to\") ||\n+\t\t\t\tev.reason.startsWith(\"Could not connect to InspectorProxyWorker\"))\n+\t\t) {\n+\t\t\tlogger.debug(`Error in ${ev.source}: ${ev.reason}\\n`, ev.cause);\n+\t\t\tlogger.debug(\"=> Error contextual data:\", ev.data);\n+\t\t}\n+\t\t// if other knowable + recoverable errors occur, handle them here\n+\t\telse {\n+\t\t\t// otherwise, re-emit the unknowable errors to the top-level\n+\t\t\tthis.emit(\"error\", ev);\n+\t\t}\n+\t}\n+}\n+\n+export function createWorkerObject(devEnv: DevEnv): DevWorker {\n+\treturn {\n+\t\tget ready() {\n+\t\t\treturn devEnv.proxy.ready.promise.then(() => undefined);\n+\t\t},\n+\t\tget config() {\n+\t\t\treturn devEnv.config.config;\n+\t\t},\n+\t\tsetOptions(options) {\n+\t\t\treturn devEnv.config.setOptions(options);\n+\t\t},\n+\t\tupdateOptions(options) {\n+\t\t\treturn devEnv.config.updateOptions(options);\n+\t\t},\n+\t\tasync fetch(...args) {\n+\t\t\tconst { proxyWorker } = await devEnv.proxy.ready.promise;\n+\t\t\tawait devEnv.proxy.runtimeMessageMutex.drained();\n+\n+\t\t\treturn proxyWorker.dispatchFetch(...args);\n+\t\t},\n+\t\tasync queue(..._args) {\n+\t\t\t// const { worker } = await devEnv.proxy.ready;\n+\t\t\t// return worker.queue(...args);\n+\t\t},\n+\t\tasync scheduled(..._args) {\n+\t\t\t// const { worker } = await devEnv.proxy.ready;\n+\t\t\t// return worker.scheduled(...args);\n+\t\t},\n+\t\tasync dispose() {\n+\t\t\tawait devEnv.teardown();\n+\t\t},\n+\t};\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/LocalRuntimeController.ts",
            "diff": "@@ -0,0 +1,41 @@\n+// import { readFileSync } from \"../../parse\";\n+import { RuntimeController } from \"./BaseController\";\n+import { notImplemented } from \"./NotImplementedError\";\n+import type {\n+\tBundleCompleteEvent,\n+\tBundleStartEvent,\n+\tPreviewTokenExpiredEvent,\n+\tReloadCompleteEvent,\n+\tReloadStartEvent,\n+} from \"./events\";\n+\n+export class LocalRuntimeController extends RuntimeController {\n+\t// ******************\n+\t//   Event Handlers\n+\t// ******************\n+\n+\tonBundleStart(_: BundleStartEvent) {\n+\t\tnotImplemented(this.onBundleStart.name, this.constructor.name);\n+\t}\n+\tonBundleComplete(_: BundleCompleteEvent) {\n+\t\tnotImplemented(this.onBundleComplete.name, this.constructor.name);\n+\t}\n+\tonPreviewTokenExpired(_: PreviewTokenExpiredEvent): void {\n+\t\t// ignore in local runtime\n+\t}\n+\n+\tasync teardown() {\n+\t\tnotImplemented(this.teardown.name, this.constructor.name);\n+\t}\n+\n+\t// *********************\n+\t//   Event Dispatchers\n+\t// *********************\n+\n+\temitReloadStartEvent(data: ReloadStartEvent) {\n+\t\tthis.emit(\"reloadComplete\", data);\n+\t}\n+\temitReloadCompletetEvent(data: ReloadCompleteEvent) {\n+\t\tthis.emit(\"reloadComplete\", data);\n+\t}\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/NotImplementedError.ts",
            "diff": "@@ -0,0 +1,15 @@\n+import { logger } from \"../../logger\";\n+\n+export class NotImplementedError extends Error {\n+\tconstructor(func: string, namespace?: string) {\n+\t\tif (namespace) func = `${namespace}#${func}`;\n+\t\tsuper(`Not Implemented Error: ${func}`);\n+\t}\n+}\n+\n+export function notImplemented(func: string, namespace?: string) {\n+\tif (namespace) func = `${namespace}#${func}`;\n+\tlogger.debug(`Not Implemented Error: ${func}`);\n+\n+\treturn new NotImplementedError(func, namespace);\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/ProxyController.ts",
            "diff": "@@ -0,0 +1,526 @@\n+import assert from \"node:assert\";\n+import { randomUUID } from \"node:crypto\";\n+import { EventEmitter } from \"node:events\";\n+import path from \"node:path\";\n+import { LogLevel, Miniflare, Mutex, Response, WebSocket } from \"miniflare\";\n+import inspectorProxyWorkerPath from \"worker:startDevWorker/InspectorProxyWorker\";\n+import proxyWorkerPath from \"worker:startDevWorker/ProxyWorker\";\n+import {\n+\tlogConsoleMessage,\n+\tmaybeHandleNetworkLoadResource,\n+} from \"../../dev/inspect\";\n+import { WranglerLog, castLogLevel } from \"../../dev/miniflare\";\n+import { handleRuntimeStdio } from \"../../dev/miniflare\";\n+import { getHttpsOptions } from \"../../https-options\";\n+import { logger } from \"../../logger\";\n+import { getSourceMappedStack } from \"../../sourcemap\";\n+import { castErrorCause } from \"./events\";\n+import { assertNever, createDeferred, type DeferredPromise } from \"./utils\";\n+import type { EsbuildBundle } from \"../../dev/use-esbuild\";\n+import type {\n+\tBundleStartEvent,\n+\tConfigUpdateEvent,\n+\tErrorEvent,\n+\tInspectorProxyWorkerIncomingWebSocketMessage,\n+\tInspectorProxyWorkerOutgoingRequestBody,\n+\tInspectorProxyWorkerOutgoingWebsocketMessage,\n+\tPreviewTokenExpiredEvent,\n+\tProxyData,\n+\tProxyWorkerIncomingRequestBody,\n+\tProxyWorkerOutgoingRequestBody,\n+\tReadyEvent,\n+\tReloadCompleteEvent,\n+\tReloadStartEvent,\n+\tSerializedError,\n+} from \"./events\";\n+import type { StartDevWorkerOptions } from \"./types\";\n+import type { MiniflareOptions } from \"miniflare\";\n+\n+export class ProxyController extends EventEmitter {\n+\tpublic ready = createDeferred<ReadyEvent>();\n+\n+\tpublic proxyWorker?: Miniflare;\n+\tproxyWorkerOptions?: MiniflareOptions;\n+\tinspectorProxyWorkerWebSocket?: DeferredPromise<WebSocket>;\n+\n+\tprotected latestConfig?: StartDevWorkerOptions;\n+\tprotected latestBundle?: EsbuildBundle;\n+\tsecret = randomUUID();\n+\n+\tprotected createProxyWorker() {\n+\t\tif (this._torndown) return;\n+\t\tassert(this.latestConfig !== undefined);\n+\n+\t\tconst cert =\n+\t\t\tthis.latestConfig.dev?.server?.secure ||\n+\t\t\tthis.latestConfig.dev?.inspector?.secure\n+\t\t\t\t? getHttpsOptions()\n+\t\t\t\t: undefined;\n+\n+\t\tconst proxyWorkerOptions: MiniflareOptions = {\n+\t\t\thost: this.latestConfig.dev?.server?.hostname,\n+\t\t\tport: this.latestConfig.dev?.server?.port,\n+\t\t\thttps: this.latestConfig.dev?.server?.secure,\n+\t\t\thttpsCert: cert?.cert,\n+\t\t\thttpsKey: cert?.key,\n+\n+\t\t\tworkers: [\n+\t\t\t\t{\n+\t\t\t\t\tname: \"ProxyWorker\",\n+\t\t\t\t\tcompatibilityFlags: [\"nodejs_compat\"],\n+\t\t\t\t\tmodulesRoot: path.dirname(proxyWorkerPath),\n+\t\t\t\t\tmodules: [{ type: \"ESModule\", path: proxyWorkerPath }],\n+\t\t\t\t\tdurableObjects: {\n+\t\t\t\t\t\tDURABLE_OBJECT: {\n+\t\t\t\t\t\t\tclassName: \"ProxyWorker\",\n+\t\t\t\t\t\t\tunsafePreventEviction: true,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tserviceBindings: {\n+\t\t\t\t\t\tPROXY_CONTROLLER: async (req): Promise<Response> => {\n+\t\t\t\t\t\t\tconst message =\n+\t\t\t\t\t\t\t\t(await req.json()) as ProxyWorkerOutgoingRequestBody;\n+\n+\t\t\t\t\t\t\tthis.onProxyWorkerMessage(message);\n+\n+\t\t\t\t\t\t\treturn new Response(null, { status: 204 });\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tbindings: {\n+\t\t\t\t\t\tPROXY_CONTROLLER_AUTH_SECRET: this.secret,\n+\t\t\t\t\t},\n+\n+\t\t\t\t\t// no need to use file-system, so don't\n+\t\t\t\t\tcache: false,\n+\t\t\t\t\tunsafeEphemeralDurableObjects: true,\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tname: \"InspectorProxyWorker\",\n+\t\t\t\t\tcompatibilityFlags: [\"nodejs_compat\"],\n+\t\t\t\t\tmodulesRoot: path.dirname(inspectorProxyWorkerPath),\n+\t\t\t\t\tmodules: [{ type: \"ESModule\", path: inspectorProxyWorkerPath }],\n+\t\t\t\t\tdurableObjects: {\n+\t\t\t\t\t\tDURABLE_OBJECT: {\n+\t\t\t\t\t\t\tclassName: \"InspectorProxyWorker\",\n+\t\t\t\t\t\t\tunsafePreventEviction: true,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tserviceBindings: {\n+\t\t\t\t\t\tPROXY_CONTROLLER: async (req): Promise<Response> => {\n+\t\t\t\t\t\t\tconst body =\n+\t\t\t\t\t\t\t\t(await req.json()) as InspectorProxyWorkerOutgoingRequestBody;\n+\n+\t\t\t\t\t\t\treturn this.onInspectorProxyWorkerRequest(body);\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t\tbindings: {\n+\t\t\t\t\t\tPROXY_CONTROLLER_AUTH_SECRET: this.secret,\n+\t\t\t\t\t},\n+\n+\t\t\t\t\tunsafeDirectHost: this.latestConfig.dev?.inspector?.hostname,\n+\t\t\t\t\tunsafeDirectPort: this.latestConfig.dev?.inspector?.port ?? 0,\n+\n+\t\t\t\t\t// no need to use file-system, so don't\n+\t\t\t\t\tcache: false,\n+\t\t\t\t\tunsafeEphemeralDurableObjects: true,\n+\t\t\t\t},\n+\t\t\t],\n+\n+\t\t\tverbose: logger.loggerLevel === \"debug\",\n+\n+\t\t\t// log requests into the ProxyWorker (for local + remote mode)\n+\t\t\tlog: new ProxyControllerLogger(castLogLevel(logger.loggerLevel), {\n+\t\t\t\tprefix:\n+\t\t\t\t\t// if debugging, log requests with specic ProxyWorker prefix\n+\t\t\t\t\tlogger.loggerLevel === \"debug\" ? \"wrangler-ProxyWorker\" : \"wrangler\",\n+\t\t\t}),\n+\t\t\thandleRuntimeStdio,\n+\t\t};\n+\n+\t\tconst proxyWorkerOptionsChanged = didMiniflareOptionsChange(\n+\t\t\tthis.proxyWorkerOptions,\n+\t\t\tproxyWorkerOptions\n+\t\t);\n+\n+\t\tconst willInstantiateMiniflareInstance =\n+\t\t\t!this.proxyWorker || proxyWorkerOptionsChanged;\n+\t\tthis.proxyWorker ??= new Miniflare(proxyWorkerOptions);\n+\t\tthis.proxyWorkerOptions = proxyWorkerOptions;\n+\n+\t\tif (proxyWorkerOptionsChanged) {\n+\t\t\tlogger.debug(\"ProxyWorker miniflare options changed, reinstantiating...\");\n+\n+\t\t\tvoid this.proxyWorker.setOptions(proxyWorkerOptions);\n+\n+\t\t\t// this creates a new .ready promise that will be resolved when both ProxyWorkers are ready\n+\t\t\t// it also respects any await-ers of the existing .ready promise\n+\t\t\tthis.ready = createDeferred<ReadyEvent>(this.ready);\n+\t\t}\n+\n+\t\t// store the non-null versions for callbacks\n+\t\tconst { proxyWorker } = this;\n+\n+\t\tif (willInstantiateMiniflareInstance) {\n+\t\t\tvoid Promise.all([\n+\t\t\t\tproxyWorker.ready,\n+\t\t\t\tthis.reconnectInspectorProxyWorker(),\n+\t\t\t])\n+\t\t\t\t.then(() => {\n+\t\t\t\t\tthis.emitReadyEvent(proxyWorker);\n+\t\t\t\t})\n+\t\t\t\t.catch((error) => {\n+\t\t\t\t\tthis.emitErrorEvent(\n+\t\t\t\t\t\t\"Failed to start ProxyWorker or InspectorProxyWorker\",\n+\t\t\t\t\t\terror\n+\t\t\t\t\t);\n+\t\t\t\t});\n+\t\t}\n+\t}\n+\n+\tasync reconnectInspectorProxyWorker(): Promise<WebSocket | undefined> {\n+\t\tif (this._torndown) return;\n+\n+\t\tconst existingWebSocket = await this.inspectorProxyWorkerWebSocket?.promise;\n+\t\tif (existingWebSocket?.readyState === WebSocket.READY_STATE_OPEN) {\n+\t\t\treturn existingWebSocket;\n+\t\t}\n+\n+\t\tthis.inspectorProxyWorkerWebSocket = createDeferred<WebSocket>();\n+\n+\t\tlet webSocket: WebSocket | null = null;\n+\n+\t\ttry {\n+\t\t\tassert(this.proxyWorker);\n+\t\t\tconst inspectorProxyWorker = await this.proxyWorker.getWorker(\n+\t\t\t\t\"InspectorProxyWorker\"\n+\t\t\t);\n+\t\t\t({ webSocket } = await inspectorProxyWorker.fetch(\n+\t\t\t\t\"http://dummy/cdn-cgi/InspectorProxyWorker/websocket\",\n+\t\t\t\t{\n+\t\t\t\t\theaders: { Authorization: this.secret, Upgrade: \"websocket\" },\n+\t\t\t\t}\n+\t\t\t));\n+\t\t} catch (cause) {\n+\t\t\tif (this._torndown) return;\n+\n+\t\t\tconst error = castErrorCause(cause);\n+\n+\t\t\tthis.inspectorProxyWorkerWebSocket?.reject(error);\n+\t\t\tthis.emitErrorEvent(\"Could not connect to InspectorProxyWorker\", error);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tassert(\n+\t\t\twebSocket,\n+\t\t\t\"Expected webSocket on response from inspectorProxyWorker\"\n+\t\t);\n+\n+\t\twebSocket.addEventListener(\"message\", (event) => {\n+\t\t\tassert(typeof event.data === \"string\");\n+\n+\t\t\tthis.onInspectorProxyWorkerMessage(JSON.parse(event.data));\n+\t\t});\n+\t\twebSocket.addEventListener(\"close\", () => {\n+\t\t\t// don't reconnect\n+\t\t});\n+\t\twebSocket.addEventListener(\"error\", () => {\n+\t\t\tif (this._torndown) return;\n+\n+\t\t\tvoid this.reconnectInspectorProxyWorker();\n+\t\t});\n+\n+\t\twebSocket.accept();\n+\t\tthis.inspectorProxyWorkerWebSocket?.resolve(webSocket);\n+\n+\t\treturn webSocket;\n+\t}\n+\n+\truntimeMessageMutex = new Mutex();\n+\tasync sendMessageToProxyWorker(\n+\t\tmessage: ProxyWorkerIncomingRequestBody,\n+\t\tretries = 3\n+\t): Promise<void> {\n+\t\tif (this._torndown) return;\n+\n+\t\t// Don't do any async work here. Enqueue the message with the mutex immediately.\n+\n+\t\ttry {\n+\t\t\tawait this.runtimeMessageMutex.runWith(async () => {\n+\t\t\t\tassert(this.proxyWorker, \"proxyWorker should already be instantiated\");\n+\n+\t\t\t\tconst ready = await this.proxyWorker.ready.catch(() => undefined);\n+\t\t\t\tif (!ready) return;\n+\n+\t\t\t\treturn this.proxyWorker.dispatchFetch(\n+\t\t\t\t\t`http://dummy/cdn-cgi/ProxyWorker/${message.type}`,\n+\t\t\t\t\t{\n+\t\t\t\t\t\theaders: { Authorization: this.secret },\n+\t\t\t\t\t\tcf: { hostMetadata: message },\n+\t\t\t\t\t}\n+\t\t\t\t);\n+\t\t\t});\n+\t\t} catch (cause) {\n+\t\t\tif (this._torndown) return;\n+\n+\t\t\tconst error = castErrorCause(cause);\n+\n+\t\t\tif (retries > 0) {\n+\t\t\t\treturn this.sendMessageToProxyWorker(message, retries - 1);\n+\t\t\t}\n+\n+\t\t\tthis.emitErrorEvent(\n+\t\t\t\t`Failed to send message to ProxyWorker: ${JSON.stringify(message)}`,\n+\t\t\t\terror\n+\t\t\t);\n+\n+\t\t\tthrow error;\n+\t\t}\n+\t}\n+\tasync sendMessageToInspectorProxyWorker(\n+\t\tmessage: InspectorProxyWorkerIncomingWebSocketMessage,\n+\t\tretries = 3\n+\t): Promise<void> {\n+\t\tif (this._torndown) return;\n+\n+\t\ttry {\n+\t\t\t// returns the existing websocket, if already connected\n+\t\t\tconst websocket = await this.reconnectInspectorProxyWorker();\n+\t\t\tassert(websocket);\n+\n+\t\t\twebsocket.send(JSON.stringify(message));\n+\t\t} catch (cause) {\n+\t\t\tif (this._torndown) return;\n+\n+\t\t\tconst error = castErrorCause(cause);\n+\n+\t\t\tif (retries > 0) {\n+\t\t\t\treturn this.sendMessageToInspectorProxyWorker(message, retries - 1);\n+\t\t\t}\n+\n+\t\t\tthis.emitErrorEvent(\n+\t\t\t\t`Failed to send message to InspectorProxyWorker: ${JSON.stringify(\n+\t\t\t\t\tmessage\n+\t\t\t\t)}`,\n+\t\t\t\terror\n+\t\t\t);\n+\n+\t\t\tthrow error;\n+\t\t}\n+\t}\n+\n+\t// ******************\n+\t//   Event Handlers\n+\t// ******************\n+\n+\tonConfigUpdate(data: ConfigUpdateEvent) {\n+\t\tthis.latestConfig = data.config;\n+\t\tthis.createProxyWorker();\n+\n+\t\tvoid this.sendMessageToProxyWorker({ type: \"pause\" });\n+\t}\n+\tonBundleStart(data: BundleStartEvent) {\n+\t\tthis.latestConfig = data.config;\n+\n+\t\tvoid this.sendMessageToProxyWorker({ type: \"pause\" });\n+\t}\n+\tonReloadStart(data: ReloadStartEvent) {\n+\t\tthis.latestConfig = data.config;\n+\n+\t\tvoid this.sendMessageToProxyWorker({ type: \"pause\" });\n+\t\tvoid this.sendMessageToInspectorProxyWorker({ type: \"reloadStart\" });\n+\t}\n+\tonReloadComplete(data: ReloadCompleteEvent) {\n+\t\tthis.latestConfig = data.config;\n+\t\tthis.latestBundle = data.bundle;\n+\n+\t\tvoid this.sendMessageToProxyWorker({\n+\t\t\ttype: \"play\",\n+\t\t\tproxyData: data.proxyData,\n+\t\t});\n+\n+\t\tvoid this.sendMessageToInspectorProxyWorker({\n+\t\t\ttype: \"reloadComplete\",\n+\t\t\tproxyData: data.proxyData,\n+\t\t});\n+\t}\n+\tonProxyWorkerMessage(message: ProxyWorkerOutgoingRequestBody) {\n+\t\tswitch (message.type) {\n+\t\t\tcase \"previewTokenExpired\":\n+\t\t\t\tthis.emitPreviewTokenExpiredEvent(message.proxyData);\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"error\":\n+\t\t\t\tthis.emitErrorEvent(\"Error inside ProxyWorker\", message.error);\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"debug-log\":\n+\t\t\t\tlogger.debug(\"[ProxyWorker]\", ...message.args);\n+\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tassertNever(message);\n+\t\t}\n+\t}\n+\tonInspectorProxyWorkerMessage(\n+\t\tmessage: InspectorProxyWorkerOutgoingWebsocketMessage\n+\t) {\n+\t\tswitch (message.method) {\n+\t\t\tcase \"Runtime.consoleAPICalled\": {\n+\t\t\t\tif (this._torndown) return;\n+\n+\t\t\t\tlogConsoleMessage(message.params);\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase \"Runtime.exceptionThrown\": {\n+\t\t\t\tif (this._torndown) return;\n+\n+\t\t\t\tconst stack = getSourceMappedStack(message.params.exceptionDetails);\n+\t\t\t\tlogger.error(message.params.exceptionDetails.text, stack);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tdefault: {\n+\t\t\t\tassertNever(message);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tasync onInspectorProxyWorkerRequest(\n+\t\tmessage: InspectorProxyWorkerOutgoingRequestBody\n+\t) {\n+\t\tswitch (message.type) {\n+\t\t\tcase \"runtime-websocket-error\":\n+\t\t\t\t// TODO: consider sending proxyData again to trigger the InspectorProxyWorker to reconnect to the runtime\n+\t\t\t\tlogger.debug(\n+\t\t\t\t\t\"[InspectorProxyWorker] 'runtime websocket' error\",\n+\t\t\t\t\tmessage.error\n+\t\t\t\t);\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"error\":\n+\t\t\t\tthis.emitErrorEvent(\"Error inside InspectorProxyWorker\", message.error);\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"debug-log\":\n+\t\t\t\tif (this._torndown) break;\n+\n+\t\t\t\tlogger.debug(\"[InspectorProxyWorker]\", ...message.args);\n+\n+\t\t\t\tbreak;\n+\t\t\tcase \"load-network-resource\": {\n+\t\t\t\tassert(this.latestConfig !== undefined);\n+\t\t\t\tassert(this.latestBundle !== undefined);\n+\n+\t\t\t\tlet maybeContents: string | undefined;\n+\t\t\t\tif (message.url.startsWith(\"wrangler-file:\")) {\n+\t\t\t\t\tmaybeContents = maybeHandleNetworkLoadResource(\n+\t\t\t\t\t\tmessage.url.replace(\"wrangler-file:\", \"file:\"),\n+\t\t\t\t\t\tthis.latestBundle,\n+\t\t\t\t\t\tthis.latestBundle.sourceMapMetadata?.tmpDir\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\n+\t\t\t\tif (maybeContents === undefined) {\n+\t\t\t\t\treturn new Response(null, { status: 404 });\n+\t\t\t\t}\n+\n+\t\t\t\treturn new Response(maybeContents);\n+\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tassertNever(message);\n+\t\t\t\treturn new Response(null, { status: 404 });\n+\t\t}\n+\n+\t\treturn new Response(null, { status: 204 });\n+\t}\n+\n+\t_torndown = false;\n+\tasync teardown() {\n+\t\tlogger.debug(\"ProxyController teardown\");\n+\t\tthis._torndown = true;\n+\n+\t\tconst { proxyWorker } = this;\n+\t\tthis.proxyWorker = undefined;\n+\n+\t\tawait Promise.all([\n+\t\t\tproxyWorker?.dispose(),\n+\t\t\tthis.inspectorProxyWorkerWebSocket?.promise\n+\t\t\t\t.then((ws) => ws.close())\n+\t\t\t\t.catch(() => {\n+\t\t\t\t\t/* ignore */\n+\t\t\t\t}),\n+\t\t]);\n+\t}\n+\n+\t// *********************\n+\t//   Event Dispatchers\n+\t// *********************\n+\n+\temitReadyEvent(proxyWorker: Miniflare) {\n+\t\tconst data: ReadyEvent = {\n+\t\t\ttype: \"ready\",\n+\t\t\tproxyWorker,\n+\t\t};\n+\n+\t\tthis.emit(\"ready\", data);\n+\t\tthis.ready.resolve(data);\n+\t}\n+\temitPreviewTokenExpiredEvent(proxyData: ProxyData) {\n+\t\tthis.emit(\"previewTokenExpired\", {\n+\t\t\ttype: \"previewTokenExpired\",\n+\t\t\tproxyData,\n+\t\t});\n+\t}\n+\temitErrorEvent(reason: string, cause: Error | SerializedError) {\n+\t\tconst event: ErrorEvent = {\n+\t\t\ttype: \"error\",\n+\t\t\tsource: \"ProxyController\",\n+\t\t\tcause,\n+\t\t\treason,\n+\t\t\tdata: {\n+\t\t\t\tconfig: this.latestConfig,\n+\t\t\t\tbundle: this.latestBundle,\n+\t\t\t},\n+\t\t};\n+\n+\t\tthis.emit(\"error\", event);\n+\t}\n+\n+\t// *********************\n+\t//   Event Subscribers\n+\t// *********************\n+\n+\ton(event: \"ready\", listener: (_: ReadyEvent) => void): this;\n+\ton(\n+\t\tevent: \"previewTokenExpired\",\n+\t\tlistener: (_: PreviewTokenExpiredEvent) => void\n+\t): this;\n+\t// @ts-expect-error Missing overload implementation (only need the signature types, base implementation is fine)\n+\ton(event: \"error\", listener: (_: ErrorEvent) => void): this;\n+\t// @ts-expect-error Missing initialisation (only need the signature types, base implementation is fine)\n+\tonce: typeof this.on;\n+}\n+\n+export class ProxyControllerLogger extends WranglerLog {\n+\tlog(message: string) {\n+\t\t// filter out request logs being handled by the ProxyWorker\n+\t\t// the requests log remaining are handled by the UserWorker\n+\t\t// keep the ProxyWorker request logs if we're in debug mode\n+\t\tif (message.includes(\"/cdn-cgi/\") && this.level < LogLevel.DEBUG) return;\n+\t\tsuper.log(message);\n+\t}\n+}\n+\n+function deepEquality(a: unknown, b: unknown): boolean {\n+\t// could be more efficient, but this is fine for now\n+\treturn JSON.stringify(a) === JSON.stringify(b);\n+}\n+\n+function didMiniflareOptionsChange(\n+\tprev: MiniflareOptions | undefined,\n+\tnext: MiniflareOptions\n+) {\n+\tif (prev === undefined) return false; // first time, so 'no change'\n+\n+\t// otherwise, if they're not deeply equal, they've changed\n+\treturn !deepEquality(prev, next);\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/RemoteRuntimeController.ts",
            "diff": "@@ -0,0 +1,41 @@\n+// import { readFileSync } from \"../../parse\";\n+import { RuntimeController } from \"./BaseController\";\n+import { notImplemented } from \"./NotImplementedError\";\n+import type {\n+\tBundleCompleteEvent,\n+\tBundleStartEvent,\n+\tPreviewTokenExpiredEvent,\n+\tReloadCompleteEvent,\n+\tReloadStartEvent,\n+} from \"./events\";\n+\n+export class RemoteRuntimeController extends RuntimeController {\n+\t// ******************\n+\t//   Event Handlers\n+\t// ******************\n+\n+\tonBundleStart(_: BundleStartEvent) {\n+\t\tnotImplemented(this.onBundleStart.name, this.constructor.name);\n+\t}\n+\tonBundleComplete(_: BundleCompleteEvent) {\n+\t\tnotImplemented(this.onBundleComplete.name, this.constructor.name);\n+\t}\n+\tonPreviewTokenExpired(_: PreviewTokenExpiredEvent): void {\n+\t\tnotImplemented(this.onPreviewTokenExpired.name, this.constructor.name);\n+\t}\n+\n+\tasync teardown() {\n+\t\tnotImplemented(this.teardown.name, this.constructor.name);\n+\t}\n+\n+\t// *********************\n+\t//   Event Dispatchers\n+\t// *********************\n+\n+\temitReloadStartEvent(data: ReloadStartEvent) {\n+\t\tthis.emit(\"reloadComplete\", data);\n+\t}\n+\temitReloadCompletetEvent(data: ReloadCompleteEvent) {\n+\t\tthis.emit(\"reloadComplete\", data);\n+\t}\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/bundle-allowed-paths.ts",
            "diff": "@@ -0,0 +1,99 @@\n+/**\n+ * Browser DevTools will send `Network.loadNetworkResource` commands for source\n+ * maps and source files. We only want to allow files referenced by the bundle\n+ * to be requested (to prevent arbitrary file access). This module exports\n+ * functions for checking whether a specific file may be requested as a source\n+ * file, or source map (i.e. is safe to serve from the file system).\n+ */\n+import assert from \"node:assert\";\n+import fs from \"node:fs\";\n+import path from \"node:path\";\n+import { fileURLToPath, pathToFileURL } from \"node:url\";\n+import type { EsbuildBundle } from \"../../dev/use-esbuild\";\n+import type { RawSourceMap } from \"source-map\";\n+\n+export function isAllowedSourcePath(\n+\tbundle: EsbuildBundle,\n+\tfilePath: string\n+): boolean {\n+\tconst allowed = getBundleReferencedPaths(bundle);\n+\treturn allowed.sourcePaths.has(filePath);\n+}\n+export function isAllowedSourceMapPath(\n+\tbundle: EsbuildBundle,\n+\tfilePath: string\n+): boolean {\n+\tconst allowed = getBundleReferencedPaths(bundle);\n+\treturn allowed.sourceMapPaths.has(filePath);\n+}\n+\n+interface BundleReferencedPaths {\n+\tsourcePaths: Set<string>;\n+\tsourceMapPaths: Set<string>;\n+}\n+const bundleReferencedPathsCache = new WeakMap<\n+\tEsbuildBundle,\n+\tBundleReferencedPaths\n+>();\n+function getBundleReferencedPaths(\n+\tbundle: EsbuildBundle\n+): BundleReferencedPaths {\n+\tlet allowed = bundleReferencedPathsCache.get(bundle);\n+\tif (allowed !== undefined) return allowed;\n+\tallowed = { sourcePaths: new Set(), sourceMapPaths: new Set() };\n+\tbundleReferencedPathsCache.set(bundle, allowed);\n+\n+\tfor (const sourcePath of getBundleSourcePaths(bundle)) {\n+\t\t// We don't need to add `sourcePath` to `allowed` here, as DevTools sends\n+\t\t// `Debugger.getScriptSource` commands instead, which get the code from V8.\n+\n+\t\tconst sourceMappingURL = maybeGetSourceMappingURL(sourcePath);\n+\t\tif (sourceMappingURL === undefined) continue;\n+\t\tconst sourceMappingPath = fileURLToPath(sourceMappingURL);\n+\t\tallowed.sourceMapPaths.add(sourceMappingPath);\n+\n+\t\tconst sourceMapData = fs.readFileSync(sourceMappingPath, \"utf8\");\n+\t\tconst sourceMap: RawSourceMap = JSON.parse(sourceMapData);\n+\n+\t\tconst sourceRoot = sourceMap.sourceRoot ?? \"\";\n+\t\tfor (const source of sourceMap.sources) {\n+\t\t\tconst sourceURL = new URL(\n+\t\t\t\tpath.posix.join(sourceRoot, source),\n+\t\t\t\tsourceMappingURL\n+\t\t\t);\n+\t\t\tallowed.sourcePaths.add(fileURLToPath(sourceURL));\n+\t\t}\n+\t}\n+\n+\treturn allowed;\n+}\n+\n+function* getBundleSourcePaths(bundle: EsbuildBundle): Generator<string> {\n+\tyield bundle.path;\n+\tfor (const module of bundle.modules) {\n+\t\tif (module.type !== \"esm\" && module.type !== \"commonjs\") continue;\n+\t\tif (module.filePath === undefined) continue;\n+\t\tyield module.filePath;\n+\t}\n+}\n+\n+function maybeGetSourceMappingURL(sourcePath: string): URL | undefined {\n+\tconst source = fs.readFileSync(sourcePath, \"utf8\");\n+\tconst sourceMappingURLIndex = source.lastIndexOf(\"//# sourceMappingURL=\");\n+\tif (sourceMappingURLIndex === -1) return;\n+\n+\tconst sourceMappingURLMatch = source\n+\t\t.substring(sourceMappingURLIndex)\n+\t\t.match(/^\\/\\/# sourceMappingURL=(.+)/);\n+\tassert(sourceMappingURLMatch !== null);\n+\tconst sourceMappingURLSpecifier = sourceMappingURLMatch[1];\n+\n+\tconst sourceURL = pathToFileURL(sourcePath);\n+\ttry {\n+\t\tconst sourceMappingURL = new URL(sourceMappingURLSpecifier, sourceURL);\n+\t\tif (sourceMappingURL.protocol !== \"file:\") return;\n+\t\treturn sourceMappingURL;\n+\t} catch {\n+\t\t// If we can't parse `sourceMappingURLSpecifier`, ignore it\n+\t}\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/devtools.ts",
            "diff": "@@ -0,0 +1,41 @@\n+import type Protocol from \"devtools-protocol/types/protocol-mapping\";\n+\n+type _Params<ParamsArray extends [unknown?]> = ParamsArray extends [infer P]\n+\t? P\n+\t: undefined;\n+\n+type _EventMethods = keyof Protocol.Events;\n+export type DevToolsEvent<Method extends _EventMethods> = Method extends unknown\n+\t? {\n+\t\t\tmethod: Method;\n+\t\t\tparams: _Params<Protocol.Events[Method]>;\n+\t  }\n+\t: never;\n+\n+export type DevToolsEvents = DevToolsEvent<_EventMethods>;\n+\n+type _CommandMethods = keyof Protocol.Commands;\n+export type DevToolsCommandRequest<Method extends _CommandMethods> =\n+\tMethod extends unknown\n+\t\t? _Params<Protocol.Commands[Method][\"paramsType\"]> extends undefined\n+\t\t\t? {\n+\t\t\t\t\tid: number;\n+\t\t\t\t\tmethod: Method;\n+\t\t\t  }\n+\t\t\t: {\n+\t\t\t\t\tid: number;\n+\t\t\t\t\tmethod: Method;\n+\t\t\t\t\tparams: _Params<Protocol.Commands[Method][\"paramsType\"]>;\n+\t\t\t  }\n+\t\t: never;\n+\n+export type DevToolsCommandRequests = DevToolsCommandRequest<_CommandMethods>;\n+\n+export type DevToolsCommandResponse<Method extends _CommandMethods> =\n+\tMethod extends unknown\n+\t\t? {\n+\t\t\t\tid: number;\n+\t\t\t\tresult: Protocol.Commands[Method][\"returnType\"];\n+\t\t  }\n+\t\t: never;\n+export type DevToolsCommandResponses = DevToolsCommandResponse<_CommandMethods>;"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/events.ts",
            "diff": "@@ -0,0 +1,150 @@\n+import type { EsbuildBundle } from \"../../dev/use-esbuild\";\n+import type { DevToolsEvent } from \"./devtools\";\n+import type { StartDevWorkerOptions } from \"./types\";\n+import type { Miniflare } from \"miniflare\";\n+\n+export type TeardownEvent = {\n+\ttype: \"teardown\";\n+};\n+export type ErrorEvent =\n+\t| BaseErrorEvent<\n+\t\t\t| \"ConfigController\"\n+\t\t\t| \"BundlerController\"\n+\t\t\t| \"LocalRuntimeController\"\n+\t\t\t| \"RemoteRuntimeController\"\n+\t\t\t| \"ProxyWorker\"\n+\t\t\t| \"InspectorProxyWorker\"\n+\t  >\n+\t| BaseErrorEvent<\n+\t\t\t\"ProxyController\",\n+\t\t\t{ config?: StartDevWorkerOptions; bundle?: EsbuildBundle }\n+\t  >;\n+export type BaseErrorEvent<Source = string, Data = undefined> = {\n+\ttype: \"error\";\n+\treason: string;\n+\tcause: Error | SerializedError;\n+\tsource: Source;\n+\tdata: Data;\n+};\n+\n+export function castErrorCause(cause: unknown) {\n+\tif (cause instanceof Error) return cause;\n+\n+\tconst error = new Error();\n+\terror.cause = cause;\n+\n+\treturn error;\n+}\n+\n+// ConfigController\n+export type ConfigUpdateEvent = {\n+\ttype: \"configUpdate\";\n+\n+\tconfig: StartDevWorkerOptions;\n+};\n+\n+// BundlerController\n+export type BundleStartEvent = {\n+\ttype: \"bundleStart\";\n+\n+\tconfig: StartDevWorkerOptions;\n+};\n+export type BundleCompleteEvent = {\n+\ttype: \"bundleComplete\";\n+\n+\tconfig: StartDevWorkerOptions;\n+\tbundle: EsbuildBundle;\n+};\n+\n+// RuntimeController\n+export type ReloadStartEvent = {\n+\ttype: \"reloadStart\";\n+\n+\tconfig: StartDevWorkerOptions;\n+\tbundle: EsbuildBundle;\n+};\n+export type ReloadCompleteEvent = {\n+\ttype: \"reloadComplete\";\n+\n+\tconfig: StartDevWorkerOptions;\n+\tbundle: EsbuildBundle;\n+\tproxyData: ProxyData;\n+};\n+\n+// ProxyController\n+export type PreviewTokenExpiredEvent = {\n+\ttype: \"previewTokenExpired\";\n+\n+\tproxyData: ProxyData;\n+\t// ... other details of failed request/response\n+};\n+export type ReadyEvent = {\n+\ttype: \"ready\";\n+\n+\tproxyWorker: Miniflare;\n+};\n+\n+// ProxyWorker\n+export type ProxyWorkerIncomingRequestBody =\n+\t| { type: \"play\"; proxyData: ProxyData }\n+\t| { type: \"pause\" };\n+export type ProxyWorkerOutgoingRequestBody =\n+\t| { type: \"error\"; error: SerializedError }\n+\t| { type: \"previewTokenExpired\"; proxyData: ProxyData }\n+\t| { type: \"debug-log\"; args: Parameters<typeof console.debug> };\n+\n+// InspectorProxyWorker\n+export * from \"./devtools\";\n+export type InspectorProxyWorkerIncomingWebSocketMessage =\n+\t| {\n+\t\t\ttype: ReloadStartEvent[\"type\"];\n+\t  }\n+\t| {\n+\t\t\ttype: ReloadCompleteEvent[\"type\"];\n+\t\t\tproxyData: ProxyData;\n+\t  };\n+export type InspectorProxyWorkerOutgoingWebsocketMessage =\n+\t// Relayed Chrome DevTools Protocol Messages\n+\t| DevToolsEvent<\"Runtime.consoleAPICalled\">\n+\t| DevToolsEvent<\"Runtime.exceptionThrown\">;\n+\n+export type InspectorProxyWorkerOutgoingRequestBody =\n+\t| { type: \"error\"; error: SerializedError }\n+\t| { type: \"runtime-websocket-error\"; error: SerializedError }\n+\t| { type: \"debug-log\"; args: Parameters<typeof console.debug> }\n+\t// Intercepted Chrome DevTools Protocol Messages\n+\t| { type: \"load-network-resource\"; url: string }; // responds with `url`'s contents\n+\n+export type SerializedError = {\n+\tmessage: string;\n+\tname?: string;\n+\tstack?: string | undefined;\n+\tcause?: unknown;\n+};\n+export function serialiseError(e: unknown): SerializedError {\n+\tif (e instanceof Error) {\n+\t\treturn {\n+\t\t\tmessage: e.message,\n+\t\t\tname: e.name,\n+\t\t\tstack: e.stack,\n+\t\t\tcause: e.cause && serialiseError(e.cause),\n+\t\t};\n+\t} else {\n+\t\treturn { message: String(e) };\n+\t}\n+}\n+\n+export type UrlOriginParts = Pick<URL, \"protocol\" | \"hostname\" | \"port\">;\n+export type UrlOriginAndPathnameParts = Pick<\n+\tURL,\n+\t\"protocol\" | \"hostname\" | \"port\" | \"pathname\"\n+>;\n+\n+export type ProxyData = {\n+\tuserWorkerUrl: UrlOriginParts;\n+\tuserWorkerInspectorUrl: UrlOriginAndPathnameParts;\n+\tuserWorkerInnerUrlOverrides: Partial<UrlOriginParts>;\n+\theaders: Record<string, string | undefined>;\n+\tliveReload?: boolean;\n+\tproxyLogsToController?: boolean;\n+};"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/index.ts",
            "diff": "@@ -0,0 +1,12 @@\n+import { DevEnv } from \"./DevEnv\";\n+import type { StartDevWorkerOptions, DevWorker } from \"./types\";\n+\n+export { DevEnv };\n+export * from \"./types\";\n+export * from \"./events\";\n+\n+export function startWorker(options: StartDevWorkerOptions): DevWorker {\n+\tconst devEnv = new DevEnv();\n+\n+\treturn devEnv.startWorker(options);\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/types.ts",
            "diff": "@@ -0,0 +1,197 @@\n+import type { RawConfig } from \"../../config/config\";\n+import type { CfAccount } from \"../../dev/create-worker-preview\";\n+import type { Json, Request, Response, DispatchFetch } from \"miniflare\";\n+import type * as undici from \"undici\";\n+\n+export interface DevWorker {\n+\tready: Promise<void>;\n+\tconfig?: StartDevWorkerOptions;\n+\tsetOptions(options: StartDevWorkerOptions): void;\n+\tupdateOptions(options: Partial<StartDevWorkerOptions>): void;\n+\tfetch: DispatchFetch;\n+\tscheduled(cron?: string): Promise<void>;\n+\tqueue(queueName: string, ...messages: unknown[]): Promise<void>;\n+\tdispose(): Promise<void>;\n+}\n+\n+export interface StartDevWorkerOptions {\n+\t/** The name of the worker. */\n+\tname: string;\n+\t/**\n+\t * The javascript or typescript entry-point of the worker.\n+\t * This is the `main` property of a wrangler.toml.\n+\t * You can specify a file path or provide the contents directly.\n+\t */\n+\tscript: File<string>;\n+\t/** The configuration of the worker. */\n+\tconfig?: File<string | RawConfig> & { env?: string };\n+\t/** The compatibility date for the workerd runtime. */\n+\tcompatibilityDate?: string;\n+\t/** The compatibility flags for the workerd runtime. */\n+\tcompatibilityFlags?: string[];\n+\n+\t/** The bindings available to the worker. The specified bindind type will be exposed to the worker on the `env` object under the same key. */\n+\tbindings?: Record<string, Binding>; // Type level constraint for bindings not sharing names\n+\t/** The triggers which will cause the worker's exported default handlers to be called. */\n+\ttriggers?: Trigger[];\n+\n+\t/** Options applying to (legacy) Worker Sites. Please consider using Cloudflare Pages. */\n+\tsite?: {\n+\t\tpath: string;\n+\t\tinclude?: string[];\n+\t\texclude?: string[];\n+\t};\n+\n+\t/** Options applying to the worker's build step. Applies to deploy and dev. */\n+\tbuild?: {\n+\t\t/** Whether the worker and its dependencies are bundled. Defaults to true. */\n+\t\tbundle?: boolean;\n+\t\t/** Specifies types of modules matched by globs. */\n+\t\tmoduleRules?: ModuleRule[];\n+\t\t/** Replace global identifiers with constant expressions, e.g. ['debug=true','version=\"1.0.0\"'] or { debug: 'true', version: '\"1.0.0\"' }. Only takes effect if bundle: true. */\n+\t\tdefine: string[] | Record<string, string>;\n+\t\t/** Whether the bundled worker is minified. Only takes effect if bundle: true. */\n+\t\tminify: boolean;\n+\t\t/** Options controlling a custom build step. */\n+\t\tcustom: {\n+\t\t\t/** Custom shell command to run before bundling. Runs even if bundle. */\n+\t\t\tcommand: string;\n+\t\t\t/** The cwd to run the command in. */\n+\t\t\tworkingDirectory?: string;\n+\t\t\t/** Filepath(s) to watch for changes. Upon changes, the command will be rerun. */\n+\t\t\twatch?: string | string[];\n+\t\t};\n+\t};\n+\n+\t/** Options applying to the worker's development preview environment. */\n+\tdev?: {\n+\t\t/** Options applying to the worker's inspector server. */\n+\t\tinspector?: { hostname?: string; port?: number; secure?: boolean };\n+\t\t/** Whether the worker runs on the edge or locally. */\n+\t\tremote?: boolean;\n+\t\t/** Cloudflare Account credentials. Can be provided upfront or as a function which will be called only when required. */\n+\t\tauth?: Hook<CfAccount>;\n+\t\t/** Whether local storage (KV, Durable Objects, R2, D1, etc) is persisted. You can also specify the directory to persist data to. */\n+\t\tpersist?: boolean | { path: string };\n+\t\t/** Controls which logs are logged \ud83e\udd19. */\n+\t\tlogLevel?: LogLevel;\n+\t\t/** Whether the worker server restarts upon source/config file changes. */\n+\t\twatch?: boolean;\n+\t\t/** Whether a script tag is inserted on text/html responses which will reload the page upon file changes. Defaults to false. */\n+\t\tliveReload?: boolean;\n+\n+\t\t/** The local address to reach your worker. Applies to remote: true (remote mode) and remote: false (local mode). */\n+\t\tserver?: { hostname?: string; port?: number; secure?: boolean }; // hostname: --ip, port: --port, secure: --local-protocol\n+\t\t/** Controls what request.url looks like inside the worker. */\n+\t\turlOverrides?: { hostname?: string; secure?: boolean }; // hostname: --host (remote)/--local-upstream (local), port: doesn't make sense in remote/=== server.port in local, secure: --upstream-protocol\n+\t\t/** A hook for outbound fetch calls from within the worker. */\n+\t\toutboundService?: ServiceFetch;\n+\t\t/** An undici MockAgent to declaratively mock fetch calls to particular resources. */\n+\t\tmockFetch?: undici.MockAgent;\n+\t};\n+}\n+\n+export type Hook<T, Args extends unknown[] = unknown[]> =\n+\t| T\n+\t| Promise<T>\n+\t| ((...args: Args) => T | Promise<T>);\n+\n+export type LogLevel = \"debug\" | \"info\" | \"log\" | \"warn\" | \"error\" | \"none\";\n+\n+export type File<Contents = string> =\n+\t| { path: string } // `path` resolved relative to cwd\n+\t| { contents: Contents; path?: string }; // `contents` used instead, `path` can be specified if needed e.g. for module resolution\n+export type BinaryFile = File<Uint8Array>; // Note: Node's `Buffer`s are instances of `Uint8Array`\n+\n+export interface Location {\n+\thostname?: string;\n+\tport?: number;\n+\tsecure?: boolean; // Usually `https`, but could be `wss` for inspector\n+}\n+\n+export type PatternRoute = {\n+\tpattern: string;\n+} & (\n+\t| { pattern: string; customDomain: true }\n+\t| { pattern: string; zoneId: string; customDomain?: true; zoneName?: never }\n+\t| { pattern: string; zoneName: string; customDomain?: true; zoneId?: never }\n+);\n+export type WorkersDevRoute = { workersDev: true };\n+export type Route = PatternRoute | WorkersDevRoute;\n+\n+export interface ModuleRule {\n+\ttype:\n+\t\t| \"ESModule\"\n+\t\t| \"CommonJS\"\n+\t\t| \"NodeJSCompat\"\n+\t\t| \"CompiledWasm\"\n+\t\t| \"Text\"\n+\t\t| \"Data\";\n+\tinclude?: string[];\n+\tfallthrough?: boolean;\n+}\n+\n+export type Trigger =\n+\t| { type: \"workers.dev\" }\n+\t| { type: \"route\"; pattern: string; customDomain: true }\n+\t| {\n+\t\t\ttype: \"route\";\n+\t\t\tpattern: string;\n+\t\t\tzoneId: string;\n+\t\t\tcustomDomain?: true;\n+\t\t\tzoneName?: never;\n+\t  }\n+\t| {\n+\t\t\ttype: \"route\";\n+\t\t\tpattern: string;\n+\t\t\tzoneName: string;\n+\t\t\tcustomDomain?: true;\n+\t\t\tzoneId?: never;\n+\t  }\n+\t| { type: \"schedule\"; schedule: string }\n+\t| {\n+\t\t\ttype: \"queue-consumer\";\n+\t\t\tname: string;\n+\t\t\tmaxBatchSize?: number;\n+\t\t\tmaxBatchTimeout?: number;\n+\t\t\tmaxRetries?: string;\n+\t\t\tdeadLetterQueue?: string;\n+\t  };\n+\n+export type Binding =\n+\t| { type: \"kv\"; id: string }\n+\t| { type: \"r2\"; bucket_name: string }\n+\t| {\n+\t\t\ttype: \"d1\";\n+\t\t\t/** The binding name used to refer to the D1 database in the worker. */\n+\t\t\tbinding: string;\n+\t\t\t/** The name of this D1 database. */\n+\t\t\tdatabase_name: string;\n+\t\t\t/** The UUID of this D1 database (not required). */\n+\t\t\tdatabase_id: string;\n+\t\t\t/** The UUID of this D1 database for Wrangler Dev (if specified). */\n+\t\t\tpreview_database_id?: string;\n+\t\t\t/** The name of the migrations table for this D1 database (defaults to 'd1_migrations'). */\n+\t\t\tmigrations_table?: string;\n+\t\t\t/** The path to the directory of migrations for this D1 database (defaults to './migrations'). */\n+\t\t\tmigrations_dir?: string;\n+\t\t\t/** Internal use only. */\n+\t\t\tdatabase_internal_env?: string;\n+\t  }\n+\t| {\n+\t\t\ttype: \"durable-object\";\n+\t\t\tclassName: string;\n+\t\t\tservice?: ServiceDesignator;\n+\t  }\n+\t| { type: \"service\"; service: ServiceDesignator | ServiceFetch }\n+\t| { type: \"queue-producer\"; name: string }\n+\t| { type: \"constellation\"; project_id: string }\n+\t| { type: \"var\"; value: string | Json | Uint8Array }\n+\t| { type: `unsafe-${string}`; [key: string]: unknown };\n+\n+export type ServiceFetch = (request: Request) => Promise<Response>;\n+\n+export interface ServiceDesignator {\n+\tname: string;\n+\tenv?: string;\n+}"
        },
        {
            "filename": "packages/wrangler/src/api/startDevWorker/utils.ts",
            "diff": "@@ -0,0 +1,43 @@\n+import assert from \"node:assert\";\n+\n+export type MaybePromise<T> = T | Promise<T>;\n+export type DeferredPromise<T> = {\n+\tpromise: Promise<T>;\n+\tresolve: (_: MaybePromise<T>) => void;\n+\treject: (_: Error) => void;\n+};\n+\n+export function createDeferred<T>(\n+\tpreviousDeferred?: DeferredPromise<T>\n+): DeferredPromise<T> {\n+\tlet resolve, reject;\n+\tconst newPromise = new Promise<T>((_resolve, _reject) => {\n+\t\tresolve = _resolve;\n+\t\treject = _reject;\n+\t});\n+\tassert(resolve);\n+\tassert(reject);\n+\n+\t// if passed a previousDeferred, ensure it is resolved with the newDeferred\n+\t// so that await-ers of previousDeferred are now await-ing newDeferred\n+\tpreviousDeferred?.resolve(newPromise);\n+\n+\treturn {\n+\t\tpromise: newPromise,\n+\t\tresolve,\n+\t\treject,\n+\t};\n+}\n+\n+export function assertNever(_value: never) {}\n+\n+export function urlFromParts(\n+\tparts: Partial<URL>,\n+\tbase = \"http://localhost\"\n+): URL {\n+\tconst url = new URL(base);\n+\n+\tObject.assign(url, parts);\n+\n+\treturn url;\n+}"
        },
        {
            "filename": "packages/wrangler/src/cli.ts",
            "diff": "@@ -1,6 +1,6 @@\n import process from \"process\";\n import { hideBin } from \"yargs/helpers\";\n-import { unstable_dev, unstable_pages } from \"./api\";\n+import { unstable_dev, unstable_pages, DevEnv as unstable_DevEnv } from \"./api\";\n import { FatalError } from \"./errors\";\n import { main } from \".\";\n \n@@ -24,5 +24,5 @@ if (typeof jest === \"undefined\" && require.main === module) {\n  * It makes it possible to import wrangler from 'wrangler',\n  * and call wrangler.unstable_dev().\n  */\n-export { unstable_dev, unstable_pages };\n+export { unstable_dev, unstable_pages, unstable_DevEnv };\n export type { UnstableDevWorker, UnstableDevOptions };"
        },
        {
            "filename": "packages/wrangler/src/dev.tsx",
            "diff": "@@ -26,6 +26,7 @@ import {\n \tisLegacyEnv,\n \tprintWranglerBanner,\n } from \"./index\";\n+import type { ProxyData } from \"./api\";\n import type { Config, Environment } from \"./config\";\n import type { Route, Rule } from \"./config/environment\";\n import type { CfWorkerInit, CfModule } from \"./deployment-bundle/worker\";\n@@ -340,7 +341,7 @@ export type StartDevOptions = DevArguments &\n \t\tforceLocal?: boolean;\n \t\tdisableDevRegistry?: boolean;\n \t\tenablePagesAssetsServiceBinding?: EnablePagesAssetsServiceBindingOptions;\n-\t\tonReady?: (ip: string, port: number) => void;\n+\t\tonReady?: (ip: string, port: number, proxyData: ProxyData) => void;\n \t\tshowInteractiveDevSession?: boolean;\n \t\tupdateCheck?: boolean;\n \t};"
        },
        {
            "filename": "packages/wrangler/src/dev/dev.tsx",
            "diff": "@@ -5,10 +5,17 @@ import { watch } from \"chokidar\";\n import clipboardy from \"clipboardy\";\n import commandExists from \"command-exists\";\n import { Box, Text, useApp, useInput, useStdin } from \"ink\";\n-import React, { useEffect, useRef, useState } from \"react\";\n+import React, {\n+\tuseCallback,\n+\tuseEffect,\n+\tuseMemo,\n+\tuseRef,\n+\tuseState,\n+} from \"react\";\n import { useErrorHandler, withErrorBoundary } from \"react-error-boundary\";\n import onExit from \"signal-exit\";\n import { fetch } from \"undici\";\n+import { DevEnv } from \"../api\";\n import { runCustomBuild } from \"../deployment-bundle/run-custom-build\";\n import {\n \tgetBoundRegisteredWorkers,\n@@ -24,6 +31,7 @@ import { Local } from \"./local\";\n import { Remote } from \"./remote\";\n import { useEsbuild } from \"./use-esbuild\";\n import { validateDevProps } from \"./validate-dev-props\";\n+import type { ProxyData, StartDevWorkerOptions } from \"../api\";\n import type { Config } from \"../config\";\n import type { Route } from \"../config/environment\";\n import type { Entry } from \"../deployment-bundle/entry\";\n@@ -32,6 +40,7 @@ import type { WorkerRegistry } from \"../dev-registry\";\n import type { EnablePagesAssetsServiceBindingOptions } from \"../miniflare-cli/types\";\n import type { EphemeralDirectory } from \"../paths\";\n import type { AssetPaths } from \"../sites\";\n+import type { EsbuildBundle } from \"./use-esbuild\";\n \n /**\n  * This hooks establishes a connection with the dev registry,\n@@ -157,7 +166,9 @@ export type DevProps = {\n \thost: string | undefined;\n \troutes: Route[] | undefined;\n \tinspect: boolean;\n-\tonReady: ((ip: string, port: number) => void) | undefined;\n+\tonReady:\n+\t\t| ((ip: string, port: number, proxyData: ProxyData) => void)\n+\t\t| undefined;\n \tshowInteractiveDevSession: boolean | undefined;\n \tforceLocal: boolean | undefined;\n \tenablePagesAssetsServiceBinding?: EnablePagesAssetsServiceBindingOptions;\n@@ -204,12 +215,12 @@ function InteractiveDevSession(props: DevProps) {\n \n \tuseTunnel(toggles.tunnel);\n \n-\tconst onReady = (newIp: string, newPort: number) => {\n+\tconst onReady = (newIp: string, newPort: number, proxyData: ProxyData) => {\n \t\tif (newIp !== props.initialIp || newPort !== props.initialPort) {\n \t\t\tip = newIp;\n \t\t\tport = newPort;\n \t\t\tif (props.onReady) {\n-\t\t\t\tprops.onReady(newIp, newPort);\n+\t\t\t\tprops.onReady(newIp, newPort, proxyData);\n \t\t\t}\n \t\t}\n \t};\n@@ -247,7 +258,60 @@ type DevSessionProps = DevProps & {\n };\n \n function DevSession(props: DevSessionProps) {\n-\tuseCustomBuild(props.entry, props.build);\n+\tconst [devEnv] = useState(() => new DevEnv());\n+\tuseEffect(() => {\n+\t\treturn () => {\n+\t\t\tvoid devEnv.teardown();\n+\t\t};\n+\t}, [devEnv]);\n+\tconst startDevWorkerOptions: StartDevWorkerOptions = useMemo(\n+\t\t() => ({\n+\t\t\tname: props.name ?? \"worker\",\n+\t\t\tscript: { contents: \"\" },\n+\t\t\tdev: {\n+\t\t\t\tserver: {\n+\t\t\t\t\thostname: props.initialIp,\n+\t\t\t\t\tport: props.initialPort,\n+\t\t\t\t\tsecure: props.localProtocol === \"https\",\n+\t\t\t\t},\n+\t\t\t\tinspector: {\n+\t\t\t\t\tport: props.inspectorPort,\n+\t\t\t\t},\n+\t\t\t\turlOverrides: {\n+\t\t\t\t\tsecure: props.localProtocol === \"https\",\n+\t\t\t\t\thostname: props.localUpstream,\n+\t\t\t\t},\n+\t\t\t\tliveReload: props.liveReload,\n+\t\t\t},\n+\t\t}),\n+\t\t[\n+\t\t\tprops.name,\n+\t\t\tprops.initialIp,\n+\t\t\tprops.initialPort,\n+\t\t\tprops.localProtocol,\n+\t\t\tprops.localUpstream,\n+\t\t\tprops.inspectorPort,\n+\t\t\tprops.liveReload,\n+\t\t]\n+\t);\n+\tconst onBundleStart = useCallback(() => {\n+\t\tdevEnv.proxy.onBundleStart({\n+\t\t\ttype: \"bundleStart\",\n+\t\t\tconfig: startDevWorkerOptions,\n+\t\t});\n+\t}, [devEnv, startDevWorkerOptions]);\n+\tconst onReloadStart = useCallback(\n+\t\t(bundle: EsbuildBundle) => {\n+\t\t\tdevEnv.proxy.onReloadStart({\n+\t\t\t\ttype: \"reloadStart\",\n+\t\t\t\tconfig: startDevWorkerOptions,\n+\t\t\t\tbundle,\n+\t\t\t});\n+\t\t},\n+\t\t[devEnv, startDevWorkerOptions]\n+\t);\n+\n+\tuseCustomBuild(props.entry, props.build, onBundleStart);\n \n \tconst directory = useTmpDir(props.projectRoot);\n \n@@ -257,6 +321,13 @@ function DevSession(props: DevSessionProps) {\n \t\tprops.bindings.durable_objects,\n \t\tprops.local ? \"local\" : \"remote\"\n \t);\n+\tuseEffect(() => {\n+\t\t// temp: fake these events by calling the handler directly\n+\t\tdevEnv.proxy.onConfigUpdate({\n+\t\t\ttype: \"configUpdate\",\n+\t\t\tconfig: startDevWorkerOptions,\n+\t\t});\n+\t}, [devEnv, startDevWorkerOptions]);\n \n \tconst bundle = useEsbuild({\n \t\tentry: props.entry,\n@@ -286,7 +357,11 @@ function DevSession(props: DevSessionProps) {\n \t\ttestScheduled: props.testScheduled ?? false,\n \t\texperimentalLocal: props.experimentalLocal,\n \t\tprojectRoot: props.projectRoot,\n+\t\tonBundleStart,\n \t});\n+\tuseEffect(() => {\n+\t\tif (bundle) onReloadStart(bundle);\n+\t}, [onReloadStart, bundle]);\n \n \t// TODO(queues) support remote wrangler dev\n \tif (\n@@ -298,7 +373,24 @@ function DevSession(props: DevSessionProps) {\n \t\t);\n \t}\n \n-\tconst announceAndOnReady: typeof props.onReady = (finalIp, finalPort) => {\n+\tif (props.local && props.bindings.hyperdrive?.length) {\n+\t\tlogger.warn(\n+\t\t\t\"Hyperdrive does not currently support 'wrangler dev' in local mode at this stage of the beta. Use the '--remote' flag to test a Hyperdrive configuration before deploying.\"\n+\t\t);\n+\t}\n+\n+\tconst announceAndOnReady: typeof props.onReady = async (\n+\t\tfinalIp,\n+\t\tfinalPort,\n+\t\tproxyData\n+\t) => {\n+\t\t// at this point (in the layers of onReady callbacks), we have devEnv in scope\n+\t\t// so rewrite the onReady params to be the ip/port of the ProxyWorker instead of the UserWorker\n+\t\tconst { proxyWorker } = await devEnv.proxy.ready.promise;\n+\t\tconst url = await proxyWorker.ready;\n+\t\tfinalIp = url.hostname;\n+\t\tfinalPort = parseInt(url.port);\n+\n \t\tif (process.send) {\n \t\t\tprocess.send(\n \t\t\t\tJSON.stringify({\n@@ -309,8 +401,17 @@ function DevSession(props: DevSessionProps) {\n \t\t\t);\n \t\t}\n \n+\t\tif (bundle) {\n+\t\t\tdevEnv.proxy.onReloadComplete({\n+\t\t\t\ttype: \"reloadComplete\",\n+\t\t\t\tconfig: startDevWorkerOptions,\n+\t\t\t\tbundle,\n+\t\t\t\tproxyData,\n+\t\t\t});\n+\t\t}\n+\n \t\tif (props.onReady) {\n-\t\t\tprops.onReady(finalIp, finalPort);\n+\t\t\tprops.onReady(finalIp, finalPort, proxyData);\n \t\t}\n \t};\n \n@@ -325,16 +426,16 @@ function DevSession(props: DevSessionProps) {\n \t\t\tbindings={props.bindings}\n \t\t\tworkerDefinitions={workerDefinitions}\n \t\t\tassetPaths={props.assetPaths}\n-\t\t\tinitialPort={props.initialPort}\n-\t\t\tinitialIp={props.initialIp}\n+\t\t\tinitialPort={undefined} // hard-code for userworker, DevEnv-ProxyWorker now uses this prop value\n+\t\t\tinitialIp={\"127.0.0.1\"} // hard-code for userworker, DevEnv-ProxyWorker now uses this prop value\n \t\t\trules={props.rules}\n \t\t\tinspectorPort={props.inspectorPort}\n \t\t\truntimeInspectorPort={props.runtimeInspectorPort}\n \t\t\tlocalPersistencePath={props.localPersistencePath}\n \t\t\tliveReload={props.liveReload}\n \t\t\tcrons={props.crons}\n \t\t\tqueueConsumers={props.queueConsumers}\n-\t\t\tlocalProtocol={props.localProtocol}\n+\t\t\tlocalProtocol={\"http\"} // hard-code for userworker, DevEnv-ProxyWorker now uses this prop value\n \t\t\tlocalUpstream={props.localUpstream}\n \t\t\tinspect={props.inspect}\n \t\t\tonReady={announceAndOnReady}\n@@ -392,7 +493,11 @@ function useTmpDir(projectRoot: string | undefined): string | undefined {\n \treturn directory;\n }\n \n-function useCustomBuild(expectedEntry: Entry, build: Config[\"build\"]): void {\n+function useCustomBuild(\n+\texpectedEntry: Entry,\n+\tbuild: Config[\"build\"],\n+\tonBundleStart: () => void\n+): void {\n \tuseEffect(() => {\n \t\tif (!build.command) return;\n \t\tlet watcher: ReturnType<typeof watch> | undefined;\n@@ -405,6 +510,7 @@ function useCustomBuild(expectedEntry: Entry, build: Config[\"build\"]): void {\n \t\t\t\t\tpath.relative(expectedEntry.directory, expectedEntry.file) || \".\";\n \t\t\t\t//TODO: we should buffer requests to the proxy until this completes\n \t\t\t\tlogger.log(`The file ${filePath} changed, restarting build...`);\n+\t\t\t\tonBundleStart();\n \t\t\t\trunCustomBuild(expectedEntry.file, relativeFile, build).catch((err) => {\n \t\t\t\t\tlogger.error(\"Custom build failed:\", err);\n \t\t\t\t});\n@@ -414,7 +520,7 @@ function useCustomBuild(expectedEntry: Entry, build: Config[\"build\"]): void {\n \t\treturn () => {\n \t\t\tvoid watcher?.close();\n \t\t};\n-\t}, [build, expectedEntry]);\n+\t}, [build, expectedEntry, onBundleStart]);\n }\n \n function sleep(period: number) {"
        },
        {
            "filename": "packages/wrangler/src/dev/inspect.ts",
            "diff": "@@ -1,617 +1,16 @@\n import { readFileSync } from \"fs\";\n-import assert from \"node:assert\";\n-import crypto from \"node:crypto\";\n-import { createServer } from \"node:http\";\n import os from \"node:os\";\n-import path from \"node:path\";\n-import { URL, fileURLToPath, pathToFileURL } from \"node:url\";\n+import { URL, fileURLToPath } from \"node:url\";\n+import path from \"path\";\n import open from \"open\";\n-import { useEffect, useRef, useState } from \"react\";\n-import WebSocket, { WebSocketServer } from \"ws\";\n-import { version } from \"../../package.json\";\n+import {\n+\tisAllowedSourceMapPath,\n+\tisAllowedSourcePath,\n+} from \"../api/startDevWorker/bundle-allowed-paths\";\n import { logger } from \"../logger\";\n-import { getSourceMappedStack } from \"../sourcemap\";\n-import { getAccessToken } from \"../user/access\";\n-import { waitForPortToBeAvailable } from \"./proxy\";\n-import type { SourceMapMetadata } from \"../deployment-bundle/bundle\";\n+import type { EsbuildBundle } from \"../dev/use-esbuild\";\n import type Protocol from \"devtools-protocol\";\n-import type { IncomingMessage, Server, ServerResponse } from \"node:http\";\n import type { RawSourceMap } from \"source-map\";\n-import type { MessageEvent } from \"ws\";\n-\n-/**\n- * `useInspector` is a hook for debugging Workers applications\n- *  when using `wrangler dev`.\n- *\n- * When we start a session with `wrangler dev`, the Workers platform\n- * also exposes a debugging websocket that implements the DevTools\n- * Protocol. While we could just start up DevTools and connect to this\n- * URL, that URL changes every time we make a change to the\n- * worker, or when the session expires. Instead, we start up a proxy\n- * server locally that acts as a bridge between the remote DevTools\n- * server and the local DevTools instance. So whenever the URL changes,\n- * we can can silently connect to it and keep the local DevTools instance\n- * up to date. Further, we also intercept these messages and selectively\n- * log them directly to the terminal (namely, calls to `console.<x>`,\n- * and exceptions)\n- */\n-\n-// TODO:\n-// - clear devtools whenever we save changes to the worker\n-// - clear devtools when we switch between local/remote modes\n-// - handle more methods from console\n-\n-interface InspectorProps {\n-\t/**\n-\t * The port that the local proxy server should listen on.\n-\t */\n-\tport: number;\n-\t/**\n-\t * The websocket URL exposed by Workers that the inspector should connect to.\n-\t */\n-\tinspectorUrl: string | undefined;\n-\t/**\n-\t * Whether console statements and exceptions should be logged to the terminal.\n-\t * (We don't log them in local mode because they're already getting\n-\t * logged to the terminal by nature of them actually running in node locally.)\n-\t */\n-\tlogToTerminal: boolean;\n-\t/**\n-\t * Sourcemap path, so that stacktraces can be interpretted\n-\t */\n-\tsourceMapPath: string | undefined;\n-\n-\tsourceMapMetadata: SourceMapMetadata | undefined;\n-\n-\thost?: string;\n-\n-\tname?: string;\n-}\n-\n-type LocalWebSocket = WebSocket & { isDevTools?: boolean };\n-\n-export default function useInspector(props: InspectorProps) {\n-\t/** A unique ID for this session. */\n-\tconst inspectorIdRef = useRef(crypto.randomUUID());\n-\n-\t/** The websocket from the devtools instance. */\n-\tconst [localWebSocket, setLocalWebSocket] = useState<LocalWebSocket>();\n-\t/**  The websocket from the edge */\n-\tconst [remoteWebSocket, setRemoteWebSocket] = useState<WebSocket>();\n-\n-\t/**\n-\t * Source maps included in `Debugger.scriptParsed` events sent by the current\n-\t * `remoteWebSocket`. Each source map is given a unique ID which must be\n-\t * included when fetching the source map to prevent arbitrary file access.\n-\t * We assume each `Debugger.scriptParsed` event will trigger a single fetch\n-\t * for the corresponding source map, so remove source maps after they've been\n-\t * fetched once.\n-\t */\n-\tconst sourceMaps = useRef<Map<string /* id */, string /* filePath */>>();\n-\tsourceMaps.current ??= new Map();\n-\t/**\n-\t * For source maps without `sourcesContent`, DevTools will request the\n-\t * contents of source files too. Again, we'd like to prevent arbitrary file\n-\t * access here, so only allow fetching sources if we've seen the path\n-\t * when responding with a source map. We again assume each source will be\n-\t * fetched once, so remove allowed sources after fetch.\n-\t */\n-\tconst allowedSourcePaths = useRef<Set<string /* filePath */>>();\n-\tallowedSourcePaths.current ??= new Set();\n-\n-\t/**\n-\t *  The local proxy server that acts as the bridge between\n-\t *  the remote websocket and the local DevTools instance.\n-\t */\n-\tconst serverRef = useRef<Server>();\n-\tif (serverRef.current === undefined) {\n-\t\tserverRef.current = createServer(\n-\t\t\t(req: IncomingMessage, res: ServerResponse) => {\n-\t\t\t\tswitch (req.url) {\n-\t\t\t\t\t// We implement a couple of well known end points\n-\t\t\t\t\t// that are queried for metadata by chrome://inspect\n-\t\t\t\t\tcase \"/json/version\":\n-\t\t\t\t\t\tres.setHeader(\"Content-Type\", \"application/json\");\n-\t\t\t\t\t\tres.end(\n-\t\t\t\t\t\t\tJSON.stringify({\n-\t\t\t\t\t\t\t\tBrowser: `wrangler/v${version}`,\n-\t\t\t\t\t\t\t\t// TODO: (someday): The DevTools protocol should match that of Edge Worker.\n-\t\t\t\t\t\t\t\t// This could be exposed by the preview API.\n-\t\t\t\t\t\t\t\t\"Protocol-Version\": \"1.3\",\n-\t\t\t\t\t\t\t})\n-\t\t\t\t\t\t);\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\tcase \"/json\":\n-\t\t\t\t\tcase \"/json/list\":\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tres.setHeader(\"Content-Type\", \"application/json\");\n-\t\t\t\t\t\t\tconst localHost = `127.0.0.1:${props.port}/ws`;\n-\t\t\t\t\t\t\tconst devtoolsFrontendUrl = `devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws=${localHost}`;\n-\t\t\t\t\t\t\tconst devtoolsFrontendUrlCompat = `devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=${localHost}`;\n-\t\t\t\t\t\t\tres.end(\n-\t\t\t\t\t\t\t\tJSON.stringify([\n-\t\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t\tid: inspectorIdRef.current,\n-\t\t\t\t\t\t\t\t\t\ttype: \"node\",\n-\t\t\t\t\t\t\t\t\t\tdescription: \"workers\",\n-\t\t\t\t\t\t\t\t\t\twebSocketDebuggerUrl: `ws://${localHost}`,\n-\t\t\t\t\t\t\t\t\t\tdevtoolsFrontendUrl,\n-\t\t\t\t\t\t\t\t\t\tdevtoolsFrontendUrlCompat,\n-\t\t\t\t\t\t\t\t\t\t// Below are fields that are visible in the DevTools UI.\n-\t\t\t\t\t\t\t\t\t\ttitle: \"Cloudflare Worker\",\n-\t\t\t\t\t\t\t\t\t\tfaviconUrl: \"https://workers.cloudflare.com/favicon.ico\",\n-\t\t\t\t\t\t\t\t\t\turl:\n-\t\t\t\t\t\t\t\t\t\t\t\"https://\" +\n-\t\t\t\t\t\t\t\t\t\t\t(remoteWebSocket\n-\t\t\t\t\t\t\t\t\t\t\t\t? new URL(remoteWebSocket.url).host\n-\t\t\t\t\t\t\t\t\t\t\t\t: \"workers.dev\"),\n-\t\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\t])\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\tdefault:\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t);\n-\t}\n-\tconst server = serverRef.current;\n-\n-\t/**\n-\t * The websocket server that runs on top of the proxy server.\n-\t */\n-\tconst wsServerRef = useRef<WebSocketServer>();\n-\tif (wsServerRef.current === undefined) {\n-\t\twsServerRef.current = new WebSocketServer({\n-\t\t\tserver,\n-\t\t\tclientTracking: true,\n-\t\t});\n-\t}\n-\tconst wsServer = wsServerRef.current;\n-\n-\twsServer.on(\"connection\", (ws, req) => {\n-\t\tif (wsServer.clients.size > 1) {\n-\t\t\t/** We only want to have one active Devtools instance at a time. */\n-\t\t\tlogger.error(\n-\t\t\t\t\"Tried to open a new devtools window when a previous one was already open.\"\n-\t\t\t);\n-\t\t\tws.close(1013, \"Too many clients; only one can be connected at a time\");\n-\t\t} else {\n-\t\t\t// Since Wrangler proxies the inspector, reloading Chrome DevTools won't trigger debugger initialisation events (because it's connecting to an extant session).\n-\t\t\t// This sends a `Debugger.disable` message to the remote when a new WebSocket connection is initialised,\n-\t\t\t// with the assumption that the new connection will shortly send a `Debugger.enable` event and trigger re-initialisation.\n-\t\t\t// The key initialisation messages that are needed are the `Debugger.scriptParsed events`.\n-\t\t\tremoteWebSocket?.send(\n-\t\t\t\tJSON.stringify({\n-\t\t\t\t\t// This number is arbitrary, and is chosen to be high so as not to conflict with messages that DevTools might actually send.\n-\t\t\t\t\t// For completeness, these options don't work: 0, -1, or Number.MAX_SAFE_INTEGER\n-\t\t\t\t\tid: 100_000_000,\n-\t\t\t\t\tmethod: \"Debugger.disable\",\n-\t\t\t\t})\n-\t\t\t);\n-\n-\t\t\t// Our patched DevTools are hosted on a `https://` URL. These cannot\n-\t\t\t// access `file://` URLs, meaning local source maps cannot be fetched.\n-\t\t\t// To get around this, we can rewrite `Debugger.scriptParsed` events to\n-\t\t\t// include a special `worker:` scheme for source maps, and respond to\n-\t\t\t// `Network.loadNetworkResource` commands for these. Unfortunately, this\n-\t\t\t// breaks IDE's built-in debuggers (e.g. VSCode and WebStorm), so we only\n-\t\t\t// want to enable this transformation when we detect hosted DevTools has\n-\t\t\t// connected. We do this by looking at the WebSocket handshake headers:\n-\t\t\t//\n-\t\t\t// # DevTools\n-\t\t\t//\n-\t\t\t// Upgrade: websocket\n-\t\t\t// Host: localhost:9229\n-\t\t\t// (from Chrome)  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36\n-\t\t\t// (from Firefox) User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/116.0\n-\t\t\t// Origin: https://devtools.devprod.cloudflare.dev\n-\t\t\t// ...\n-\t\t\t//\n-\t\t\t// # VSCode\n-\t\t\t//\n-\t\t\t// Upgrade: websocket\n-\t\t\t// Host: localhost\n-\t\t\t// ...\n-\t\t\t//\n-\t\t\t// # WebStorm\n-\t\t\t//\n-\t\t\t// Upgrade: websocket\n-\t\t\t// Host: localhost:9229\n-\t\t\t// Origin: http://localhost:9229\n-\t\t\t// ...\n-\t\t\t//\n-\t\t\t// From this, we could just use the presence of a `User-Agent` header to\n-\t\t\t// determine if DevTools connected, but VSCode/WebStorm could very well\n-\t\t\t// add this in future versions. We could also look for an `Origin` header\n-\t\t\t// matching the hosted DevTools URL, but this would prevent preview/local\n-\t\t\t// versions working. Instead, we look for a browser-like `User-Agent`.\n-\t\t\tconst localWs: LocalWebSocket = ws;\n-\t\t\tlocalWs.isDevTools = /mozilla/i.test(req.headers[\"user-agent\"] ?? \"\");\n-\n-\t\t\t// As promised, save the created websocket in a state hook\n-\t\t\tsetLocalWebSocket(localWs);\n-\n-\t\t\tws.addEventListener(\"close\", () => {\n-\t\t\t\t// And cleanup when devtools closes\n-\t\t\t\tsetLocalWebSocket(undefined);\n-\t\t\t});\n-\t\t}\n-\t});\n-\n-\t/**\n-\t * We start and stop the server in an effect to take advantage\n-\t * of the component lifecycle. Convenient.\n-\t */\n-\tuseEffect(() => {\n-\t\tconst abortController = new AbortController();\n-\t\tasync function startInspectorProxy() {\n-\t\t\tawait waitForPortToBeAvailable(props.port, {\n-\t\t\t\tretryPeriod: 200,\n-\t\t\t\ttimeout: 2000,\n-\t\t\t\tabortSignal: abortController.signal,\n-\t\t\t});\n-\t\t\tserver.listen(props.port, \"127.0.0.1\");\n-\t\t}\n-\t\tstartInspectorProxy().catch((err) => {\n-\t\t\tif ((err as { code: string }).code !== \"ABORT_ERR\") {\n-\t\t\t\tlogger.error(\"Failed to start inspector:\", err);\n-\t\t\t}\n-\t\t});\n-\t\treturn () => {\n-\t\t\tserver.close();\n-\t\t\t// Also disconnect any open websockets/devtools connections\n-\t\t\twsServer.clients.forEach((ws) => ws.close());\n-\t\t\twsServer.close();\n-\t\t\tabortController.abort();\n-\t\t};\n-\t}, [props.port, server, wsServer]);\n-\n-\t/**\n-\t * When connecting to the remote websocket, if we don't start either\n-\t * the devtools instance or make an actual request to the worker in time,\n-\t * then the connecting process can error out. When this happens, we\n-\t * want to simply retry the connection. We use a state hook to trigger retries\n-\t * of the effect that connects to the remote websocket.\n-\t */\n-\tconst [\n-\t\tretryRemoteWebSocketConnectionSigil,\n-\t\tsetRetryRemoteWebSocketConnectionSigil,\n-\t] = useState<number>(0);\n-\tfunction retryRemoteWebSocketConnection() {\n-\t\tsetRetryRemoteWebSocketConnectionSigil((x) => x + 1);\n-\t}\n-\n-\t/** A simple incrementing id to attach to messages we send to devtools */\n-\tconst messageCounterRef = useRef(1);\n-\n-\tconst cfAccessRef = useRef<string>();\n-\n-\tuseEffect(() => {\n-\t\tconst run = async () => {\n-\t\t\tif (props.host && !cfAccessRef.current) {\n-\t\t\t\tconst token = await getAccessToken(props.host);\n-\t\t\t\tcfAccessRef.current = token;\n-\t\t\t}\n-\t\t};\n-\t\tif (props.host) void run();\n-\t}, [props.host]);\n-\n-\t// This effect tracks the connection to the remote websocket\n-\t// (stored in, no surprises here, `remoteWebSocket`)\n-\tuseEffect(() => {\n-\t\tif (!props.inspectorUrl) {\n-\t\t\treturn;\n-\t\t}\n-\n-\t\t// The actual websocket instance\n-\t\tconst ws = new WebSocket(props.inspectorUrl, {\n-\t\t\theaders: {\n-\t\t\t\tcookie: `CF_Authorization=${cfAccessRef.current}`,\n-\t\t\t},\n-\t\t});\n-\t\tsetRemoteWebSocket(ws);\n-\n-\t\t/**\n-\t\t * A handle to the interval we run to keep the websocket alive\n-\t\t */\n-\t\tlet keepAliveInterval: NodeJS.Timer;\n-\n-\t\t/**\n-\t\t * Test if the websocket is closed\n-\t\t */\n-\t\tfunction isClosed() {\n-\t\t\treturn (\n-\t\t\t\tws.readyState === WebSocket.CLOSED ||\n-\t\t\t\tws.readyState === WebSocket.CLOSING\n-\t\t\t);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Send a message to the remote websocket\n-\t\t */\n-\t\tfunction send(event: Record<string, unknown>): void {\n-\t\t\tif (!isClosed()) {\n-\t\t\t\tws.send(JSON.stringify(event));\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * Closes the inspector.\n-\t\t */\n-\t\tfunction close(): void {\n-\t\t\tif (!isClosed()) {\n-\t\t\t\tsend({\n-\t\t\t\t\tmethod: \"Runtime.discardConsoleEntries\",\n-\t\t\t\t\tid: messageCounterRef.current++,\n-\t\t\t\t});\n-\t\t\t\ttry {\n-\t\t\t\t\tws.close();\n-\t\t\t\t} catch (err) {\n-\t\t\t\t\t// Closing before the websocket is ready will throw an error.\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t/**\n-\t\t * Since we have a handle on the remote websocket, we can tap\n-\t\t * into its events, and log any pertinent ones directly to\n-\t\t * the terminal (which means you have insight into your worker\n-\t\t * without having to open the devtools).\n-\t\t */\n-\t\tif (props.logToTerminal) {\n-\t\t\tws.addEventListener(\"message\", async (event: MessageEvent) => {\n-\t\t\t\tif (typeof event.data === \"string\") {\n-\t\t\t\t\tconst evt = JSON.parse(event.data);\n-\t\t\t\t\tif (evt.method === \"Runtime.exceptionThrown\") {\n-\t\t\t\t\t\tconst params = evt.params as Protocol.Runtime.ExceptionThrownEvent;\n-\t\t\t\t\t\tconst stack = getSourceMappedStack(params.exceptionDetails);\n-\t\t\t\t\t\tlogger.error(params.exceptionDetails.text, stack);\n-\t\t\t\t\t}\n-\t\t\t\t\tif (evt.method === \"Runtime.consoleAPICalled\") {\n-\t\t\t\t\t\tlogConsoleMessage(\n-\t\t\t\t\t\t\tevt.params as Protocol.Runtime.ConsoleAPICalledEvent\n-\t\t\t\t\t\t);\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\t// We should never get here, but who know is 2022...\n-\t\t\t\t\tlogger.error(\"Unrecognised devtools event:\", event);\n-\t\t\t\t}\n-\t\t\t});\n-\t\t}\n-\n-\t\tws.addEventListener(\"open\", () => {\n-\t\t\tsend({ method: \"Runtime.enable\", id: messageCounterRef.current++ });\n-\t\t\t// TODO: This doesn't actually work. Must fix.\n-\t\t\tsend({ method: \"Network.enable\", id: messageCounterRef.current++ });\n-\n-\t\t\tkeepAliveInterval = setInterval(() => {\n-\t\t\t\tsend({\n-\t\t\t\t\tmethod: \"Runtime.getIsolateId\",\n-\t\t\t\t\tid: messageCounterRef.current++,\n-\t\t\t\t});\n-\t\t\t}, 10_000);\n-\t\t});\n-\n-\t\tws.on(\"unexpected-response\", () => {\n-\t\t\tlogger.log(\"Waiting for connection...\");\n-\t\t\t/**\n-\t\t\t * This usually means the worker is not \"ready\" yet\n-\t\t\t * so we'll just retry the connection process\n-\t\t\t */\n-\t\t\tretryRemoteWebSocketConnection();\n-\t\t});\n-\n-\t\tws.addEventListener(\"close\", () => {\n-\t\t\tclearInterval(keepAliveInterval);\n-\t\t});\n-\n-\t\treturn () => {\n-\t\t\t// clean up! Let's first stop the heartbeat interval\n-\t\t\tclearInterval(keepAliveInterval);\n-\t\t\t// Then we'll send a message to the devtools instance to\n-\t\t\t// tell it to clear the console.\n-\t\t\twsServer.clients.forEach((client) => {\n-\t\t\t\t// We could've used `localSocket` here, but\n-\t\t\t\t// then we would have had to add it to the effect\n-\t\t\t\t// change detection array, which would have made a\n-\t\t\t\t// bunch of other stuff complicated. So we'll just\n-\t\t\t\t// cycle through all of the server's connected clients\n-\t\t\t\t// (in practice, there should only be one or zero) and send\n-\t\t\t\t// the Log.clear message.\n-\t\t\t\tclient.send(\n-\t\t\t\t\tJSON.stringify({\n-\t\t\t\t\t\t// TODO: This doesn't actually work. Must fix.\n-\t\t\t\t\t\tmethod: \"Log.clear\",\n-\t\t\t\t\t\t// we can disable the next eslint warning since\n-\t\t\t\t\t\t// we're referencing a ref that stays alive\n-\t\t\t\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n-\t\t\t\t\t\tid: messageCounterRef.current++,\n-\t\t\t\t\t\tparams: {},\n-\t\t\t\t\t})\n-\t\t\t\t);\n-\t\t\t});\n-\t\t\t// Finally, we'll close the websocket\n-\t\t\tclose();\n-\t\t\t// And we'll clear `remoteWebsocket`\n-\t\t\tsetRemoteWebSocket(undefined);\n-\t\t};\n-\t}, [\n-\t\tprops.inspectorUrl,\n-\t\tprops.logToTerminal,\n-\t\tprops.sourceMapPath,\n-\t\twsServer,\n-\t\t// We use a state value as a sigil to trigger a retry of the\n-\t\t// remote websocket connection. It's not used inside the effect,\n-\t\t// so react-hooks/exhaustive-deps doesn't complain if it's not\n-\t\t// included in the dependency array. But its presence is critical,\n-\t\t// so do NOT remove it from the dependency list.\n-\t\tretryRemoteWebSocketConnectionSigil,\n-\t]);\n-\n-\t/**\n-\t * We want to make sure we don't lose any messages we receive from the\n-\t * remote websocket before devtools connects. So we use a ref to buffer\n-\t * messages, and flush them whenever devtools connects.\n-\t */\n-\tconst messageBufferRef = useRef<MessageEvent[]>([]);\n-\n-\t// This effect tracks the state changes _between_ the local\n-\t// and remote websockets, and handles how messages flow between them.\n-\tuseEffect(() => {\n-\t\t/**\n-\t\t * This event listener is used for buffering messages from\n-\t\t * the remote websocket, and flushing them\n-\t\t * when the local websocket connects.\n-\t\t */\n-\t\tfunction bufferMessageFromRemoteSocket(event: MessageEvent) {\n-\t\t\tmessageBufferRef.current.push(event);\n-\t\t\t// TODO: maybe we should have a max limit on this?\n-\t\t\t// if so, we should be careful when removing messages\n-\t\t\t// from the front, because they could be critical for\n-\t\t\t// devtools (like execution context creation, etc)\n-\t\t}\n-\n-\t\tif (remoteWebSocket && !localWebSocket) {\n-\t\t\t// The local websocket hasn't connected yet, so we'll\n-\t\t\t// buffer messages until it does.\n-\t\t\tremoteWebSocket.addEventListener(\n-\t\t\t\t\"message\",\n-\t\t\t\tbufferMessageFromRemoteSocket\n-\t\t\t);\n-\t\t}\n-\n-\t\t/** Send a message from the local websocket to the remote websocket */\n-\t\tfunction sendMessageToRemoteWebSocket(event: MessageEvent) {\n-\t\t\ttry {\n-\t\t\t\t// Intercept Network.loadNetworkResource to load sourcemaps\n-\t\t\t\tconst message = JSON.parse(event.data as string);\n-\t\t\t\tif (message.method === \"Network.loadNetworkResource\") {\n-\t\t\t\t\t// `sourceMaps.current` and `allowSourcePaths.current` are always\n-\t\t\t\t\t// defined after `useRef()`\n-\t\t\t\t\tassert(sourceMaps.current !== undefined);\n-\t\t\t\t\tassert(allowedSourcePaths.current !== undefined);\n-\t\t\t\t\tconst maybeText = maybeHandleNetworkLoadResource(\n-\t\t\t\t\t\tmessage.params.url,\n-\t\t\t\t\t\tsourceMaps.current,\n-\t\t\t\t\t\tallowedSourcePaths.current,\n-\t\t\t\t\t\tprops.sourceMapMetadata?.tmpDir\n-\t\t\t\t\t);\n-\t\t\t\t\tif (maybeText !== undefined) {\n-\t\t\t\t\t\tsendMessageToLocalWebSocket({\n-\t\t\t\t\t\t\tdata: JSON.stringify({\n-\t\t\t\t\t\t\t\tid: message.id,\n-\t\t\t\t\t\t\t\tresult: { resource: { success: true, text: maybeText } },\n-\t\t\t\t\t\t\t}),\n-\t\t\t\t\t\t});\n-\t\t\t\t\t\treturn;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (e) {\n-\t\t\t\tlogger.debug(e);\n-\t\t\t\t// Ignore errors, fallthrough to the remote inspector\n-\t\t\t}\n-\t\t\ttry {\n-\t\t\t\tassert(\n-\t\t\t\t\tremoteWebSocket,\n-\t\t\t\t\t\"Trying to send a message to an undefined `remoteWebSocket`\"\n-\t\t\t\t);\n-\t\t\t\tremoteWebSocket.send(event.data);\n-\t\t\t} catch (e) {\n-\t\t\t\tif (\n-\t\t\t\t\t(e as Error).message !==\n-\t\t\t\t\t\"WebSocket is not open: readyState 0 (CONNECTING)\"\n-\t\t\t\t) {\n-\t\t\t\t\t/**\n-\t\t\t\t\t * ^ this just means we haven't opened a websocket yet\n-\t\t\t\t\t * usually happens until there's at least one request\n-\t\t\t\t\t * which is weird, because we may miss something that\n-\t\t\t\t\t * happens on the first request. Maybe we should buffer\n-\t\t\t\t\t * these messages too?\n-\t\t\t\t\t */\n-\t\t\t\t\tlogger.error(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n-\t\t/** Send a message from the local websocket to the remote websocket */\n-\t\tfunction sendMessageToLocalWebSocket(event: Pick<MessageEvent, \"data\">) {\n-\t\t\tassert(\n-\t\t\t\tlocalWebSocket,\n-\t\t\t\t\"Trying to send a message to an undefined `localWebSocket`\"\n-\t\t\t);\n-\t\t\ttry {\n-\t\t\t\t// Intercept Debugger.scriptParsed responses to inject URL schemes\n-\t\t\t\tif (localWebSocket.isDevTools) {\n-\t\t\t\t\tconst message = JSON.parse(event.data as string);\n-\t\t\t\t\tif (message.method === \"Debugger.scriptParsed\") {\n-\t\t\t\t\t\tif (message.params.sourceMapURL) {\n-\t\t\t\t\t\t\tconst url = new URL(\n-\t\t\t\t\t\t\t\tmessage.params.sourceMapURL,\n-\t\t\t\t\t\t\t\tmessage.params.url\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\tif (url.protocol === \"file:\") {\n-\t\t\t\t\t\t\t\t// `sourceMaps.current` is always defined after `useRef()`\n-\t\t\t\t\t\t\t\tassert(sourceMaps.current !== undefined);\n-\t\t\t\t\t\t\t\tconst name = props.name ?? \"worker\";\n-\t\t\t\t\t\t\t\tconst id = crypto.randomUUID();\n-\t\t\t\t\t\t\t\tsourceMaps.current.set(id, fileURLToPath(url));\n-\t\t\t\t\t\t\t\t// The hostname of this URL will show up next to the cloud icon\n-\t\t\t\t\t\t\t\t// under authored sources, so use the worker name.\n-\t\t\t\t\t\t\t\tmessage.params.sourceMapURL = `worker://${name}/${id}`;\n-\t\t\t\t\t\t\t\tlocalWebSocket.send(JSON.stringify(message));\n-\t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t} catch (e) {\n-\t\t\t\tlogger.debug(e);\n-\t\t\t\t// Ignore errors, fallthrough to the local websocket\n-\t\t\t}\n-\n-\t\t\tlocalWebSocket.send(event.data);\n-\t\t}\n-\n-\t\tif (localWebSocket && remoteWebSocket) {\n-\t\t\t// Both the remote and local websockets are connected, so let's\n-\t\t\t// start sending messages between them.\n-\t\t\tlocalWebSocket.addEventListener(\"message\", sendMessageToRemoteWebSocket);\n-\t\t\tremoteWebSocket.addEventListener(\"message\", sendMessageToLocalWebSocket);\n-\n-\t\t\t// Also, let's flush any buffered messages\n-\t\t\tmessageBufferRef.current.forEach(sendMessageToLocalWebSocket);\n-\t\t\tmessageBufferRef.current = [];\n-\t\t}\n-\n-\t\treturn () => {\n-\t\t\t// Cleanup like good citizens\n-\t\t\tif (remoteWebSocket) {\n-\t\t\t\tremoteWebSocket.removeEventListener(\n-\t\t\t\t\t\"message\",\n-\t\t\t\t\tbufferMessageFromRemoteSocket\n-\t\t\t\t);\n-\t\t\t\tremoteWebSocket.removeEventListener(\n-\t\t\t\t\t\"message\",\n-\t\t\t\t\tsendMessageToLocalWebSocket\n-\t\t\t\t);\n-\t\t\t}\n-\t\t\tif (localWebSocket) {\n-\t\t\t\tlocalWebSocket.removeEventListener(\n-\t\t\t\t\t\"message\",\n-\t\t\t\t\tsendMessageToRemoteWebSocket\n-\t\t\t\t);\n-\t\t\t}\n-\t\t};\n-\t}, [\n-\t\tlocalWebSocket,\n-\t\tremoteWebSocket,\n-\t\tprops.name,\n-\t\tprops.sourceMapMetadata,\n-\t\tprops.sourceMapPath,\n-\t]);\n-}\n \n /**\n  * This function converts a message serialized as a devtools event\n@@ -646,7 +45,9 @@ const mapConsoleAPIMessageTypeToConsoleMethod: {\n \tendGroup: \"groupEnd\",\n };\n \n-function logConsoleMessage(evt: Protocol.Runtime.ConsoleAPICalledEvent): void {\n+export function logConsoleMessage(\n+\tevt: Protocol.Runtime.ConsoleAPICalledEvent\n+): void {\n \tconst args: string[] = [];\n \tfor (const ro of evt.args) {\n \t\tswitch (ro.type) {\n@@ -786,28 +187,20 @@ function logConsoleMessage(evt: Protocol.Runtime.ConsoleAPICalledEvent): void {\n \t}\n }\n \n-function maybeHandleNetworkLoadResource(\n+export function maybeHandleNetworkLoadResource(\n \turl: string | URL,\n-\tsourceMaps: Map<string /* id */, string /* filePath */>,\n-\tallowedSourcePaths: Set<string /* filePath */>,\n+\tbundle: EsbuildBundle,\n \ttmpDir?: string\n ): string | undefined {\n \tif (typeof url === \"string\") url = new URL(url);\n-\tif (url.protocol !== \"worker:\") return;\n-\n-\t// Check whether we have a source map matching this ID...\n-\tconst id = url.pathname.substring(1);\n-\tconst maybeSourceMapFilePath = sourceMaps.get(id);\n-\tif (maybeSourceMapFilePath !== undefined) {\n-\t\t// Assume DevTools fetches each source map once (after receipt of the\n-\t\t// `Debugger.scriptParsed` event), and remove it from the map to prevent\n-\t\t// unbounded growth.\n-\t\tsourceMaps.delete(id);\n+\tif (url.protocol !== \"file:\") return;\n+\tconst filePath = fileURLToPath(url);\n \n+\tif (isAllowedSourceMapPath(bundle, filePath)) {\n \t\t// Read and parse the source map\n \t\tconst sourceMap: RawSourceMap & {\n \t\t\tx_google_ignoreList?: number[];\n-\t\t} = JSON.parse(readFileSync(maybeSourceMapFilePath, \"utf-8\"));\n+\t\t} = JSON.parse(readFileSync(filePath, \"utf-8\"));\n \n \t\t// See https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.mt2g20loc2ct\n \t\t// The above link documents the `x_google_ignoreList property`, which is\n@@ -827,28 +220,10 @@ function maybeHandleNetworkLoadResource(\n \t\t\t})\n \t\t\t.filter((i): i is number => i !== undefined);\n \n-\t\t// If this source map doesn't have inline sources, DevTools will attempt to\n-\t\t// make requests for them, so add all sources paths in this map to the\n-\t\t// allowed set.\n-\t\tif (!sourceMap.sourcesContent) {\n-\t\t\tconst fileURL = pathToFileURL(maybeSourceMapFilePath);\n-\t\t\tfor (const source of sourceMap.sources) {\n-\t\t\t\tconst sourcePath = fileURLToPath(new URL(source, fileURL));\n-\t\t\t\tallowedSourcePaths.add(sourcePath);\n-\t\t\t}\n-\t\t}\n-\n \t\treturn JSON.stringify(sourceMap);\n \t}\n \n-\t// Otherwise, assume this is a request for a source file. Resolve the ID\n-\t// relative to the current working directory, and check if this is allowed.\n-\tconst filePath = path.resolve(id);\n-\tif (allowedSourcePaths.has(filePath)) {\n-\t\t// Assume DevTools fetches each source once (after receipt of the\n-\t\t// `Network.loadNetworkResource` command response for the source map), and\n-\t\t// remove it from the set to prevent unbounded growth.\n-\t\tallowedSourcePaths.delete(filePath);\n+\tif (isAllowedSourcePath(bundle, filePath)) {\n \t\treturn readFileSync(filePath, \"utf-8\");\n \t}\n }"
        },
        {
            "filename": "packages/wrangler/src/dev/local.tsx",
            "diff": "@@ -1,12 +1,12 @@\n import assert from \"node:assert\";\n import chalk from \"chalk\";\n-import { useEffect, useRef, useState } from \"react\";\n+import { useEffect, useRef } from \"react\";\n import onExit from \"signal-exit\";\n-import { fetch } from \"undici\";\n import { registerWorker } from \"../dev-registry\";\n import { logger } from \"../logger\";\n-import useInspector from \"./inspect\";\n import { MiniflareServer } from \"./miniflare\";\n+import { DEFAULT_WORKER_NAME } from \"./miniflare\";\n+import type { ProxyData } from \"../api\";\n import type { Config } from \"../config\";\n import type { CfWorkerInit, CfScriptFormat } from \"../deployment-bundle/worker\";\n import type { WorkerRegistry } from \"../dev-registry\";\n@@ -25,7 +25,7 @@ export interface LocalProps {\n \tbindings: CfWorkerInit[\"bindings\"];\n \tworkerDefinitions: WorkerRegistry | undefined;\n \tassetPaths: AssetPaths | undefined;\n-\tinitialPort: number;\n+\tinitialPort: number | undefined;\n \tinitialIp: string;\n \trules: Config[\"rules\"];\n \tinspectorPort: number;\n@@ -37,7 +37,9 @@ export interface LocalProps {\n \tlocalProtocol: \"http\" | \"https\";\n \tlocalUpstream: string | undefined;\n \tinspect: boolean;\n-\tonReady: ((ip: string, port: number) => void) | undefined;\n+\tonReady:\n+\t\t| ((ip: string, port: number, proxyData: ProxyData) => void)\n+\t\t| undefined;\n \tenablePagesAssetsServiceBinding?: EnablePagesAssetsServiceBindingOptions;\n \ttestScheduled?: boolean;\n \tsourceMapPath: string | undefined;\n@@ -115,36 +117,15 @@ export function maybeRegisterLocalWorker(event: ReloadedEvent, name?: string) {\n \t});\n }\n \n-// https://chromedevtools.github.io/devtools-protocol/#endpoints\n-interface InspectorWebSocketTarget {\n-\tid: string;\n-\ttitle: string;\n-\ttype: \"node\";\n-\tdescription: string;\n-\twebSocketDebuggerUrl: string;\n-\tdevtoolsFrontendUrl: string;\n-\tdevtoolsFrontendUrlCompat: string;\n-\tfaviconUrl: string;\n-\turl: string;\n-}\n-\n export function Local(props: LocalProps) {\n-\tconst { inspectorUrl } = useLocalWorker(props);\n-\tuseInspector({\n-\t\tinspectorUrl,\n-\t\tport: props.inspectorPort,\n-\t\tlogToTerminal: props.bundle?.entry.format === \"service-worker\",\n-\t\tsourceMapPath: props.sourceMapPath,\n-\t\tname: props.name,\n-\t\tsourceMapMetadata: props.bundle?.sourceMapMetadata,\n-\t});\n+\tuseLocalWorker(props);\n+\n \treturn null;\n }\n \n function useLocalWorker(props: LocalProps) {\n \tconst miniflareServerRef = useRef<MiniflareServer>();\n \tconst removeMiniflareServerExitListenerRef = useRef<() => void>();\n-\tconst [inspectorUrl, setInspectorUrl] = useState<string | undefined>();\n \n \tuseEffect(() => {\n \t\tif (props.bindings.services && props.bindings.services.length > 0) {\n@@ -177,33 +158,36 @@ function useLocalWorker(props: LocalProps) {\n \t\t\tminiflareServerRef.current = server = newServer;\n \t\t\tserver.addEventListener(\"reloaded\", async (event) => {\n \t\t\t\tawait maybeRegisterLocalWorker(event, props.name);\n-\t\t\t\tprops.onReady?.(event.url.hostname, parseInt(event.url.port));\n \n-\t\t\t\ttry {\n-\t\t\t\t\t// Fetch the inspector JSON response from the DevTools Inspector protocol\n-\t\t\t\t\tconst jsonUrl = `http://127.0.0.1:${props.runtimeInspectorPort}/json`;\n-\t\t\t\t\tconst res = await fetch(jsonUrl);\n-\t\t\t\t\tconst body = (await res.json()) as InspectorWebSocketTarget[];\n-\t\t\t\t\tconst debuggerUrl = body?.find(({ id }) =>\n-\t\t\t\t\t\tid.startsWith(\"core:user\")\n-\t\t\t\t\t)?.webSocketDebuggerUrl;\n-\t\t\t\t\tif (debuggerUrl === undefined) {\n-\t\t\t\t\t\tsetInspectorUrl(undefined);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tconst url = new URL(debuggerUrl);\n-\t\t\t\t\t\t// Force inspector URL to be different on each reload so `useEffect`\n-\t\t\t\t\t\t// in `useInspector` is re-run to connect to newly restarted\n-\t\t\t\t\t\t// `workerd` server when updating options. Can't use a query param\n-\t\t\t\t\t\t// here as that seems to cause an infinite connection loop, can't\n-\t\t\t\t\t\t// use a hash as those are forbidden by `ws`, so username it is.\n-\t\t\t\t\t\turl.username = `${Date.now()}-${Math.floor(\n-\t\t\t\t\t\t\tMath.random() * Number.MAX_SAFE_INTEGER\n-\t\t\t\t\t\t)}`;\n-\t\t\t\t\t\tsetInspectorUrl(url.toString());\n-\t\t\t\t\t}\n-\t\t\t\t} catch (error: unknown) {\n-\t\t\t\t\tlogger.error(\"Error attempting to retrieve debugger URL:\", error);\n-\t\t\t\t}\n+\t\t\t\tconst proxyData: ProxyData = {\n+\t\t\t\t\tuserWorkerUrl: {\n+\t\t\t\t\t\tprotocol: event.url.protocol,\n+\t\t\t\t\t\thostname: event.url.hostname,\n+\t\t\t\t\t\tport: event.url.port,\n+\t\t\t\t\t},\n+\t\t\t\t\tuserWorkerInspectorUrl: {\n+\t\t\t\t\t\tprotocol: \"ws:\",\n+\t\t\t\t\t\thostname: \"127.0.0.1\",\n+\t\t\t\t\t\tport: props.runtimeInspectorPort.toString(),\n+\t\t\t\t\t\tpathname: `/core:user:${props.name ?? DEFAULT_WORKER_NAME}`,\n+\t\t\t\t\t},\n+\t\t\t\t\tuserWorkerInnerUrlOverrides: {\n+\t\t\t\t\t\tprotocol: props.localProtocol,\n+\t\t\t\t\t\thostname: props.localUpstream,\n+\t\t\t\t\t\tport: props.localUpstream ? \"\" : undefined, // `localUpstream` was essentially `host`, not `hostname`, so if it was set delete the `port`\n+\t\t\t\t\t},\n+\t\t\t\t\theaders: {}, // no headers needed in local-mode\n+\t\t\t\t\tliveReload: props.liveReload,\n+\t\t\t\t\t// in local mode, the logs are already being printed to the console by workerd but only for workers written in \"module\" format\n+\t\t\t\t\t// workers written in \"service-worker\" format still need to proxy logs to the ProxyController\n+\t\t\t\t\tproxyLogsToController: props.format === \"service-worker\",\n+\t\t\t\t};\n+\n+\t\t\t\tprops.onReady?.(\n+\t\t\t\t\tevent.url.hostname,\n+\t\t\t\t\tparseInt(event.url.port),\n+\t\t\t\t\tproxyData\n+\t\t\t\t);\n \t\t\t});\n \t\t\tserver.addEventListener(\"error\", ({ error }) => {\n \t\t\t\tif (\n@@ -254,6 +238,4 @@ function useLocalWorker(props: LocalProps) {\n \t\t},\n \t\t[]\n \t);\n-\n-\treturn { inspectorUrl };\n }"
        },
        {
            "filename": "packages/wrangler/src/dev/miniflare.ts",
            "diff": "@@ -1,14 +1,7 @@\n import assert from \"node:assert\";\n import { realpathSync } from \"node:fs\";\n import path from \"node:path\";\n-import {\n-\tLog,\n-\tLogLevel,\n-\tNoOpLog,\n-\tTypedEventTarget,\n-\tMutex,\n-\tMiniflare,\n-} from \"miniflare\";\n+import { Log, LogLevel, TypedEventTarget, Mutex, Miniflare } from \"miniflare\";\n import { ModuleTypeToRuleType } from \"../deployment-bundle/module-collection\";\n import { withSourceURLs } from \"../deployment-bundle/source-url\";\n import { getHttpsOptions } from \"../https-options\";\n@@ -89,6 +82,11 @@ export default {\n }\n `;\n \n+type SpecificPort = Exclude<number, 0>;\n+type RandomConsistentPort = 0; // random port, but consistent across reloads\n+type RandomDifferentPort = undefined; // random port, but different across reloads\n+type Port = SpecificPort | RandomConsistentPort | RandomDifferentPort;\n+\n export interface ConfigBundle {\n \t// TODO(soon): maybe rename some of these options, check proposed API Google Docs\n \tname: string | undefined;\n@@ -100,7 +98,7 @@ export interface ConfigBundle {\n \tbindings: CfWorkerInit[\"bindings\"];\n \tworkerDefinitions: WorkerRegistry | undefined;\n \tassetPaths: AssetPaths | undefined;\n-\tinitialPort: number;\n+\tinitialPort: Port;\n \tinitialIp: string;\n \trules: Config[\"rules\"];\n \tinspectorPort: number;\n@@ -114,13 +112,13 @@ export interface ConfigBundle {\n \tserviceBindings: Record<string, (_request: Request) => Promise<Response>>;\n }\n \n-class WranglerLog extends Log {\n+export class WranglerLog extends Log {\n \t#warnedCompatibilityDateFallback = false;\n \n-\tinfo(message: string) {\n+\tlog(message: string) {\n \t\t// Hide request logs for external Durable Objects proxy worker\n \t\tif (message.includes(EXTERNAL_DURABLE_OBJECTS_WORKER_NAME)) return;\n-\t\tsuper.info(message);\n+\t\tsuper.log(message);\n \t}\n \n \twarn(message: string) {\n@@ -143,19 +141,31 @@ class WranglerLog extends Log {\n \t}\n }\n \n+export const DEFAULT_WORKER_NAME = \"worker\";\n function getName(config: ConfigBundle) {\n-\treturn config.name ?? \"worker\";\n+\treturn config.name ?? DEFAULT_WORKER_NAME;\n }\n const IDENTIFIER_UNSAFE_REGEXP = /[^a-zA-Z0-9_$]/g;\n function getIdentifier(name: string) {\n \treturn name.replace(IDENTIFIER_UNSAFE_REGEXP, \"_\");\n }\n \n+export function castLogLevel(level: LoggerLevel): LogLevel {\n+\tlet key = level.toUpperCase() as Uppercase<LoggerLevel>;\n+\tif (key === \"LOG\") key = \"INFO\";\n+\n+\treturn LogLevel[key];\n+}\n+\n function buildLog(): Log {\n-\tlet level = logger.loggerLevel.toUpperCase() as Uppercase<LoggerLevel>;\n-\tif (level === \"LOG\") level = \"INFO\";\n-\tconst logLevel = LogLevel[level];\n-\treturn logLevel === LogLevel.NONE ? new NoOpLog() : new WranglerLog(logLevel);\n+\tlet level = castLogLevel(logger.loggerLevel);\n+\n+\t// if we're in DEBUG or VERBOSE mode, clamp logLevel to WARN -- ie. don't show request logs for user worker\n+\tif (level <= LogLevel.DEBUG) {\n+\t\tlevel = Math.min(level, LogLevel.WARN);\n+\t}\n+\n+\treturn new WranglerLog(level, { prefix: \"wrangler-UserWorker\" });\n }\n \n async function buildSourceOptions(\n@@ -389,7 +399,7 @@ function buildSitesOptions({ assetPaths }: ConfigBundle) {\n \t}\n }\n \n-function handleRuntimeStdio(stdout: Readable, stderr: Readable) {\n+export function handleRuntimeStdio(stdout: Readable, stderr: Readable) {\n \t// ASSUMPTION: each chunk is a whole message from workerd\n \t// This may not hold across OSes/architectures, but it seems to work on macOS M-line\n \t// I'm going with this simple approach to avoid complicating this too early\n@@ -400,14 +410,20 @@ function handleRuntimeStdio(stdout: Readable, stderr: Readable) {\n \t\t\tconst containsLlvmSymbolizerWarning = chunk.includes(\n \t\t\t\t\"Not symbolizing stack traces because $LLVM_SYMBOLIZER is not set\"\n \t\t\t);\n-\t\t\tconst containsHexStack = /stack:( [a-f\\d]{9}){3,}/.test(chunk);\n+\t\t\t// Matches stack traces from workerd\n+\t\t\t//  - on unix: groups of 9 hex digits separated by spaces\n+\t\t\t//  - on windows: groups of 12 hex digits, or a single digit 0, separated by spaces\n+\t\t\tconst containsHexStack = /stack:( (0|[a-f\\d]{4,})){3,}/.test(chunk);\n \n \t\t\treturn containsLlvmSymbolizerWarning || containsHexStack;\n \t\t},\n \t\t// Is this chunk an Address In Use error?\n \t\tisAddressInUse(chunk: string) {\n \t\t\treturn chunk.includes(\"Address already in use; toString() = \");\n \t\t},\n+\t\tisWarning(chunk: string) {\n+\t\t\treturn /\\.c\\+\\+:\\d+: warning:/.test(chunk);\n+\t\t},\n \t};\n \n \tstdout.on(\"data\", (chunk: Buffer | string) => {\n@@ -427,6 +443,11 @@ function handleRuntimeStdio(stdout: Readable, stderr: Readable) {\n \t\t\tlogger.debug(chunk);\n \t\t}\n \n+\t\t// known case: warnings are not info, log them as such\n+\t\telse if (classifiers.isWarning(chunk)) {\n+\t\t\tlogger.warn(chunk);\n+\t\t}\n+\n \t\t// anything not exlicitly handled above should be logged as info (via stdout)\n \t\telse {\n \t\t\tlogger.info(chunk);\n@@ -461,6 +482,11 @@ function handleRuntimeStdio(stdout: Readable, stderr: Readable) {\n \t\t\tlogger.debug(chunk);\n \t\t}\n \n+\t\t// known case: warnings are not errors, log them as such\n+\t\telse if (classifiers.isWarning(chunk)) {\n+\t\t\tlogger.warn(chunk);\n+\t\t}\n+\n \t\t// anything not exlicitly handled above should be logged as an error (via stderr)\n \t\telse {\n \t\t\tlogger.error(chunk);"
        },
        {
            "filename": "packages/wrangler/src/dev/remote.tsx",
            "diff": "@@ -14,12 +14,13 @@ import {\n \trequireApiToken,\n \tsaveAccountToCache,\n } from \"../user\";\n+import { getAccessToken } from \"../user/access\";\n import {\n \tcreatePreviewSession,\n \tcreateWorkerPreview,\n } from \"./create-worker-preview\";\n-import useInspector from \"./inspect\";\n-import { startPreviewServer, usePreviewServer } from \"./proxy\";\n+import { startPreviewServer } from \"./proxy\";\n+import type { ProxyData } from \"../api\";\n import type { Route } from \"../config/environment\";\n import type {\n \tCfModule,\n@@ -57,7 +58,9 @@ interface RemoteProps {\n \tzone: string | undefined;\n \thost: string | undefined;\n \troutes: Route[] | undefined;\n-\tonReady?: ((ip: string, port: number) => void) | undefined;\n+\tonReady?:\n+\t\t| ((ip: string, port: number, proxyData: ProxyData) => void)\n+\t\t| undefined;\n \tsourceMapPath: string | undefined;\n \tsendMetrics: boolean | undefined;\n }\n@@ -67,7 +70,7 @@ export function Remote(props: RemoteProps) {\n \tconst accountChoicesRef = useRef<Promise<ChooseAccountItem[]>>();\n \tconst [accountChoices, setAccountChoices] = useState<ChooseAccountItem[]>();\n \n-\tconst previewToken = useWorker({\n+\tuseWorker({\n \t\tname: props.name,\n \t\tbundle: props.bundle,\n \t\tformat: props.format,\n@@ -89,29 +92,6 @@ export function Remote(props: RemoteProps) {\n \t\tport: props.port,\n \t});\n \n-\tusePreviewServer({\n-\t\tpreviewToken,\n-\t\tassetDirectory: props.isWorkersSite\n-\t\t\t? undefined\n-\t\t\t: props.assetPaths?.assetDirectory,\n-\t\tlocalProtocol: props.localProtocol,\n-\t\tlocalPort: props.port,\n-\t\tip: props.ip,\n-\t});\n-\n-\tuseInspector({\n-\t\tinspectorUrl:\n-\t\t\tprops.inspect && previewToken\n-\t\t\t\t? previewToken.inspectorUrl.href\n-\t\t\t\t: undefined,\n-\t\tport: props.inspectorPort,\n-\t\tlogToTerminal: true,\n-\t\tsourceMapPath: props.sourceMapPath,\n-\t\thost: previewToken?.host,\n-\t\tname: props.name,\n-\t\tsourceMapMetadata: props.bundle?.sourceMapMetadata,\n-\t});\n-\n \tconst errorHandler = useErrorHandler();\n \n \t// This effect handles the async step of fetching the available accounts for the current user.\n@@ -173,7 +153,9 @@ interface RemoteWorkerProps {\n \tzone: string | undefined;\n \thost: string | undefined;\n \troutes: Route[] | undefined;\n-\tonReady: ((ip: string, port: number) => void) | undefined;\n+\tonReady:\n+\t\t| ((ip: string, port: number, proxyData: ProxyData) => void)\n+\t\t| undefined;\n \tsendMetrics: boolean | undefined;\n \tport: number;\n }\n@@ -325,7 +307,30 @@ export function useWorker(\n \t\t\t\t});\n \t\t\t}\n \t\t\t*/\n-\t\t\tonReady?.(props.host || \"localhost\", props.port);\n+\t\t\tconst accessToken = await getAccessToken(workerPreviewToken.host);\n+\n+\t\t\tconst proxyData: ProxyData = {\n+\t\t\t\tuserWorkerUrl: {\n+\t\t\t\t\tprotocol: \"https:\",\n+\t\t\t\t\thostname: workerPreviewToken.host,\n+\t\t\t\t\tport: \"443\",\n+\t\t\t\t},\n+\t\t\t\tuserWorkerInspectorUrl: {\n+\t\t\t\t\tprotocol: workerPreviewToken.inspectorUrl.protocol,\n+\t\t\t\t\thostname: workerPreviewToken.inspectorUrl.hostname,\n+\t\t\t\t\tport: workerPreviewToken.inspectorUrl.port.toString(),\n+\t\t\t\t\tpathname: workerPreviewToken.inspectorUrl.pathname,\n+\t\t\t\t},\n+\t\t\t\tuserWorkerInnerUrlOverrides: {}, // there is no analagous prop for this option because we did not permit overriding request.url in remote mode\n+\t\t\t\theaders: {\n+\t\t\t\t\t\"cf-workers-preview-token\": workerPreviewToken.value,\n+\t\t\t\t\tCookie: accessToken && `CF_Authorization=${accessToken}`,\n+\t\t\t\t},\n+\t\t\t\tliveReload: false, // liveReload currently disabled in remote-mode, but will be supported with startDevWorker\n+\t\t\t\tproxyLogsToController: true,\n+\t\t\t};\n+\n+\t\t\tonReady?.(props.host || \"localhost\", props.port, proxyData);\n \t\t}\n \t\tstart().catch((err) => {\n \t\t\t// we want to log the error, but not end the process\n@@ -419,7 +424,32 @@ export async function startRemoteServer(props: RemoteProps) {\n \t\tlocalProtocol: props.localProtocol,\n \t\tlocalPort: props.port,\n \t\tip: props.ip,\n-\t\tonReady: props.onReady,\n+\t\tonReady: async (ip, port) => {\n+\t\t\tconst accessToken = await getAccessToken(previewToken.host);\n+\n+\t\t\tconst proxyData: ProxyData = {\n+\t\t\t\tuserWorkerUrl: {\n+\t\t\t\t\tprotocol: \"https:\",\n+\t\t\t\t\thostname: previewToken.host,\n+\t\t\t\t\tport: \"443\",\n+\t\t\t\t},\n+\t\t\t\tuserWorkerInspectorUrl: {\n+\t\t\t\t\tprotocol: previewToken.inspectorUrl.protocol,\n+\t\t\t\t\thostname: previewToken.inspectorUrl.hostname,\n+\t\t\t\t\tport: previewToken.inspectorUrl.port.toString(),\n+\t\t\t\t\tpathname: previewToken.inspectorUrl.pathname,\n+\t\t\t\t},\n+\t\t\t\tuserWorkerInnerUrlOverrides: {}, // there is no analagous prop for this option because we did not permit overriding request.url in remote mode\n+\t\t\t\theaders: {\n+\t\t\t\t\t\"cf-workers-preview-token\": previewToken.value,\n+\t\t\t\t\tCookie: accessToken && `CF_Authorization=${accessToken}`,\n+\t\t\t\t},\n+\t\t\t\tliveReload: false, // liveReload currently disabled in remote-mode, but will be supported with startDevWorker\n+\t\t\t\tproxyLogsToController: true,\n+\t\t\t};\n+\n+\t\t\tprops.onReady?.(ip, port, proxyData);\n+\t\t},\n \t});\n \tif (!previewServer) {\n \t\tthrow logger.error(\"Failed to start remote server\");"
        },
        {
            "filename": "packages/wrangler/src/dev/start-server.ts",
            "diff": "@@ -2,6 +2,7 @@ import * as path from \"node:path\";\n import * as util from \"node:util\";\n import chalk from \"chalk\";\n import onExit from \"signal-exit\";\n+import { DevEnv, type StartDevWorkerOptions } from \"../api\";\n import { bundleWorker } from \"../deployment-bundle/bundle\";\n import { getBundleType } from \"../deployment-bundle/bundle-type\";\n import { dedupeModulesByName } from \"../deployment-bundle/dedupe-modules\";\n@@ -20,9 +21,10 @@ import {\n import { logger } from \"../logger\";\n import { getWranglerTmpDir } from \"../paths\";\n import { localPropsToConfigBundle, maybeRegisterLocalWorker } from \"./local\";\n-import { MiniflareServer } from \"./miniflare\";\n+import { DEFAULT_WORKER_NAME, MiniflareServer } from \"./miniflare\";\n import { startRemoteServer } from \"./remote\";\n import { validateDevProps } from \"./validate-dev-props\";\n+import type { ProxyData } from \"../api\";\n import type { Config } from \"../config\";\n import type { DurableObjectBindings } from \"../config/environment\";\n import type { Entry } from \"../deployment-bundle/entry\";\n@@ -79,6 +81,38 @@ export async function startDevServer(\n \t\t}\n \t}\n \n+\tconst devEnv = new DevEnv();\n+\tconst startDevWorkerOptions: StartDevWorkerOptions = {\n+\t\tname: props.name ?? \"worker\",\n+\t\tscript: { contents: \"\" },\n+\t\tdev: {\n+\t\t\tserver: {\n+\t\t\t\thostname: props.initialIp,\n+\t\t\t\tport: props.initialPort,\n+\t\t\t\tsecure: props.localProtocol === \"https\",\n+\t\t\t},\n+\t\t\tinspector: {\n+\t\t\t\tport: props.inspectorPort,\n+\t\t\t},\n+\t\t\turlOverrides: {\n+\t\t\t\tsecure: props.localProtocol === \"https\",\n+\t\t\t\thostname: props.localUpstream,\n+\t\t\t},\n+\t\t\tliveReload: props.liveReload,\n+\t\t\tremote: !props.local,\n+\t\t},\n+\t};\n+\n+\t// temp: fake these events by calling the handler directly\n+\tdevEnv.proxy.onConfigUpdate({\n+\t\ttype: \"configUpdate\",\n+\t\tconfig: startDevWorkerOptions,\n+\t});\n+\tdevEnv.proxy.onBundleStart({\n+\t\ttype: \"bundleStart\",\n+\t\tconfig: startDevWorkerOptions,\n+\t});\n+\n \t//implement a react-free version of useEsbuild\n \tconst bundle = await runEsbuild({\n \t\tentry: props.entry,\n@@ -108,6 +142,13 @@ export async function startDevServer(\n \t});\n \n \tif (props.local) {\n+\t\t// temp: fake these events by calling the handler directly\n+\t\tdevEnv.proxy.onReloadStart({\n+\t\t\ttype: \"reloadStart\",\n+\t\t\tconfig: startDevWorkerOptions,\n+\t\t\tbundle,\n+\t\t});\n+\n \t\tconst { stop } = await startLocalServer({\n \t\t\tname: props.name,\n \t\t\tbundle: bundle,\n@@ -127,8 +168,25 @@ export async function startDevServer(\n \t\t\tqueueConsumers: props.queueConsumers,\n \t\t\tlocalProtocol: props.localProtocol,\n \t\t\tlocalUpstream: props.localUpstream,\n-\t\t\tinspect: props.inspect,\n-\t\t\tonReady: props.onReady,\n+\t\t\tinspect: true,\n+\t\t\tonReady: async (ip, port, proxyData) => {\n+\t\t\t\t// at this point (in the layers of onReady callbacks), we have devEnv in scope\n+\t\t\t\t// so rewrite the onReady params to be the ip/port of the ProxyWorker instead of the UserWorker\n+\t\t\t\tconst { proxyWorker } = await devEnv.proxy.ready.promise;\n+\t\t\t\tconst url = await proxyWorker.ready;\n+\t\t\t\tip = url.hostname;\n+\t\t\t\tport = parseInt(url.port);\n+\n+\t\t\t\tprops.onReady?.(ip, port, proxyData);\n+\n+\t\t\t\t// temp: fake these events by calling the handler directly\n+\t\t\t\tdevEnv.proxy.onReloadComplete({\n+\t\t\t\t\ttype: \"reloadComplete\",\n+\t\t\t\t\tconfig: startDevWorkerOptions,\n+\t\t\t\t\tbundle,\n+\t\t\t\t\tproxyData,\n+\t\t\t\t});\n+\t\t\t},\n \t\t\tenablePagesAssetsServiceBinding: props.enablePagesAssetsServiceBinding,\n \t\t\tusageModel: props.usageModel,\n \t\t\tworkerDefinitions,\n@@ -137,7 +195,7 @@ export async function startDevServer(\n \n \t\treturn {\n \t\t\tstop: async () => {\n-\t\t\t\tawait Promise.all([stop(), stopWorkerRegistry()]);\n+\t\t\t\tawait Promise.all([stop(), stopWorkerRegistry(), devEnv.teardown()]);\n \t\t\t},\n \t\t\t// TODO: inspectorUrl,\n \t\t};\n@@ -163,14 +221,30 @@ export async function startDevServer(\n \t\t\tzone: props.zone,\n \t\t\thost: props.host,\n \t\t\troutes: props.routes,\n-\t\t\tonReady: props.onReady,\n+\t\t\tonReady: async (ip, port, proxyData) => {\n+\t\t\t\t// at this point (in the layers of onReady callbacks), we have devEnv in scope\n+\t\t\t\t// so rewrite the onReady params to be the ip/port of the ProxyWorker instead of the UserWorker\n+\t\t\t\tconst { proxyWorker } = await devEnv.proxy.ready.promise;\n+\t\t\t\tconst url = await proxyWorker.ready;\n+\t\t\t\tip = url.hostname;\n+\t\t\t\tport = parseInt(url.port);\n+\n+\t\t\t\tprops.onReady?.(ip, port, proxyData);\n+\n+\t\t\t\t// temp: fake these events by calling the handler directly\n+\t\t\t\tdevEnv.proxy.onReloadComplete({\n+\t\t\t\t\ttype: \"reloadComplete\",\n+\t\t\t\t\tconfig: startDevWorkerOptions,\n+\t\t\t\t\tbundle,\n+\t\t\t\t\tproxyData,\n+\t\t\t\t});\n+\t\t\t},\n \t\t\tsourceMapPath: bundle?.sourceMapPath,\n \t\t\tsendMetrics: props.sendMetrics,\n \t\t});\n \t\treturn {\n \t\t\tstop: async () => {\n-\t\t\t\tstop();\n-\t\t\t\tawait stopWorkerRegistry();\n+\t\t\t\tawait Promise.all([stop(), stopWorkerRegistry(), devEnv.teardown()]);\n \t\t\t},\n \t\t\t// TODO: inspectorUrl,\n \t\t};\n@@ -211,7 +285,7 @@ async function runEsbuild({\n \tprojectRoot,\n }: {\n \tentry: Entry;\n-\tdestination: string | undefined;\n+\tdestination: string;\n \tjsxFactory: string | undefined;\n \tjsxFragment: string | undefined;\n \tprocessEntrypoint: boolean;\n@@ -232,9 +306,7 @@ async function runEsbuild({\n \tlocal: boolean;\n \tdoBindings: DurableObjectBindings;\n \tprojectRoot: string | undefined;\n-}): Promise<EsbuildBundle | undefined> {\n-\tif (!destination) return;\n-\n+}): Promise<EsbuildBundle> {\n \tif (noBundle) {\n \t\tadditionalModules = dedupeModulesByName([\n \t\t\t...((await doFindAdditionalModules(entry, rules)) ?? []),\n@@ -322,7 +394,32 @@ export async function startLocalServer(\n \t\tconst server = new MiniflareServer();\n \t\tserver.addEventListener(\"reloaded\", async (event) => {\n \t\t\tawait maybeRegisterLocalWorker(event, props.name);\n-\t\t\tprops.onReady?.(event.url.hostname, parseInt(event.url.port));\n+\n+\t\t\tconst proxyData: ProxyData = {\n+\t\t\t\tuserWorkerUrl: {\n+\t\t\t\t\tprotocol: event.url.protocol,\n+\t\t\t\t\thostname: event.url.hostname,\n+\t\t\t\t\tport: event.url.port,\n+\t\t\t\t},\n+\t\t\t\tuserWorkerInspectorUrl: {\n+\t\t\t\t\tprotocol: \"ws:\",\n+\t\t\t\t\thostname: \"127.0.0.1\",\n+\t\t\t\t\tport: props.runtimeInspectorPort.toString(),\n+\t\t\t\t\tpathname: `/core:user:${props.name ?? DEFAULT_WORKER_NAME}`,\n+\t\t\t\t},\n+\t\t\t\tuserWorkerInnerUrlOverrides: {\n+\t\t\t\t\tprotocol: props.localProtocol,\n+\t\t\t\t\thostname: props.localUpstream,\n+\t\t\t\t\tport: props.localUpstream ? \"\" : undefined, // `localUpstream` was essentially `host`, not `hostname`, so if it was set delete the `port`\n+\t\t\t\t},\n+\t\t\t\theaders: {},\n+\t\t\t\tliveReload: props.liveReload,\n+\t\t\t\t// in local mode, the logs are already being printed to the console by workerd but only for workers written in \"module\" format\n+\t\t\t\t// workers written in \"service-worker\" format still need to proxy logs to the ProxyController\n+\t\t\t\tproxyLogsToController: props.format === \"service-worker\",\n+\t\t\t};\n+\n+\t\t\tprops.onReady?.(event.url.hostname, parseInt(event.url.port), proxyData);\n \t\t\t// Note `unstable_dev` doesn't do anything with the inspector URL yet\n \t\t\tresolve({\n \t\t\t\tstop: async () => {"
        },
        {
            "filename": "packages/wrangler/src/dev/use-esbuild.ts",
            "diff": "@@ -57,6 +57,7 @@ export function useEsbuild({\n \ttestScheduled,\n \texperimentalLocal,\n \tprojectRoot,\n+\tonBundleStart,\n }: {\n \tentry: Entry;\n \tdestination: string | undefined;\n@@ -82,6 +83,7 @@ export function useEsbuild({\n \ttestScheduled: boolean;\n \texperimentalLocal: boolean | undefined;\n \tprojectRoot: string | undefined;\n+\tonBundleStart: () => void;\n }): EsbuildBundle | undefined {\n \tconst [bundle, setBundle] = useState<EsbuildBundle>();\n \tconst { exit } = useApp();\n@@ -131,6 +133,9 @@ export function useEsbuild({\n \t\tconst onEnd = {\n \t\t\tname: \"on-end\",\n \t\t\tsetup(b: PluginBuild) {\n+\t\t\t\tb.onStart(() => {\n+\t\t\t\t\tonBundleStart();\n+\t\t\t\t});\n \t\t\t\tb.onEnd(async (result: BuildResult) => {\n \t\t\t\t\tconst errors = result.errors;\n \t\t\t\t\tconst warnings = result.warnings;\n@@ -252,6 +257,7 @@ export function useEsbuild({\n \t\ttestScheduled,\n \t\texperimentalLocal,\n \t\tprojectRoot,\n+\t\tonBundleStart,\n \t]);\n \treturn bundle;\n }"
        },
        {
            "filename": "packages/wrangler/src/https-options.ts",
            "diff": "@@ -1,6 +1,5 @@\n import * as fs from \"node:fs\";\n import * as path from \"node:path\";\n-import { promisify } from \"node:util\";\n import { getAccessibleHosts } from \"miniflare\";\n import { getGlobalWranglerConfigPath } from \"./global-wrangler-config-path\";\n import { logger } from \"./logger\";\n@@ -17,7 +16,7 @@ const ONE_DAY_IN_MS = 86400000;\n  *\n  * The certificates are self-signed and generated locally, and cached in the `CERT_ROOT` directory.\n  */\n-export async function getHttpsOptions() {\n+export function getHttpsOptions() {\n \tconst certDirectory = path.join(getGlobalWranglerConfigPath(), \"local-cert\");\n \tconst keyPath = path.join(certDirectory, \"key.pem\");\n \tconst certPath = path.join(certDirectory, \"cert.pem\");\n@@ -29,7 +28,7 @@ export async function getHttpsOptions() {\n \n \tif (regenerate) {\n \t\tlogger.log(\"Generating new self-signed certificate...\");\n-\t\tconst { key, cert } = await generateCertificate();\n+\t\tconst { key, cert } = generateCertificate();\n \t\ttry {\n \t\t\t// Write certificate files so we can reuse them later.\n \t\t\tfs.mkdirSync(certDirectory, { recursive: true });\n@@ -67,14 +66,13 @@ function hasCertificateExpired(keyPath: string, certPath: string): boolean {\n /**\n  * Generate a new self-signed certificate and cache it in `CERT_ROOT` directory.\n  */\n-async function generateCertificate() {\n+function generateCertificate() {\n \t// `selfsigned` imports `node-forge`, which is a pretty big library.\n \t// To reduce startup time, only load this dynamically when needed.\n \t// eslint-disable-next-line @typescript-eslint/consistent-type-imports\n-\tconst generate: typeof import(\"selfsigned\").generate = promisify(\n+\tconst generate: typeof import(\"selfsigned\").generate =\n \t\t// eslint-disable-next-line @typescript-eslint/no-var-requires\n-\t\trequire(\"selfsigned\").generate\n-\t);\n+\t\trequire(\"selfsigned\").generate;\n \n \tconst certAttrs: Attributes = [{ name: \"commonName\", value: \"localhost\" }];\n \n@@ -109,6 +107,6 @@ async function generateCertificate() {\n \t\t],\n \t};\n \n-\tconst { private: key, cert } = await generate(certAttrs, certOptions);\n+\tconst { private: key, cert } = generate(certAttrs, certOptions);\n \treturn { key, cert };\n }"
        },
        {
            "filename": "packages/wrangler/src/worker.d.ts",
            "diff": "@@ -0,0 +1,4 @@\n+declare module \"worker:*\" {\n+    const module: { path: string, contents: string };\n+    export default path;\n+}"
        },
        {
            "filename": "packages/wrangler/templates/startDevWorker/InspectorProxyWorker.ts",
            "diff": "@@ -0,0 +1,608 @@\n+import assert from \"node:assert\";\n+import {\n+\tDevToolsCommandRequest,\n+\tDevToolsCommandRequests,\n+\tDevToolsCommandResponses,\n+\tDevToolsEvent,\n+\tDevToolsEvents,\n+\ttype InspectorProxyWorkerIncomingWebSocketMessage,\n+\ttype InspectorProxyWorkerOutgoingRequestBody,\n+\ttype InspectorProxyWorkerOutgoingWebsocketMessage,\n+\ttype ProxyData,\n+\tserialiseError,\n+} from \"../../src/api/startDevWorker/events\";\n+import {\n+\tassertNever,\n+\tcreateDeferred,\n+\tDeferredPromise,\n+\tMaybePromise,\n+\turlFromParts,\n+} from \"../../src/api/startDevWorker/utils\";\n+\n+interface Env {\n+\tPROXY_CONTROLLER: Fetcher;\n+\tPROXY_CONTROLLER_AUTH_SECRET: string;\n+\tWRANGLER_VERSION: string;\n+\tDURABLE_OBJECT: DurableObjectNamespace;\n+}\n+\n+export default {\n+\tfetch(req, env) {\n+\t\tconst singleton = env.DURABLE_OBJECT.idFromName(\"\");\n+\t\tconst inspectorProxy = env.DURABLE_OBJECT.get(singleton);\n+\n+\t\treturn inspectorProxy.fetch(req);\n+\t},\n+} as ExportedHandler<Env>;\n+\n+function isDevToolsEvent<Method extends DevToolsEvents[\"method\"]>(\n+\tevent: unknown,\n+\tname: Method\n+): event is DevToolsEvent<Method> {\n+\treturn (\n+\t\ttypeof event === \"object\" &&\n+\t\tevent !== null &&\n+\t\t\"method\" in event &&\n+\t\tevent.method === name\n+\t);\n+}\n+\n+export class InspectorProxyWorker implements DurableObject {\n+\tconstructor(_state: DurableObjectState, readonly env: Env) {}\n+\n+\twebsockets: {\n+\t\tproxyController?: WebSocket;\n+\t\truntime?: WebSocket;\n+\t\tdevtools?: WebSocket;\n+\n+\t\t// Browser DevTools cannot read the filesystem,\n+\t\t// instead they fetch via `Network.loadNetworkResource` messages.\n+\t\t// IDE DevTools can read the filesystem and expect absolute paths.\n+\t\tdevtoolsHasFileSystemAccess?: boolean;\n+\n+\t\t// We want to be able to delay devtools connection response\n+\t\t// until we've connected to the runtime inspector server\n+\t\t// so this deferred holds a promise to websockets.runtime\n+\t\truntimeDeferred: DeferredPromise<WebSocket>;\n+\t} = {\n+\t\truntimeDeferred: createDeferred<WebSocket>(),\n+\t};\n+\tproxyData?: ProxyData;\n+\truntimeMessageBuffer: (DevToolsCommandResponses | DevToolsEvents)[] = [];\n+\n+\tasync fetch(req: Request) {\n+\t\tif (\n+\t\t\treq.headers.get(\"Authorization\") === this.env.PROXY_CONTROLLER_AUTH_SECRET\n+\t\t) {\n+\t\t\treturn this.handleProxyControllerRequest(req);\n+\t\t}\n+\n+\t\tif (req.headers.get(\"Upgrade\") === \"websocket\") {\n+\t\t\treturn this.handleDevToolsWebSocketUpgradeRequest(req);\n+\t\t}\n+\n+\t\treturn this.handleDevToolsJsonRequest(req);\n+\t}\n+\n+\t// ************************\n+\t// **  PROXY CONTROLLER  **\n+\t// ************************\n+\n+\thandleProxyControllerRequest(req: Request) {\n+\t\tassert(\n+\t\t\treq.headers.get(\"Upgrade\") === \"websocket\",\n+\t\t\t\"Expected proxy controller data request to be WebSocket upgrade\"\n+\t\t);\n+\n+\t\tconst { 0: response, 1: proxyController } = new WebSocketPair();\n+\t\tproxyController.accept();\n+\t\tproxyController.addEventListener(\"close\", (event) => {\n+\t\t\t// don't reconnect the proxyController websocket\n+\t\t\t// ProxyController can detect this event and reconnect itself\n+\n+\t\t\tthis.sendDebugLog(\n+\t\t\t\t\"PROXY CONTROLLER WEBSOCKET CLOSED\",\n+\t\t\t\tevent.code,\n+\t\t\t\tevent.reason\n+\t\t\t);\n+\n+\t\t\tif (this.websockets.proxyController === proxyController) {\n+\t\t\t\tthis.websockets.proxyController = undefined;\n+\t\t\t}\n+\t\t});\n+\t\tproxyController.addEventListener(\"error\", (event) => {\n+\t\t\t// don't reconnect the proxyController websocket\n+\t\t\t// ProxyController can detect this event and reconnect itself\n+\n+\t\t\tconst error = serialiseError(event.error);\n+\t\t\tthis.sendDebugLog(\"PROXY CONTROLLER WEBSOCKET ERROR\", error);\n+\n+\t\t\tif (this.websockets.proxyController === proxyController) {\n+\t\t\t\tthis.websockets.proxyController = undefined;\n+\t\t\t}\n+\t\t});\n+\t\tproxyController.addEventListener(\n+\t\t\t\"message\",\n+\t\t\tthis.handleProxyControllerIncomingMessage\n+\t\t);\n+\n+\t\tthis.websockets.proxyController = proxyController;\n+\n+\t\treturn new Response(null, {\n+\t\t\tstatus: 101,\n+\t\t\twebSocket: response,\n+\t\t});\n+\t}\n+\n+\thandleProxyControllerIncomingMessage = (event: MessageEvent) => {\n+\t\tassert(\n+\t\t\ttypeof event.data === \"string\",\n+\t\t\t\"Expected event.data from proxy controller to be string\"\n+\t\t);\n+\n+\t\tconst message: InspectorProxyWorkerIncomingWebSocketMessage = JSON.parse(\n+\t\t\tevent.data\n+\t\t);\n+\n+\t\tthis.sendDebugLog(\"handleProxyControllerIncomingMessage\", event.data);\n+\n+\t\tswitch (message.type) {\n+\t\t\tcase \"reloadStart\": {\n+\t\t\t\tthis.sendRuntimeDiscardConsoleEntries();\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcase \"reloadComplete\": {\n+\t\t\t\tthis.proxyData = message.proxyData;\n+\n+\t\t\t\tthis.reconnectRuntimeWebSocket();\n+\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tdefault: {\n+\t\t\t\tassertNever(message);\n+\t\t\t}\n+\t\t}\n+\t};\n+\n+\tsendProxyControllerMessage(\n+\t\tmessage: string | InspectorProxyWorkerOutgoingWebsocketMessage\n+\t) {\n+\t\tmessage = typeof message === \"string\" ? message : JSON.stringify(message);\n+\n+\t\t// if the proxyController websocket is disconnected, throw away the message\n+\t\tthis.websockets.proxyController?.send(message);\n+\t}\n+\n+\tasync sendProxyControllerRequest(\n+\t\tmessage: InspectorProxyWorkerOutgoingRequestBody\n+\t) {\n+\t\ttry {\n+\t\t\tconst res = await this.env.PROXY_CONTROLLER.fetch(\"http://dummy\", {\n+\t\t\t\tmethod: \"POST\",\n+\t\t\t\tbody: JSON.stringify(message),\n+\t\t\t});\n+\t\t\treturn res.ok ? await res.text() : undefined;\n+\t\t} catch (e) {\n+\t\t\tthis.sendDebugLog(\n+\t\t\t\t\"FAILED TO SEND PROXY CONTROLLER REQUEST\",\n+\t\t\t\tserialiseError(e)\n+\t\t\t);\n+\t\t\treturn undefined;\n+\t\t}\n+\t}\n+\n+\tsendDebugLog: typeof console.debug = (...args) => {\n+\t\tthis.sendProxyControllerRequest({ type: \"debug-log\", args });\n+\t};\n+\n+\t// ***************\n+\t// **  RUNTIME  **\n+\t// ***************\n+\n+\thandleRuntimeIncomingMessage = (event: MessageEvent) => {\n+\t\tassert(typeof event.data === \"string\");\n+\n+\t\tconst msg = JSON.parse(event.data) as\n+\t\t\t| DevToolsCommandResponses\n+\t\t\t| DevToolsEvents;\n+\t\tthis.sendDebugLog(\"RUNTIME INCOMING MESSAGE\", msg);\n+\n+\t\tif (isDevToolsEvent(msg, \"Runtime.exceptionThrown\")) {\n+\t\t\tthis.sendProxyControllerMessage(event.data);\n+\t\t}\n+\t\tif (\n+\t\t\tthis.proxyData?.proxyLogsToController &&\n+\t\t\tisDevToolsEvent(msg, \"Runtime.consoleAPICalled\")\n+\t\t) {\n+\t\t\tthis.sendProxyControllerMessage(event.data);\n+\t\t}\n+\n+\t\tthis.runtimeMessageBuffer.push(msg);\n+\t\tthis.tryDrainRuntimeMessageBuffer();\n+\t};\n+\n+\thandleRuntimeScriptParsed(msg: DevToolsEvent<\"Debugger.scriptParsed\">) {\n+\t\t// If the devtools does not have filesystem access,\n+\t\t// rewrite the sourceMapURL to use a special scheme.\n+\t\t// This special scheme is used to indicate whether\n+\t\t// to intercept each loadNetworkResource message.\n+\n+\t\tif (\n+\t\t\t!this.websockets.devtoolsHasFileSystemAccess &&\n+\t\t\tmsg.params.sourceMapURL !== undefined &&\n+\t\t\t// Don't try to find a sourcemap for e.g. node-internal: scripts\n+\t\t\tmsg.params.url.startsWith(\"file:\")\n+\t\t) {\n+\t\t\tconst url = new URL(msg.params.sourceMapURL, msg.params.url);\n+\t\t\t// Check for file: in case msg.params.sourceMapURL has a different\n+\t\t\t// protocol (e.g. data). In that case we should ignore this file\n+\t\t\tif (url.protocol === \"file:\") {\n+\t\t\t\tmsg.params.sourceMapURL = url.href.replace(\"file:\", \"wrangler-file:\");\n+\t\t\t}\n+\t\t}\n+\n+\t\tvoid this.sendDevToolsMessage(msg);\n+\t}\n+\n+\ttryDrainRuntimeMessageBuffer = () => {\n+\t\t// If we don't have a DevTools WebSocket, try again later\n+\t\tif (this.websockets.devtools === undefined) return;\n+\n+\t\t// clear the buffer and replay each message to devtools\n+\t\tfor (const msg of this.runtimeMessageBuffer.splice(0)) {\n+\t\t\tif (isDevToolsEvent(msg, \"Debugger.scriptParsed\")) {\n+\t\t\t\tthis.handleRuntimeScriptParsed(msg);\n+\t\t\t} else {\n+\t\t\t\tvoid this.sendDevToolsMessage(msg);\n+\t\t\t}\n+\t\t}\n+\t};\n+\n+\truntimeAbortController = new AbortController(); // will abort the in-flight websocket upgrade request to the remote runtime\n+\truntimeKeepAliveInterval: number | null = null;\n+\tasync reconnectRuntimeWebSocket() {\n+\t\tassert(this.proxyData, \"Expected this.proxyData to be defined\");\n+\n+\t\tthis.sendDebugLog(\"reconnectRuntimeWebSocket\");\n+\n+\t\tthis.websockets.runtime?.close();\n+\t\tthis.websockets.runtime = undefined;\n+\t\tthis.runtimeAbortController.abort();\n+\t\tthis.runtimeAbortController = new AbortController();\n+\t\tthis.websockets.runtimeDeferred = createDeferred<WebSocket>(\n+\t\t\tthis.websockets.runtimeDeferred\n+\t\t);\n+\n+\t\tconst runtimeWebSocketUrl = urlFromParts(\n+\t\t\tthis.proxyData.userWorkerInspectorUrl\n+\t\t);\n+\t\truntimeWebSocketUrl.protocol = this.proxyData.userWorkerUrl.protocol; // http: or https:\n+\n+\t\tthis.sendDebugLog(\"NEW RUNTIME WEBSOCKET\", runtimeWebSocketUrl);\n+\n+\t\tconst upgrade = await fetch(runtimeWebSocketUrl, {\n+\t\t\theaders: {\n+\t\t\t\t...this.proxyData.headers,\n+\t\t\t\tUpgrade: \"websocket\",\n+\t\t\t},\n+\t\t\tsignal: this.runtimeAbortController.signal,\n+\t\t});\n+\n+\t\tconst runtime = upgrade.webSocket;\n+\t\tif (!runtime) {\n+\t\t\tconst error = new Error(\n+\t\t\t\t`Failed to establish the WebSocket connection: expected server to reply with HTTP status code 101 (switching protocols), but received ${upgrade.status} instead.`\n+\t\t\t);\n+\n+\t\t\tthis.websockets.runtimeDeferred.reject(error);\n+\t\t\tthis.sendProxyControllerRequest({\n+\t\t\t\ttype: \"runtime-websocket-error\",\n+\t\t\t\terror: serialiseError(error),\n+\t\t\t});\n+\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tthis.websockets.runtime = runtime;\n+\n+\t\truntime.addEventListener(\"message\", this.handleRuntimeIncomingMessage);\n+\n+\t\truntime.addEventListener(\"close\", (event) => {\n+\t\t\tthis.sendDebugLog(\"RUNTIME WEBSOCKET CLOSED\", event.code, event.reason);\n+\n+\t\t\tclearInterval(this.runtimeKeepAliveInterval);\n+\n+\t\t\tif (this.websockets.runtime === runtime) {\n+\t\t\t\tthis.websockets.runtime = undefined;\n+\t\t\t}\n+\n+\t\t\t// don't reconnect the runtime websocket\n+\t\t\t// if it closes unexpectedly (very rare or a case where reconnecting won't succeed anyway)\n+\t\t\t// wait for a new proxy-data message or manual restart\n+\t\t});\n+\n+\t\truntime.addEventListener(\"error\", (event) => {\n+\t\t\tconst error = serialiseError(event.error);\n+\t\t\tthis.sendDebugLog(\"RUNTIME WEBSOCKET ERROR\", error);\n+\n+\t\t\tclearInterval(this.runtimeKeepAliveInterval);\n+\n+\t\t\tif (this.websockets.runtime === runtime) {\n+\t\t\t\tthis.websockets.runtime = undefined;\n+\t\t\t}\n+\n+\t\t\tthis.sendProxyControllerRequest({\n+\t\t\t\ttype: \"runtime-websocket-error\",\n+\t\t\t\terror,\n+\t\t\t});\n+\n+\t\t\t// don't reconnect the runtime websocket\n+\t\t\t// if it closes unexpectedly (very rare or a case where reconnecting won't succeed anyway)\n+\t\t\t// wait for a new proxy-data message or manual restart\n+\t\t});\n+\n+\t\truntime.accept();\n+\n+\t\t// fetch(Upgrade: websocket) resolves when the websocket is open\n+\t\t// therefore the open event will not fire, so just trigger the handler\n+\t\tthis.handleRuntimeWebSocketOpen(runtime);\n+\t}\n+\n+\t#runtimeMessageCounter = 1e8;\n+\tnextCounter() {\n+\t\treturn ++this.#runtimeMessageCounter;\n+\t}\n+\thandleRuntimeWebSocketOpen(runtime: WebSocket) {\n+\t\tthis.sendDebugLog(\"RUNTIME WEBSOCKET OPENED\");\n+\n+\t\tthis.sendRuntimeMessage(\n+\t\t\t{ method: \"Runtime.enable\", id: this.nextCounter() },\n+\t\t\truntime\n+\t\t);\n+\t\tthis.sendRuntimeMessage(\n+\t\t\t{ method: \"Debugger.enable\", id: this.nextCounter() },\n+\t\t\truntime\n+\t\t);\n+\t\tthis.sendRuntimeMessage(\n+\t\t\t{ method: \"Network.enable\", id: this.nextCounter() },\n+\t\t\truntime\n+\t\t);\n+\n+\t\tclearInterval(this.runtimeKeepAliveInterval);\n+\t\tthis.runtimeKeepAliveInterval = setInterval(() => {\n+\t\t\tthis.sendRuntimeMessage(\n+\t\t\t\t{ method: \"Runtime.getIsolateId\", id: this.nextCounter() },\n+\t\t\t\truntime\n+\t\t\t);\n+\t\t}, 10_000) as any;\n+\n+\t\tthis.websockets.runtimeDeferred.resolve(runtime);\n+\t}\n+\n+\tsendRuntimeDiscardConsoleEntries() {\n+\t\t// by default, sendRuntimeMessage waits for the runtime websocket to connect\n+\t\t// but we only want to send this message now or never\n+\t\t// if we schedule it to send later (like waiting for the websocket, by default)\n+\t\t// then we risk clearing logs that have occured since we scheduled it too\n+\t\t// which is worse than leaving logs from the previous version on screen\n+\t\tif (this.websockets.runtime) {\n+\t\t\tthis.sendRuntimeMessage(\n+\t\t\t\t{\n+\t\t\t\t\tmethod: \"Runtime.discardConsoleEntries\",\n+\t\t\t\t\tid: this.nextCounter(),\n+\t\t\t\t},\n+\t\t\t\tthis.websockets.runtime\n+\t\t\t);\n+\t\t}\n+\t}\n+\n+\tasync sendRuntimeMessage(\n+\t\tmessage: string | DevToolsCommandRequests,\n+\t\truntime: MaybePromise<WebSocket> = this.websockets.runtimeDeferred.promise\n+\t) {\n+\t\truntime = await runtime;\n+\t\tmessage = typeof message === \"string\" ? message : JSON.stringify(message);\n+\n+\t\tthis.sendDebugLog(\"SEND TO RUNTIME\", message);\n+\n+\t\truntime.send(message);\n+\t}\n+\n+\t// ****************\n+\t// **  DEVTOOLS  **\n+\t// ****************\n+\n+\t#inspectorId = crypto.randomUUID();\n+\tasync handleDevToolsJsonRequest(req: Request) {\n+\t\tconst url = new URL(req.url);\n+\n+\t\tif (url.pathname === \"/json/version\") {\n+\t\t\treturn Response.json({\n+\t\t\t\tBrowser: `wrangler/v${this.env.WRANGLER_VERSION}`,\n+\t\t\t\t// TODO: (someday): The DevTools protocol should match that of workerd.\n+\t\t\t\t// This could be exposed by the preview API.\n+\t\t\t\t\"Protocol-Version\": \"1.3\",\n+\t\t\t});\n+\t\t}\n+\n+\t\tif (url.pathname === \"/json\" || url.pathname === \"/json/list\") {\n+\t\t\t// TODO: can we remove the `/ws` here if we only have a single worker?\n+\t\t\tconst localHost = `${url.host}/ws`;\n+\t\t\tconst devtoolsFrontendUrl = `https://devtools.devprod.cloudflare.dev/js_app?theme=systemPreferred&debugger=true&ws=${localHost}`;\n+\n+\t\t\treturn Response.json([\n+\t\t\t\t{\n+\t\t\t\t\tid: this.#inspectorId,\n+\t\t\t\t\ttype: \"node\", // TODO: can we specify different type?\n+\t\t\t\t\tdescription: \"workers\",\n+\t\t\t\t\twebSocketDebuggerUrl: `ws://${localHost}`,\n+\t\t\t\t\tdevtoolsFrontendUrl,\n+\t\t\t\t\tdevtoolsFrontendUrlCompat: devtoolsFrontendUrl,\n+\t\t\t\t\t// Below are fields that are visible in the DevTools UI.\n+\t\t\t\t\ttitle: \"Cloudflare Worker\",\n+\t\t\t\t\tfaviconUrl: \"https://workers.cloudflare.com/favicon.ico\",\n+\t\t\t\t\t// url: \"http://\" + localHost, // looks unnecessary\n+\t\t\t\t},\n+\t\t\t]);\n+\t\t}\n+\n+\t\treturn new Response(null, { status: 404 });\n+\t}\n+\n+\tasync handleDevToolsWebSocketUpgradeRequest(req: Request) {\n+\t\t// DevTools attempting to connect\n+\t\tthis.sendDebugLog(\"DEVTOOLS WEBSOCKET TRYING TO CONNECT\");\n+\n+\t\t// Delay devtools connection response until we've connected to the runtime inspector server\n+\t\tawait this.websockets.runtimeDeferred.promise;\n+\n+\t\tthis.sendDebugLog(\"DEVTOOLS WEBSOCKET CAN NOW CONNECT\");\n+\n+\t\tassert(\n+\t\t\treq.headers.get(\"Upgrade\") === \"websocket\",\n+\t\t\t\"Expected DevTools connection to be WebSocket upgrade\"\n+\t\t);\n+\t\tconst { 0: response, 1: devtools } = new WebSocketPair();\n+\t\tdevtools.accept();\n+\n+\t\tif (this.websockets.devtools !== undefined) {\n+\t\t\t/** We only want to have one active Devtools instance at a time. */\n+\t\t\t// TODO(consider): prioritise new websocket over previous\n+\t\t\tdevtools.close(\n+\t\t\t\t1013,\n+\t\t\t\t\"Too many clients; only one can be connected at a time\"\n+\t\t\t);\n+\t\t} else {\n+\t\t\tdevtools.addEventListener(\"message\", this.handleDevToolsIncomingMessage);\n+\t\t\tdevtools.addEventListener(\"close\", (event) => {\n+\t\t\t\tthis.sendDebugLog(\n+\t\t\t\t\t\"DEVTOOLS WEBSOCKET CLOSED\",\n+\t\t\t\t\tevent.code,\n+\t\t\t\t\tevent.reason\n+\t\t\t\t);\n+\n+\t\t\t\tif (this.websockets.devtools === devtools) {\n+\t\t\t\t\tthis.websockets.devtools = undefined;\n+\t\t\t\t}\n+\t\t\t});\n+\t\t\tdevtools.addEventListener(\"error\", (event) => {\n+\t\t\t\tconst error = serialiseError(event.error);\n+\t\t\t\tthis.sendDebugLog(\"DEVTOOLS WEBSOCKET ERROR\", error);\n+\n+\t\t\t\tif (this.websockets.devtools === devtools) {\n+\t\t\t\t\tthis.websockets.devtools = undefined;\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\t// Since Wrangler proxies the inspector, reloading Chrome DevTools won't trigger debugger initialisation events (because it's connecting to an extant session).\n+\t\t\t// This sends a `Debugger.disable` message to the remote when a new WebSocket connection is initialised,\n+\t\t\t// with the assumption that the new connection will shortly send a `Debugger.enable` event and trigger re-initialisation.\n+\t\t\t// The key initialisation messages that are needed are the `Debugger.scriptParsed events`.\n+\t\t\tthis.sendRuntimeMessage({\n+\t\t\t\tid: this.nextCounter(),\n+\t\t\t\tmethod: \"Debugger.disable\",\n+\t\t\t});\n+\n+\t\t\tthis.sendDebugLog(\"DEVTOOLS WEBSOCKET CONNECTED\");\n+\n+\t\t\t// Our patched DevTools are hosted on a `https://` URL. These cannot\n+\t\t\t// access `file://` URLs, meaning local source maps cannot be fetched.\n+\t\t\t// To get around this, we can rewrite `Debugger.scriptParsed` events to\n+\t\t\t// include a special `worker:` scheme for source maps, and respond to\n+\t\t\t// `Network.loadNetworkResource` commands for these. Unfortunately, this\n+\t\t\t// breaks IDE's built-in debuggers (e.g. VSCode and WebStorm), so we only\n+\t\t\t// want to enable this transformation when we detect hosted DevTools has\n+\t\t\t// connected. We do this by looking at the WebSocket handshake headers:\n+\t\t\t//\n+\t\t\t//  DevTools\n+\t\t\t//\n+\t\t\t// Upgrade: websocket\n+\t\t\t// Host: localhost:9229\n+\t\t\t// (from Chrome)  User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36\n+\t\t\t// (from Firefox) User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/116.0\n+\t\t\t// Origin: https://devtools.devprod.cloudflare.dev\n+\t\t\t// ...\n+\t\t\t//\n+\t\t\t//  VSCode\n+\t\t\t//\n+\t\t\t// Upgrade: websocket\n+\t\t\t// Host: localhost\n+\t\t\t// ...\n+\t\t\t//\n+\t\t\t//  WebStorm\n+\t\t\t//\n+\t\t\t// Upgrade: websocket\n+\t\t\t// Host: localhost:9229\n+\t\t\t// Origin: http://localhost:9229\n+\t\t\t// ...\n+\t\t\t//\n+\t\t\t// From this, we could just use the presence of a `User-Agent` header to\n+\t\t\t// determine if DevTools connected, but VSCode/WebStorm could very well\n+\t\t\t// add this in future versions. We could also look for an `Origin` header\n+\t\t\t// matching the hosted DevTools URL, but this would prevent preview/local\n+\t\t\t// versions working. Instead, we look for a browser-like `User-Agent`.\n+\t\t\tconst userAgent = req.headers.get(\"User-Agent\") ?? \"\";\n+\t\t\tconst hasFileSystemAccess = !/mozilla/i.test(userAgent);\n+\n+\t\t\tthis.websockets.devtools = devtools;\n+\t\t\tthis.websockets.devtoolsHasFileSystemAccess = hasFileSystemAccess;\n+\n+\t\t\tthis.tryDrainRuntimeMessageBuffer();\n+\t\t}\n+\n+\t\treturn new Response(null, { status: 101, webSocket: response });\n+\t}\n+\n+\thandleDevToolsIncomingMessage = (event: MessageEvent) => {\n+\t\tassert(\n+\t\t\ttypeof event.data === \"string\",\n+\t\t\t\"Expected devtools incoming message to be of type string\"\n+\t\t);\n+\n+\t\tconst message = JSON.parse(event.data) as DevToolsCommandRequests;\n+\t\tthis.sendDebugLog(\"DEVTOOLS INCOMING MESSAGE\", message);\n+\n+\t\tif (message.method === \"Network.loadNetworkResource\") {\n+\t\t\treturn void this.handleDevToolsLoadNetworkResource(message);\n+\t\t}\n+\n+\t\tthis.sendRuntimeMessage(JSON.stringify(message));\n+\t};\n+\n+\tasync handleDevToolsLoadNetworkResource(\n+\t\tmessage: DevToolsCommandRequest<\"Network.loadNetworkResource\">\n+\t) {\n+\t\tconst response = await this.sendProxyControllerRequest({\n+\t\t\ttype: \"load-network-resource\",\n+\t\t\turl: message.params.url,\n+\t\t});\n+\t\tif (response === undefined) {\n+\t\t\tthis.sendDebugLog(\n+\t\t\t\t`ProxyController could not resolve Network.loadNetworkResource for \"${message.params.url}\"`\n+\t\t\t);\n+\n+\t\t\t// When the ProxyController cannot resolve a resource, let the runtime handle the request\n+\t\t\tthis.sendRuntimeMessage(JSON.stringify(message));\n+\t\t} else {\n+\t\t\t// this.websockets.devtools can be undefined here\n+\t\t\t// the incoming message implies we have a devtools connection, but after\n+\t\t\t// the await it could've dropped in which case we can safely not respond\n+\t\t\tthis.sendDevToolsMessage({\n+\t\t\t\tid: message.id,\n+\t\t\t\t// @ts-expect-error DevTools Protocol type does not match our patched devtools -- result.resource.text was added\n+\t\t\t\tresult: { resource: { success: true, text: response } },\n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tsendDevToolsMessage(\n+\t\tmessage: string | DevToolsCommandResponses | DevToolsEvents\n+\t) {\n+\t\tmessage = typeof message === \"string\" ? message : JSON.stringify(message);\n+\n+\t\tthis.sendDebugLog(\"SEND TO DEVTOOLS\", message);\n+\n+\t\tthis.websockets.devtools?.send(message);\n+\t}\n+}"
        },
        {
            "filename": "packages/wrangler/templates/startDevWorker/ProxyWorker.ts",
            "diff": "@@ -0,0 +1,252 @@\n+import assert from \"node:assert\";\n+import type {\n+\tProxyWorkerIncomingRequestBody,\n+\tProxyWorkerOutgoingRequestBody,\n+\tProxyData,\n+} from \"../../src/api/startDevWorker/events\";\n+import {\n+\tDeferredPromise,\n+\tcreateDeferred,\n+} from \"../../src/api/startDevWorker/utils\";\n+\n+interface Env {\n+\tPROXY_CONTROLLER: Fetcher;\n+\tPROXY_CONTROLLER_AUTH_SECRET: string;\n+\tDURABLE_OBJECT: DurableObjectNamespace;\n+}\n+\n+// request.cf.hostMetadata is verbose to type using the workers-types Request -- this allows us to have Request correctly typed in this scope\n+type Request = Parameters<\n+\tNonNullable<\n+\t\tExportedHandler<Env, unknown, ProxyWorkerIncomingRequestBody>[\"fetch\"]\n+\t>\n+>[0];\n+\n+const LIVE_RELOAD_PROTOCOL = \"WRANGLER_PROXYWORKER_LIVE_RELOAD_PROTOCOL\";\n+export default {\n+\tfetch(req, env) {\n+\t\tconst singleton = env.DURABLE_OBJECT.idFromName(\"\");\n+\t\tconst inspectorProxy = env.DURABLE_OBJECT.get(singleton);\n+\n+\t\treturn inspectorProxy.fetch(req);\n+\t},\n+} as ExportedHandler<Env, unknown, ProxyWorkerIncomingRequestBody>;\n+\n+export class ProxyWorker implements DurableObject {\n+\tconstructor(readonly state: DurableObjectState, readonly env: Env) {}\n+\n+\tproxyData?: ProxyData;\n+\trequestQueue = new Map<Request, DeferredPromise<Response>>();\n+\n+\tfetch(request: Request) {\n+\t\tif (isRequestForLiveReloadWebsocket(request)) {\n+\t\t\t// requests for live-reload websocket\n+\n+\t\t\treturn this.handleLiveReloadWebSocket(request);\n+\t\t}\n+\n+\t\tif (isRequestFromProxyController(request, this.env)) {\n+\t\t\t// requests from ProxyController\n+\n+\t\t\treturn this.processProxyControllerRequest(request);\n+\t\t}\n+\n+\t\t// regular requests to be proxied\n+\t\tconst deferred = createDeferred<Response>();\n+\n+\t\tthis.requestQueue.set(request, deferred);\n+\t\tthis.processQueue();\n+\n+\t\treturn deferred.promise;\n+\t}\n+\n+\thandleLiveReloadWebSocket(request: Request) {\n+\t\tconst { 0: response, 1: liveReload } = new WebSocketPair();\n+\t\tconst websocketProtocol =\n+\t\t\trequest.headers.get(\"Sec-WebSocket-Protocol\") ?? \"\";\n+\n+\t\tthis.state.acceptWebSocket(liveReload, [\"live-reload\"]);\n+\n+\t\treturn new Response(null, {\n+\t\t\tstatus: 101,\n+\t\t\twebSocket: response,\n+\t\t\theaders: { \"Sec-WebSocket-Protocol\": websocketProtocol },\n+\t\t});\n+\t}\n+\n+\tprocessProxyControllerRequest(request: Request) {\n+\t\tconst event = request.cf?.hostMetadata;\n+\t\tswitch (event?.type) {\n+\t\t\tcase \"pause\":\n+\t\t\t\tthis.proxyData = undefined;\n+\t\t\t\tbreak;\n+\n+\t\t\tcase \"play\":\n+\t\t\t\tthis.proxyData = event.proxyData;\n+\t\t\t\tthis.processQueue();\n+\t\t\t\tthis.state\n+\t\t\t\t\t.getWebSockets(\"live-reload\")\n+\t\t\t\t\t.forEach((ws) => ws.send(\"reload\"));\n+\n+\t\t\t\tbreak;\n+\t\t}\n+\n+\t\treturn new Response(null, { status: 204 });\n+\t}\n+\n+\tprocessQueue() {\n+\t\tconst { proxyData } = this; // destructuring is required to keep the type-narrowing (not undefined) in the .then callback and to ensure the same proxyData is used throughout each request\n+\t\tif (proxyData === undefined) return;\n+\n+\t\tfor (const [request, deferredResponse] of this.requestQueue) {\n+\t\t\tthis.requestQueue.delete(request);\n+\n+\t\t\tconst userWorkerUrl = new URL(request.url);\n+\t\t\tconst headers = new Headers(request.headers);\n+\n+\t\t\t// override url parts for proxying\n+\t\t\tObject.assign(userWorkerUrl, proxyData.userWorkerUrl);\n+\n+\t\t\t// set request.url in the UserWorker\n+\t\t\tconst innerUrl = new URL(request.url);\n+\t\t\tObject.assign(innerUrl, proxyData.userWorkerInnerUrlOverrides);\n+\t\t\theaders.set(\"MF-Original-URL\", innerUrl.href);\n+\t\t\theaders.set(\"MF-Disable-Pretty-Error\", \"true\"); // disables the UserWorker miniflare instance from rendering the pretty error -- instead the ProxyWorker miniflare instance will intercept the json error response and render the pretty error page\n+\n+\t\t\t// merge proxyData headers with the request headers\n+\t\t\tfor (const [key, value] of Object.entries(proxyData.headers ?? {})) {\n+\t\t\t\tif (key.toLowerCase() === \"cookie\") {\n+\t\t\t\t\tconst existing = request.headers.get(\"cookie\") ?? \"\";\n+\t\t\t\t\theaders.set(\"cookie\", `${existing};${value}`);\n+\t\t\t\t} else {\n+\t\t\t\t\theaders.set(key, value);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t// explicitly NOT await-ing this promise, we are in a loop and want to process the whole queue quickly\n+\t\t\t// if we decide to await, we should include a timeout (~100ms) in case the user worker has long-running/parellel requests\n+\t\t\tvoid fetch(userWorkerUrl, new Request(request, { headers }))\n+\t\t\t\t.then((res) => {\n+\t\t\t\t\tif (isHtmlResponse(res)) {\n+\t\t\t\t\t\tres = insertLiveReloadScript(request, res, this.env, proxyData);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tdeferredResponse.resolve(res);\n+\t\t\t\t})\n+\t\t\t\t.catch((error: Error) => {\n+\t\t\t\t\t// errors here are network errors or from response post-processing\n+\t\t\t\t\t// to catch only network errors, use the 2nd param of the fetch.then()\n+\n+\t\t\t\t\tvoid sendMessageToProxyController(this.env, {\n+\t\t\t\t\t\ttype: \"error\",\n+\t\t\t\t\t\terror: {\n+\t\t\t\t\t\t\tname: error.name,\n+\t\t\t\t\t\t\tmessage: error.message,\n+\t\t\t\t\t\t\tstack: error.stack,\n+\t\t\t\t\t\t\tcause: error.cause,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t});\n+\n+\t\t\t\t\tdeferredResponse.reject(error);\n+\t\t\t\t});\n+\t\t}\n+\t}\n+}\n+\n+function isRequestFromProxyController(req: Request, env: Env): boolean {\n+\treturn req.headers.get(\"Authorization\") === env.PROXY_CONTROLLER_AUTH_SECRET;\n+}\n+function isHtmlResponse(res: Response): boolean {\n+\treturn res.headers.get(\"content-type\")?.startsWith(\"text/html\") ?? false;\n+}\n+function isRequestForLiveReloadWebsocket(req: Request): boolean {\n+\tconst websocketProtocol = req.headers.get(\"Sec-WebSocket-Protocol\");\n+\tconst isWebSocketUpgrade = req.headers.get(\"Upgrade\") === \"websocket\";\n+\n+\treturn isWebSocketUpgrade && websocketProtocol === LIVE_RELOAD_PROTOCOL;\n+}\n+\n+async function sendMessageToProxyController(\n+\tenv: Env,\n+\tmessage: ProxyWorkerOutgoingRequestBody,\n+\tretries = 3\n+) {\n+\ttry {\n+\t\tawait env.PROXY_CONTROLLER.fetch(\"http://dummy\", {\n+\t\t\tmethod: \"POST\",\n+\t\t\tbody: JSON.stringify(message),\n+\t\t});\n+\t} catch (cause) {\n+\t\tif (retries > 0) {\n+\t\t\treturn sendMessageToProxyController(env, message, retries - 1);\n+\t\t}\n+\n+\t\t// no point sending an error message if we can't send this message\n+\n+\t\tthrow cause;\n+\t}\n+}\n+\n+function insertLiveReloadScript(\n+\trequest: Request,\n+\tresponse: Response,\n+\tenv: Env,\n+\tproxyData: ProxyData\n+) {\n+\tconst htmlRewriter = new HTMLRewriter();\n+\n+\t// if preview-token-expired response, errorDetails will contain \"Invalid Workers Preview configuration\"\n+\tlet errorDetails = \"\";\n+\thtmlRewriter.on(\"#cf-error-details\", {\n+\t\ttext(element) {\n+\t\t\terrorDetails += element.text;\n+\t\t},\n+\t});\n+\n+\thtmlRewriter.onDocument({\n+\t\tend(end) {\n+\t\t\tif (\n+\t\t\t\tresponse.status === 400 &&\n+\t\t\t\terrorDetails.includes(\"Invalid Workers Preview configuration\")\n+\t\t\t) {\n+\t\t\t\tvoid sendMessageToProxyController(env, {\n+\t\t\t\t\ttype: \"previewTokenExpired\",\n+\t\t\t\t\tproxyData,\n+\t\t\t\t});\n+\t\t\t}\n+\n+\t\t\t// if liveReload enabled, append a script tag\n+\t\t\t// TODO: compare to existing nodejs implementation\n+\t\t\tif (proxyData.liveReload) {\n+\t\t\t\tconst websocketUrl = new URL(request.url);\n+\t\t\t\twebsocketUrl.protocol =\n+\t\t\t\t\twebsocketUrl.protocol === \"http:\" ? \"ws:\" : \"wss:\";\n+\n+\t\t\t\tend.append(\n+\t\t\t\t\t`\n+\t\t\t\t\t<script>\n+\t\t\t\t\t\t(function() {\n+\t\t\t\t\t\t\tvar ws;\n+\t\t\t\t\t\t\tfunction recover() {\n+\t\t\t\t\t\t\t\tws = null;\n+\t\t\t\t\t\t\t\tsetTimeout(initLiveReload, 100);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tfunction initLiveReload() {\n+\t\t\t\t\t\t\t\tif (ws) return;\n+                var origin = (location.protocol === \"http:\" ? \"ws://\" : \"wss://\") + location.host;\n+\t\t\t\t\t\t\t\tws = new WebSocket(origin + \"/cdn-cgi/live-reload\", \"${LIVE_RELOAD_PROTOCOL}\");\n+\t\t\t\t\t\t\t\tws.onclose = recover;\n+\t\t\t\t\t\t\t\tws.onerror = recover;\n+\t\t\t\t\t\t\t\tws.onmessage = location.reload.bind(location);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})();\n+\t\t\t\t\t</script>\n+\t\t\t\t`,\n+\t\t\t\t\t{ html: true }\n+\t\t\t\t);\n+\t\t\t}\n+\t\t},\n+\t});\n+\n+\treturn htmlRewriter.transform(response);\n+}"
        },
        {
            "filename": "pnpm-lock.yaml",
            "diff": "@@ -106,6 +106,30 @@ importers:\n         specifier: workspace:*\n         version: link:../../packages/wrangler\n \n+  fixtures/dev-env:\n+    devDependencies:\n+      '@cloudflare/workers-tsconfig':\n+        specifier: workspace:^\n+        version: link:../../packages/workers-tsconfig\n+      '@types/ws':\n+        specifier: ^8.5.7\n+        version: 8.5.9\n+      get-port:\n+        specifier: ^7.0.0\n+        version: 7.0.0\n+      miniflare:\n+        specifier: 3.20231025.1\n+        version: link:../../packages/miniflare\n+      undici:\n+        specifier: ^5.23.0\n+        version: 5.23.0\n+      wrangler:\n+        specifier: workspace:*\n+        version: link:../../packages/wrangler\n+      ws:\n+        specifier: ^8.14.2\n+        version: 8.14.2\n+\n   fixtures/durable-objects-app:\n     devDependencies:\n       '@cloudflare/workers-tsconfig':\n@@ -631,7 +655,7 @@ importers:\n         version: 8.4.0\n       pnpm:\n         specifier: ^8.10.0\n-        version: 8.10.0\n+        version: 8.10.2\n       recast:\n         specifier: ^0.22.0\n         version: 0.22.0\n@@ -697,7 +721,7 @@ importers:\n         version: 8.49.0\n       eslint-config-turbo:\n         specifier: latest\n-        version: 1.10.14(eslint@8.49.0)\n+        version: 1.10.16(eslint@8.49.0)\n       eslint-plugin-import:\n         specifier: 2.26.x\n         version: 2.26.0(@typescript-eslint/parser@6.7.2)(eslint@8.49.0)\n@@ -772,7 +796,7 @@ importers:\n         version: 1.20231030.0\n       ws:\n         specifier: ^8.11.0\n-        version: 8.13.0\n+        version: 8.14.2\n       youch:\n         specifier: ^3.2.2\n         version: 3.2.3\n@@ -791,7 +815,7 @@ importers:\n         version: 4.20231025.0\n       '@microsoft/api-extractor':\n         specifier: ^7.36.3\n-        version: 7.38.1(@types/node@18.16.10)\n+        version: 7.38.2(@types/node@18.16.10)\n       '@types/debug':\n         specifier: ^4.1.7\n         version: 4.1.7\n@@ -815,19 +839,19 @@ importers:\n         version: 0.5.7\n       '@types/stoppable':\n         specifier: ^1.1.1\n-        version: 1.1.2\n+        version: 1.1.3\n       '@types/which':\n         specifier: ^2.0.1\n         version: 2.0.2\n       '@types/ws':\n         specifier: ^8.5.3\n-        version: 8.5.3\n+        version: 8.5.9\n       '@typescript-eslint/eslint-plugin':\n         specifier: ^6.9.0\n-        version: 6.9.1(@typescript-eslint/parser@6.9.1)(eslint@8.49.0)(typescript@5.0.4)\n+        version: 6.10.0(@typescript-eslint/parser@6.10.0)(eslint@8.49.0)(typescript@5.0.4)\n       '@typescript-eslint/parser':\n         specifier: ^6.9.0\n-        version: 6.9.1(eslint@8.49.0)(typescript@5.0.4)\n+        version: 6.10.0(eslint@8.49.0)(typescript@5.0.4)\n       ava:\n         specifier: ^5.2.0\n         version: 5.3.1(@ava/typescript@4.1.0)\n@@ -854,7 +878,7 @@ importers:\n         version: 4.1.0(eslint@8.49.0)\n       eslint-plugin-import:\n         specifier: 2.26.x\n-        version: 2.26.0(@typescript-eslint/parser@6.9.1)(eslint@8.49.0)\n+        version: 2.26.0(@typescript-eslint/parser@6.10.0)(eslint@8.49.0)\n       eslint-plugin-prettier:\n         specifier: ^5.0.1\n         version: 5.0.1(eslint-config-prettier@9.0.0)(eslint@8.49.0)(prettier@3.0.3)\n@@ -4765,7 +4789,7 @@ packages:\n       debug: 4.3.4(supports-color@9.2.2)\n       espree: 9.5.2\n       globals: 13.20.0\n-      ignore: 5.2.4\n+      ignore: 5.2.0\n       import-fresh: 3.3.0\n       js-yaml: 4.1.0\n       minimatch: 3.1.2\n@@ -4782,7 +4806,7 @@ packages:\n       debug: 4.3.4(supports-color@9.2.2)\n       espree: 9.6.1\n       globals: 13.20.0\n-      ignore: 5.2.4\n+      ignore: 5.2.0\n       import-fresh: 3.3.0\n       js-yaml: 4.1.0\n       minimatch: 3.1.2\n@@ -5234,16 +5258,16 @@ packages:\n       typescript: 4.6.4\n     dev: true\n \n-  /@microsoft/api-extractor@7.38.1(@types/node@18.16.10):\n-    resolution: {integrity: sha512-Hxu/RrVpItQ4dzeMyfwlk4lGQFsXMoMS7bYU9YUrpW16hH04PXLRiTXJz77WhBiSGNtTuufz2xh6hWyXhC9JuQ==}\n+  /@microsoft/api-extractor@7.38.2(@types/node@18.16.10):\n+    resolution: {integrity: sha512-JOARuhTwOcOMIU0O2czscoJy3ddVzIRhSA9/7T1ALuZSNphgWsPk+Bv4E7AnBDmTV4pP4lBNLtCxEHjjpWaytQ==}\n     hasBin: true\n     dependencies:\n       '@microsoft/api-extractor-model': 7.28.2(@types/node@18.16.10)\n       '@microsoft/tsdoc': 0.14.2\n       '@microsoft/tsdoc-config': 0.16.1\n       '@rushstack/node-core-library': 3.61.0(@types/node@18.16.10)\n       '@rushstack/rig-package': 0.5.1\n-      '@rushstack/ts-command-line': 4.17.0\n+      '@rushstack/ts-command-line': 4.17.1\n       colors: 1.2.5\n       lodash: 4.17.21\n       resolve: 1.22.2\n@@ -5771,8 +5795,8 @@ packages:\n       string-argv: 0.3.1\n     dev: true\n \n-  /@rushstack/ts-command-line@4.17.0:\n-    resolution: {integrity: sha512-1S0sXuEpZlzKTfvUqNs7Rg4leVkeLJc4Dn9cm+pSIn35a0Ztp5GxPN2gabD2G4RrQoQcJLLyVu+twzrJl1C0eA==}\n+  /@rushstack/ts-command-line@4.17.1:\n+    resolution: {integrity: sha512-2jweO1O57BYP5qdBGl6apJLB+aRIn5ccIRTPDyULh0KMwVzFqWtw6IZWt1qtUoZD/pD2RNkIOosH6Cq45rIYeg==}\n     dependencies:\n       '@types/argparse': 1.0.38\n       argparse: 1.0.10\n@@ -6433,8 +6457,8 @@ packages:\n     resolution: {integrity: sha512-Hl219/BT5fLAaz6NDkSuhzasy49dwQS/DSdu4MdggFB8zcXv7vflBI3xp7FEmkmdDkBUI2bPUNeMttp2knYdxw==}\n     dev: true\n \n-  /@types/stoppable@1.1.2:\n-    resolution: {integrity: sha512-zRBGFTIdkCAdM4VDeFvka5NbD6JVfz7yEYzggKrXQ03ZplrZp5vqQPWHTw0wk81wer61dwi44Tp6FDDXoPBW5A==}\n+  /@types/stoppable@1.1.3:\n+    resolution: {integrity: sha512-7wGKIBJGE4ZxFjk9NkjAxZMLlIXroETqP1FJCdoSvKmEznwmBxQFmTB1dsCkAvVcNemuSZM5qkkd9HE/NL2JTw==}\n     dependencies:\n       '@types/node': 18.16.10\n     dev: true\n@@ -6483,6 +6507,12 @@ packages:\n       '@types/node': 18.16.10\n     dev: true\n \n+  /@types/ws@8.5.9:\n+    resolution: {integrity: sha512-jbdrY0a8lxfdTp/+r7Z4CkycbOFN8WX+IOchLJr3juT/xzbJ8URyTVSJ/hvNdadTgM1mnedb47n+Y31GsFnQlg==}\n+    dependencies:\n+      '@types/node': 18.16.10\n+    dev: true\n+\n   /@types/yargs-parser@20.2.1:\n     resolution: {integrity: sha512-7tFImggNeNBVMsn0vLrpn1H1uPrUBdnARPTpZoitY37ZrdJREzf7I16tMrlK3hen349gr1NYh8CmZQa7CTG6Aw==}\n     dev: true\n@@ -6552,7 +6582,7 @@ packages:\n       graphemer: 1.4.0\n       ignore: 5.2.0\n       natural-compare-lite: 1.4.0\n-      semver: 7.5.4\n+      semver: 7.5.1\n       tsutils: 3.21.0(typescript@4.9.5)\n       typescript: 4.9.5\n     transitivePeerDependencies:\n@@ -6608,15 +6638,15 @@ packages:\n       graphemer: 1.4.0\n       ignore: 5.2.0\n       natural-compare-lite: 1.4.0\n-      semver: 7.5.4\n+      semver: 7.5.1\n       tsutils: 3.21.0(typescript@5.0.3)\n       typescript: 5.0.3\n     transitivePeerDependencies:\n       - supports-color\n     dev: true\n \n-  /@typescript-eslint/eslint-plugin@6.7.2(@typescript-eslint/parser@6.7.2)(eslint@8.49.0)(typescript@4.9.5):\n-    resolution: {integrity: sha512-ooaHxlmSgZTM6CHYAFRlifqh1OAr3PAQEwi7lhYhaegbnXrnh7CDcHmc3+ihhbQC7H0i4JF0psI5ehzkF6Yl6Q==}\n+  /@typescript-eslint/eslint-plugin@6.10.0(@typescript-eslint/parser@6.10.0)(eslint@8.49.0)(typescript@5.0.4):\n+    resolution: {integrity: sha512-uoLj4g2OTL8rfUQVx2AFO1hp/zja1wABJq77P6IclQs6I/m9GLrm7jCdgzZkvWdDCQf1uEvoa8s8CupsgWQgVg==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       '@typescript-eslint/parser': ^6.0.0 || ^6.0.0-alpha\n@@ -6626,26 +6656,26 @@ packages:\n       typescript:\n         optional: true\n     dependencies:\n-      '@eslint-community/regexpp': 4.5.1\n-      '@typescript-eslint/parser': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n-      '@typescript-eslint/scope-manager': 6.7.2\n-      '@typescript-eslint/type-utils': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n-      '@typescript-eslint/utils': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n-      '@typescript-eslint/visitor-keys': 6.7.2\n+      '@eslint-community/regexpp': 4.8.1\n+      '@typescript-eslint/parser': 6.10.0(eslint@8.49.0)(typescript@5.0.4)\n+      '@typescript-eslint/scope-manager': 6.10.0\n+      '@typescript-eslint/type-utils': 6.10.0(eslint@8.49.0)(typescript@5.0.4)\n+      '@typescript-eslint/utils': 6.10.0(eslint@8.49.0)(typescript@5.0.4)\n+      '@typescript-eslint/visitor-keys': 6.10.0\n       debug: 4.3.4(supports-color@9.2.2)\n       eslint: 8.49.0\n       graphemer: 1.4.0\n       ignore: 5.2.4\n       natural-compare: 1.4.0\n       semver: 7.5.4\n-      ts-api-utils: 1.0.3(typescript@4.9.5)\n-      typescript: 4.9.5\n+      ts-api-utils: 1.0.3(typescript@5.0.4)\n+      typescript: 5.0.4\n     transitivePeerDependencies:\n       - supports-color\n-    dev: false\n+    dev: true\n \n-  /@typescript-eslint/eslint-plugin@6.9.1(@typescript-eslint/parser@6.9.1)(eslint@8.49.0)(typescript@5.0.4):\n-    resolution: {integrity: sha512-w0tiiRc9I4S5XSXXrMHOWgHgxbrBn1Ro+PmiYhSg2ZVdxrAJtQgzU5o2m1BfP6UOn7Vxcc6152vFjQfmZR4xEg==}\n+  /@typescript-eslint/eslint-plugin@6.7.2(@typescript-eslint/parser@6.7.2)(eslint@8.49.0)(typescript@4.9.5):\n+    resolution: {integrity: sha512-ooaHxlmSgZTM6CHYAFRlifqh1OAr3PAQEwi7lhYhaegbnXrnh7CDcHmc3+ihhbQC7H0i4JF0psI5ehzkF6Yl6Q==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       '@typescript-eslint/parser': ^6.0.0 || ^6.0.0-alpha\n@@ -6655,23 +6685,23 @@ packages:\n       typescript:\n         optional: true\n     dependencies:\n-      '@eslint-community/regexpp': 4.8.1\n-      '@typescript-eslint/parser': 6.9.1(eslint@8.49.0)(typescript@5.0.4)\n-      '@typescript-eslint/scope-manager': 6.9.1\n-      '@typescript-eslint/type-utils': 6.9.1(eslint@8.49.0)(typescript@5.0.4)\n-      '@typescript-eslint/utils': 6.9.1(eslint@8.49.0)(typescript@5.0.4)\n-      '@typescript-eslint/visitor-keys': 6.9.1\n+      '@eslint-community/regexpp': 4.5.1\n+      '@typescript-eslint/parser': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n+      '@typescript-eslint/scope-manager': 6.7.2\n+      '@typescript-eslint/type-utils': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n+      '@typescript-eslint/utils': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n+      '@typescript-eslint/visitor-keys': 6.7.2\n       debug: 4.3.4(supports-color@9.2.2)\n       eslint: 8.49.0\n       graphemer: 1.4.0\n       ignore: 5.2.4\n       natural-compare: 1.4.0\n       semver: 7.5.4\n-      ts-api-utils: 1.0.3(typescript@5.0.4)\n-      typescript: 5.0.4\n+      ts-api-utils: 1.0.3(typescript@4.9.5)\n+      typescript: 4.9.5\n     transitivePeerDependencies:\n       - supports-color\n-    dev: true\n+    dev: false\n \n   /@typescript-eslint/parser@5.59.9(eslint@8.49.0)(typescript@5.0.3):\n     resolution: {integrity: sha512-FsPkRvBtcLQ/eVK1ivDiNYBjn3TGJdXy2fhXX+rc7czWl4ARwnpArwbihSOHI2Peg9WbtGHrbThfBUkZZGTtvQ==}\n@@ -6753,8 +6783,8 @@ packages:\n       - supports-color\n     dev: true\n \n-  /@typescript-eslint/parser@6.7.2(eslint@8.49.0)(typescript@4.9.5):\n-    resolution: {integrity: sha512-KA3E4ox0ws+SPyxQf9iSI25R6b4Ne78ORhNHeVKrPQnoYsb9UhieoiRoJgrzgEeKGOXhcY1i8YtOeCHHTDa6Fw==}\n+  /@typescript-eslint/parser@6.10.0(eslint@8.49.0)(typescript@5.0.4):\n+    resolution: {integrity: sha512-+sZwIj+s+io9ozSxIWbNB5873OSdfeBEH/FR0re14WLI6BaKuSOnnwCJ2foUiu8uXf4dRp1UqHP0vrZ1zXGrog==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       eslint: ^7.0.0 || ^8.0.0\n@@ -6763,19 +6793,19 @@ packages:\n       typescript:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/scope-manager': 6.7.2\n-      '@typescript-eslint/types': 6.7.2\n-      '@typescript-eslint/typescript-estree': 6.7.2(typescript@4.9.5)\n-      '@typescript-eslint/visitor-keys': 6.7.2\n+      '@typescript-eslint/scope-manager': 6.10.0\n+      '@typescript-eslint/types': 6.10.0\n+      '@typescript-eslint/typescript-estree': 6.10.0(typescript@5.0.4)\n+      '@typescript-eslint/visitor-keys': 6.10.0\n       debug: 4.3.4(supports-color@9.2.2)\n       eslint: 8.49.0\n-      typescript: 4.9.5\n+      typescript: 5.0.4\n     transitivePeerDependencies:\n       - supports-color\n-    dev: false\n+    dev: true\n \n-  /@typescript-eslint/parser@6.9.1(eslint@8.49.0)(typescript@5.0.4):\n-    resolution: {integrity: sha512-C7AK2wn43GSaCUZ9do6Ksgi2g3mwFkMO3Cis96kzmgudoVaKyt62yNzJOktP0HDLb/iO2O0n2lBOzJgr6Q/cyg==}\n+  /@typescript-eslint/parser@6.7.2(eslint@8.49.0)(typescript@4.9.5):\n+    resolution: {integrity: sha512-KA3E4ox0ws+SPyxQf9iSI25R6b4Ne78ORhNHeVKrPQnoYsb9UhieoiRoJgrzgEeKGOXhcY1i8YtOeCHHTDa6Fw==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       eslint: ^7.0.0 || ^8.0.0\n@@ -6784,16 +6814,16 @@ packages:\n       typescript:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/scope-manager': 6.9.1\n-      '@typescript-eslint/types': 6.9.1\n-      '@typescript-eslint/typescript-estree': 6.9.1(typescript@5.0.4)\n-      '@typescript-eslint/visitor-keys': 6.9.1\n+      '@typescript-eslint/scope-manager': 6.7.2\n+      '@typescript-eslint/types': 6.7.2\n+      '@typescript-eslint/typescript-estree': 6.7.2(typescript@4.9.5)\n+      '@typescript-eslint/visitor-keys': 6.7.2\n       debug: 4.3.4(supports-color@9.2.2)\n       eslint: 8.49.0\n-      typescript: 5.0.4\n+      typescript: 4.9.5\n     transitivePeerDependencies:\n       - supports-color\n-    dev: true\n+    dev: false\n \n   /@typescript-eslint/scope-manager@5.59.9:\n     resolution: {integrity: sha512-8RA+E+w78z1+2dzvK/tGZ2cpGigBZ58VMEHDZtpE1v+LLjzrYGc8mMaTONSxKyEkz3IuXFM0IqYiGHlCsmlZxQ==}\n@@ -6811,6 +6841,14 @@ packages:\n       '@typescript-eslint/visitor-keys': 5.62.0\n     dev: true\n \n+  /@typescript-eslint/scope-manager@6.10.0:\n+    resolution: {integrity: sha512-TN/plV7dzqqC2iPNf1KrxozDgZs53Gfgg5ZHyw8erd6jd5Ta/JIEcdCheXFt9b1NYb93a1wmIIVW/2gLkombDg==}\n+    engines: {node: ^16.0.0 || >=18.0.0}\n+    dependencies:\n+      '@typescript-eslint/types': 6.10.0\n+      '@typescript-eslint/visitor-keys': 6.10.0\n+    dev: true\n+\n   /@typescript-eslint/scope-manager@6.7.2:\n     resolution: {integrity: sha512-bgi6plgyZjEqapr7u2mhxGR6E8WCzKNUFWNh6fkpVe9+yzRZeYtDTbsIBzKbcxI+r1qVWt6VIoMSNZ4r2A+6Yw==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n@@ -6819,14 +6857,6 @@ packages:\n       '@typescript-eslint/visitor-keys': 6.7.2\n     dev: false\n \n-  /@typescript-eslint/scope-manager@6.9.1:\n-    resolution: {integrity: sha512-38IxvKB6NAne3g/+MyXMs2Cda/Sz+CEpmm+KLGEM8hx/CvnSRuw51i8ukfwB/B/sESdeTGet1NH1Wj7I0YXswg==}\n-    engines: {node: ^16.0.0 || >=18.0.0}\n-    dependencies:\n-      '@typescript-eslint/types': 6.9.1\n-      '@typescript-eslint/visitor-keys': 6.9.1\n-    dev: true\n-\n   /@typescript-eslint/type-utils@5.59.9(eslint@8.49.0)(typescript@5.0.3):\n     resolution: {integrity: sha512-ksEsT0/mEHg9e3qZu98AlSrONAQtrSTljL3ow9CGej8eRo7pe+yaC/mvTjptp23Xo/xIf2mLZKC6KPv4Sji26Q==}\n     engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}\n@@ -6907,8 +6937,8 @@ packages:\n       - supports-color\n     dev: true\n \n-  /@typescript-eslint/type-utils@6.7.2(eslint@8.49.0)(typescript@4.9.5):\n-    resolution: {integrity: sha512-36F4fOYIROYRl0qj95dYKx6kybddLtsbmPIYNK0OBeXv2j9L5nZ17j9jmfy+bIDHKQgn2EZX+cofsqi8NPATBQ==}\n+  /@typescript-eslint/type-utils@6.10.0(eslint@8.49.0)(typescript@5.0.4):\n+    resolution: {integrity: sha512-wYpPs3hgTFblMYwbYWPT3eZtaDOjbLyIYuqpwuLBBqhLiuvJ+9sEp2gNRJEtR5N/c9G1uTtQQL5AhV0fEPJYcg==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       eslint: ^7.0.0 || ^8.0.0\n@@ -6917,18 +6947,18 @@ packages:\n       typescript:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/typescript-estree': 6.7.2(typescript@4.9.5)\n-      '@typescript-eslint/utils': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n+      '@typescript-eslint/typescript-estree': 6.10.0(typescript@5.0.4)\n+      '@typescript-eslint/utils': 6.10.0(eslint@8.49.0)(typescript@5.0.4)\n       debug: 4.3.4(supports-color@9.2.2)\n       eslint: 8.49.0\n-      ts-api-utils: 1.0.3(typescript@4.9.5)\n-      typescript: 4.9.5\n+      ts-api-utils: 1.0.3(typescript@5.0.4)\n+      typescript: 5.0.4\n     transitivePeerDependencies:\n       - supports-color\n-    dev: false\n+    dev: true\n \n-  /@typescript-eslint/type-utils@6.9.1(eslint@8.49.0)(typescript@5.0.4):\n-    resolution: {integrity: sha512-eh2oHaUKCK58qIeYp19F5V5TbpM52680sB4zNSz29VBQPTWIlE/hCj5P5B1AChxECe/fmZlspAWFuRniep1Skg==}\n+  /@typescript-eslint/type-utils@6.7.2(eslint@8.49.0)(typescript@4.9.5):\n+    resolution: {integrity: sha512-36F4fOYIROYRl0qj95dYKx6kybddLtsbmPIYNK0OBeXv2j9L5nZ17j9jmfy+bIDHKQgn2EZX+cofsqi8NPATBQ==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       eslint: ^7.0.0 || ^8.0.0\n@@ -6937,15 +6967,15 @@ packages:\n       typescript:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/typescript-estree': 6.9.1(typescript@5.0.4)\n-      '@typescript-eslint/utils': 6.9.1(eslint@8.49.0)(typescript@5.0.4)\n+      '@typescript-eslint/typescript-estree': 6.7.2(typescript@4.9.5)\n+      '@typescript-eslint/utils': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n       debug: 4.3.4(supports-color@9.2.2)\n       eslint: 8.49.0\n-      ts-api-utils: 1.0.3(typescript@5.0.4)\n-      typescript: 5.0.4\n+      ts-api-utils: 1.0.3(typescript@4.9.5)\n+      typescript: 4.9.5\n     transitivePeerDependencies:\n       - supports-color\n-    dev: true\n+    dev: false\n \n   /@typescript-eslint/types@5.59.9:\n     resolution: {integrity: sha512-uW8H5NRgTVneSVTfiCVffBb8AbwWSKg7qcA4Ot3JI3MPCJGsB4Db4BhvAODIIYE5mNj7Q+VJkK7JxmRhk2Lyjw==}\n@@ -6957,16 +6987,16 @@ packages:\n     engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}\n     dev: true\n \n+  /@typescript-eslint/types@6.10.0:\n+    resolution: {integrity: sha512-36Fq1PWh9dusgo3vH7qmQAj5/AZqARky1Wi6WpINxB6SkQdY5vQoT2/7rW7uBIsPDcvvGCLi4r10p0OJ7ITAeg==}\n+    engines: {node: ^16.0.0 || >=18.0.0}\n+    dev: true\n+\n   /@typescript-eslint/types@6.7.2:\n     resolution: {integrity: sha512-flJYwMYgnUNDAN9/GAI3l8+wTmvTYdv64fcH8aoJK76Y+1FCZ08RtI5zDerM/FYT5DMkAc+19E4aLmd5KqdFyg==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     dev: false\n \n-  /@typescript-eslint/types@6.9.1:\n-    resolution: {integrity: sha512-BUGslGOb14zUHOUmDB2FfT6SI1CcZEJYfF3qFwBeUrU6srJfzANonwRYHDpLBuzbq3HaoF2XL2hcr01c8f8OaQ==}\n-    engines: {node: ^16.0.0 || >=18.0.0}\n-    dev: true\n-\n   /@typescript-eslint/typescript-estree@5.59.9(typescript@4.9.5):\n     resolution: {integrity: sha512-pmM0/VQ7kUhd1QyIxgS+aRvMgw+ZljB3eDb+jYyp6d2bC0mQWLzUDF+DLwCTkQ3tlNyVsvZRXjFyV0LkU/aXjA==}\n     engines: {node: ^12.22.0 || ^14.17.0 || >=16.0.0}\n@@ -7051,47 +7081,47 @@ packages:\n       - supports-color\n     dev: true\n \n-  /@typescript-eslint/typescript-estree@6.7.2(typescript@4.9.5):\n-    resolution: {integrity: sha512-kiJKVMLkoSciGyFU0TOY0fRxnp9qq1AzVOHNeN1+B9erKFCJ4Z8WdjAkKQPP+b1pWStGFqezMLltxO+308dJTQ==}\n+  /@typescript-eslint/typescript-estree@6.10.0(typescript@5.0.4):\n+    resolution: {integrity: sha512-ek0Eyuy6P15LJVeghbWhSrBCj/vJpPXXR+EpaRZqou7achUWL8IdYnMSC5WHAeTWswYQuP2hAZgij/bC9fanBg==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       typescript: '*'\n     peerDependenciesMeta:\n       typescript:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/types': 6.7.2\n-      '@typescript-eslint/visitor-keys': 6.7.2\n+      '@typescript-eslint/types': 6.10.0\n+      '@typescript-eslint/visitor-keys': 6.10.0\n       debug: 4.3.4(supports-color@9.2.2)\n       globby: 11.1.0\n       is-glob: 4.0.3\n       semver: 7.5.4\n-      ts-api-utils: 1.0.3(typescript@4.9.5)\n-      typescript: 4.9.5\n+      ts-api-utils: 1.0.3(typescript@5.0.4)\n+      typescript: 5.0.4\n     transitivePeerDependencies:\n       - supports-color\n-    dev: false\n+    dev: true\n \n-  /@typescript-eslint/typescript-estree@6.9.1(typescript@5.0.4):\n-    resolution: {integrity: sha512-U+mUylTHfcqeO7mLWVQ5W/tMLXqVpRv61wm9ZtfE5egz7gtnmqVIw9ryh0mgIlkKk9rZLY3UHygsBSdB9/ftyw==}\n+  /@typescript-eslint/typescript-estree@6.7.2(typescript@4.9.5):\n+    resolution: {integrity: sha512-kiJKVMLkoSciGyFU0TOY0fRxnp9qq1AzVOHNeN1+B9erKFCJ4Z8WdjAkKQPP+b1pWStGFqezMLltxO+308dJTQ==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       typescript: '*'\n     peerDependenciesMeta:\n       typescript:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/types': 6.9.1\n-      '@typescript-eslint/visitor-keys': 6.9.1\n+      '@typescript-eslint/types': 6.7.2\n+      '@typescript-eslint/visitor-keys': 6.7.2\n       debug: 4.3.4(supports-color@9.2.2)\n       globby: 11.1.0\n       is-glob: 4.0.3\n       semver: 7.5.4\n-      ts-api-utils: 1.0.3(typescript@5.0.4)\n-      typescript: 5.0.4\n+      ts-api-utils: 1.0.3(typescript@4.9.5)\n+      typescript: 4.9.5\n     transitivePeerDependencies:\n       - supports-color\n-    dev: true\n+    dev: false\n \n   /@typescript-eslint/utils@5.59.9(eslint@8.42.0)(typescript@4.9.5):\n     resolution: {integrity: sha512-1PuMYsju/38I5Ggblaeb98TOoUvjhRvLpLa1DoTOFaLWqaXl/1iQ1eGurTXgBY58NUdtfTXKP5xBq7q9NDaLKg==}\n@@ -7107,7 +7137,7 @@ packages:\n       '@typescript-eslint/typescript-estree': 5.59.9(typescript@4.9.5)\n       eslint: 8.42.0\n       eslint-scope: 5.1.1\n-      semver: 7.5.4\n+      semver: 7.5.1\n     transitivePeerDependencies:\n       - supports-color\n       - typescript\n@@ -7127,7 +7157,7 @@ packages:\n       '@typescript-eslint/typescript-estree': 5.59.9(typescript@5.0.3)\n       eslint: 8.49.0\n       eslint-scope: 5.1.1\n-      semver: 7.5.4\n+      semver: 7.5.1\n     transitivePeerDependencies:\n       - supports-color\n       - typescript\n@@ -7193,43 +7223,43 @@ packages:\n       - typescript\n     dev: true\n \n-  /@typescript-eslint/utils@6.7.2(eslint@8.49.0)(typescript@4.9.5):\n-    resolution: {integrity: sha512-ZCcBJug/TS6fXRTsoTkgnsvyWSiXwMNiPzBUani7hDidBdj1779qwM1FIAmpH4lvlOZNF3EScsxxuGifjpLSWQ==}\n+  /@typescript-eslint/utils@6.10.0(eslint@8.49.0)(typescript@5.0.4):\n+    resolution: {integrity: sha512-v+pJ1/RcVyRc0o4wAGux9x42RHmAjIGzPRo538Z8M1tVx6HOnoQBCX/NoadHQlZeC+QO2yr4nNSFWOoraZCAyg==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       eslint: ^7.0.0 || ^8.0.0\n     dependencies:\n       '@eslint-community/eslint-utils': 4.4.0(eslint@8.49.0)\n       '@types/json-schema': 7.0.13\n       '@types/semver': 7.5.1\n-      '@typescript-eslint/scope-manager': 6.7.2\n-      '@typescript-eslint/types': 6.7.2\n-      '@typescript-eslint/typescript-estree': 6.7.2(typescript@4.9.5)\n+      '@typescript-eslint/scope-manager': 6.10.0\n+      '@typescript-eslint/types': 6.10.0\n+      '@typescript-eslint/typescript-estree': 6.10.0(typescript@5.0.4)\n       eslint: 8.49.0\n       semver: 7.5.4\n     transitivePeerDependencies:\n       - supports-color\n       - typescript\n-    dev: false\n+    dev: true\n \n-  /@typescript-eslint/utils@6.9.1(eslint@8.49.0)(typescript@5.0.4):\n-    resolution: {integrity: sha512-L1T0A5nFdQrMVunpZgzqPL6y2wVreSyHhKGZryS6jrEN7bD9NplVAyMryUhXsQ4TWLnZmxc2ekar/lSGIlprCA==}\n+  /@typescript-eslint/utils@6.7.2(eslint@8.49.0)(typescript@4.9.5):\n+    resolution: {integrity: sha512-ZCcBJug/TS6fXRTsoTkgnsvyWSiXwMNiPzBUani7hDidBdj1779qwM1FIAmpH4lvlOZNF3EScsxxuGifjpLSWQ==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n     peerDependencies:\n       eslint: ^7.0.0 || ^8.0.0\n     dependencies:\n       '@eslint-community/eslint-utils': 4.4.0(eslint@8.49.0)\n       '@types/json-schema': 7.0.13\n       '@types/semver': 7.5.1\n-      '@typescript-eslint/scope-manager': 6.9.1\n-      '@typescript-eslint/types': 6.9.1\n-      '@typescript-eslint/typescript-estree': 6.9.1(typescript@5.0.4)\n+      '@typescript-eslint/scope-manager': 6.7.2\n+      '@typescript-eslint/types': 6.7.2\n+      '@typescript-eslint/typescript-estree': 6.7.2(typescript@4.9.5)\n       eslint: 8.49.0\n       semver: 7.5.4\n     transitivePeerDependencies:\n       - supports-color\n       - typescript\n-    dev: true\n+    dev: false\n \n   /@typescript-eslint/visitor-keys@5.59.9:\n     resolution: {integrity: sha512-bT7s0td97KMaLwpEBckbzj/YohnvXtqbe2XgqNvTl6RJVakY5mvENOTPvw5u66nljfZxthESpDozs86U+oLY8Q==}\n@@ -7247,6 +7277,14 @@ packages:\n       eslint-visitor-keys: 3.4.3\n     dev: true\n \n+  /@typescript-eslint/visitor-keys@6.10.0:\n+    resolution: {integrity: sha512-xMGluxQIEtOM7bqFCo+rCMh5fqI+ZxV5RUUOa29iVPz1OgCZrtc7rFnz5cLUazlkPKYqX+75iuDq7m0HQ48nCg==}\n+    engines: {node: ^16.0.0 || >=18.0.0}\n+    dependencies:\n+      '@typescript-eslint/types': 6.10.0\n+      eslint-visitor-keys: 3.4.3\n+    dev: true\n+\n   /@typescript-eslint/visitor-keys@6.7.2:\n     resolution: {integrity: sha512-uVw9VIMFBUTz8rIeaUT3fFe8xIUx8r4ywAdlQv1ifH+6acn/XF8Y6rwJ7XNmkNMDrTW+7+vxFFPIF40nJCVsMQ==}\n     engines: {node: ^16.0.0 || >=18.0.0}\n@@ -7255,14 +7293,6 @@ packages:\n       eslint-visitor-keys: 3.4.1\n     dev: false\n \n-  /@typescript-eslint/visitor-keys@6.9.1:\n-    resolution: {integrity: sha512-MUaPUe/QRLEffARsmNfmpghuQkW436DvESW+h+M52w0coICHRfD6Np9/K6PdACwnrq1HmuLl+cSPZaJmeVPkSw==}\n-    engines: {node: ^16.0.0 || >=18.0.0}\n-    dependencies:\n-      '@typescript-eslint/types': 6.9.1\n-      eslint-visitor-keys: 3.4.3\n-    dev: true\n-\n   /@vanilla-extract/babel-plugin-debug-ids@1.0.3:\n     resolution: {integrity: sha512-vm4jYu1xhSa6ofQ9AhIpR3DkAp4c+eoR1Rpm8/TQI4DmWbmGbOjYRcqV0aWsfaIlNhN4kFuxFMKBNN9oG6iRzA==}\n     dependencies:\n@@ -7635,7 +7665,7 @@ packages:\n     engines: {node: '>= 0.4'}\n     dependencies:\n       call-bind: 1.0.2\n-      define-properties: 1.2.1\n+      define-properties: 1.2.0\n       es-abstract: 1.22.1\n       es-array-method-boxes-properly: 1.0.0\n       get-intrinsic: 1.2.1\n@@ -7657,7 +7687,7 @@ packages:\n     dependencies:\n       array-buffer-byte-length: 1.0.0\n       call-bind: 1.0.2\n-      define-properties: 1.2.1\n+      define-properties: 1.2.0\n       get-intrinsic: 1.2.1\n       is-array-buffer: 3.0.2\n       is-shared-array-buffer: 1.0.2\n@@ -8734,7 +8764,7 @@ packages:\n       js-string-escape: 1.0.1\n       lodash: 4.17.21\n       md5-hex: 3.0.1\n-      semver: 7.5.4\n+      semver: 7.5.1\n       well-known-symbols: 2.0.0\n     dev: true\n \n@@ -9215,6 +9245,7 @@ packages:\n       get-intrinsic: 1.2.1\n       gopd: 1.0.1\n       has-property-descriptors: 1.0.0\n+    dev: false\n \n   /define-lazy-prop@2.0.0:\n     resolution: {integrity: sha512-Ds09qNh8yw3khSjiJjiUInaGX9xlqZDY7JVryGxdxV7NPeuqQfplOpQ66yJFZut3jLa5zOwkXw1g9EI2uKh4Og==}\n@@ -9240,6 +9271,7 @@ packages:\n       define-data-property: 1.1.0\n       has-property-descriptors: 1.0.0\n       object-keys: 1.1.1\n+    dev: false\n \n   /define-property@0.2.5:\n     resolution: {integrity: sha512-Rr7ADjQZenceVOAKop6ALkkRAmH1A4Gx9hV/7ZujPUN2rkATqFO0JZLZInbAjpZYoJ1gUx8MRMQVkYemcbMSTA==}\n@@ -9882,13 +9914,13 @@ packages:\n       eslint: 8.49.0\n     dev: true\n \n-  /eslint-config-turbo@1.10.14(eslint@8.49.0):\n-    resolution: {integrity: sha512-ZeB+IcuFXy1OICkLuAplVa0euoYbhK+bMEQd0nH9+Lns18lgZRm33mVz/iSoH9VdUzl/1ZmFmoK+RpZc+8R80A==}\n+  /eslint-config-turbo@1.10.16(eslint@8.49.0):\n+    resolution: {integrity: sha512-O3NQI72bQHV7FvSC6lWj66EGx8drJJjuT1kuInn6nbMLOHdMBhSUX/8uhTAlHRQdlxZk2j9HtgFCIzSc93w42g==}\n     peerDependencies:\n       eslint: '>6.6.0'\n     dependencies:\n       eslint: 8.49.0\n-      eslint-plugin-turbo: 1.10.14(eslint@8.49.0)\n+      eslint-plugin-turbo: 1.10.16(eslint@8.49.0)\n     dev: false\n \n   /eslint-import-resolver-node@0.3.7:\n@@ -9954,7 +9986,7 @@ packages:\n       - supports-color\n     dev: true\n \n-  /eslint-module-utils@2.8.0(@typescript-eslint/parser@6.7.2)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0):\n+  /eslint-module-utils@2.8.0(@typescript-eslint/parser@6.10.0)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0):\n     resolution: {integrity: sha512-aWajIYfsqCKRDgUfjEXNN/JlrzauMuSEy5sbd7WXbtW3EH6A6MpwEh42c7qD+MqQo9QMJ6fWLAeIJynx0g6OAw==}\n     engines: {node: '>=4'}\n     peerDependencies:\n@@ -9975,15 +10007,15 @@ packages:\n       eslint-import-resolver-webpack:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/parser': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n+      '@typescript-eslint/parser': 6.10.0(eslint@8.49.0)(typescript@5.0.4)\n       debug: 3.2.7\n       eslint: 8.49.0\n       eslint-import-resolver-node: 0.3.7\n     transitivePeerDependencies:\n       - supports-color\n-    dev: false\n+    dev: true\n \n-  /eslint-module-utils@2.8.0(@typescript-eslint/parser@6.9.1)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0):\n+  /eslint-module-utils@2.8.0(@typescript-eslint/parser@6.7.2)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0):\n     resolution: {integrity: sha512-aWajIYfsqCKRDgUfjEXNN/JlrzauMuSEy5sbd7WXbtW3EH6A6MpwEh42c7qD+MqQo9QMJ6fWLAeIJynx0g6OAw==}\n     engines: {node: '>=4'}\n     peerDependencies:\n@@ -10004,13 +10036,13 @@ packages:\n       eslint-import-resolver-webpack:\n         optional: true\n     dependencies:\n-      '@typescript-eslint/parser': 6.9.1(eslint@8.49.0)(typescript@5.0.4)\n+      '@typescript-eslint/parser': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n       debug: 3.2.7\n       eslint: 8.49.0\n       eslint-import-resolver-node: 0.3.7\n     transitivePeerDependencies:\n       - supports-color\n-    dev: true\n+    dev: false\n \n   /eslint-plugin-es@3.0.1(eslint@8.42.0):\n     resolution: {integrity: sha512-GUmAsJaN4Fc7Gbtl8uOBlayo2DqhwWvEzykMHSCZHU3XdJ+NSzzZcVhXh3VxX5icqQ+oQdIEawXX8xkR3mIFmQ==}\n@@ -10034,7 +10066,7 @@ packages:\n       regexpp: 3.2.0\n     dev: true\n \n-  /eslint-plugin-import@2.26.0(@typescript-eslint/parser@6.7.2)(eslint@8.49.0):\n+  /eslint-plugin-import@2.26.0(@typescript-eslint/parser@6.10.0)(eslint@8.49.0):\n     resolution: {integrity: sha512-hYfi3FXaM8WPLf4S1cikh/r4IxnO6zrhZbEGz2b660EJRbuxgpDS5gkCuYgGWg2xxh2rBuIr4Pvhve/7c31koA==}\n     engines: {node: '>=4'}\n     peerDependencies:\n@@ -10044,14 +10076,14 @@ packages:\n       '@typescript-eslint/parser':\n         optional: true\n     dependencies:\n-      '@typescript-eslint/parser': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n+      '@typescript-eslint/parser': 6.10.0(eslint@8.49.0)(typescript@5.0.4)\n       array-includes: 3.1.6\n       array.prototype.flat: 1.3.1\n       debug: 2.6.9(supports-color@9.2.2)\n       doctrine: 2.1.0\n       eslint: 8.49.0\n       eslint-import-resolver-node: 0.3.7\n-      eslint-module-utils: 2.8.0(@typescript-eslint/parser@6.7.2)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0)\n+      eslint-module-utils: 2.8.0(@typescript-eslint/parser@6.10.0)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0)\n       has: 1.0.3\n       is-core-module: 2.13.0\n       is-glob: 4.0.3\n@@ -10063,9 +10095,9 @@ packages:\n       - eslint-import-resolver-typescript\n       - eslint-import-resolver-webpack\n       - supports-color\n-    dev: false\n+    dev: true\n \n-  /eslint-plugin-import@2.26.0(@typescript-eslint/parser@6.9.1)(eslint@8.49.0):\n+  /eslint-plugin-import@2.26.0(@typescript-eslint/parser@6.7.2)(eslint@8.49.0):\n     resolution: {integrity: sha512-hYfi3FXaM8WPLf4S1cikh/r4IxnO6zrhZbEGz2b660EJRbuxgpDS5gkCuYgGWg2xxh2rBuIr4Pvhve/7c31koA==}\n     engines: {node: '>=4'}\n     peerDependencies:\n@@ -10075,14 +10107,14 @@ packages:\n       '@typescript-eslint/parser':\n         optional: true\n     dependencies:\n-      '@typescript-eslint/parser': 6.9.1(eslint@8.49.0)(typescript@5.0.4)\n+      '@typescript-eslint/parser': 6.7.2(eslint@8.49.0)(typescript@4.9.5)\n       array-includes: 3.1.6\n       array.prototype.flat: 1.3.1\n       debug: 2.6.9(supports-color@9.2.2)\n       doctrine: 2.1.0\n       eslint: 8.49.0\n       eslint-import-resolver-node: 0.3.7\n-      eslint-module-utils: 2.8.0(@typescript-eslint/parser@6.9.1)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0)\n+      eslint-module-utils: 2.8.0(@typescript-eslint/parser@6.7.2)(eslint-import-resolver-node@0.3.7)(eslint@8.49.0)\n       has: 1.0.3\n       is-core-module: 2.13.0\n       is-glob: 4.0.3\n@@ -10094,7 +10126,7 @@ packages:\n       - eslint-import-resolver-typescript\n       - eslint-import-resolver-webpack\n       - supports-color\n-    dev: true\n+    dev: false\n \n   /eslint-plugin-import@2.27.5(@typescript-eslint/parser@5.62.0)(eslint-import-resolver-typescript@3.5.5)(eslint@8.42.0):\n     resolution: {integrity: sha512-LmEt3GVofgiGuiE+ORpnvP+kAm3h6MLZJ4Q5HCyHADofsb4VzXFsRiWj3c0OFiV+3DWFh0qg3v9gcPlfc3zRow==}\n@@ -10315,8 +10347,8 @@ packages:\n       - typescript\n     dev: true\n \n-  /eslint-plugin-turbo@1.10.14(eslint@8.49.0):\n-    resolution: {integrity: sha512-sBdBDnYr9AjT1g4lR3PBkZDonTrMnR4TvuGv5W0OiF7z9az1rI68yj2UHJZvjkwwcGu5mazWA1AfB0oaagpmfg==}\n+  /eslint-plugin-turbo@1.10.16(eslint@8.49.0):\n+    resolution: {integrity: sha512-ZjrR88MTN64PNGufSEcM0tf+V1xFYVbeiMeuIqr0aiABGomxFLo4DBkQ7WI4WzkZtWQSIA2sP+yxqSboEfL9MQ==}\n     peerDependencies:\n       eslint: '>6.6.0'\n     dependencies:\n@@ -11184,7 +11216,7 @@ packages:\n     engines: {node: '>= 0.4'}\n     dependencies:\n       call-bind: 1.0.2\n-      define-properties: 1.2.1\n+      define-properties: 1.2.0\n       es-abstract: 1.22.1\n       functions-have-names: 1.2.3\n \n@@ -11233,6 +11265,11 @@ packages:\n     engines: {node: ^12.20.0 || ^14.13.1 || >=16.0.0}\n     dev: true\n \n+  /get-port@7.0.0:\n+    resolution: {integrity: sha512-mDHFgApoQd+azgMdwylJrv2DX47ywGq1i5VFJE7fZ0dttNq3iQMfsU4IvEgBHojA3KqEudyu7Vq+oN8kNaNkWw==}\n+    engines: {node: '>=16'}\n+    dev: true\n+\n   /get-source@2.0.12:\n     resolution: {integrity: sha512-X5+4+iD+HoSeEED+uwrQ07BOQr0kEDFMVqqpBuI+RaZBpBpHCuXxo70bjar6f0b0u/DQJsJ7ssurpP0V60Az+w==}\n     dependencies:\n@@ -11964,7 +12001,7 @@ packages:\n       mute-stream: 0.0.8\n       ora: 5.4.1\n       run-async: 2.4.1\n-      rxjs: 7.8.0\n+      rxjs: 7.8.1\n       string-width: 4.2.3\n       strip-ansi: 6.0.1\n       through: 2.3.8\n@@ -15173,8 +15210,8 @@ packages:\n       irregular-plurals: 3.5.0\n     dev: true\n \n-  /pnpm@8.10.0:\n-    resolution: {integrity: sha512-nCy4Pyts9qJdjFgwC/mRl8fvO+hM8+dm8pBUtAuDtC+Kq6b8wxSp7PJ8APfOgKdXu0xgiADnrb4tKdxccFb1vg==}\n+  /pnpm@8.10.2:\n+    resolution: {integrity: sha512-B4IJPVumx62UYggbwe8HdQFqS0EJ7KHh/tzqbxEBQ69fUJk9s2xCfU+oxivjkgoyJNsS2nGdJGyhndnxgEjDPA==}\n     engines: {node: '>=16.14'}\n     hasBin: true\n     dev: true\n@@ -16431,7 +16468,6 @@ packages:\n     hasBin: true\n     dependencies:\n       lru-cache: 6.0.0\n-    dev: true\n \n   /semver@7.5.4:\n     resolution: {integrity: sha512-1bCSESV6Pv+i21Hvpxp3Dx+pSD8lIPt8uVjRrxAUt/nbswYc+tK6Y2btiULjd4+fnq15PX+nqQDC7Oft7WkwcA==}\n@@ -16974,21 +17010,21 @@ packages:\n     engines: {node: '>= 0.4'}\n     dependencies:\n       call-bind: 1.0.2\n-      define-properties: 1.2.1\n+      define-properties: 1.2.0\n       es-abstract: 1.22.1\n \n   /string.prototype.trimend@1.0.6:\n     resolution: {integrity: sha512-JySq+4mrPf9EsDBEDYMOb/lM7XQLulwg5R/m1r0PXEFqrV0qHvl58sdTilSXtKOflCsK2E8jxf+GKC0T07RWwQ==}\n     dependencies:\n       call-bind: 1.0.2\n-      define-properties: 1.2.1\n+      define-properties: 1.2.0\n       es-abstract: 1.22.1\n \n   /string.prototype.trimstart@1.0.6:\n     resolution: {integrity: sha512-omqjMDaY92pbn5HOX7f9IccLA+U1tA9GvtU4JrodiXFfYB7jPzzHpRzpglLAjtUV6bB557zwClJezTqnAiYnQA==}\n     dependencies:\n       call-bind: 1.0.2\n-      define-properties: 1.2.1\n+      define-properties: 1.2.0\n       es-abstract: 1.22.1\n \n   /string_decoder@0.10.31:\n@@ -18503,8 +18539,8 @@ packages:\n         optional: true\n     dev: true\n \n-  /ws@8.13.0:\n-    resolution: {integrity: sha512-x9vcZYTrFPC7aSIbj7sRCYo7L/Xb8Iy+pW0ng0wt2vCJv7M9HOMy0UoN3rr+IFC7hb7vXoqS+P9ktyLLLhO+LA==}\n+  /ws@8.14.2:\n+    resolution: {integrity: sha512-wEBG1ftX4jcglPxgFCMJmZ2PLtSbJ2Peg6TmpJFTbe9GZYOQCDPdMYu/Tm0/bGZkw8paZnJY45J4K2PZrLYq8g==}\n     engines: {node: '>=10.0.0'}\n     peerDependencies:\n       bufferutil: ^4.0.1"
        }
    ],
    "commitTime": "2023-11-30 21:51:20"
}