{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "NONE",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "LOW",
        "integrity": "LOW",
        "availability": "LOW"
    },
    "credit": [
        "Fudan University"
    ],
    "cvssDetails": [
        {
            "assigner": "NVD",
            "cvssV3BaseScore": 8.8,
            "cvssV3Vector": {
                "CVSS": "3.1",
                "attackVector": "NETWORK",
                "attackComplexity": "LOW",
                "privilegesRequired": "NONE",
                "userInteraction": "REQUIRED",
                "scope": "UNCHANGED",
                "confidentiality": "HIGH",
                "integrity": "HIGH",
                "availability": "HIGH"
            },
            "severity": "high"
        }
    ],
    "cvssScore": 7.3,
    "disclosureTime": "2023-11-29 13:44:39",
    "epssDetails": {
        "modelVersion": "v2023.03.01",
        "percentile": "0.33302",
        "probability": "0.00080"
    },
    "exploitMaturity": "Not Defined",
    "id": "SNYK-JS-ELECTRON-6100741",
    "identifiers": {
        "CVE": [
            "CVE-2023-6351"
        ],
        "CWE": [
            "CWE-416"
        ]
    },
    "language": "js",
    "malicious": false,
    "packageManager": "npm",
    "publicationTime": "2023-12-06 06:39:09",
    "remediation": "Upgrade electron to version 25.9.8 or higher. ",
    "severity": "high",
    "socialTrendAlert": false,
    "title": "Use After Free",
    "vulnDescription": {
        "Overview": "electron is a framework which lets you write cross-platform desktop applications using JavaScript, HTML and CSS. Affected versions of this package are vulnerable to Use After Free. An attacker can potentially exploit heap corruption by using a crafted avif file. "
    },
    "source_code": [
        {
            "filename": "patches/config.json",
            "diff": "@@ -25,6 +25,8 @@\n \n   \"src/electron/patches/skia\": \"src/third_party/skia\",\n \n+  \"src/electron/patches/libavif\": \"src/third_party/libavif/src\",\n+\n   \"src/electron/patches/libwebp\": \"src/third_party/libwebp/src\",\n \n   \"src/electron/patches/libvpx\": \"src/third_party/libvpx/source/libvpx\","
        },
        {
            "filename": "patches/libavif/.patches",
            "diff": "@@ -0,0 +1,2 @@\n+remove_potential_out_of_bound_access_to_alphaitemindices.patch\n+do_not_store_potentially_invalid_pointers.patch"
        },
        {
            "filename": "patches/libavif/do_not_store_potentially_invalid_pointers.patch",
            "diff": "@@ -0,0 +1,79 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: VerteDinde <vertedinde@electronjs.org>\n+Date: Thu, 30 Nov 2023 20:39:28 -0800\n+Subject: Do not store potentially invalid pointers\n+\n+Manual cherry-pick of PR #1757 into the chromium-m118 branch.\n+\n+diff --git a/src/read.c b/src/read.c\n+index 756af390f451eb7e7422248ddc0b3e88e1640a94..5f2c527911f0896f78b26c7313db215671c217dd 100644\n+--- a/src/read.c\n++++ b/src/read.c\n+@@ -752,6 +752,8 @@ static void avifMetaDestroy(avifMeta * meta)\n+     avifFree(meta);\n+ }\n+ \n++// CAUTION: This function could potentially resize the meta->items array thereby invalidating all existing pointers that are being\n++// stored locally. So if this function is being called, exercise caution in the caller to not use invalid pointers.\n+ static avifDecoderItem * avifMetaFindItem(avifMeta * meta, uint32_t itemID)\n+ {\n+     if (itemID == 0) {\n+@@ -1259,6 +1261,19 @@ static avifResult avifDecoderItemRead(avifDecoderItem * item,\n+     return AVIF_RESULT_OK;\n+ }\n+ \n++// Returns the avifCodecType of the first tile of the gridItem.\n++static avifCodecType avifDecoderItemGetGridCodecType(const avifDecoderItem * gridItem)\n++{\n++    for (uint32_t i = 0; i < gridItem->meta->items.count; ++i) {\n++        avifDecoderItem * item = &gridItem->meta->items.item[i];\n++        const avifCodecType tileCodecType = avifGetCodecType(item->type);\n++        if ((item->dimgForID == gridItem->id) && (tileCodecType != AVIF_CODEC_TYPE_UNKNOWN)) {\n++            return tileCodecType;\n++        }\n++    }\n++    return AVIF_CODEC_TYPE_UNKNOWN;\n++}\n++\n+ static avifBool avifDecoderGenerateImageGridTiles(avifDecoder * decoder, avifImageGrid * grid, avifDecoderItem * gridItem, avifBool alpha)\n+ {\n+     unsigned int tilesRequested = grid->rows * grid->columns;\n+@@ -3843,16 +3858,28 @@ avifResult avifDecoderReset(avifDecoder * decoder)\n+         avifBool isAlphaItemInInput;\n+         avifDecoderItem * alphaItem;\n+         AVIF_CHECKRES(avifDecoderDataFindAlphaItem(data, &colorItem, &alphaItem, &isAlphaItemInInput));\n+-        if (alphaItem && !memcmp(alphaItem->type, \"grid\", 4)) {\n+-            avifROData readData;\n+-            AVIF_CHECKRES(avifDecoderItemRead(alphaItem, decoder->io, &readData, 0, 0, data->diag));\n+-            AVIF_CHECKERR(avifParseImageGridBox(&data->alpha.grid,\n+-                                                readData.data,\n+-                                                readData.size,\n+-                                                decoder->imageSizeLimit,\n+-                                                decoder->imageDimensionLimit,\n+-                                                data->diag),\n+-                          AVIF_RESULT_INVALID_IMAGE_GRID);\n++        avifCodecType alphaCodecType = AVIF_CODEC_TYPE_UNKNOWN;\n++        if (alphaItem) {\n++            if (!memcmp(alphaItem->type, \"grid\", 4)) {\n++                if (isAlphaItemInInput) {\n++                    avifROData readData;\n++                    AVIF_CHECKRES(avifDecoderItemRead(alphaItem, decoder->io, &readData, 0, 0, data->diag));\n++                    AVIF_CHECKERR(avifParseImageGridBox(&data->alpha.grid,\n++                                                        readData.data,\n++                                                        readData.size,\n++                                                        decoder->imageSizeLimit,\n++                                                        decoder->imageDimensionLimit,\n++                                                        data->diag),\n++                                  AVIF_RESULT_INVALID_IMAGE_GRID);\n++                }\n++                alphaCodecType = avifDecoderItemGetGridCodecType(alphaItem);\n++                if (alphaCodecType == AVIF_CODEC_TYPE_UNKNOWN) {\n++                    return AVIF_RESULT_INVALID_IMAGE_GRID;\n++                }\n++            } else {\n++                alphaCodecType = avifGetCodecType(alphaItem->type);\n++                assert(alphaCodecType != AVIF_CODEC_TYPE_UNKNOWN);\n++            }\n+         }\n+ \n+         // Find Exif and/or XMP metadata, if any"
        },
        {
            "filename": "patches/libavif/remove_potential_out_of_bound_access_to_alphaitemindices.patch",
            "diff": "@@ -0,0 +1,227 @@\n+From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001\n+From: VerteDinde <vertedinde@electronjs.org>\n+Date: Thu, 30 Nov 2023 20:33:02 -0800\n+Subject: Remove potential out of bound access to alphaItemIndices\n+\n+Manual cherry-pick of PR #1756 into the chromium-m118 branch.\n+\n+diff --git a/include/avif/internal.h b/include/avif/internal.h\n+index 0d3651fb4fb26baafc756b0033141e50495d9127..8562dce8bb93bee9f151b0321d41692f0a62ea9c 100644\n+--- a/include/avif/internal.h\n++++ b/include/avif/internal.h\n+@@ -397,6 +397,19 @@ __attribute__((__format__(__printf__, 2, 3)))\n+ #endif\n+ void avifDiagnosticsPrintf(avifDiagnostics * diag, const char * format, ...);\n+ \n++// ---------------------------------------------------------------------------\n++// avifCodecType (underlying video format)\n++\n++// Alliance for Open Media video formats that can be used in the AVIF image format.\n++typedef enum avifCodecType\n++{\n++    AVIF_CODEC_TYPE_UNKNOWN,\n++    AVIF_CODEC_TYPE_AV1,\n++#if defined(AVIF_CODEC_AVM)\n++    AVIF_CODEC_TYPE_AV2, // Experimental.\n++#endif\n++} avifCodecType;\n++\n+ // ---------------------------------------------------------------------------\n+ // avifStream\n+ //\n+diff --git a/src/read.c b/src/read.c\n+index 36a9058abfda94b623609e5ffff5fac2e48d8701..756af390f451eb7e7422248ddc0b3e88e1640a94 100644\n+--- a/src/read.c\n++++ b/src/read.c\n+@@ -37,6 +37,23 @@ static const size_t xmpContentTypeSize = sizeof(xmpContentType);\n+ // can't be more than 4 unique tuples right now.\n+ #define MAX_IPMA_VERSION_AND_FLAGS_SEEN 4\n+ \n++// ---------------------------------------------------------------------------\n++// AVIF codec type (AV1 or AV2)\n++\n++static avifCodecType avifGetCodecType(const uint8_t * fourcc)\n++{\n++    if (!memcmp(fourcc, \"av01\", 4)) {\n++        return AVIF_CODEC_TYPE_AV1;\n++    }\n++#if defined(AVIF_CODEC_AVM)\n++    if (!memcmp(fourcc, \"av02\", 4)) {\n++        return AVIF_CODEC_TYPE_AV2;\n++    }\n++#endif\n++    return AVIF_CODEC_TYPE_UNKNOWN;\n++}\n++\n++\n+ // ---------------------------------------------------------------------------\n+ // Box data structures\n+ \n+@@ -1267,7 +1284,7 @@ static avifBool avifDecoderGenerateImageGridTiles(avifDecoder * decoder, avifIma\n+ \n+     if (tilesRequested != tilesAvailable) {\n+         avifDiagnosticsPrintf(&decoder->diag,\n+-                              \"Grid image of dimensions %ux%u requires %u tiles, and only %u were found\",\n++                              \"Grid image of dimensions %ux%u requires %u tiles, but %u were found\",\n+                               grid->columns,\n+                               grid->rows,\n+                               tilesRequested,\n+@@ -3465,6 +3482,135 @@ static avifDecoderItem * avifDecoderDataFindItem(avifDecoderData * data, avifBoo\n+     return NULL;\n+ }\n+ \n++// Returns AVIF_TRUE if item is an alpha auxiliary item of the parent color\n++// item.\n++static avifBool avifDecoderItemIsAlphaAux(avifDecoderItem * item, uint32_t colorItemId)\n++{\n++    if (item->auxForID != colorItemId)\n++        return AVIF_FALSE;\n++    const avifProperty * auxCProp = avifPropertyArrayFind(&item->properties, \"auxC\");\n++    return auxCProp && isAlphaURN(auxCProp->u.auxC.auxType);\n++}\n++\n++// Returns AVIF_TRUE if the item should be skipped. Items should be skipped for one of the following reasons:\n++//  * Size is 0.\n++//  * Has an essential property that isn't supported by libavif.\n++//  * Item is not a single image or a grid.\n++//  * Item is a thumbnail.\n++static avifBool avifDecoderItemShouldBeSkipped(const avifDecoderItem * item)\n++{\n++    return !item->size || item->hasUnsupportedEssentialProperty ||\n++           (avifGetCodecType(item->type) == AVIF_CODEC_TYPE_UNKNOWN && memcmp(item->type, \"grid\", 4)) || item->thumbnailForID != 0;\n++}\n++\n++// Finds the alpha item whose parent item is *colorItemPtr and sets it in the alphaItem output parameter. Returns AVIF_RESULT_OK\n++// on success. Note that *alphaItem can be NULL even if the return value is AVIF_RESULT_OK. If the *colorItemPtr is a grid and the\n++// alpha item is represented as a set of auxl items to each color tile, then a fake item will be created and *isAlphaItemInInput\n++// will be set to AVIF_FALSE. In this case, the alpha item merely exists to hold the locations of the alpha tile items. The data\n++// of this item need not be read and the pixi property cannot be validated. Otherwise, *isAlphaItemInInput will be set to\n++// AVIF_TRUE when *alphaItem is not NULL. If the data->meta->items array is resized, then the value in *colorItemPtr could become\n++// invalid. This function also resets *colorItemPtr to the right value if an alpha item was found and added to the data->meta->items\n++// array.\n++static avifResult avifDecoderDataFindAlphaItem(avifDecoderData * data,\n++                                               avifDecoderItem ** colorItemPtr,\n++                                               avifDecoderItem ** alphaItem,\n++                                               avifBool * isAlphaItemInInput)\n++{\n++    const avifDecoderItem * colorItem = *colorItemPtr;\n++    for (uint32_t itemIndex = 0; itemIndex < data->meta->items.count; ++itemIndex) {\n++        avifDecoderItem * item = &data->meta->items.item[itemIndex];\n++        if (avifDecoderItemShouldBeSkipped(item)) {\n++            continue;\n++        }\n++        if (avifDecoderItemIsAlphaAux(item, colorItem->id)) {\n++            *alphaItem = item;\n++            *isAlphaItemInInput = AVIF_TRUE;\n++            return AVIF_RESULT_OK;\n++        }\n++    }\n++    if (memcmp(colorItem->type, \"grid\", 4)) {\n++        *alphaItem = NULL;\n++        *isAlphaItemInInput = AVIF_FALSE;\n++        return AVIF_RESULT_OK;\n++    }\n++    // If color item is a grid, check if there is an alpha channel which is represented as an auxl item to each color tile\n++    // item.\n++    uint32_t colorItemCount = data->color.grid.rows * data->color.grid.columns;\n++    if (colorItemCount == 0) {\n++        *alphaItem = NULL;\n++        *isAlphaItemInInput = AVIF_FALSE;\n++        return AVIF_RESULT_OK;\n++    }\n++    uint32_t * alphaItemIndices = avifAlloc(colorItemCount * sizeof(uint32_t));\n++    AVIF_CHECKERR(alphaItemIndices, AVIF_RESULT_OUT_OF_MEMORY);\n++    uint32_t alphaItemCount = 0;\n++    uint32_t maxItemID = 0;\n++    for (uint32_t i = 0; i < colorItem->meta->items.count; ++i) {\n++        avifDecoderItem * item = &colorItem->meta->items.item[i];\n++        if (item->id > maxItemID) {\n++            maxItemID = item->id;\n++        }\n++        if (item->dimgForID == colorItem->id) {\n++            avifBool seenAlphaForCurrentItem = AVIF_FALSE;\n++            for (uint32_t j = 0; j < colorItem->meta->items.count; ++j) {\n++                avifDecoderItem * auxlItem = &colorItem->meta->items.item[j];\n++                if (avifDecoderItemIsAlphaAux(auxlItem, item->id)) {\n++                    if (seenAlphaForCurrentItem || auxlItem->dimgForID != 0) {\n++                        // One of the following invalid cases:\n++                        // * Multiple items are claiming to be the alpha auxiliary of the current item.\n++                        // * Alpha auxiliary is dimg for another item.\n++                        avifFree(alphaItemIndices);\n++                        *alphaItem = NULL;\n++                        *isAlphaItemInInput = AVIF_FALSE;\n++                        return AVIF_RESULT_INVALID_IMAGE_GRID;\n++                    }\n++                    alphaItemIndices[alphaItemCount++] = j;\n++                    seenAlphaForCurrentItem = AVIF_TRUE;\n++                }\n++            }\n++            if (!seenAlphaForCurrentItem) {\n++                // No alpha auxiliary item was found for the current item. Treat this as an image without alpha.\n++                avifFree(alphaItemIndices);\n++                *alphaItem = NULL;\n++                *isAlphaItemInInput = AVIF_FALSE;\n++                return AVIF_RESULT_OK;\n++            }\n++        }\n++    }\n++    assert(alphaItemCount == colorItemCount);\n++\n++    int colorItemIndex = -1;\n++    for (uint32_t i = 0; i < data->meta->items.count; ++i) {\n++        if (colorItem->id == data->meta->items.item[i].id) {\n++            colorItemIndex = i;\n++            break;\n++        }\n++    }\n++    assert(colorItemIndex >= 0);\n++\n++    *alphaItem = avifMetaFindItem(colorItem->meta, maxItemID + 1);\n++    if (*alphaItem == NULL) {\n++        avifFree(alphaItemIndices);\n++        *isAlphaItemInInput = AVIF_FALSE;\n++        return AVIF_RESULT_OUT_OF_MEMORY;\n++    }\n++    // avifMetaFindItem() could invalidate all existing item pointers. So reset the colorItem pointers.\n++    *colorItemPtr = &data->meta->items.item[colorItemIndex];\n++    colorItem = *colorItemPtr;\n++\n++    memcpy((*alphaItem)->type, \"grid\", 4);\n++    (*alphaItem)->width = colorItem->width;\n++    (*alphaItem)->height = colorItem->height;\n++    for (uint32_t i = 0; i < alphaItemCount; ++i) {\n++        avifDecoderItem * item = &colorItem->meta->items.item[alphaItemIndices[i]];\n++        item->dimgForID = (*alphaItem)->id;\n++    }\n++    avifFree(alphaItemIndices);\n++    *isAlphaItemInInput = AVIF_FALSE;\n++    data->alpha.grid = data->color.grid;\n++    return AVIF_RESULT_OK;\n++}\n++\n+ static avifResult avifDecoderGenerateImageTiles(avifDecoder * decoder, avifTileInfo * info, avifDecoderItem * item, avifBool alpha)\n+ {\n+     const uint32_t previousTileCount = decoder->data->tiles.count;\n+@@ -3682,9 +3828,21 @@ avifResult avifDecoderReset(avifDecoder * decoder)\n+                                                 decoder->imageDimensionLimit,\n+                                                 data->diag),\n+                           AVIF_RESULT_INVALID_IMAGE_GRID);\n++            // Validate that there are exactly the same number of dimg items to form the grid.\n++            uint32_t dimgItemCount = 0;\n++            for (uint32_t i = 0; i < colorItem->meta->items.count; ++i) {\n++                if (colorItem->meta->items.item[i].dimgForID == colorItem->id) {\n++                    ++dimgItemCount;\n++                }\n++            }\n++            if (dimgItemCount != data->color.grid.rows * data->color.grid.columns) {\n++                return AVIF_RESULT_INVALID_IMAGE_GRID;\n++            }\n+         }\n+ \n+-        avifDecoderItem * alphaItem = avifDecoderDataFindItem(data, /*alpha=*/AVIF_TRUE, /*parentItemID=*/colorItem->id);\n++        avifBool isAlphaItemInInput;\n++        avifDecoderItem * alphaItem;\n++        AVIF_CHECKRES(avifDecoderDataFindAlphaItem(data, &colorItem, &alphaItem, &isAlphaItemInInput));\n+         if (alphaItem && !memcmp(alphaItem->type, \"grid\", 4)) {\n+             avifROData readData;\n+             AVIF_CHECKRES(avifDecoderItemRead(alphaItem, decoder->io, &readData, 0, 0, data->diag));"
        }
    ],
    "commitTime": "2023-12-01 17:53:14"
}