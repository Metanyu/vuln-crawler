{
    "CVSSv3": {
        "CVSS": "3.1",
        "attackVector": "NETWORK",
        "attackComplexity": "LOW",
        "privilegesRequired": "LOW",
        "userInteraction": "NONE",
        "scope": "UNCHANGED",
        "confidentiality": "NONE",
        "integrity": "HIGH",
        "availability": "NONE"
    },
    "credit": [
        "Nicolas Bachschmidt"
    ],
    "cvssDetails": [],
    "cvssScore": 6.5,
    "disclosureTime": "2024-01-03 21:44:35",
    "epssDetails": null,
    "exploitMaturity": "Not Defined",
    "id": "SNYK-SWIFT-VAPORVAPOR-6143589",
    "identifiers": {
        "CVE": [
            "CVE-2024-21631"
        ],
        "CWE": [
            "CWE-1104"
        ]
    },
    "language": "swift",
    "malicious": false,
    "packageManager": "swift",
    "publicationTime": "2024-01-04 15:23:23",
    "remediation": "Upgrade vapor/vapor to version 4.90.0 or higher. ",
    "severity": "medium",
    "socialTrendAlert": false,
    "title": "Integer Overflow or Wraparound",
    "vulnDescription": {
        "Overview": "vapor/vapor is an a server-side Swift HTTP web framework. Affected versions of this package are vulnerable to Integer Overflow or Wraparound in the vapor_urlparser_parse function. An attacker can spoof the host by padding the port number with zeros, causing an integer overflow when the URL authority is parsed. "
    },
    "source_code": [
        {
            "filename": "Package.swift",
            "diff": "@@ -66,15 +66,13 @@ let package = Package(\n     targets: [\n         // C helpers\n         .target(name: \"CVaporBcrypt\"),\n-        .target(name: \"CVaporURLParser\"),\n \n         // Vapor\n         .target(name: \"Vapor\", dependencies: [\n             .product(name: \"AsyncHTTPClient\", package: \"async-http-client\"),\n             .product(name: \"AsyncKit\", package: \"async-kit\"),\n             .product(name: \"Backtrace\", package: \"swift-backtrace\"),\n             .target(name: \"CVaporBcrypt\"),\n-            .target(name: \"CVaporURLParser\"),\n             .product(name: \"ConsoleKit\", package: \"console-kit\"),\n             .product(name: \"Logging\", package: \"swift-log\"),\n             .product(name: \"Metrics\", package: \"swift-metrics\"),"
        },
        {
            "filename": "Package@swift-5.9.swift",
            "diff": "@@ -63,16 +63,14 @@ let package = Package(\n     targets: [\n         // C helpers\n         .target(name: \"CVaporBcrypt\"),\n-        .target(name: \"CVaporURLParser\"),\n-\n+        \n         // Vapor\n         .target(\n             name: \"Vapor\",\n             dependencies: [\n                 .product(name: \"AsyncHTTPClient\", package: \"async-http-client\"),\n                 .product(name: \"AsyncKit\", package: \"async-kit\"),\n                 .target(name: \"CVaporBcrypt\"),\n-                .target(name: \"CVaporURLParser\"),\n                 .product(name: \"ConsoleKit\", package: \"console-kit\"),\n                 .product(name: \"Logging\", package: \"swift-log\"),\n                 .product(name: \"Metrics\", package: \"swift-metrics\"),\n@@ -130,15 +128,21 @@ let package = Package(\n                 .copy(\"Utilities/expired.crt\"),\n                 .copy(\"Utilities/expired.key\"),\n             ],\n-            swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]\n+            swiftSettings: [\n+                .enableUpcomingFeature(\"BareSlashRegexLiterals\"),\n+                .enableExperimentalFeature(\"StrictConcurrency=complete\"),\n+            ]\n         ),\n         .testTarget(\n             name: \"AsyncTests\",\n             dependencies: [\n                 .product(name: \"NIOTestUtils\", package: \"swift-nio\"),\n                 .target(name: \"XCTVapor\"),\n             ],\n-            swiftSettings: [.enableExperimentalFeature(\"StrictConcurrency=complete\")]\n+            swiftSettings: [\n+                .enableUpcomingFeature(\"BareSlashRegexLiterals\"),\n+                .enableExperimentalFeature(\"StrictConcurrency=complete\"),\n+            ]\n         ),\n     ]\n )"
        },
        {
            "filename": "Sources/CVaporURLParser/include/urlparser.h",
            "diff": "@@ -1,59 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-#ifndef urlparser_h\n-#define urlparser_h\n-#include <stdint.h>\n-#include <stddef.h>\n-\n-enum vapor_urlparser_fields\n-{ UF_SCHEMA           = 0\n-    , UF_HOST             = 1\n-    , UF_PORT             = 2\n-    , UF_PATH             = 3\n-    , UF_QUERY            = 4\n-    , UF_FRAGMENT         = 5\n-    , UF_USERINFO         = 6\n-    , UF_MAX              = 7\n-};\n-\n-struct vapor_urlparser_field_data {\n-    uint16_t off;               /* Offset into buffer in which field starts */\n-    uint16_t len;               /* Length of run in buffer */\n-};\n-\n-/* Result structure for urlparser_parse_url().\n- *\n- * Callers should index into field_data[] with UF_* values iff field_set\n- * has the relevant (1 << UF_*) bit set. As a courtesy to clients (and\n- * because we probably have padding left over), we convert any port to\n- * a uint16_t.\n- */\n-struct vapor_urlparser_url {\n-    uint16_t field_set;           /* Bitmask of (1 << UF_*) values */\n-    uint16_t port;                /* Converted UF_PORT string */\n-    struct vapor_urlparser_field_data field_data[UF_MAX];\n-};\n-\n-/* Parse a URL; return nonzero on failure */\n-int vapor_urlparser_parse(const char *buf, size_t buflen,\n-                          int is_connect,\n-                          struct vapor_urlparser_url *u);\n-#endif"
        },
        {
            "filename": "Sources/CVaporURLParser/urlparser.c",
            "diff": "@@ -1,707 +0,0 @@\n-/* Copyright Joyent, Inc. and other Node contributors.\n- *\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\n- * of this software and associated documentation files (the \"Software\"), to\n- * deal in the Software without restriction, including without limitation the\n- * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n- * sell copies of the Software, and to permit persons to whom the Software is\n- * furnished to do so, subject to the following conditions:\n- *\n- * The above copyright notice and this permission notice shall be included in\n- * all copies or substantial portions of the Software.\n- *\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n- * IN THE SOFTWARE.\n- */\n-#include \"urlparser.h\"\n-#include <assert.h>\n-#include <stddef.h>\n-#include <ctype.h>\n-#include <string.h>\n-#include <limits.h>\n-\n-#ifndef BIT_AT\n-# define BIT_AT(a, i)                                                \\\n-(!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \\\n-(1 << ((unsigned int) (i) & 7))))\n-#endif\n-\n-/* Tokens as defined by rfc 2616. Also lowercases them.\n- *        token       = 1*<any CHAR except CTLs or separators>\n- *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n- *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n- *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n- *                    | \"{\" | \"}\" | SP | HT\n- */\n-static const char tokens[256] = {\n-    /*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */\n-    0,       0,       0,       0,       0,       0,       0,       0,\n-    /*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */\n-    0,       0,       0,       0,       0,       0,       0,       0,\n-    /*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */\n-    0,       0,       0,       0,       0,       0,       0,       0,\n-    /*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */\n-    0,       0,       0,       0,       0,       0,       0,       0,\n-    /*  32 sp    33  !    34  \"    35  #    36  $    37  %    38  &    39  '  */\n-    ' ',     '!',      0,      '#',     '$',     '%',     '&',    '\\'',\n-    /*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */\n-    0,       0,      '*',     '+',      0,      '-',     '.',      0,\n-    /*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */\n-    '0',     '1',     '2',     '3',     '4',     '5',     '6',     '7',\n-    /*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */\n-    '8',     '9',      0,       0,       0,       0,       0,       0,\n-    /*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */\n-    0,      'a',     'b',     'c',     'd',     'e',     'f',     'g',\n-    /*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */\n-    'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',\n-    /*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */\n-    'p',     'q',     'r',     's',     't',     'u',     'v',     'w',\n-    /*  88  X    89  Y    90  Z    91  [    92  \\    93  ]    94  ^    95  _  */\n-    'x',     'y',     'z',      0,       0,       0,      '^',     '_',\n-    /*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */\n-    '`',     'a',     'b',     'c',     'd',     'e',     'f',     'g',\n-    /* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */\n-    'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',\n-    /* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */\n-    'p',     'q',     'r',     's',     't',     'u',     'v',     'w',\n-    /* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */\n-    'x',     'y',     'z',      0,      '|',      0,      '~',       0 };\n-\n-\n-static const int8_t unhex[256] =\n-{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-    , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1\n-    ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-    ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1\n-};\n-\n-\n-#if URLPARSER_STRICT\n-# define T(v) 0\n-#else\n-# define T(v) v\n-#endif\n-\n-\n-static const uint8_t normal_url_char[32] = {\n-    /*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */\n-    0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n-    /*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */\n-    0    | T(2)   |   0    |   0    | T(16)  |   0    |   0    |   0,\n-    /*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */\n-    0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n-    /*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */\n-    0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,\n-    /*  32 sp    33  !    34  \"    35  #    36  $    37  %    38  &    39  '  */\n-    0    |   2    |   4    |   0    |   16   |   32   |   64   |  128,\n-    /*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |   0,\n-    /*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /*  88  X    89  Y    90  Z    91  [    92  \\    93  ]    94  ^    95  _  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,\n-    /* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */\n-    1    |   2    |   4    |   8    |   16   |   32   |   64   |   0, };\n-\n-#undef T\n-\n-enum state\n-{ s_dead = 1 /* important that this is > 0 */\n-\n-    , s_start_req_or_res\n-    , s_res_or_resp_H\n-    , s_start_res\n-    , s_res_H\n-    , s_res_HT\n-    , s_res_HTT\n-    , s_res_HTTP\n-    , s_res_http_major\n-    , s_res_http_dot\n-    , s_res_http_minor\n-    , s_res_http_end\n-    , s_res_first_status_code\n-    , s_res_status_code\n-    , s_res_status_start\n-    , s_res_status\n-    , s_res_line_almost_done\n-\n-    , s_start_req\n-\n-    , s_req_method\n-    , s_req_spaces_before_url\n-    , s_req_schema\n-    , s_req_schema_slash\n-    , s_req_schema_slash_slash\n-    , s_req_server_start\n-    , s_req_server\n-    , s_req_server_with_at\n-    , s_req_path\n-    , s_req_query_string_start\n-    , s_req_query_string\n-    , s_req_fragment_start\n-    , s_req_fragment\n-    , s_req_http_start\n-    , s_req_http_H\n-    , s_req_http_HT\n-    , s_req_http_HTT\n-    , s_req_http_HTTP\n-    , s_req_http_I\n-    , s_req_http_IC\n-    , s_req_http_major\n-    , s_req_http_dot\n-    , s_req_http_minor\n-    , s_req_http_end\n-    , s_req_line_almost_done\n-\n-    , s_header_field_start\n-    , s_header_field\n-    , s_header_value_discard_ws\n-    , s_header_value_discard_ws_almost_done\n-    , s_header_value_discard_lws\n-    , s_header_value_start\n-    , s_header_value\n-    , s_header_value_lws\n-\n-    , s_header_almost_done\n-\n-    , s_chunk_size_start\n-    , s_chunk_size\n-    , s_chunk_parameters\n-    , s_chunk_size_almost_done\n-\n-    , s_headers_almost_done\n-    , s_headers_done\n-\n-    /* Important: 's_headers_done' must be the last 'header' state. All\n-     * states beyond this must be 'body' states. It is used for overflow\n-     * checking. See the PARSING_HEADER() macro.\n-     */\n-\n-    , s_chunk_data\n-    , s_chunk_data_almost_done\n-    , s_chunk_data_done\n-\n-    , s_body_identity\n-    , s_body_identity_eof\n-\n-    , s_message_done\n-};\n-\n-enum http_host_state\n-{\n-    s_http_host_dead = 1\n-    , s_http_userinfo_start\n-    , s_http_userinfo\n-    , s_http_host_start\n-    , s_http_host_v6_start\n-    , s_http_host\n-    , s_http_host_v6\n-    , s_http_host_v6_end\n-    , s_http_host_v6_zone_start\n-    , s_http_host_v6_zone\n-    , s_http_host_port_start\n-    , s_http_host_port\n-};\n-\n-/* Macros for character classes; depends on strict-mode  */\n-#define CR                  '\\r'\n-#define LF                  '\\n'\n-#define LOWER(c)            (unsigned char)(c | 0x20)\n-#define IS_ALPHA(c)         (LOWER(c) >= 'a' && LOWER(c) <= 'z')\n-#define IS_NUM(c)           ((c) >= '0' && (c) <= '9')\n-#define IS_ALPHANUM(c)      (IS_ALPHA(c) || IS_NUM(c))\n-#define IS_HEX(c)           (IS_NUM(c) || (LOWER(c) >= 'a' && LOWER(c) <= 'f'))\n-#define IS_MARK(c)          ((c) == '-' || (c) == '_' || (c) == '.' || \\\n-(c) == '!' || (c) == '~' || (c) == '*' || (c) == '\\'' || (c) == '(' || \\\n-(c) == ')')\n-#define IS_USERINFO_CHAR(c) (IS_ALPHANUM(c) || IS_MARK(c) || (c) == '%' || \\\n-(c) == ';' || (c) == ':' || (c) == '&' || (c) == '=' || (c) == '+' || \\\n-(c) == '$' || (c) == ',')\n-\n-#define STRICT_TOKEN(c)     ((c == ' ') ? 0 : tokens[(unsigned char)c])\n-\n-#if URLPARSER_STRICT\n-#define TOKEN(c)            STRICT_TOKEN(c)\n-#define IS_URL_CHAR(c)      (BIT_AT(normal_url_char, (unsigned char)c))\n-#define IS_HOST_CHAR(c)     (IS_ALPHANUM(c) || (c) == '.' || (c) == '-')\n-#else\n-#define TOKEN(c)            tokens[(unsigned char)c]\n-#define IS_URL_CHAR(c)                                                         \\\n-(BIT_AT(normal_url_char, (unsigned char)c) || ((c) & 0x80))\n-#define IS_HOST_CHAR(c)                                                        \\\n-(IS_ALPHANUM(c) || (c) == '.' || (c) == '-' || (c) == '_')\n-#endif\n-\n-/* Our URL parser.\n- *\n- * This is designed to be shared by urlparser_execute() for URL validation,\n- * hence it has a state transition + byte-for-byte interface. In addition, it\n- * is meant to be embedded in urlparser_parse_url(), which does the dirty\n- * work of turning state transitions URL components for its API.\n- *\n- * This function should only be invoked with non-space characters. It is\n- * assumed that the caller cares about (and can detect) the transition between\n- * URL and non-URL states by looking for these.\n- */\n-static enum state\n-parse_url_char(enum state s, const char ch)\n-{\n-    if (ch == ' ' || ch == '\\r' || ch == '\\n') {\n-        return s_dead;\n-    }\n-\n-#if URLPARSER_STRICT\n-    if (ch == '\\t' || ch == '\\f') {\n-        return s_dead;\n-    }\n-#endif\n-\n-    switch (s) {\n-        case s_req_spaces_before_url:\n-        /* Proxied requests are followed by scheme of an absolute URI (alpha).\n-         * All methods except CONNECT are followed by '/' or '*'.\n-         */\n-\n-        if (ch == '/' || ch == '*') {\n-            return s_req_path;\n-        }\n-\n-        if (IS_ALPHA(ch)) {\n-            return s_req_schema;\n-        }\n-\n-        break;\n-\n-        case s_req_schema:\n-        if (IS_ALPHA(ch)) {\n-            return s;\n-        }\n-\n-        if (ch == ':') {\n-            return s_req_schema_slash;\n-        }\n-\n-        break;\n-\n-        case s_req_schema_slash:\n-        if (ch == '/') {\n-            return s_req_schema_slash_slash;\n-        }\n-\n-        break;\n-\n-        case s_req_schema_slash_slash:\n-        if (ch == '/') {\n-            return s_req_server_start;\n-        }\n-\n-        break;\n-\n-        case s_req_server_with_at:\n-        if (ch == '@') {\n-            return s_dead;\n-        }\n-\n-        /* fall through */\n-        case s_req_server_start:\n-        case s_req_server:\n-        if (ch == '/') {\n-            return s_req_path;\n-        }\n-\n-        if (ch == '?') {\n-            return s_req_query_string_start;\n-        }\n-\n-        if (ch == '@') {\n-            return s_req_server_with_at;\n-        }\n-\n-        if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {\n-            return s_req_server;\n-        }\n-\n-        break;\n-\n-        case s_req_path:\n-        if (IS_URL_CHAR(ch)) {\n-            return s;\n-        }\n-\n-        switch (ch) {\n-            case '?':\n-            return s_req_query_string_start;\n-\n-            case '#':\n-            return s_req_fragment_start;\n-        }\n-\n-        break;\n-\n-        case s_req_query_string_start:\n-        case s_req_query_string:\n-        if (IS_URL_CHAR(ch)) {\n-            return s_req_query_string;\n-        }\n-\n-        switch (ch) {\n-            case '?':\n-            /* allow extra '?' in query string */\n-            return s_req_query_string;\n-\n-            case '#':\n-            return s_req_fragment_start;\n-        }\n-\n-        break;\n-\n-        case s_req_fragment_start:\n-        if (IS_URL_CHAR(ch)) {\n-            return s_req_fragment;\n-        }\n-\n-        switch (ch) {\n-            case '?':\n-            return s_req_fragment;\n-\n-            case '#':\n-            return s;\n-        }\n-\n-        break;\n-\n-        case s_req_fragment:\n-        if (IS_URL_CHAR(ch)) {\n-            return s;\n-        }\n-\n-        switch (ch) {\n-            case '?':\n-            case '#':\n-            return s;\n-        }\n-\n-        break;\n-\n-        default:\n-        break;\n-    }\n-\n-    /* We should never fall out of the switch above unless there's an error */\n-    return s_dead;\n-}\n-\n-static enum http_host_state\n-http_parse_host_char(enum http_host_state s, const char ch) {\n-    switch(s) {\n-        case s_http_userinfo:\n-        case s_http_userinfo_start:\n-        if (ch == '@') {\n-            return s_http_host_start;\n-        }\n-\n-        if (IS_USERINFO_CHAR(ch)) {\n-            return s_http_userinfo;\n-        }\n-        break;\n-\n-        case s_http_host_start:\n-        if (ch == '[') {\n-            return s_http_host_v6_start;\n-        }\n-\n-        if (IS_HOST_CHAR(ch)) {\n-            return s_http_host;\n-        }\n-\n-        break;\n-\n-        case s_http_host:\n-        if (IS_HOST_CHAR(ch)) {\n-            return s_http_host;\n-        }\n-\n-        /* fall through */\n-        case s_http_host_v6_end:\n-        if (ch == ':') {\n-            return s_http_host_port_start;\n-        }\n-\n-        break;\n-\n-        case s_http_host_v6:\n-        if (ch == ']') {\n-            return s_http_host_v6_end;\n-        }\n-\n-        /* fall through */\n-        case s_http_host_v6_start:\n-        if (IS_HEX(ch) || ch == ':' || ch == '.') {\n-            return s_http_host_v6;\n-        }\n-\n-        if (s == s_http_host_v6 && ch == '%') {\n-            return s_http_host_v6_zone_start;\n-        }\n-        break;\n-\n-        case s_http_host_v6_zone:\n-        if (ch == ']') {\n-            return s_http_host_v6_end;\n-        }\n-\n-        /* fall through */\n-        case s_http_host_v6_zone_start:\n-        /* RFC 6874 Zone ID consists of 1*( unreserved / pct-encoded) */\n-        if (IS_ALPHANUM(ch) || ch == '%' || ch == '.' || ch == '-' || ch == '_' ||\n-            ch == '~') {\n-            return s_http_host_v6_zone;\n-        }\n-        break;\n-\n-        case s_http_host_port:\n-        case s_http_host_port_start:\n-        if (IS_NUM(ch)) {\n-            return s_http_host_port;\n-        }\n-\n-        break;\n-\n-        default:\n-        break;\n-    }\n-    return s_http_host_dead;\n-}\n-\n-static int\n-http_parse_host(const char * buf, struct vapor_urlparser_url *u, int found_at) {\n-    enum http_host_state s;\n-\n-    const char *p;\n-    size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;\n-\n-    assert(u->field_set & (1 << UF_HOST));\n-\n-    u->field_data[UF_HOST].len = 0;\n-\n-    s = found_at ? s_http_userinfo_start : s_http_host_start;\n-\n-    for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {\n-        enum http_host_state new_s = http_parse_host_char(s, *p);\n-\n-        if (new_s == s_http_host_dead) {\n-            return 1;\n-        }\n-\n-        switch(new_s) {\n-            case s_http_host:\n-            if (s != s_http_host) {\n-                u->field_data[UF_HOST].off = (uint16_t)(p - buf);\n-            }\n-            u->field_data[UF_HOST].len++;\n-            break;\n-\n-            case s_http_host_v6:\n-            if (s != s_http_host_v6) {\n-                u->field_data[UF_HOST].off = (uint16_t)(p - buf);\n-            }\n-            u->field_data[UF_HOST].len++;\n-            break;\n-\n-            case s_http_host_v6_zone_start:\n-            case s_http_host_v6_zone:\n-            u->field_data[UF_HOST].len++;\n-            break;\n-\n-            case s_http_host_port:\n-            if (s != s_http_host_port) {\n-                u->field_data[UF_PORT].off = (uint16_t)(p - buf);\n-                u->field_data[UF_PORT].len = 0;\n-                u->field_set |= (1 << UF_PORT);\n-            }\n-            u->field_data[UF_PORT].len++;\n-            break;\n-\n-            case s_http_userinfo:\n-            if (s != s_http_userinfo) {\n-                u->field_data[UF_USERINFO].off = (uint16_t)(p - buf);\n-                u->field_data[UF_USERINFO].len = 0;\n-                u->field_set |= (1 << UF_USERINFO);\n-            }\n-            u->field_data[UF_USERINFO].len++;\n-            break;\n-\n-            default:\n-            break;\n-        }\n-        s = new_s;\n-    }\n-\n-    /* Make sure we don't end somewhere unexpected */\n-    switch (s) {\n-        case s_http_host_start:\n-        case s_http_host_v6_start:\n-        case s_http_host_v6:\n-        case s_http_host_v6_zone_start:\n-        case s_http_host_v6_zone:\n-        case s_http_host_port_start:\n-        case s_http_userinfo:\n-        case s_http_userinfo_start:\n-        return 1;\n-        default:\n-        break;\n-    }\n-\n-    return 0;\n-}\n-\n-void\n-urlparser_url_init(struct vapor_urlparser_url *u) {\n-    memset(u, 0, sizeof(*u));\n-}\n-\n-int\n-vapor_urlparser_parse(const char *buf, size_t buflen, int is_connect,\n-                      struct vapor_urlparser_url *u)\n-{\n-    enum state s;\n-    const char *p;\n-    enum vapor_urlparser_fields uf, old_uf;\n-    int found_at = 0;\n-\n-    if (buflen == 0) {\n-        return 1;\n-    }\n-\n-    u->port = u->field_set = 0;\n-    s = is_connect ? s_req_server_start : s_req_spaces_before_url;\n-    old_uf = UF_MAX;\n-\n-    for (p = buf; p < buf + buflen; p++) {\n-        s = parse_url_char(s, *p);\n-\n-        /* Figure out the next field that we're operating on */\n-        switch (s) {\n-            case s_dead:\n-            return 1;\n-\n-            /* Skip delimeters */\n-            case s_req_schema_slash:\n-            case s_req_schema_slash_slash:\n-            case s_req_server_start:\n-            case s_req_query_string_start:\n-            case s_req_fragment_start:\n-            continue;\n-\n-            case s_req_schema:\n-            uf = UF_SCHEMA;\n-            break;\n-\n-            case s_req_server_with_at:\n-            found_at = 1;\n-\n-            /* fall through */\n-            case s_req_server:\n-            uf = UF_HOST;\n-            break;\n-\n-            case s_req_path:\n-            uf = UF_PATH;\n-            break;\n-\n-            case s_req_query_string:\n-            uf = UF_QUERY;\n-            break;\n-\n-            case s_req_fragment:\n-            uf = UF_FRAGMENT;\n-            break;\n-\n-            default:\n-            assert(!\"Unexpected state\");\n-            return 1;\n-        }\n-\n-        /* Nothing's changed; soldier on */\n-        if (uf == old_uf) {\n-            u->field_data[uf].len++;\n-            continue;\n-        }\n-\n-        u->field_data[uf].off = (uint16_t)(p - buf);\n-        u->field_data[uf].len = 1;\n-\n-        u->field_set |= (1 << uf);\n-        old_uf = uf;\n-    }\n-\n-    /* host must be present if there is a schema */\n-    /* parsing http:///toto will fail */\n-    if ((u->field_set & (1 << UF_SCHEMA)) &&\n-        (u->field_set & (1 << UF_HOST)) == 0) {\n-        return 1;\n-    }\n-\n-    if (u->field_set & (1 << UF_HOST)) {\n-        if (http_parse_host(buf, u, found_at) != 0) {\n-            return 1;\n-        }\n-    }\n-\n-    /* CONNECT requests can only contain \"hostname:port\" */\n-    if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {\n-        return 1;\n-    }\n-\n-    if (u->field_set & (1 << UF_PORT)) {\n-        uint16_t off;\n-        uint16_t len;\n-        const char* p;\n-        const char* end;\n-        unsigned long v;\n-\n-        off = u->field_data[UF_PORT].off;\n-        len = u->field_data[UF_PORT].len;\n-        end = buf + off + len;\n-\n-        /* NOTE: The characters are already validated and are in the [0-9] range */\n-        assert(off + len <= buflen && \"Port number overflow\");\n-        v = 0;\n-        for (p = buf + off; p < end; p++) {\n-            v *= 10;\n-            v += *p - '0';\n-\n-            /* Ports have a max value of 2^16 */\n-            if (v > 0xffff) {\n-                return 1;\n-            }\n-        }\n-\n-        u->port = (uint16_t) v;\n-    }\n-\n-    return 0;\n-}"
        },
        {
            "filename": "Sources/Vapor/HTTP/EndpointCache.swift",
            "diff": "@@ -1,4 +1,8 @@\n+#if !canImport(Darwin) && swift(<5.9)\n+@preconcurrency import Foundation\n+#else\n import Foundation\n+#endif\n import NIOConcurrencyHelpers\n import NIOCore\n import Logging"
        },
        {
            "filename": "Sources/Vapor/HTTP/Headers/HTTPCookies.swift",
            "diff": "@@ -1,4 +1,8 @@\n+#if !canImport(Darwin) && swift(<5.9)\n+@preconcurrency import Foundation\n+#else\n import Foundation\n+#endif\n import NIOHTTP1\n \n extension HTTPHeaders {"
        },
        {
            "filename": "Sources/Vapor/Response/Response+Body.swift",
            "diff": "@@ -1,5 +1,9 @@\n @preconcurrency import Dispatch\n+#if !canImport(Darwin) && swift(<5.9)\n+@preconcurrency import Foundation\n+#else\n import Foundation\n+#endif\n import NIOCore\n import NIOConcurrencyHelpers\n "
        },
        {
            "filename": "Sources/Vapor/Utilities/URI.swift",
            "diff": "@@ -1,51 +1,48 @@\n-import CVaporURLParser\n+#if !canImport(Darwin)\n+@preconcurrency import struct Foundation.URLComponents\n+#else\n+import struct Foundation.URLComponents\n+#endif\n \n+/// A type for constructing and manipulating (most) Uniform Resource Indicators.\n+///\n+/// > Warning: This is **NOT** the same as Foundation's [`URL`] type!\n+///\n+/// Can be used to both parse strings containing well-formed URIs and to generate such strings from\n+/// a set of individual URI components.\n+///\n+/// Use of this type is (gently, for now) discouraged. Consider using Foundation's [`URL`] and/or\n+/// [`URLComponents`] types instead. See below for details.\n+///\n+/// ## URI is for URLs, not URIs\n+///\n+/// Thanks to both backwards compatibility requirements and name collision concerns, this type, despite\n+/// its name, does not actually represent a generic Uniform Resource Identifier as defined by [RFC 3986].\n+/// In particular, the underlying implementation is currently based on Foundation's [`URLComponents`] type,\n+/// whose semantics are inconsistent between different methods; in addition, its behavior has differed\n+/// drastically between the macOS and Linux implementations for most of its existence, and continues to do\n+/// so in Swift 5.9. This is not expected to be remedied until the [`swift-foundation`] package reaches a\n+/// 1.0 release, which as of this writing will not for quite some time yet). In short, instances of `URI`\n+/// may not always behave as expected according to either the spec or what Foundation does.\n+///\n+/// [RFC 3986]: https://datatracker.ietf.org/doc/html/rfc3986\n+/// [`swift-foundation`]: https://github.com/apple/swift-foundation\n+/// [`URL`]: https://developer.apple.com/documentation/foundation/url\n+/// [`URLComponents`]: https://developer.apple.com/documentation/foundation/urlcomponents\n public struct URI: Sendable, ExpressibleByStringInterpolation, CustomStringConvertible {\n-    /// A URI's scheme.\n-    public struct Scheme: Sendable, ExpressibleByStringInterpolation {\n-        /// HTTP\n-        public static let http: Self = \"http\"\n-        \n-        /// HTTPS\n-        public static let https: Self = \"https\"\n-        \n-        /// HTTP over Unix Domain Socket Paths. The socket path should be encoded as the host in the URI, making sure to encode any special characters:\n-        /// ```\n-        /// host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)\n-        /// ```\n-        /// Do note that URI's initializer will encode the host in this way if you use `init(scheme:host:port:path:query:fragment:)`.\n-        public static let httpUnixDomainSocket: Self = \"http+unix\"\n-        \n-        /// HTTPS over Unix Domain Socket Paths. The socket path should be encoded as the host in the URI, making sure to encode any special characters:\n-        /// ```\n-        /// host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)\n-        /// ```\n-        /// Do note that URI's initializer will encode the host in this way if you use `init(scheme:host:port:path:query:fragment:)`.\n-        public static let httpsUnixDomainSocket: Self = \"https+unix\"\n-        \n-        public let value: String?\n-        \n-        public init(stringLiteral value: String) {\n-            self.value = value\n-        }\n-        \n-        public init(_ value: String? = nil) {\n-            self.value = value\n-        }\n-    }\n+    private var components: URLComponents?\n     \n-    public var string: String\n-\n     public init(string: String = \"/\") {\n-        self.string = string\n+        self.components = URL(string: string).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }\n     }\n \n     public var description: String {\n-        return self.string\n+        self.string\n     }\n \n     public init(\n         scheme: String?,\n+        userinfo: String?,\n         host: String? = nil,\n         port: Int? = nil,\n         path: String,\n@@ -54,175 +51,241 @@ public struct URI: Sendable, ExpressibleByStringInterpolation, CustomStringConve\n     ) {\n         self.init(\n             scheme: Scheme(scheme),\n+            userinfo: userinfo,\n             host: host,\n             port: port,\n             path: path,\n             query: query,\n             fragment: fragment\n         )\n     }\n+\n+    public init(scheme: String?, host: String? = nil, port: Int? = nil, path: String, query: String? = nil, fragment: String? = nil) {\n+        self.init(scheme: scheme, userinfo: nil, host: host, port: port, path: path, query: query, fragment: fragment)\n+    }\n+    \n+    public init(scheme: Scheme = .init(), host: String? = nil, port: Int? = nil, path: String, query: String? = nil, fragment: String? = nil) {\n+        self.init(scheme: scheme, userinfo: nil, host: host, port: port, path: path, query: query, fragment: fragment)\n+    }\n     \n+    /// Construct a ``URI`` from various subcomponents.\n+    ///\n+    /// Percent encoding is added to each component (if necessary) automatically. There is currently no\n+    /// way to change this behavior; use `URLComponents` instead if this is insufficient.\n+    ///\n+    /// > Warning: For backwards compatibility reasons, if the `path` component is specified in isolation\n+    /// > (e.g. all other components are `nil`), the path is parsed as if by the ``init(string:)`` initializer.\n+    ///\n+    /// > Important: If the `path` does not begin with a `/`, one is prepended. This occurs even if the path\n+    /// > is specified in isolation (as described above).\n     public init(\n-        scheme: Scheme = Scheme(),\n+        scheme: Scheme = .init(),\n+        userinfo: String?,\n         host: String? = nil,\n         port: Int? = nil,\n         path: String,\n         query: String? = nil,\n         fragment: String? = nil\n     ) {\n-        var string = \"\"\n-        if let scheme = scheme.value {\n-            string += scheme + \"://\"\n-        }\n-        if let host = host?.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed) {\n-            string += host\n-        }\n-        if let port = port {\n-            string += \":\" + port.description\n-        }\n-        if path.hasPrefix(\"/\") {\n-            string += path\n+        let path = path.first == \"/\" ? path : \"/\\(path)\"\n+        var components: URLComponents!\n+        \n+        if scheme.value == nil, userinfo == nil, host == nil, port == nil, query == nil, fragment == nil {\n+            // If only a path is given, treat it as a string to parse. (This behavior is awful, but must be kept for compatibility.)\n+            components = URL(string: path).flatMap { .init(url: $0, resolvingAgainstBaseURL: true) }\n         } else {\n-            string += \"/\" + path\n-        }\n-        if let query = query {\n-            string += \"?\" + query\n+            // N.B.: We perform percent encoding manually and unconditionally on each non-nil component because the\n+            // behavior of URLComponents is completely different on Linux than on macOS for inputs which are already\n+            // fully or partially percent-encoded, as well as inputs which contain invalid characters (especially\n+            // for the host component). This is the only way to provide consistent behavior (and to avoid various\n+            // fatalError()s in URLComponents on Linux).\n+            components = .init()\n+            components.scheme = scheme.value?.addingPercentEncoding(withAllowedCharacters: .urlSchemeAllowed)\n+            if let host {\n+                if let creds = userinfo?.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false), !creds[0].isEmpty {\n+                    components.percentEncodedUser = creds[0].addingPercentEncoding(withAllowedCharacters: .urlUserAllowed)\n+                    if creds.count > 1, !creds[1].isEmpty {\n+                        components.percentEncodedPassword = creds[1].addingPercentEncoding(withAllowedCharacters: .urlPasswordAllowed)\n+                    }\n+                }\n+                // TODO: Use the `encodedHost` polyfill\n+                #if canImport(Darwin)\n+                if #available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *) {\n+                    components.encodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)\n+                } else {\n+                    components.percentEncodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)\n+                }\n+                #else\n+                components.percentEncodedHost = host.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)\n+                #endif\n+                components.port = port\n+            } else {\n+                // TODO: Should this be enforced?\n+                // assert(userinfo == nil, \"Can't provide userinfo without an authority (hostname)\")\n+                // assert(port == nil, \"Can't provide userinfo without an authority (hostname)\")\n+            }\n+            components.percentEncodedPath = path.addingPercentEncoding(withAllowedCharacters: .urlCorrectPathAllowed) ?? \"/\"\n+            components.percentEncodedQuery = query?.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)\n+            components.percentEncodedFragment = fragment?.addingPercentEncoding(withAllowedCharacters: .urlFragmentAllowed)\n         }\n-        if let fragment = fragment {\n-            string += \"#\" + fragment\n-        }\n-        self.string = string\n+        self.components = components\n     }\n \n     public init(stringLiteral value: String) {\n         self.init(string: value)\n     }\n \n-    private enum Component {\n-        case scheme, host, port, path, query, fragment, userinfo\n-    }\n-\n     public var scheme: String? {\n-        get {\n-            return self.parse(.scheme)\n-        }\n+        get { self.components?.scheme }\n+        set { self.components?.scheme = newValue }\n+    }\n+    \n+    public var userinfo: String? {\n+        get { self.components?.user.map { \"\\($0)\\(self.components?.password.map { \":\\($0)\" } ?? \"\")\" } }\n         set {\n-            self = .init(\n-                scheme: newValue,\n-                host: self.host,\n-                port: self.port,\n-                path: self.path,\n-                query: self.query,\n-                fragment: self.fragment\n-            )\n+            if let userinfoData = newValue?.split(separator: \":\", maxSplits: 1, omittingEmptySubsequences: false) {\n+                self.components?.user = .init(userinfoData[0])\n+                self.components?.password = userinfoData.count > 1 ? .init(userinfoData[1]) : nil\n+            } else {\n+                self.components?.user = nil\n+            }\n         }\n     }\n \n     public var host: String? {\n-        get {\n-            return self.parse(.host)\n-        }\n-        set {\n-            self = .init(\n-                scheme: self.scheme,\n-                host: newValue,\n-                port: self.port,\n-                path: self.path,\n-                query: self.query,\n-                fragment: self.fragment\n-            )\n-        }\n+        get { self.components?.host }\n+        set { self.components?.host = newValue }\n     }\n \n     public var port: Int? {\n-        get {\n-            return self.parse(.port).flatMap(Int.init)\n-        }\n-        set {\n-            self = .init(\n-                scheme: self.scheme,\n-                host: self.host,\n-                port: newValue,\n-                path: self.path,\n-                query: self.query,\n-                fragment: self.fragment\n-            )\n-        }\n+        get { self.components?.port }\n+        set { self.components?.port = newValue }\n     }\n \n     public var path: String {\n-        get {\n-            return self.parse(.path) ?? \"\"\n-        }\n-        set {\n-            self = .init(\n-                scheme: self.scheme,\n-                host: self.host,\n-                port: self.port,\n-                path: newValue,\n-                query: self.query,\n-                fragment: self.fragment\n-            )\n-        }\n+        get { self.components?.path ?? \"/\" }\n+        set { self.components?.path = newValue }\n     }\n \n     public var query: String? {\n-        get {\n-            return self.parse(.query)\n-        }\n-        set {\n-            self = .init(\n-                scheme: self.scheme,\n-                host: self.host,\n-                port: self.port,\n-                path: self.path,\n-                query: newValue,\n-                fragment: self.fragment\n-            )\n-        }\n+        get { self.components?.query }\n+        set { self.components?.query = newValue }\n     }\n \n     public var fragment: String? {\n-        get {\n-            return self.parse(.fragment)\n-        }\n-        set {\n-            self = .init(\n-                scheme: self.scheme,\n-                host: self.host,\n-                port: self.port,\n-                path: self.path,\n-                query: self.query,\n-                fragment: newValue\n-            )\n-        }\n+        get { self.components?.fragment }\n+        set { self.components?.fragment = newValue }\n     }\n \n-    private func parse(_ component: Component) -> String? {\n-        var url = vapor_urlparser_url()\n-        vapor_urlparser_parse(self.string, self.string.count, 0, &url)\n-        let data: vapor_urlparser_field_data\n-        switch component {\n-        case .scheme:\n-            data = url.field_data.0\n-        case .host:\n-            data = url.field_data.1\n-        case .port:\n-            data = url.field_data.2\n-        case .path:\n-            data = url.field_data.3\n-        case .query:\n-            data = url.field_data.4\n-        case .fragment:\n-            data = url.field_data.5\n-        case .userinfo:\n-            data = url.field_data.6\n-        }\n-        if data.len == 0 {\n-            return nil\n-        }\n-        let start = self.string.index(self.string.startIndex, offsetBy: numericCast(data.off))\n-        let end = self.string.index(start, offsetBy: numericCast(data.len))\n-        return String(self.string[start..<end])\n+    public var string: String {\n+        #if canImport(Darwin)\n+        self.components?.string ?? \"\"\n+        #else\n+        // On Linux, URLComponents incorrectly treats `;` as *not* allowed in the path component.\n+        self.components?.string?.replacingOccurrences(of: \"%3B\", with: \";\") ?? \"\"\n+        #endif\n+    }\n+    \n+}\n+\n+extension URI {\n+    /// A URI scheme, as defined by [RFC 3986 \u00a7 3.1] and [RFC 7595].\n+    ///\n+    /// [RFC 3986 \u00a7 3.1]: https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n+    /// [RGC 7595]: https://datatracker.ietf.org/doc/html/rfc7595\n+    public struct Scheme {\n+        /// The string representation of the scheme.\n+        public let value: String?\n+        \n+        /// Designated initializer.\n+        ///\n+        /// - Parameter value: The string representation for the desired scheme.\n+        public init(_ value: String? = nil) { self.value = value }\n+\n+        // MARK: - \"Well-known\" schemes\n+        \n+        /// HyperText Transfer Protocol (HTTP)\n+        ///\n+        /// > Registration: [RFC 9110 \u00a7 4.2.1](https://www.rfc-editor.org/rfc/rfc9110.html#section-4.2.1)\n+        public static let http: Self = \"http\"\n+        \n+        /// Secure HyperText Transfer Protocol (HTTPS)\n+        ///\n+        /// > Registration: [RFC 9110 \u00a7 4.2.2](https://www.rfc-editor.org/rfc/rfc9110.html#section-4.2.2)\n+        public static let https: Self = \"https\"\n+        \n+        /// HyperText Transfer Protocol (HTTP) over Unix Domain Sockets.\n+        ///\n+        /// The socket path must be given as the URI's \"host\" component, appropriately percent-encoded. The\n+        /// ``URI/init(scheme:userinfo:host:port:path:query:fragment:)`` initializer adds such encoding\n+        /// automatically. To manually apply the correct encoding, use:\n+        ///\n+        /// ```swift\n+        /// socketPath.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)\n+        /// ```\n+        /// \n+        /// > Registration: None (non-standard)\n+        public static let httpUnixDomainSocket: Self = \"http+unix\"\n+        \n+        /// Secure HyperText Transfer Protocol (HTTPS) over Unix Domain Sockets.\n+        ///\n+        /// The socket path must be given as the URI's \"host\" component, appropriately percent-encoded. The\n+        /// ``URI/init(scheme:userinfo:host:port:path:query:fragment:)`` initializer adds such encoding\n+        /// automatically. To manually apply the correct encoding, use:\n+        ///\n+        /// ```swift\n+        /// socketPath.addingPercentEncoding(withAllowedCharacters: .urlHostAllowed)\n+        /// ```\n+        ///\n+        /// > Note: The primary use case for this scheme is for local communication with servers (most\n+        /// > often database servers) which require TLS client certificate authentication. In most other\n+        /// > situations, the added encryption is unnecessary and will just slow things down.\n+        /// >\n+        /// > (Well, unless your security concerns include other processes spying on your server's\n+        /// > communications when using UNIX sockets. But since doing that would require having already\n+        /// > compromised the host kernel (\"It rather involved being on the other side of this airtight\n+        /// > hatchway.\"), it seems fairly safe to say such a concern would be moot.)\n+        ///\n+        /// > Registration: None (non-standard)\n+        public static let httpsUnixDomainSocket: Self = \"https+unix\"\n+        \n+        // MARK: End of \"well-known\" schemes -\n+    }\n+}\n+\n+extension URI.Scheme: ExpressibleByStringInterpolation {\n+    // See `ExpressibleByStringInterpolation.init(stringLiteral:)`.\n+    public init(stringLiteral value: String) { self.init(value) }\n+}\n+\n+extension URI.Scheme: CustomStringConvertible {\n+    // See `CustomStringConvertible.description`.\n+    public var description: String { self.value ?? \"\" }\n+}\n+\n+extension URI.Scheme: Sendable {}\n+\n+extension CharacterSet {\n+    /// The set of characters allowed in a URI scheme, as per [RFC 3986 \u00a7 3.1].\n+    ///\n+    /// [RFC 3986 \u00a7 3.1]: https://datatracker.ietf.org/doc/html/rfc3986#section-3.1\n+    fileprivate static var urlSchemeAllowed: Self {\n+        // Intersect the alphanumeric set plus additional characters with the host-allowed set to ensure\n+        // we get only ASCII codepoints in the result.\n+        Self.urlHostAllowed.intersection(Self.alphanumerics.union(.init(charactersIn: \"+-.\")))\n+    }\n+    \n+    /// The set of characters allowed in a URI path, as per [RFC 3986 \u00a7 3.3].\n+    ///\n+    /// > Note: This is identical to the built-in `urlPathAllowed` on macOS; on Linux it adds the missing\n+    /// > semicolon character to the set.\n+    ///\n+    /// [RFC 3986 \u00a7 3.3]: https://datatracker.ietf.org/doc/html/rfc3986#section-3.3\n+    fileprivate static var urlCorrectPathAllowed: Self {\n+        #if canImport(Darwin)\n+        .urlPathAllowed\n+        #else\n+        .urlPathAllowed.union(.init(charactersIn: \";\"))\n+        #endif\n     }\n }"
        },
        {
            "filename": "Tests/VaporTests/ClientTests.swift",
            "diff": "@@ -1,8 +1,7 @@\n-#if os(Linux)\n-@preconcurrency import Foundation\n-#else\n-import Foundation\n+#if !canImport(Darwin)\n+@preconcurrency import Dispatch\n #endif\n+import Foundation\n import XCTest\n import Vapor\n import NIOCore\n@@ -12,7 +11,6 @@ import NIOEmbedded\n import NIOConcurrencyHelpers\n \n final class ClientTests: XCTestCase {\n-    \n     var remoteAppPort: Int!\n     var remoteApp: Application!\n     "
        },
        {
            "filename": "Tests/VaporTests/RequestTests.swift",
            "diff": "@@ -143,107 +143,6 @@ final class RequestTests: XCTestCase {\n         }\n     }\n \n-    func testURI() throws {\n-        do {\n-            var uri = URI(string: \"http://vapor.codes/foo?bar=baz#qux\")\n-            XCTAssertEqual(uri.scheme, \"http\")\n-            XCTAssertEqual(uri.host, \"vapor.codes\")\n-            XCTAssertEqual(uri.path, \"/foo\")\n-            XCTAssertEqual(uri.query, \"bar=baz\")\n-            XCTAssertEqual(uri.fragment, \"qux\")\n-            uri.query = \"bar=baz&test=1\"\n-            XCTAssertEqual(uri.string, \"http://vapor.codes/foo?bar=baz&test=1#qux\")\n-            uri.query = nil\n-            XCTAssertEqual(uri.string, \"http://vapor.codes/foo#qux\")\n-        }\n-        do {\n-            let uri = URI(string: \"/foo/bar/baz\")\n-            XCTAssertEqual(uri.path, \"/foo/bar/baz\")\n-        }\n-        do {\n-            let uri = URI(string: \"ws://echo.websocket.org/\")\n-            XCTAssertEqual(uri.scheme, \"ws\")\n-            XCTAssertEqual(uri.host, \"echo.websocket.org\")\n-            XCTAssertEqual(uri.path, \"/\")\n-        }\n-        do {\n-            let uri = URI(string: \"http://foo\")\n-            XCTAssertEqual(uri.scheme, \"http\")\n-            XCTAssertEqual(uri.host, \"foo\")\n-            XCTAssertEqual(uri.path, \"\")\n-        }\n-        do {\n-            let uri = URI(string: \"foo\")\n-            XCTAssertEqual(uri.scheme, \"foo\")\n-            XCTAssertEqual(uri.host, nil)\n-            XCTAssertEqual(uri.path, \"\")\n-        }\n-        do {\n-            let uri: URI = \"/foo/bar/baz\"\n-            XCTAssertEqual(uri.path, \"/foo/bar/baz\")\n-        }\n-        do {\n-            let foo = \"foo\"\n-            let uri: URI = \"/\\(foo)/bar/baz\"\n-            XCTAssertEqual(uri.path, \"/foo/bar/baz\")\n-        }\n-        do {\n-            let uri = URI(scheme: \"foo\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")\n-        }\n-        do {\n-            let bar = \"bar\"\n-            let uri = URI(scheme: \"foo\\(bar)\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"foobar://host:1/test?query#fragment\")\n-        }\n-        do {\n-            let uri = URI(scheme: \"foo\", host: \"host\", port: 1, path: \"/test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")\n-        }\n-        do {\n-            let scheme = \"foo\"\n-            let uri = URI(scheme: scheme, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")\n-        }\n-        do {\n-            let scheme: String? = \"foo\"\n-            let uri = URI(scheme: scheme, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"foo://host:1/test?query#fragment\")\n-        }\n-        do {\n-            let uri = URI(scheme: .http, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"http://host:1/test?query#fragment\")\n-        }\n-        do {\n-            let uri = URI(scheme: nil, host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")\n-        }\n-        do {\n-            let uri = URI(scheme: URI.Scheme(), host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")\n-        }\n-        do {\n-            let uri = URI(host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"host:1/test?query#fragment\")\n-        }\n-        do {\n-            let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", query: \"query\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test?query#fragment\")\n-        }\n-        do {\n-            let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", fragment: \"fragment\")\n-            XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test#fragment\")\n-        }\n-        do {\n-            let uri = URI(scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\")\n-            XCTAssertEqual(uri.string, \"http+unix://%2Fpath/test\")\n-        }\n-        do {\n-            let uri = URI()\n-            XCTAssertEqual(uri.string, \"/\")\n-        }\n-    }\n-    \n     func testRedirect() throws {\n         let app = Application(.testing)\n         defer { app.shutdown() }"
        },
        {
            "filename": "Tests/VaporTests/ServerTests.swift",
            "diff": "@@ -1,8 +1,7 @@\n-#if os(Linux)\n-@preconcurrency import Foundation\n-#else\n-import Foundation\n+#if !canImport(Darwin)\n+@preconcurrency import Dispatch\n #endif\n+import Foundation\n import Vapor\n import XCTest\n import AsyncHTTPClient"
        },
        {
            "filename": "Tests/VaporTests/URITests.swift",
            "diff": "@@ -0,0 +1,345 @@\n+import XCTVapor\n+import XCTest\n+import Vapor\n+import NIOCore\n+import Algorithms\n+\n+extension RangeReplaceableCollection where Self.SubSequence == Substring, Self: StringProtocol {\n+    #if compiler(>=5.9)\n+    #if hasFeature(BareSlashRegexLiterals)\n+    private static var percentEncodingPattern: Regex<Substring> { /(?:%\\p{AHex}{2})+/ }\n+    #else\n+    private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }\n+    #endif\n+    #else\n+    private static var percentEncodingPattern: Regex<Substring> { try! Regex(\"(?:%\\\\p{AHex}{2})+\") }\n+    #endif\n+    \n+    /// Foundation's `String.removingPercentEncoding` property is very unforgiving; `nil` is returned\n+    /// for any kind of failure whatsoever. This is just a version that gracefully ignores invalid\n+    /// sequences whenever possible (which is almost always).\n+    var safelyUrlDecoded: Self {\n+        self.replacing(\n+            Self.percentEncodingPattern,\n+            with: { Self(decoding: $0.0.split(separator: \"%\").map { .init($0, radix: 16)! }, as: UTF8.self) }\n+        )\n+    }\n+}\n+\n+func XCTAssertURIComponents(\n+       scheme: @autoclosure () throws -> URI.Scheme?,\n+     userinfo: @autoclosure () throws -> String? = nil,\n+         host: @autoclosure () throws -> String? = nil,\n+         port: @autoclosure () throws -> Int?    = nil,\n+         path: @autoclosure () throws -> String,\n+        query: @autoclosure () throws -> String? = nil,\n+     fragment: @autoclosure () throws -> String? = nil,\n+     generate expected: @autoclosure () throws -> String,\n+    _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line\n+) {\n+    XCTAssertURIComponents(\n+        scheme: try scheme()?.value,\n+        userinfo: try userinfo(),\n+        host: try host(),\n+        port: try port(),\n+        path: try path(),\n+        query: try query(),\n+        fragment: try fragment(),\n+        generate: try expected(),\n+        message(), file: file, line: line\n+    )\n+}\n+\n+func XCTAssertURIComponents(\n+       scheme: @autoclosure () throws -> String? = nil,\n+     userinfo: @autoclosure () throws -> String? = nil,\n+         host: @autoclosure () throws -> String? = nil,\n+         port: @autoclosure () throws -> Int?    = nil,\n+         path: @autoclosure () throws -> String,\n+        query: @autoclosure () throws -> String? = nil,\n+     fragment: @autoclosure () throws -> String? = nil,\n+     generate expected: @autoclosure () throws -> String,\n+    _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line\n+) {\n+    do {\n+        let scheme = try scheme(), userinfo = try userinfo(), host = try host(), port = try port(),\n+            path = try path(), query = try query(), fragment = try fragment()\n+        let uri = URI(scheme: scheme, userinfo: userinfo, host: host, port: port, path: path, query: query, fragment: fragment)\n+        \n+        // All components should be identical to their input counterparts, sans percent encoding.\n+        XCTAssertEqual(uri.scheme,   scheme?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.userinfo, userinfo?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.host,     host?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.port,     port,                       \"(port) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.path,     \"/\\(path.safelyUrlDecoded.trimmingPrefix(\"/\"))\", \"(path) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.query,    query?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.fragment, fragment?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)\n+        \n+        // The URI's generated string should match the expected input.\n+        XCTAssertEqual(uri.string,   try expected(),             \"(string) \\(message())\", file: file, line: line)\n+    } catch {\n+        XCTAssertEqual(try { throw error }(), false,             message(), file: file, line: line)\n+    }\n+}\n+\n+func XCTAssertURIString(\n+     _ string: @autoclosure () throws -> String,\n+     hasScheme scheme:     @autoclosure () throws -> String? = nil,\n+     hasUserinfo userinfo: @autoclosure () throws -> String? = nil,\n+     hasHost host:         @autoclosure () throws -> String? = \"\",\n+     hasPort port:         @autoclosure () throws -> Int?    = nil,\n+     hasPath path:         @autoclosure () throws -> String,\n+     hasQuery query:       @autoclosure () throws -> String? = nil,\n+     hasFragment fragment: @autoclosure () throws -> String? = nil,\n+     hasEqualString exact: @autoclosure () throws -> Bool = true,\n+    _ message: @autoclosure () -> String = \"\", file: StaticString = #filePath, line: UInt = #line\n+) {\n+    do {\n+        let string = try string()\n+        let uri = URI(string: string)\n+\n+        // Each component should match its expected value.\n+        XCTAssertEqual(uri.scheme,   try scheme()?.safelyUrlDecoded,   \"(scheme) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.userinfo, try userinfo()?.safelyUrlDecoded, \"(userinfo) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.host,     try host()?.safelyUrlDecoded,     \"(host) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.port,     try port(),                       \"(port) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.path,     try path().safelyUrlDecoded,      \"(path) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.query,    try query()?.safelyUrlDecoded,    \"(query) \\(message())\", file: file, line: line)\n+        XCTAssertEqual(uri.fragment, try fragment()?.safelyUrlDecoded, \"(fragment) \\(message())\", file: file, line: line)\n+        \n+        // The URI's generated string should come out identical to the input string, unless explicitly stated otherwise.\n+        if try exact() {\n+            XCTAssertEqual(uri.string,   string,                       \"(string) \\(message())\", file: file, line: line)\n+        }\n+    } catch {\n+        XCTAssertEqual(try { throw error }(), false,                   message(), file: file, line: line)\n+    }\n+}\n+\n+final class URITests: XCTestCase {\n+    func testBasicConstruction() {\n+        XCTAssertURIString(\n+            \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\",\n+            hasScheme: \"https\",\n+            hasUserinfo: \"user:pass\",\n+            hasHost: \"vapor.codes\",\n+            hasPort: 1234,\n+            hasPath: \"/foo\",\n+            hasQuery: \"bar=baz\",\n+            hasFragment: \"qux\"\n+        )\n+        XCTAssertURIComponents(\n+            scheme: \"https\",\n+            userinfo: \"user:pass\",\n+            host: \"vapor.codes\",\n+            port: 1234,\n+            path: \"/foo\",\n+            query: \"bar=baz\",\n+            fragment: \"qux\",\n+            generate: \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\"\n+        )\n+\n+        XCTAssertURIString(\"wss://echo.websocket.org/\", hasScheme: \"wss\", hasHost: \"echo.websocket.org\", hasPath: \"/\")\n+        XCTAssertURIComponents(scheme: \"wss\", host: \"echo.websocket.org\", path: \"/\", generate: \"wss://echo.websocket.org/\")\n+    }\n+    \n+    func testMutation() {\n+        var uri = URI(string: \"https://user:pass@vapor.codes:1234/foo?bar=baz#qux\")\n+    \n+        // Mutate query\n+        uri.query = \"bar=baz&test=1\"\n+        XCTAssertEqual(uri.string, \"https://user:pass@vapor.codes:1234/foo?bar=baz&test=1#qux\")\n+\n+        // Remove query\n+        uri.query = nil\n+        XCTAssertEqual(uri.string, \"https://user:pass@vapor.codes:1234/foo#qux\")\n+    }\n+    \n+    func testPathStrings() {\n+        // Absolute path string\n+        let uri = URI(string: \"/foo/bar/baz\")\n+        XCTAssertEqual(uri.path, \"/foo/bar/baz\")\n+    }\n+    \n+    func testNonAbsolutePath() {\n+        let uri = URI(string: \"foo\")\n+\n+        // N.B.: This test previously asserted that the _scheme_ of the resulting URI was `foo`. This was\n+        // a semantically incorrect parse (per RFC 3986) and should have been considered a bug; hence it\n+        // is not considered source-breaking to have fixed it.\n+        XCTAssertEqual(uri.scheme, nil)\n+        XCTAssertEqual(uri.host, nil)\n+        XCTAssertEqual(uri.path, \"foo\")\n+    }\n+    \n+    func testStringInterpolation() {\n+        let foo = \"foo\"\n+        XCTAssertEqual((\"/\\(foo)/bar/baz\" as URI).path, \"/foo/bar/baz\")\n+\n+        let bar = \"bar\"\n+        let uri = URI(scheme: \"foo\\(bar)\", host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\")\n+        XCTAssertEqual(uri.string, \"foobar://host:1/test?query#fragment\")\n+    }\n+    \n+    func testVariousSchemesAndWeirdHosts() {\n+        // N.B.: This test previously asserted that the resulting string did _not_ start with the `//` \"authority\"\n+        // prefix. Again, according to RFC 3986, this was always semantically incorrect.\n+        XCTAssertURIComponents(\n+            host: \"host\", port: 1, path: \"test\", query: \"query\", fragment: \"fragment\",\n+            generate: \"//host:1/test?query#fragment\"\n+        )\n+        XCTAssertURIComponents(\n+            scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\",\n+            generate: \"http+unix://%2Fpath/test\"\n+        )\n+        XCTAssertURIComponents(\n+            scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", fragment: \"fragment\",\n+            generate: \"http+unix://%2Fpath/test#fragment\"\n+        )\n+        XCTAssertURIComponents(\n+            scheme: .httpUnixDomainSocket, host: \"/path\", path: \"test\", query: \"query\", fragment: \"fragment\",\n+            generate: \"http+unix://%2Fpath/test?query#fragment\"\n+        )\n+    }\n+    \n+    func testDefaultInitializer() {\n+        let uri = URI.init()\n+        XCTAssertEqual(uri.string, \"/\")\n+    }\n+    \n+    func testOverlongURIParsing() {\n+        let zeros = String(repeating: \"0\", count: 65_512)\n+        let untrustedInput = \"[https://vapor.codes.somewhere-else.test:](https://vapor.codes.somewhere-else.test/\\(zeros)443)[\\(zeros)](https://vapor.codes.somewhere-else.test/\\(zeros)443)[443](https://vapor.codes.somewhere-else.test/\\(zeros)443)\"\n+    \n+        XCTAssertURIString(untrustedInput, hasHost: nil, hasPath: untrustedInput, hasEqualString: false)\n+    }\n+    \n+    func testUrlParsingVectors() {\n+        XCTAssertURIString(\"file:///usr/local/bin\", hasScheme: \"file\", hasPath: \"/usr/local/bin\")\n+        XCTAssertURIString(\"file:/usr/local/bin\", hasScheme: \"file\", hasHost: nil, hasPath: \"/usr/local/bin\")\n+        XCTAssertURIString(\"file://localhost/usr/local/bin\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/usr/local/bin\")\n+        XCTAssertURIString(\"file://usr/local/bin\", hasScheme: \"file\", hasHost: \"usr\", hasPath: \"/local/bin\")\n+        XCTAssertURIString(\"/usr/local/bin\", hasHost: nil, hasPath: \"/usr/local/bin\")\n+        XCTAssertURIString(\"file://localhost/usr/local/bin/\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/usr/local/bin/\")\n+        XCTAssertURIString(\"file://localhost/\", hasScheme: \"file\", hasHost: \"localhost\", hasPath: \"/\")\n+        XCTAssertURIString(\"file:///\", hasScheme: \"file\", hasPath: \"/\")\n+        XCTAssertURIString(\"file:/\", hasScheme: \"file\", hasHost: nil, hasPath: \"/\")\n+        XCTAssertURIString(\"file:///Volumes\", hasScheme: \"file\", hasPath: \"/Volumes\")\n+        XCTAssertURIString(\"file:///Users/darin\", hasScheme: \"file\", hasPath: \"/Users/darin\")\n+        XCTAssertURIString(\"file:/\", hasScheme: \"file\", hasHost: nil, hasPath: \"/\")\n+        XCTAssertURIString(\"file:///.\", hasScheme: \"file\", hasPath: \"/.\")\n+        XCTAssertURIString(\"file:///./.\", hasScheme: \"file\", hasPath: \"/./.\")\n+        XCTAssertURIString(\"file:///.///.\", hasScheme: \"file\", hasPath: \"/.///.\")\n+        XCTAssertURIString(\"file:///a/..\", hasScheme: \"file\", hasPath: \"/a/..\")\n+        XCTAssertURIString(\"file:///a/b/..\", hasScheme: \"file\", hasPath: \"/a/b/..\")\n+        XCTAssertURIString(\"file:///a/b//..\", hasScheme: \"file\", hasPath: \"/a/b//..\")\n+        XCTAssertURIString(\"file:///./a/b/..\", hasScheme: \"file\", hasPath: \"/./a/b/..\")\n+        XCTAssertURIString(\"file:///a/./b/..\", hasScheme: \"file\", hasPath: \"/a/./b/..\")\n+        XCTAssertURIString(\"file:///a/b/./..\", hasScheme: \"file\", hasPath: \"/a/b/./..\")\n+        XCTAssertURIString(\"file:///a///b//..\", hasScheme: \"file\", hasPath: \"/a///b//..\")\n+        XCTAssertURIString(\"file:///a/b/../..\", hasScheme: \"file\", hasPath: \"/a/b/../..\")\n+        XCTAssertURIString(\"file:///a/b/c/../..\", hasScheme: \"file\", hasPath: \"/a/b/c/../..\")\n+        XCTAssertURIString(\"file:///a/../b/..\", hasScheme: \"file\", hasPath: \"/a/../b/..\")\n+        XCTAssertURIString(\"file:///a/../b/../c\", hasScheme: \"file\", hasPath: \"/a/../b/../c\")\n+        XCTAssertURIString(\"file:///a/../b/../c\", hasScheme: \"file\", hasPath: \"/a/../b/../c\")\n+        XCTAssertURIString(\"ftp://ftp.gnu.org/\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPath: \"/\")\n+        XCTAssertURIString(\"ftp://ftp.gnu.org/pub/gnu\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\")\n+        XCTAssertURIString(\"ftp://luser@ftp.gnu.org/pub/gnu\",\n+            hasScheme: \"ftp\", hasUserinfo: \"luser\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"\n+        )\n+        XCTAssertURIString(\"ftp://@ftp.gnu.org/pub/gnu\", hasScheme: \"ftp\", hasUserinfo: \"\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\")\n+        XCTAssertURIString(\"ftp://luser:password@ftp.gnu.org/pub/gnu\",\n+            hasScheme: \"ftp\", hasUserinfo: \"luser:password\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"\n+        )\n+        XCTAssertURIString(\"ftp://:password@ftp.gnu.org/pub/gnu\",\n+            hasScheme: \"ftp\", hasUserinfo: \":password\", hasHost: \"ftp.gnu.org\", hasPath: \"/pub/gnu\"\n+        )\n+        XCTAssertURIString(\"ftp://ftp.gnu.org:72/pub/gnu\", hasScheme: \"ftp\", hasHost: \"ftp.gnu.org\", hasPort: 72, hasPath: \"/pub/gnu\")\n+        XCTAssertURIString(\"ftp://:72/pub/gnu\", hasScheme: \"ftp\", hasHost: \"\", hasPort: 72, hasPath: \"/pub/gnu\")\n+        XCTAssertURIString(\"http://localhost/usr/local/bin/\", hasScheme: \"http\", hasHost: \"localhost\", hasPath: \"/usr/local/bin/\")\n+        XCTAssertURIString(\"http://localhost/\", hasScheme: \"http\", hasHost: \"localhost\", hasPath: \"/\")\n+        XCTAssertURIString(\"http://www.apple.com/\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/\")\n+        XCTAssertURIString(\"http://www.apple.com/dir\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/dir\")\n+        XCTAssertURIString(\"http://www.apple.com/dir/\", hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/dir/\")\n+        XCTAssertURIString(\"http://darin:nothin@www.apple.com:42/dir/\",\n+            hasScheme: \"http\", hasUserinfo: \"darin:nothin\", hasHost: \"www.apple.com\", hasPort: 42, hasPath: \"/dir/\"\n+        )\n+        XCTAssertURIString(\"http:/\", hasScheme: \"http\", hasHost: nil, hasPath: \"/\")\n+        XCTAssertURIString(\"http://www.apple.com/query?email=darin@apple.com\",\n+            hasScheme: \"http\", hasHost: \"www.apple.com\", hasPath: \"/query\", hasQuery: \"email=darin@apple.com\"\n+        )\n+        XCTAssertURIString(\"HTTP://WWW.ZOO.COM/\", hasScheme: \"HTTP\", hasHost: \"WWW.ZOO.COM\", hasPath: \"/\")\n+        XCTAssertURIString(\"HTTP://WWW.ZOO.COM/ED\", hasScheme: \"HTTP\", hasHost: \"WWW.ZOO.COM\", hasPath: \"/ED\")\n+        XCTAssertURIString(\"http://groups.google.com/groups?as_uauthors=joe@blow.com&as_scoring=d&hl=en\",\n+            hasScheme: \"http\", hasHost: \"groups.google.com\", hasPath: \"/groups\", hasQuery: \"as_uauthors=joe@blow.com&as_scoring=d&hl=en\"\n+        )\n+        XCTAssertURIString(\"http://my.site.com/some/page.html#fragment\",\n+            hasScheme: \"http\", hasHost: \"my.site.com\", hasPath: \"/some/page.html\", hasFragment: \"fragment\"\n+        )\n+        XCTAssertURIString(\"scheme://user:pass@host:1/path/path2/file.html;params?query#fragment\",\n+            hasScheme: \"scheme\", hasUserinfo: \"user:pass\", hasHost: \"host\", hasPort: 1, hasPath: \"/path/path2/file.html;params\",\n+            hasQuery: \"query\", hasFragment: \"fragment\"\n+        )\n+        XCTAssertURIString(\"http://test.com/a%20space\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/a space\")\n+        XCTAssertURIString(\"http://test.com/aBrace%7B\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aBrace{\")\n+        XCTAssertURIString(\"http://test.com/aJ%4a\", hasScheme: \"http\", hasHost: \"test.com\", hasPath: \"/aJJ\")\n+        XCTAssertURIString(\"file:///%3F\", hasScheme: \"file\", hasPath: \"/?\")\n+        XCTAssertURIString(\"file:///%78\", hasScheme: \"file\", hasPath: \"/x\")\n+        XCTAssertURIString(\"file:///?\", hasScheme: \"file\", hasPath: \"/\", hasQuery: \"\")\n+        XCTAssertURIString(\"file:///&\", hasScheme: \"file\", hasPath: \"/&\")\n+        XCTAssertURIString(\"file:///x\", hasScheme: \"file\", hasPath: \"/x\")\n+        XCTAssertURIString(\"http:///%3F\", hasScheme: \"http\", hasPath: \"/?\")\n+        XCTAssertURIString(\"http:///%78\", hasScheme: \"http\", hasPath: \"/x\")\n+        XCTAssertURIString(\"http:///?\", hasScheme: \"http\", hasPath: \"/\", hasQuery: \"\")\n+        XCTAssertURIString(\"http:///&\", hasScheme: \"http\", hasPath: \"/&\")\n+        XCTAssertURIString(\"http:///x\", hasScheme: \"http\", hasPath: \"/x\")\n+        XCTAssertURIString(\"glorb:///%3F\", hasScheme: \"glorb\", hasPath: \"/?\")\n+        XCTAssertURIString(\"glorb:///%78\", hasScheme: \"glorb\", hasPath: \"/x\")\n+        XCTAssertURIString(\"glorb:///?\", hasScheme: \"glorb\", hasPath: \"/\", hasQuery: \"\")\n+        XCTAssertURIString(\"glorb:///&\", hasScheme: \"glorb\", hasPath: \"/&\")\n+        XCTAssertURIString(\"glorb:///x\", hasScheme: \"glorb\", hasPath: \"/x\")\n+        XCTAssertURIString(\"uahsfcncvuhrtgvnahr\", hasHost: nil, hasPath: \"uahsfcncvuhrtgvnahr\")\n+        XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e]\", hasPath: \"/\")\n+        XCTAssertURIString(\"http://[fe80::20a:27ff:feae:8b9e%25en0]/\", hasScheme: \"http\", hasHost: \"[fe80::20a:27ff:feae:8b9e%en0]\", hasPath: \"/\")\n+        XCTAssertURIString(\"http://host.com/foo/bar/../index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/../index.html\")\n+        XCTAssertURIString(\"http://host.com/foo/bar/./index.html\", hasScheme: \"http\", hasHost: \"host.com\", hasPath: \"/foo/bar/./index.html\")\n+        XCTAssertURIString(\"http:/cgi-bin/Count.cgi?ft=0\", hasScheme: \"http\", hasHost: nil, hasPath: \"/cgi-bin/Count.cgi\", hasQuery: \"ft=0\")\n+        XCTAssertURIString(\"file://///\", hasScheme: \"file\", hasPath: \"///\")\n+        XCTAssertURIString(\"file:/Volumes\", hasScheme: \"file\", hasHost: nil, hasPath: \"/Volumes\")\n+        XCTAssertURIString(\"/Volumes\", hasHost: nil, hasPath: \"/Volumes\")\n+        XCTAssertURIString(\".\", hasHost: nil, hasPath: \".\")\n+        XCTAssertURIString(\"./a\", hasHost: nil, hasPath: \"./a\")\n+        XCTAssertURIString(\"../a\", hasHost: nil, hasPath: \"../a\")\n+        XCTAssertURIString(\"../../a\", hasHost: nil, hasPath: \"../../a\")\n+        XCTAssertURIString(\"/\", hasHost: nil, hasPath: \"/\")\n+        XCTAssertURIString(\"http://a/b/c/./g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g\")\n+        XCTAssertURIString(\"http://a/b/c/.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/.\")\n+        XCTAssertURIString(\"http://a/b/c/./\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./\")\n+        XCTAssertURIString(\"http://a/b/c/..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/..\")\n+        XCTAssertURIString(\"http://a/b/c/../\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../\")\n+        XCTAssertURIString(\"http://a/b/c/../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../g\")\n+        XCTAssertURIString(\"http://a/b/c/../..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../..\")\n+        XCTAssertURIString(\"http://a/b/c/../../\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../\")\n+        XCTAssertURIString(\"http://a/b/c/../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../g\")\n+        XCTAssertURIString(\"http://a/b/c/../../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../../g\")\n+        XCTAssertURIString(\"http://a/b/c/../../../../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../../../../g\")\n+        XCTAssertURIString(\"http://a/b/c/./g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g\")\n+        XCTAssertURIString(\"http://a/b/c/../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/../g\")\n+        XCTAssertURIString(\"http://a/b/c/g.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g.\")\n+        XCTAssertURIString(\"http://a/b/c/.g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/.g\")\n+        XCTAssertURIString(\"http://a/b/c/g..\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g..\")\n+        XCTAssertURIString(\"http://a/b/c/..g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/..g\")\n+        XCTAssertURIString(\"http://a/b/c/./../g\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./../g\")\n+        XCTAssertURIString(\"http://a/b/c/./g/.\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/./g/.\")\n+        XCTAssertURIString(\"http://a/b/c/g/./h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/./h\")\n+        XCTAssertURIString(\"http://a/b/c/g/../h\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g/../h\")\n+        XCTAssertURIString(\"http://a/b/c/g;x=1/./y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/./y\")\n+        XCTAssertURIString(\"http://a/b/c/g;x=1/../y\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g;x=1/../y\")\n+        XCTAssertURIString(\"http://a/b/c/g?y/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/./x\")\n+        XCTAssertURIString(\"http://a/b/c/g?y/../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasQuery: \"y/../x\")\n+        XCTAssertURIString(\"http://a/b/c/g#s/./x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasFragment: \"s/./x\")\n+        XCTAssertURIString(\"http://a/b/c/g#s/../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/b/c/g\", hasFragment: \"s/../x\")\n+        XCTAssertURIString(\"http://a/../../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/../../x\")\n+        XCTAssertURIString(\"http://a/..///../x\", hasScheme: \"http\", hasHost: \"a\", hasPath: \"/..///../x\")\n+    }\n+}"
        },
        {
            "filename": "Tests/VaporTests/ValidationTests.swift",
            "diff": "@@ -161,10 +161,12 @@ class ValidationTests: XCTestCase {\n         \"\"\"\n         XCTAssertNoThrow(try Email.validate(json: valid))\n         \n-        let validURL: URI = \"https://tanner.xyz/email?email=\u00df@tanner.xyz\"\n+        // N.B.: These two checks previously asserted against a URI containing the unencoded `\u00df` character.\n+        // Such a URI is semantically incorrect (per RFC 3986) and should have been considered a bug.\n+        let validURL: URI = \"https://tanner.xyz/email?email=%C3%9F@tanner.xyz\" // \u00df\n         XCTAssertNoThrow(try Email.validate(query: validURL))\n         \n-        let validURL2: URI = \"https://tanner.xyz/email?email=me@\u00dfanner.xyz\"\n+        let validURL2: URI = \"https://tanner.xyz/email?email=me@%C3%9Fanner.xyz\"\n         XCTAssertNoThrow(try Email.validate(query: validURL2))\n         \n         let invalidUser = \"\"\""
        }
    ],
    "commitTime": "2024-01-03 16:28:27"
}